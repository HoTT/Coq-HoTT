<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>PathGroupoids.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * The groupoid structure of paths *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Tactics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Naming conventions</span>

<span class="sd">   We need good naming conventions that allow us to name theorems without looking them up. The names should indicate the structure of the theorem, but they may sometimes be ambiguous, in which case you just have to know what is going on.    We shall adopt the following principles:</span>

<span class="sd">   - we are not afraid of long names</span>
<span class="sd">   - we are not afraid of short names when they are used frequently</span>
<span class="sd">   - we use underscores</span>
<span class="sd">   - name of theorems and lemmas are lower-case</span>
<span class="sd">   - records and other types may be upper or lower case</span>

<span class="sd">   Theorems about concatenation of paths are called [concat_XXX] where [XXX] tells us what is on the left-hand side of the equation. You have to guess the right-hand side. We use the following symbols in [XXX]:</span>

<span class="sd">   - [1] means the identity path, or sometimes the identity function</span>
<span class="sd">   - [p] means &#39;the path&#39;</span>
<span class="sd">   - [V] means &#39;the inverse path&#39;</span>
<span class="sd">   - [A] means &#39;[ap]&#39;</span>
<span class="sd">   - [M] means the thing we are moving across equality</span>
<span class="sd">   - [x] means &#39;the point&#39; which is not a path, e.g. in [transport p x]</span>
<span class="sd">   - [2] means relating to 2-dimensional paths</span>
<span class="sd">   - [3] means relating to 3-dimensional paths, and so on</span>

<span class="sd">   Associativity is indicated with an underscore. Here are some examples of how the name gives hints about the left-hand side of the equation.</span>

<span class="sd">   - [concat_1p] means [1 @ p]</span>
<span class="sd">   - [concat_Vp] means [p^ @ p]</span>
<span class="sd">   - [concat_p_pp] means [p @ (q @ r)]</span>
<span class="sd">   - [concat_pp_p] means [(p @ q) @ r]</span>
<span class="sd">   - [concat_V_pp] means [p^ @ (p @ q)]</span>
<span class="sd">   - [concat_pV_p] means [(q @ p^) @ p] or [(p @ p^) @ q], but probably the former because for the latter you could just use [concat_pV].</span>

<span class="sd">   Laws about inverse of something are of the form [inv_XXX], and those about [ap] are of the form [ap_XXX], and so on. For example:</span>

<span class="sd">   - [inv_pp] is about [(p @ q)^]</span>
<span class="sd">   - [inv_V] is about [(p^)^]</span>
<span class="sd">   - [inv_A] is about [(ap f p)^]</span>
<span class="sd">   - [ap_V] is about [ap f (p^)]</span>
<span class="sd">   - [ap_pp] is about [ap f (p @ q)]</span>
<span class="sd">   - [ap_idmap] is about [ap idmap p]</span>
<span class="sd">   - [ap_1] is about [ap f 1]</span>
<span class="sd">   - [ap02_p2p] is about [ap02 f (p @@ q)]</span>

<span class="sd">   Then we have laws which move things around in an equation. The naming scheme here is [moveD_XXX]. The direction [D] indicates where to move to: [L] means that we move something to the left-hand side, whereas [R] means we are moving something to the right-hand side. The part [XXX] describes the shape of the side _from_ which we are moving where the thing that is getting moves is called [M].  The presence of 1 next to an [M] generally indicates an *implied* identity path which is inserted automatically after the movement.  Examples:</span>

<span class="sd">   - [moveL_pM] means that we transform [p = q @ r] to [p @ r^ = q]</span>
<span class="sd">     because we are moving something to the left-hand side, and we are</span>
<span class="sd">     moving the right argument of [concat].</span>

<span class="sd">   - [moveR_Mp] means that we transform [p @ q = r] to [q = p^ @ r]</span>
<span class="sd">     because we move to the right-hand side, and we are moving the left</span>
<span class="sd">     argument of [concat].</span>

<span class="sd">   - [moveR_1M] means that we transform [p = q] (rather than [p = 1 @ q]) to [p @ q^ = 1].</span>

<span class="sd">   There are also cancellation laws called [cancelR] and [cancelL], which are inverse to the 2-dimensional &#39;whiskering&#39; operations [whiskerR] and [whiskerL].</span>
<span class="sd">*)</span>

<span class="sd">(** ** The 1-dimensional groupoid structure. *)</span>

<span class="sd">(** Partially applied versions of [concat].  The first is a synonym for [concat p], but we include it to parallel the second one. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_l</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y)
  : (y = z) -&gt; (x = z)
  := concat p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_r</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">q</span> : y = z)
  : (x = y) -&gt; (x = z)
  := <span class="kr">fun</span> <span class="nv">p</span> =&gt; p @ q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The operation of composing a path on two sides. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_lr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : w = x) (<span class="nv">r</span> : y = z)
  : (x = y) -&gt; (w = z)
  := <span class="kr">fun</span> <span class="nv">q</span> =&gt; p @ q @ r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The &quot;/&quot; indicates that these should be unfolded by [cbn] and [simpl] when the specified arguments are given. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> concat_l {A x y z} p q /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> concat_r {A x y z} q p /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> concat_lr {A w x y z} p r q /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity path is a right unit. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_p1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  p @ <span class="mi">1</span> = p
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity is a left unit. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  <span class="mi">1</span> @ p = p
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It&#39;s common to need to use both. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_p1_1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : p @ <span class="mi">1</span> = <span class="mi">1</span> @ p
  := concat_p1 p @ (concat_1p p)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_1p_p1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : <span class="mi">1</span> @ p = p @ <span class="mi">1</span>
  := concat_1p p @ (concat_p1 p)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Concatenation is associative. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_p_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">t</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : z = t) :
  p @ (q @ r) = (p @ q) @ r :=
  <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
      <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span>
      <span class="kr">end</span> <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_pp_p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">t</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : z = t) :
  (p @ q) @ r = p @ (q @ r) :=
  <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
      <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span>
      <span class="kr">end</span> <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left inverse law. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_pV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  p @ p^ = <span class="mi">1</span>
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right inverse law. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  p^ @ p = <span class="mi">1</span>
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Several auxiliary theorems about canceling inverses across associativity.  These are somewhat redundant, following from earlier theorems.  *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_V_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  p^ @ (p @ q) = q
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_p_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : x = z) :
  p @ (p^ @ q) = q
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_pp_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  (p @ q) @ q^ = p
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_pV_p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) :
  (p @ q^) @ q = p
  :=
  (<span class="kr">match</span> q <span class="kr">as</span> i <span class="kr">return</span> <span class="kr">forall</span> <span class="nv">p</span>, (p @ i^) @ i = p <span class="kr">with</span>
    idpath =&gt;
    <span class="kr">fun</span> <span class="nv">p</span> =&gt;
      <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Inverse distributes over concatenation *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inv_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  (p @ q)^ = q^ @ p^
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inv_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : y = x) (<span class="nv">q</span> : y = z) :
  (p^ @ q)^ = q^ @ p
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1"><span class="kn">Definition</span> <span class="nf">inv_pV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : z = y) :
  (p @ q^)^ = q @ p^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p @ q^)^ = q @ p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p @ q^)^ = q @ p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @ q^)^ = q @ <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @ <span class="mi">1</span>^)^ = <span class="mi">1</span> @ <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5"><span class="kn">Definition</span> <span class="nf">inv_VV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : y = x) (<span class="nv">q</span> : z = y) :
  (p^ @ q^)^ = q @ p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^ @ q^)^ = q @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^ @ q^)^ = q @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span>^ @ q^)^ = q @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span>^ @ <span class="mi">1</span>^)^ = <span class="mi">1</span> @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Inverse is an involution. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inv_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  p^^ = p
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Theorems for moving things around in equations. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9"><span class="kn">Definition</span> <span class="nf">moveR_Mp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  p = r^ @ q -&gt; r @ p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = r^ @ q -&gt; r @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = r^ @ q -&gt; r @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb"><span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = <span class="mi">1</span>^ @ q -&gt; <span class="mi">1</span> @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_1p _) (concat_1p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc"><span class="kn">Definition</span> <span class="nf">moveR_pM</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  r = q @ p^ -&gt; r @ p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ p^ -&gt; r @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ p^ -&gt; r @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ <span class="mi">1</span>^ -&gt; r @ <span class="mi">1</span> = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_p1 _) (concat_p1 _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf"><span class="kn">Definition</span> <span class="nf">moveR_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : x = y) :
  p = r @ q -&gt; r^ @ p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = r @ q -&gt; r^ @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = r @ q -&gt; r^ @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11"><span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = <span class="mi">1</span> @ q -&gt; <span class="mi">1</span>^ @ p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_1p _) (concat_1p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12"><span class="kn">Definition</span> <span class="nf">moveR_pV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : z = x) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  r = q @ p -&gt; r @ p^ = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ p -&gt; r @ p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ p -&gt; r @ p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk14"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r = q @ <span class="mi">1</span> -&gt; r @ <span class="mi">1</span>^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_p1 _) (concat_p1 _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk15"><span class="kn">Definition</span> <span class="nf">moveL_Mp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  r^ @ q = p -&gt; q = r @ p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r^ @ q = p -&gt; q = r @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r^ @ q = p -&gt; q = r @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk17"><span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>^ @ q = p -&gt; q = <span class="mi">1</span> @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_1p _)^ (concat_1p _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk18"><span class="kn">Definition</span> <span class="nf">moveL_pM</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  q @ p^ = r -&gt; q = r @ p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p^ = r -&gt; q = r @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p^ = r -&gt; q = r @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1a"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ <span class="mi">1</span>^ = r -&gt; q = r @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_p1 _)^ (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1b"><span class="kn">Definition</span> <span class="nf">moveL_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = z) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : x = y) :
  r @ q = p -&gt; q = r^ @ p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ q = p -&gt; q = r^ @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ q = p -&gt; q = r^ @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1d"><span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ q = p -&gt; q = <span class="mi">1</span>^ @ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_1p _)^ (concat_1p _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1e"><span class="kn">Definition</span> <span class="nf">moveL_pV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : z = x) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : y = x) :
  q @ p = r -&gt; q = r @ p^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p = r -&gt; q = r @ p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p = r -&gt; q = r @ p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk20"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ <span class="mi">1</span> = r -&gt; q = r @ <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_lr (concat_p1 _)^ (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk21"><span class="kn">Definition</span> <span class="nf">moveL_1M</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) :
  p @ q^ = <span class="mi">1</span> -&gt; p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q^ = <span class="mi">1</span> -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q^ = <span class="mi">1</span> -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk23"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ <span class="mi">1</span>^ = <span class="mi">1</span> -&gt; p = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_l (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk24"><span class="kn">Definition</span> <span class="nf">moveL_M1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) :
  q^ @ p = <span class="mi">1</span> -&gt; p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q^ @ p = <span class="mi">1</span> -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q^ @ p = <span class="mi">1</span> -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk26"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>^ @ p = <span class="mi">1</span> -&gt; p = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_l (concat_1p _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk27"><span class="kn">Definition</span> <span class="nf">moveL_1V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = x) :
  p @ q = <span class="mi">1</span> -&gt; p = q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q = <span class="mi">1</span> -&gt; p = q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q = <span class="mi">1</span> -&gt; p = q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk29"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ <span class="mi">1</span> = <span class="mi">1</span> -&gt; p = <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_l (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2a"><span class="kn">Definition</span> <span class="nf">moveL_V1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = x) :
  q @ p = <span class="mi">1</span> -&gt; p = q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p = <span class="mi">1</span> -&gt; p = q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q @ p = <span class="mi">1</span> -&gt; p = q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2c"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ p = <span class="mi">1</span> -&gt; p = <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_l (concat_1p _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2d"><span class="kn">Definition</span> <span class="nf">moveR_M1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) :
  <span class="mi">1</span> = p^ @ q -&gt; p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = p^ @ q -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = p^ @ q -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk2f"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span>^ @ q -&gt; <span class="mi">1</span> = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_r (concat_1p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk30"><span class="kn">Definition</span> <span class="nf">moveR_1M</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) :
  <span class="mi">1</span> = q @ p^ -&gt; p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ p^ -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ p^ -&gt; p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk32"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ <span class="mi">1</span>^ -&gt; <span class="mi">1</span> = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_r (concat_p1 _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk33"><span class="kn">Definition</span> <span class="nf">moveR_1V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = x) :
  <span class="mi">1</span> = q @ p -&gt; p^ = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ p -&gt; p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ p -&gt; p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk35"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q @ <span class="mi">1</span> -&gt; <span class="mi">1</span>^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_r (concat_p1 _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk36"><span class="kn">Definition</span> <span class="nf">moveR_V1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = x) :
  <span class="mi">1</span> = p @ q -&gt; p^ = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = p @ q -&gt; p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = p @ q -&gt; p^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk38"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span> @ q -&gt; <span class="mi">1</span>^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_r (concat_1p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* In general, the path we want to move might be arbitrarily deeply nested at the beginning of a long concatenation.  Thus, instead of defining functions such as [moveL_Mp_p], we define a tactical that can repeatedly rewrite with associativity to expose it. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">with_rassoc</span> tac :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> concat_pp_p;
  tac;
  <span class="c">(* After moving, we reassociate to the left (the canonical direction for paths). *)</span>
  <span class="kp">repeat</span> <span class="nb">rewrite</span> concat_p_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_moveL_Mp_p</span> := with_rassoc <span class="kp">ltac</span>:(<span class="nb">apply</span> moveL_Mp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_moveL_Vp_p</span> := with_rassoc <span class="kp">ltac</span>:(<span class="nb">apply</span> moveL_Vp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_moveR_Mp_p</span> := with_rassoc <span class="kp">ltac</span>:(<span class="nb">apply</span> moveR_Mp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_moveR_Vp_p</span> := with_rassoc <span class="kp">ltac</span>:(<span class="nb">apply</span> moveR_Vp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk39"><span class="kn">Definition</span> <span class="nf">moveR_transport_p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
  (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y)
  : u = p^ # v -&gt; p # u = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P p^ v -&gt; transport P p u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P p^ v -&gt; transport P p u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3b"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P <span class="mi">1</span>^ v -&gt; transport P <span class="mi">1</span> u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3c"><span class="kn">Definition</span> <span class="nf">moveR_transport_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
  (<span class="nv">p</span> : y = x) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y)
  : u = p # v -&gt; p^ # u = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P p v -&gt; transport P p^ u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P p v -&gt; transport P p^ u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3e"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport P <span class="mi">1</span> v -&gt; transport P <span class="mi">1</span>^ u = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk3f"><span class="kn">Definition</span> <span class="nf">moveL_transport_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
  (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y)
  : p # u = v -&gt; u = p^ # v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P p u = v -&gt; u = transport P p^ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P p u = v -&gt; u = transport P p^ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk41"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P <span class="mi">1</span> u = v -&gt; u = transport P <span class="mi">1</span>^ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk42"><span class="kn">Definition</span> <span class="nf">moveL_transport_p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
  (<span class="nv">p</span> : y = x) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y)
  : p^ # u = v -&gt; u = p # v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P p^ u = v -&gt; u = transport P p v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P p^ u = v -&gt; u = transport P p v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk44"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P <span class="mi">1</span>^ u = v -&gt; u = transport P <span class="mi">1</span> v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* We have some coherences between those proofs. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk45"><span class="kn">Definition</span> <span class="nf">moveR_transport_p_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y) (<span class="nv">q</span> : u = p^ # v)
  : (moveR_transport_p P p u v q)^ = moveL_transport_p P p v u q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>u = transport P p^ v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveR_transport_p P p u v q)^ =
moveL_transport_p P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>u = transport P p^ v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveR_transport_p P p u v q)^ =
moveL_transport_p P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk47"><span class="kn">Definition</span> <span class="nf">moveR_transport_V_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : y = x) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y) (<span class="nv">q</span> : u = p # v)
  : (moveR_transport_V P p u v q)^ = moveL_transport_V P p v u q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>u = transport P p v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveR_transport_V P p u v q)^ =
moveL_transport_V P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>u = transport P p v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveR_transport_V P p u v q)^ =
moveL_transport_V P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk49"><span class="kn">Definition</span> <span class="nf">moveL_transport_V_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y) (<span class="nv">q</span> : p # u = v)
  : (moveL_transport_V P p u v q)^ = moveR_transport_V P p v u q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveL_transport_V P p u v q)^ =
moveR_transport_V P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveL_transport_V P p u v q)^ =
moveR_transport_V P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4b"><span class="kn">Definition</span> <span class="nf">moveL_transport_p_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : y = x) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y) (<span class="nv">q</span> : p^ # u = v)
  : (moveL_transport_p P p u v q)^ = moveR_transport_p P p v u q^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p^ u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveL_transport_p P p u v q)^ =
moveR_transport_p P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p^ u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(moveL_transport_p P p u v q)^ =
moveR_transport_p P p v u q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Functoriality of functions *)</span>

<span class="sd">(** Here we prove that functions behave like functors between groupoids, and that [ap] itself is functorial. *)</span>

<span class="sd">(** Functions take identity paths to identity paths. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_1</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : A) (<span class="nv">f</span> : A -&gt; B) :
  ap f <span class="mi">1</span> = <span class="mi">1</span> :&gt; (f x = f x)
  :=
  <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD_1</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">x</span> : A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) :
  apD f <span class="mi">1</span> = <span class="mi">1</span> :&gt; (f x = f x)
  :=
  <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Functions commute with concatenation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_pp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  ap f (p @ q) = (ap f p) @ (ap f q)
  :=
  <span class="kr">match</span> q <span class="kr">with</span>
    idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4d"><span class="kn">Definition</span> <span class="nf">ap_p_pp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">w</span> : B} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A}
  (<span class="nv">r</span> : w = f x) (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  r @ (ap f (p @ q)) = (r @ ap f p) @ (ap f q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ ap f (p @ q) = (r @ ap f p) @ ap f q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ ap f (p @ q) = (r @ ap f p) @ ap f q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk4f"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ ap f (<span class="mi">1</span> @ <span class="mi">1</span>) = (r @ ap f <span class="mi">1</span>) @ ap f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk50"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p_pp r <span class="mi">1</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk51"><span class="kn">Definition</span> <span class="nf">ap_pp_p</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">w</span> : B}
  (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : f z = w) :
  (ap f (p @ q)) @ r = (ap f p) @ (ap f q @ r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f z = w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (p @ q) @ r = ap f p @ (ap f q @ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f z = w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (p @ q) @ r = ap f p @ (ap f q @ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk53"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f x = w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (<span class="mi">1</span> @ <span class="mi">1</span>) @ r = ap f <span class="mi">1</span> @ (ap f <span class="mi">1</span> @ r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk54"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f x = w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ r = <span class="mi">1</span> @ (<span class="mi">1</span> @ r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_pp_p <span class="mi">1</span> <span class="mi">1</span> r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Functions commute with path inverses. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inverse_ap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  (ap f p)^ = ap f (p^)
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_V</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  ap f (p^) = (ap f p)^
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ap] itself is functorial in the first argument. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_idmap</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  ap idmap p = p
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  ap (g o f) p = ap g (ap f p)
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Sometimes we don&#39;t have the actual function [compose]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_compose&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) :
  ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; g (f a)) p = ap g (ap f p)
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The action of constant maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_const</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">z</span> : B) :
  ap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; z) p = <span class="mi">1</span>
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; idpath <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [ap]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_Ap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y) :
  (ap f q) @ (p y) = (p x) @ (ap g q)
  :=
  <span class="kr">match</span> q <span class="kr">with</span>
    | idpath =&gt; concat_1p_p1 _
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A useful variant of [concat_Ap]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk55"><span class="kn">Definition</span> <span class="nf">ap_homotopic</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  : (ap f q) = (p x) @ (ap g q) @ (p y)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q = (p x @ ap g q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q = (p x @ ap g q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk57"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ p y = p x @ ap g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_Ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [ap] at identity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_A1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y) :
  (ap f q) @ (p y) = (p x) @ q
  :=
  <span class="kr">match</span> q <span class="kr">with</span>
    | idpath =&gt; concat_1p_p1 _
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The corresponding variant of [concat_A1p]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk58"><span class="kn">Definition</span> <span class="nf">ap_homotopic_id</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  : (ap f q) = (p x) @ q @ (p y)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q = (p x @ q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q = (p x @ q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5a"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ p y = p x @ q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_A1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_pA1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, x = f x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y) :
  (p x) @ (ap f q) =  q @ (p y)
  :=
  <span class="kr">match</span> q <span class="kr">as</span> i <span class="kr">in</span> (_ = y) <span class="kr">return</span> (p x @ ap f i = i @ p y) <span class="kr">with</span>
    | idpath =&gt; concat_p1_1p _
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5b"><span class="kn">Definition</span> <span class="nf">apD_natural</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x}
  (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  : apD f q @ p y = ap (transport B q) (p x) @ apD g q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f q @ p y = ap (transport B q) (p x) @ apD g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f q @ p y = ap (transport B q) (p x) @ apD g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5d"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f <span class="mi">1</span> @ p x = ap (transport B <span class="mi">1</span>) (p x) @ apD g <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5e"><span class="nb">unfold</span> transport.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f <span class="mi">1</span> @ p x = ap idmap (p x) @ apD g <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_1p _ @ (ap_idmap _)^ @ (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk5f"><span class="kn">Definition</span> <span class="nf">apD_homotopic</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x}
  (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  : apD f q = ap (transport B q) (p x) @ apD g q @ (p y)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f q =
(ap (transport B q) (p x) @ apD g q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f q =
(ap (transport B q) (p x) @ apD g q) @ (p y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveL_pV, apD_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality with other paths hanging around. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk61"><span class="kn">Definition</span> <span class="nf">concat_pA_pp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> <span class="nv">z</span> : B} (<span class="nv">r</span> : w = f x) (<span class="nv">s</span> : g y = z)
  :
  (r @ ap f q) @ (p y @ s) = (r @ p x) @ (ap g q @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ (p y @ s) = (r @ p x) @ (ap g q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ (p y @ s) = (r @ p x) @ (ap g q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk63"><span class="nb">destruct</span> q, s; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ (p x @ <span class="mi">1</span>) = (r @ p x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk64"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ (<span class="mi">1</span> @ <span class="mi">1</span>) = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk65"><span class="kn">Definition</span> <span class="nf">concat_pA_p</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> : B} (<span class="nv">r</span> : w = f x)
  :
  (r @ ap f q) @ p y = (r @ p x) @ ap g q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ p y = (r @ p x) @ ap g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ p y = (r @ p x) @ ap g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk67"><span class="nb">destruct</span> q; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ p x = (r @ p x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk68"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk69"><span class="kn">Definition</span> <span class="nf">concat_A_pp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">z</span> : B} (<span class="nv">s</span> : g y = z)
  :
  (ap f q) @ (p y @ s) = (p x) @ (ap g q @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ (p y @ s) = p x @ (ap g q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ (p y @ s) = p x @ (ap g q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6b"><span class="nb">destruct</span> q, s; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ (p x @ <span class="mi">1</span>) = p x @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6c"><span class="kn">Definition</span> <span class="nf">concat_pA1_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> <span class="nv">z</span> : A} (<span class="nv">r</span> : w = f x) (<span class="nv">s</span> : y = z)
  :
  (r @ ap f q) @ (p y @ s) = (r @ p x) @ (q @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ (p y @ s) = (r @ p x) @ (q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ (p y @ s) = (r @ p x) @ (q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6e"><span class="nb">destruct</span> q, s; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ (p x @ <span class="mi">1</span>) = (r @ p x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk6f"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ (<span class="mi">1</span> @ <span class="mi">1</span>) = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk70"><span class="kn">Definition</span> <span class="nf">concat_pp_A1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">g</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> <span class="nv">z</span> : A} (<span class="nv">r</span> : w = x) (<span class="nv">s</span> : g y = z)
  :
  (r @ p x) @ (ap g q @ s) = (r @ q) @ (p y @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ (ap g q @ s) = (r @ q) @ (p y @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk71"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ (ap g q @ s) = (r @ q) @ (p y @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk72"><span class="nb">destruct</span> q, s; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ (p x @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk73"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk74"><span class="kn">Definition</span> <span class="nf">concat_pA1_p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> : A} (<span class="nv">r</span> : w = f x)
  :
  (r @ ap f q) @ p y = (r @ p x) @ q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ p y = (r @ p x) @ q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ ap f q) @ p y = (r @ p x) @ q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk76"><span class="nb">destruct</span> q; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ p x = (r @ p x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk77"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk78"><span class="kn">Definition</span> <span class="nf">concat_A1_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">z</span> : A} (<span class="nv">s</span> : y = z)
  :
  (ap f q) @ (p y @ s) = (p x) @ (q @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ (p y @ s) = p x @ (q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q @ (p y @ s) = p x @ (q @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7a"><span class="nb">destruct</span> q, s; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ (p x @ <span class="mi">1</span>) = p x @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7b"><span class="kn">Definition</span> <span class="nf">concat_pp_A1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">g</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">w</span> : A} (<span class="nv">r</span> : w = x)
  :
  (r @ p x) @ ap g q = (r @ q) @ p y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ ap g q = (r @ q) @ p y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ ap g q = (r @ q) @ p y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7d"><span class="nb">destruct</span> q; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ p x) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ p x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7e"><span class="nb">induction</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @ <span class="mi">1</span>) @ <span class="mi">1</span> = (r @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk7f"><span class="kn">Definition</span> <span class="nf">concat_p_A1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">g</span> : A -&gt; A} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">x</span>, x = g x)
  {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">q</span> : x = y)
  {<span class="nv">z</span> : A} (<span class="nv">s</span> : g y = z)
  :
  p x @ (ap g q @ s) = q @ (p y @ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p x @ (ap g q @ s) = q @ (p y @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p x @ (ap g q @ s) = q @ (p y @ s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk81"><span class="nb">destruct</span> q, s; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, x = g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p x @ <span class="mi">1</span> = <span class="mi">1</span> @ (p x @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Some coherence lemmas for functoriality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk82"><span class="kn">Lemma</span> <span class="nf">concat_1p_1</span> {<span class="nv">A</span>} {<span class="nv">x</span> : A} (<span class="nv">p</span> : x = x) (<span class="nv">q</span> : p = <span class="mi">1</span>)
: concat_1p p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; <span class="mi">1</span> @ p&#39;) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; <span class="mi">1</span> @ p&#39;) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; <span class="mi">1</span> @ p&#39;) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk84"><span class="nb">rewrite</span> &lt;- (inv_V q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p p @ (q^)^ =
ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; <span class="mi">1</span> @ p&#39;) (q^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk85"><span class="nb">set</span> (r := q^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>q^</span></span><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p p @ r^ = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; <span class="mi">1</span> @ p&#39;) r^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk86"><span class="nb">clearbody</span> r; <span class="nb">clear</span> q; <span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p <span class="mi">1</span> @ <span class="mi">1</span>^ = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; <span class="mi">1</span> @ p&#39;) <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk87"><span class="kn">Lemma</span> <span class="nf">concat_p1_1</span> {<span class="nv">A</span>} {<span class="nv">x</span> : A} (<span class="nv">p</span> : x = x) (<span class="nv">q</span> : p = <span class="mi">1</span>)
: concat_p1 p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; p&#39; @ <span class="mi">1</span>) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1 p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; p&#39; @ <span class="mi">1</span>) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1 p @ q = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; p&#39; @ <span class="mi">1</span>) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk89"><span class="nb">rewrite</span> &lt;- (inv_V q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1 p @ (q^)^ =
ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; p&#39; @ <span class="mi">1</span>) (q^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8a"><span class="nb">set</span> (r := q^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = <span class="mi">1</span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>q^</span></span><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1 p @ r^ = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; p&#39; @ <span class="mi">1</span>) r^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8b"><span class="nb">clearbody</span> r; <span class="nb">clear</span> q; <span class="nb">destruct</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1 <span class="mi">1</span> @ <span class="mi">1</span>^ = ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> : x = x =&gt; p&#39; @ <span class="mi">1</span>) <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Action of [apD10] and [ap10] on paths. *)</span>

<span class="sd">(** Application of paths between functions preserves the groupoid structure *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD10_1</span> {<span class="nv">A</span>} {<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x) (<span class="nv">x</span>:A)
  : apD10 (idpath f) x = <span class="mi">1</span>
:= <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8c"><span class="kn">Definition</span> <span class="nf">apD10_pp</span> {<span class="nv">A</span>} {<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">f&#39;&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x}
  (<span class="nv">h</span>:f=f&#39;) (<span class="nv">h&#39;</span>:f&#39;=f&#39;&#39;) (<span class="nv">x</span>:A)
: apD10 (h @ h&#39;) x = apD10 h x @ apD10 h&#39; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, f', f''</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>f&#39; = f&#39;&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (h @ h&#39;) x = apD10 h x @ apD10 h&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, f', f''</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>f&#39; = f&#39;&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (h @ h&#39;) x = apD10 h x @ apD10 h&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">case</span> h, h&#39;; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD10_V</span> {<span class="nv">A</span>} {<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x} (<span class="nv">h</span>:f=g) (<span class="nv">x</span>:A)
  : apD10 (h^) x = (apD10 h x)^
:= <span class="kr">match</span> h <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap10_1</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span>:A-&gt;B} (<span class="nv">x</span>:A) : ap10 (idpath f) x = <span class="mi">1</span>
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap10_pp</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">f&#39;&#39;</span>:A-&gt;B} (<span class="nv">h</span>:f=f&#39;) (<span class="nv">h&#39;</span>:f&#39;=f&#39;&#39;) (<span class="nv">x</span>:A)
  : ap10 (h @ h&#39;) x = ap10 h x @ ap10 h&#39; x
:= apD10_pp h h&#39; x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap10_V</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span> <span class="nv">g</span> : A-&gt;B} (<span class="nv">h</span> : f = g) (<span class="nv">x</span>:A)
  : ap10 (h^) x = (ap10 h x)^
:= apD10_V h x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [apD10] and [ap10] also behave nicely on paths produced by [ap] *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8e"><span class="kn">Definition</span> <span class="nf">apD10_ap_precompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> <span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span>:B, C x} (<span class="nv">p</span> : g = g&#39;) <span class="nv">a</span>
: apD10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span>:B, C x =&gt; h oD f) p) a = apD10 p (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, C x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span> : B, C x =&gt; h oD f) p) a =
apD10 p (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, C x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span> : B, C x =&gt; h oD f) p) a =
apD10 p (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap10_ap_precompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> <span class="nv">g&#39;</span> : B -&gt; C} (<span class="nv">p</span> : g = g&#39;) <span class="nv">a</span>
: ap10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; h o f) p) a = ap10 p (f a)
:= apD10_ap_precompose f p a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk90"><span class="kn">Definition</span> <span class="nf">apD10_ap_postcompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x -&gt; C) {<span class="nv">g</span> <span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span>:A, B x} (<span class="nv">p</span> : g = g&#39;) <span class="nv">a</span>
: apD10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span>:A, B x =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; f x (h x)) p) a = ap (f a) (apD10 p a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10
  (ap
     (<span class="kr">fun</span> (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">x</span> : A) =&gt; f x (h x))
     p) a = ap (f a) (apD10 p a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk91"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10
  (ap
     (<span class="kr">fun</span> (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">x</span> : A) =&gt; f x (h x))
     p) a = ap (f a) (apD10 p a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap10_ap_postcompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B -&gt; C) {<span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B} (<span class="nv">p</span> : g = g&#39;) <span class="nv">a</span>
: ap10 (ap (<span class="kr">fun</span> <span class="nv">h</span> : A -&gt; B =&gt; f o h) p) a = ap f (ap10 p a)
:= apD10_ap_postcompose (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f) p a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap100</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : X -&gt; Y -&gt; Z} (<span class="nv">p</span> : f = g) (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y)
  : f x y = g x y := (ap10 (ap10 p x) y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Transport and the groupoid structure of paths *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> : A} (<span class="nv">u</span> : P x)
  : <span class="mi">1</span> # u = u
:= <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) (<span class="nv">u</span> : P x) :
  p @ q # u = q # p # u :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_pV</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">z</span> : P y)
  : p # p^ # z = z
  := (transport_pp P p^ p z)^
  @ ap (<span class="kr">fun</span> <span class="nv">r</span> =&gt; transport P r z) (concat_Vp p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_Vp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">z</span> : P x)
  : p^ # p # z = z
  := (transport_pp P p p^ z)^
  @ ap (<span class="kr">fun</span> <span class="nv">r</span> =&gt; transport P r z) (concat_pV p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In the future, we may expect to need some higher coherence for transport:</span>
<span class="sd">  for instance, that transport acting on the associator is trivial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk92"><span class="kn">Definition</span> <span class="nf">transport_p_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) (<span class="nv">r</span> : z = w)
  (<span class="nv">u</span> : P x)
  : ap (<span class="kr">fun</span> <span class="nv">e</span> =&gt; e # u) (concat_p_pp p q r)
    @ (transport_pp P (p@q) r u) @ ap (transport P r) (transport_pp P p q u)
  = (transport_pp P p (q@r) u) @ (transport_pp P q r (p#u))
  :&gt; ((p @ (q @ r)) # u = r # q # p # u) .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y, z, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>z = w</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">e</span> : x = w =&gt; transport P e u)
   (concat_p_pp p q r) @ transport_pp P (p @ q) r u) @
ap (transport P r) (transport_pp P p q u) =
transport_pp P p (q @ r) u @
transport_pp P q r (transport P p u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y, z, w</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>z = w</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">e</span> : x = w =&gt; transport P e u)
   (concat_p_pp p q r) @ transport_pp P (p @ q) r u) @
ap (transport P r) (transport_pp P p q u) =
transport_pp P p (q @ r) u @
transport_pp P q r (transport P p u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk94"><span class="nb">destruct</span> p, q, r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">e</span> : x = x =&gt; transport P e u)
   (concat_p_pp <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>) @ transport_pp P (<span class="mi">1</span> @ <span class="mi">1</span>) <span class="mi">1</span> u) @
ap (transport P <span class="mi">1</span>) (transport_pp P <span class="mi">1</span> <span class="mi">1</span> u) =
transport_pp P <span class="mi">1</span> (<span class="mi">1</span> @ <span class="mi">1</span>) u @
transport_pp P <span class="mi">1</span> <span class="mi">1</span> (transport P <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk95"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Here are other coherence lemmas for transport. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk96"><span class="kn">Definition</span> <span class="nf">transport_pVp</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span>:A} (<span class="nv">p</span>:x=y) (<span class="nv">z</span>:P x)
  : transport_pV P p (transport P p z)
  = ap (transport P p) (transport_Vp P p z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_pV P p (transport P p z) =
ap (transport P p) (transport_Vp P p z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk97"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_pV P p (transport P p z) =
ap (transport P p) (transport_Vp P p z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk98"><span class="kn">Definition</span> <span class="nf">transport_VpV</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">z</span> : P y)
  : transport_Vp P p (transport P p^ z)
    = ap (transport P p^) (transport_pV P p z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_Vp P p (transport P p^ z) =
ap (transport P p^) (transport_pV P p z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_Vp P p (transport P p^ z) =
ap (transport P p^) (transport_pV P p z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9a"><span class="kn">Definition</span> <span class="nf">ap_transport_transport_pV</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) (<span class="nv">v</span> : P y) (<span class="nv">e</span> : transport P p u = v)
  : ap (transport P p) (moveL_transport_V P p u v e)
       @ transport_pV P p v = e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>transport P p u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport P p) (moveL_transport_V P p u v e) @
transport_pV P p v = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>transport P p u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport P p) (moveL_transport_V P p u v e) @
transport_pV P p v = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> e, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9c"><span class="kn">Definition</span> <span class="nf">moveL_transport_V_1</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x)
  : moveL_transport_V P p u (p # u) <span class="mi">1</span> = (transport_Vp P p u)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_transport_V P p u (transport P p u) <span class="mi">1</span> =
(transport_Vp P p u)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* moveL_transport_V P p (transport P p^ v) (transport P p (transport P p^ v)) 1 *)</span>
    <span class="c">(* = ap (transport P p^) (transport_pV P p v)^. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_transport_V P p u (transport P p u) <span class="mi">1</span> =
(transport_Vp P p u)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* pose (u := p^ # v).  *)</span>
  <span class="c">(* assert (moveL_transport_V P p u (p # u) 1 = (transport_Vp P p u)^). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* subst u. rewrite X. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Occasionally the induction principles for the identity type show up explicitly; these let us turn them into transport. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">paths_rect_transport</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x)
  : paths_rect A x (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">_</span> =&gt; P a) u y p = transport P p u
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">paths_ind_transport</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x)
  : paths_ind x (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">_</span> =&gt; P a) u y p = transport P p u
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9e"><span class="kn">Definition</span> <span class="nf">paths_ind_r_transport</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A}
           (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P y)
  : paths_ind_r y (<span class="kr">fun</span> <span class="nv">b</span> <span class="nv">_</span> =&gt; P b) u x p = transport P p^ u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths_ind_r y (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">_</span> : b = y) =&gt; P b) u x p =
transport P p^ u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths_ind_r y (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">_</span> : b = y) =&gt; P b) u x p =
transport P p^ u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** [ap11] *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka0"><span class="kn">Definition</span> <span class="nf">ap11_is_ap10_ap01</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span> <span class="nv">g</span>:A-&gt;B} (<span class="nv">h</span>:f=g) {<span class="nv">x</span> <span class="nv">y</span>:A} (<span class="nv">p</span>:x=y)
: ap11 h p = ap10 h x @ ap g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap11 h p = ap10 h x @ ap g p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap11 h p = ap10 h x @ ap g p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> path_induction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Dependent transport in doubly dependent types and more. *)</span>

<span class="sd">(** Singly dependent transport over doubly dependent types. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transportD</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, B a -&gt; <span class="kt">Type</span>)
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B x1) (<span class="nv">z</span> : C x1 y)
  : C x2 (p # y)
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; z <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Singly dependent transport over doubly dependent types of 2 variables. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transportD2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> <span class="nv">C</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, B a -&gt; C a -&gt; <span class="kt">Type</span>)
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B x1) (<span class="nv">z</span> : C x1) (<span class="nv">w</span> : D x1 y z)
  : D x2 (p # y) (p # z)
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; w <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Doubly dependent transport over doubly dependent types.  *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transportDD</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>)
  {<span class="nv">a1</span> <span class="nv">a2</span> : A} (<span class="nv">pA</span> : a1 = a2)
  {<span class="nv">b1</span> : B a1} {<span class="nv">b2</span> : B a2} (<span class="nv">pB</span> : transport B pA b1 = b2)
  (<span class="nv">c1</span> : C a1 b1)
  : C a2 b2
  := transport (C a2) pB (transportD B C pA b1 c1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** [ap] for curried two variable functions *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka2"><span class="kn">Definition</span> <span class="nf">ap011</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span>} (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : f x y = f x&#39; y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x y = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x y = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka4"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x y = f x y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka5"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka6"><span class="kn">Definition</span> <span class="nf">ap011_V</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span>} (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap011 f p^ q^ = (ap011 f p q)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p^ q^ = (ap011 f p q)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p^ q^ = (ap011 f p q)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka8"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f <span class="mi">1</span>^ q^ = (ap011 f <span class="mi">1</span> q)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chka9"><span class="kn">Definition</span> <span class="nf">ap011_pp</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">x&#39;&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span> <span class="nv">y&#39;&#39;</span>}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">p&#39;</span> : x&#39; = x&#39;&#39;) (<span class="nv">q</span> : y = y&#39;) (<span class="nv">q&#39;</span> : y&#39; = y&#39;&#39;)
  : ap011 f (p @ p&#39;) (q @ q&#39;) = ap011 f p q @ ap011 f p&#39; q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x', x''</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y', y''</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x&#39; = x&#39;&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>y&#39; = y&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f (p @ p&#39;) (q @ q&#39;) =
ap011 f p q @ ap011 f p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x', x''</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y', y''</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x&#39; = x&#39;&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>y&#39; = y&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f (p @ p&#39;) (q @ q&#39;) =
ap011 f p q @ ap011 f p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkab"><span class="nb">destruct</span> p, p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y', y''</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>y&#39; = y&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f (<span class="mi">1</span> @ <span class="mi">1</span>) (q @ q&#39;) = ap011 f <span class="mi">1</span> q @ ap011 f <span class="mi">1</span> q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkac"><span class="kn">Definition</span> <span class="nf">ap011_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">g</span> : C -&gt; D) {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span>}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap011 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; g (f x y)) p q = ap g (ap011 f p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; g (f x y)) p q =
ap g (ap011 f p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; g (f x y)) p q =
ap g (ap011 f p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkae"><span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; g (f x y)) q = ap g (ap (f x) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkaf"><span class="kn">Definition</span> <span class="nf">ap011_compose&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">g</span> : D -&gt; A) (<span class="nv">h</span> : E -&gt; B)
  {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span>}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap011 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; f (g x) (h y)) p q = ap011 f (ap g p) (ap h q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>D -&gt; A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>E -&gt; B</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 (<span class="kr">fun</span> (<span class="nv">x</span> : D) (<span class="nv">y</span> : E) =&gt; f (g x) (h y)) p q =
ap011 f (ap g p) (ap h q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>D -&gt; A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>E -&gt; B</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 (<span class="kr">fun</span> (<span class="nv">x</span> : D) (<span class="nv">y</span> : E) =&gt; f (g x) (h y)) p q =
ap011 f (ap g p) (ap h q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb1"><span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>D -&gt; A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>E -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E =&gt; f (g x) (h y)) q =
ap (f (g x)) (ap h q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb2"><span class="kn">Definition</span> <span class="nf">ap011_is_ap</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> <span class="nv">y&#39;</span> : B} (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap011 f p q = ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x y) p @ ap (<span class="kr">fun</span> <span class="nv">y</span> =&gt; f x&#39; y) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p q =
ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) p @ ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; f x&#39; y) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p q =
ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) p @ ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; f x&#39; y) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb4"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f <span class="mi">1</span> q =
ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) <span class="mi">1</span> @ ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; f x y) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb5"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) <span class="mi">1</span> @ ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; f x y) q =
ap011 f <span class="mi">1</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It would be nice to have a consistent way to name the different ways in which this can be dependent.  The following are a sort of half-hearted attempt. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb6"><span class="kn">Definition</span> <span class="nf">ap011D</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span>:A), B a -&gt; C)
           {<span class="nv">x</span> <span class="nv">x&#39;</span>} (<span class="nv">p</span> : x = x&#39;) {<span class="nv">y</span> <span class="nv">y&#39;</span>} (<span class="nv">q</span> : p # y = y&#39;)
: f x y = f x&#39; y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x y = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x y = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb8"><span class="kn">Definition</span> <span class="nf">ap01D1</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span>:A), B a -&gt; C a)
           {<span class="nv">x</span> <span class="nv">x&#39;</span>} (<span class="nv">p</span> : x = x&#39;) {<span class="nv">y</span> <span class="nv">y&#39;</span>} (<span class="nv">q</span> : p # y = y&#39;)
: transport C p (f x y) = f x&#39; y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport C p (f x y) = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport C p (f x y) = f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkba"><span class="kn">Definition</span> <span class="nf">apD011</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span>:A) (<span class="nv">b</span>:B a), C a b)
           {<span class="nv">x</span> <span class="nv">x&#39;</span>} (<span class="nv">p</span> : x = x&#39;) {<span class="nv">y</span> <span class="nv">y&#39;</span>} (<span class="nv">q</span> : p # y = y&#39;)
: transport (C x&#39;) q (transportD B C p y (f x y)) = f x&#39; y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), C a b</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x&#39;) q (transportD B C p y (f x y)) =
f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), C a b</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport B p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x&#39;) q (transportD B C p y (f x y)) =
f x&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Transporting along two 1-dimensional paths *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport011</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A -&gt; B -&gt; <span class="kt">Type</span>) {<span class="nv">x1</span> <span class="nv">x2</span> : A} {<span class="nv">y1</span> <span class="nv">y2</span> : B}
  (<span class="nv">p</span> : x1 = x2) (<span class="nv">q</span> : y1 = y2) (<span class="nv">z</span> : P x1 y1)
  : P x2 y2
  := transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x y2) p (transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; P x1 y) q z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkbc"><span class="kn">Definition</span> <span class="nf">transport011_pp</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A -&gt; B -&gt; <span class="kt">Type</span>) {<span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> : A} {<span class="nv">y1</span> <span class="nv">y2</span> <span class="nv">y3</span> : B}
  (<span class="nv">p1</span> : x1 = x2) (<span class="nv">p2</span> : x2 = x3) (<span class="nv">q1</span> : y1 = y2) (<span class="nv">q2</span> : y2 = y3) (<span class="nv">z</span> : P x1 y1)
  : transport011 P (p1 @ p2) (q1 @ q2) z
    = transport011 P p2 q2 (transport011 P p1 q1 z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2, x3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1, y2, y3</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>x2 = x3</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>y2 = y3</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport011 P (p1 @ p2) (q1 @ q2) z =
transport011 P p2 q2 (transport011 P p1 q1 z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkbd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2, x3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1, y2, y3</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>x2 = x3</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>y2 = y3</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport011 P (p1 @ p2) (q1 @ q2) z =
transport011 P p2 q2 (transport011 P p1 q1 z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p1, p2, q1, q2; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkbe"><span class="kn">Definition</span> <span class="nf">transport011_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span>} (<span class="nv">P</span> : A -&gt; B -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : A&#39; -&gt; A) (<span class="nv">g</span> : B&#39; -&gt; B)
  {<span class="nv">x1</span> <span class="nv">x2</span> : A&#39;} {<span class="nv">y1</span> <span class="nv">y2</span> : B&#39;} (<span class="nv">p</span> : x1 = x2) (<span class="nv">q</span> : y1 = y2) (<span class="nv">z</span> : P (f x1) (g y1))
  : transport011 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; P (f x) (g y)) p q z
   = transport011 P (ap f p) (ap g q) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P (f x1) (g y1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport011 (<span class="kr">fun</span> (<span class="nv">x</span> : A&#39;) (<span class="nv">y</span> : B&#39;) =&gt; P (f x) (g y))
  p q z = transport011 P (ap f p) (ap g q) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkbf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P (f x1) (g y1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport011 (<span class="kr">fun</span> (<span class="nv">x</span> : A&#39;) (<span class="nv">y</span> : B&#39;) =&gt; P (f x) (g y))
  p q z = transport011 P (ap f p) (ap g q) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [transport011]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc0"><span class="kn">Definition</span> <span class="nf">ap_transport011</span>{<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; B -&gt; <span class="kt">Type</span>}
  {<span class="nv">a1</span> <span class="nv">a2</span> : A} {<span class="nv">b1</span> <span class="nv">b2</span> : B} (<span class="nv">p</span> : a1 = a2) (<span class="nv">q</span> : b1 = b2)
  (<span class="nv">f</span> : <span class="kr">forall</span> {<span class="nv">a</span> <span class="nv">b</span>}, P a b -&gt; Q a b) (<span class="nv">x</span> : P a1 b1)
  : f (transport011 P p q x) = transport011 Q p q (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b1 = b2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b -&gt; Q a b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a1 b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a2 b2 (transport011 P p q x) =
transport011 Q p q (f a1 b1 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b1 = b2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b -&gt; Q a b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a1 b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a2 b2 (transport011 P p q x) =
transport011 Q p q (f a1 b1 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Transporting along higher-dimensional paths *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  (<span class="nv">r</span> : p = q) (<span class="nv">z</span> : P x)
  : p # z = q # z
  := ap (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; p&#39; # z) r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An alternative definition. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport2_is_ap10</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  (<span class="nv">r</span> : p = q) (<span class="nv">z</span> : Q x)
  : transport2 Q r z = ap10 (ap (transport Q) r) z
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc2"><span class="kn">Definition</span> <span class="nf">transport2_p2p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : x = y}
  (<span class="nv">r1</span> : p1 = p2) (<span class="nv">r2</span> : p2 = p3) (<span class="nv">z</span> : P x)
  : transport2 P (r1 @ r2) z = transport2 P r1 z @ transport2 P r2 z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1, p2, p3</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>p1 = p2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>p2 = p3</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport2 P (r1 @ r2) z =
transport2 P r1 z @ transport2 P r2 z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1, p2, p3</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>p1 = p2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>p2 = p3</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport2 P (r1 @ r2) z =
transport2 P r1 z @ transport2 P r2 z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> r1, r2; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport2_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  (<span class="nv">r</span> : p = q) (<span class="nv">z</span> : Q x)
  : transport2 Q (r^) z = (transport2 Q r z)^
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_AT</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  {<span class="nv">z</span> <span class="nv">w</span> : P x} (<span class="nv">r</span> : p = q) (<span class="nv">s</span> : z = w)
  : ap (transport P p) s  @  transport2 P r w
    = transport2 P r z  @  ap (transport P q) s
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; (concat_p1_1p _) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc4"><span class="kn">Definition</span> <span class="nf">transport_pp_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">a</span> <span class="nv">b</span> : A} (<span class="nv">p</span> : a = b) (<span class="nv">x</span> : P a)
  : transport_pp P p <span class="mi">1</span> x = transport2 P (concat_p1 p) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_pp P p <span class="mi">1</span> x = transport2 P (concat_p1 p) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_pp P p <span class="mi">1</span> x = transport2 P (concat_p1 p) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Naturality of transport.  TODO: What should this be called?  [transport_postcompose]? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc6"><span class="kn">Lemma</span> <span class="nf">ap_transport</span> {<span class="nv">A</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q x) (<span class="nv">z</span> : P x) :
  f y (p # z) = (p # (f x z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y (transport P p z) = transport Q p (f x z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y (transport P p z) = transport Q p (f x z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc8"><span class="kn">Lemma</span> <span class="nf">ap_transportD</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
      (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C1</span> <span class="nv">C2</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>)
      (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, C1 a b -&gt; C2 a b)
      {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B x1) (<span class="nv">z</span> : C1 x1 y)
: f x2 (p # y) (transportD B C1 p y z)
  = transportD B C2 p y (f x1 y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), C1 a b -&gt; C2 a b</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C1 x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x2 (transport B p y) (transportD B C1 p y z) =
transportD B C2 p y (f x1 y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), C1 a b -&gt; C2 a b</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C1 x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x2 (transport B p y) (transportD B C1 p y z) =
transportD B C2 p y (f x1 y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkca"><span class="kn">Lemma</span> <span class="nf">ap_transportD2</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
      (<span class="nv">B</span> <span class="nv">C</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">D1</span> <span class="nv">D2</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a -&gt; C a -&gt; <span class="kt">Type</span>)
      (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, D1 a b c -&gt; D2 a b c)
      {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B x1) (<span class="nv">z</span> : C x1) (<span class="nv">w</span> : D1 x1 y z)
: f x2 (p # y) (p # z) (transportD2 B C D1 p y z w)
  = transportD2 B C D2 p y z (f x1 y z w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) (<span class="nv">c</span> : C a),
D1 a b c -&gt; D2 a b c</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>D1 x1 y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x2 (transport B p y) (transport C p z)
  (transportD2 B C D1 p y z w) =
transportD2 B C D2 p y z (f x1 y z w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkcb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) (<span class="nv">c</span> : C a),
D1 a b c -&gt; D2 a b c</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>D1 x1 y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x2 (transport B p y) (transport C p z)
  (transportD2 B C D1 p y z w) =
transportD2 B C D2 p y z (f x1 y z w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: What should this be called? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkcc"><span class="kn">Lemma</span> <span class="nf">ap_transport_pV</span> {<span class="nv">X</span>} (<span class="nv">Y</span> : X -&gt; <span class="kt">Type</span>) {<span class="nv">x1</span> <span class="nv">x2</span> : X} (<span class="nv">p</span> : x1 = x2)
      {<span class="nv">y1</span> <span class="nv">y2</span> : Y x2} (<span class="nv">q</span> : y1 = y2)
: ap (transport Y p) (ap (transport Y p^) q) =
  transport_pV Y p y1 @ q @ (transport_pV Y p y2)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport Y p) (ap (transport Y p^) q) =
(transport_pV Y p y1 @ q) @ (transport_pV Y p y2)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkcd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport Y p) (ap (transport Y p^) q) =
(transport_pV Y p y1 @ q) @ (transport_pV Y p y2)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: And this? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkce"><span class="kn">Definition</span> <span class="nf">transport_pV_ap</span> {<span class="nv">X</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x)
      {<span class="nv">x1</span> <span class="nv">x2</span> : X} (<span class="nv">p</span> : x1 = x2)
: ap (transport P p) (apD f p^) @ apD f p = transport_pV P p (f x2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, P x</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport P p) (apD f p^) @ apD f p =
transport_pV P p (f x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, P x</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport P p) (apD f p^) @ apD f p =
transport_pV P p (f x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd0"><span class="kn">Definition</span> <span class="nf">apD_pp</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x)
           {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z)
  : apD f (p @ q)
    = transport_pp P p q (f x) @ ap (transport P q) (apD f p) @ apD f q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f (p @ q) =
(transport_pp P p q (f x) @
 ap (transport P q) (apD f p)) @ apD f q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f (p @ q) =
(transport_pp P p q (f x) @
 ap (transport P q) (apD f p)) @ apD f q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd2"><span class="kn">Definition</span> <span class="nf">apD_V</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x)
           {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : apD f p^ = moveR_transport_V _ _ _ _ (apD f p)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f p^ =
moveR_transport_V P p (f y) (f x) (apD f p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f p^ =
moveR_transport_V P p (f y) (f x) (apD f p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Transporting in particular fibrations. *)</span>

<span class="sd">(** One frequently needs lemmas showing that transport in a certain dependent type is equal to some more explicitly defined operation, defined according to the structure of that dependent type.  For most dependent types, we prove these lemmas in the appropriate file in the types/ subdirectory.  Here we consider only the most basic cases. *)</span>

<span class="sd">(** Transporting in a constant fibration. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd4"><span class="kn">Definition</span> <span class="nf">transport_const</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B)
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B) p y = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) p y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) p y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd6"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) <span class="mi">1</span> y = y</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport2_const</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x1 = x2}
  (<span class="nv">r</span> : p = q) (<span class="nv">y</span> : B)
  : transport_const p y = transport2 (<span class="kr">fun</span> <span class="nv">_</span> =&gt; B) r y @ transport_const q y
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; (concat_1p _)^ <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd7"><span class="kn">Definition</span> <span class="nf">transportD_const_fiber</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span> : <span class="kt">Type</span>)
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">y</span> : B x1) (<span class="nv">z</span> : C)
  : transportD B (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; C) p y z = z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : B a) =&gt; C) p y z = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : B a) =&gt; C) p y z = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkd9"><span class="kn">Definition</span> <span class="nf">transportD_const_base</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>) {<span class="nv">x1</span> <span class="nv">x2</span> : A}
  (<span class="nv">p</span> : x1 = x2) {<span class="nv">y</span> : B} (<span class="nv">z</span> : C x1 y)
  : transportD (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B) C p y z
    = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x (transport (<span class="kr">fun</span> <span class="nv">_</span> =&gt; B) p y)) p
      (transport (C x1) (transport_const p y)^ z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) C p y z =
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x (transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) p y))
  p (transport (C x1) (transport_const p y)^ z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) C p y z =
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x (transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; B) p y))
  p (transport (C x1) (transport_const p y)^ z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkdb"><span class="kn">Definition</span> <span class="nf">transportDD_const</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span> : <span class="kt">Type</span>)
  {<span class="nv">a1</span> <span class="nv">a2</span> : A} (<span class="nv">pA</span> : a1 = a2)
  {<span class="nv">b1</span> : B a1} {<span class="nv">b2</span> : B a2} (<span class="nv">pB</span> : transport B pA b1 = b2)
  (<span class="nv">c1</span> : C)
  : transportDD B (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; C) pA pB c1 = c1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pA</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B a1</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B a2</span></span></span><br><span><var>pB</var><span class="hyp-type"><b>: </b><span>transport B pA b1 = b2</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportDD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : B a) =&gt; C) pA pB c1 =
c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkdc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pA</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B a1</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B a2</span></span></span><br><span><var>pB</var><span class="hyp-type"><b>: </b><span>transport B pA b1 = b2</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportDD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : B a) =&gt; C) pA pB c1 =
c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> pB, pA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Transporting in a pulled back fibration. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkdd"><span class="kn">Lemma</span> <span class="nf">transport_compose</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">P</span> : B -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">p</span> : x = y) (<span class="nv">z</span> : P (f x))
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (f x)) p z  =  transport P (ap f p) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (f x)) p z =
transport P (ap f p) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkde"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (f x)) p z =
transport P (ap f p) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkdf"><span class="kn">Lemma</span> <span class="nf">transportD_compose</span> {<span class="nv">A</span> <span class="nv">A&#39;</span>} <span class="nv">B</span> {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} (<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">x</span> : A&#39;, B x -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; A&#39;)
      (<span class="nv">p</span> : x = x&#39;) <span class="nv">y</span> (<span class="nv">z</span> : C (f x) y)
: transportD (B o f) (C oD f) p y z
  = transport (C (f x&#39;)) (transport_compose B f p y)^ (transportD B C (ap f p) y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A&#39;, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B (f x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C (f x) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD (B o f) (C oD f) p y z =
transport (C (f x&#39;)) (transport_compose B f p y)^
  (transportD B C (ap f p) y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A&#39;, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B (f x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C (f x) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD (B o f) (C oD f) p y z =
transport (C (f x&#39;)) (transport_compose B f p y)^
  (transportD B C (ap f p) y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: Is there a lemma like [transportD_compose], but for [apD], which subsumes this? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke1"><span class="kn">Lemma</span> <span class="nf">transport_apD_transportD</span> {<span class="nv">A</span>} <span class="nv">B</span> (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x -&gt; <span class="kt">Type</span>)
      {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">z</span> : C x1 (f x1))
: apD f p # transportD B C p _ z
  = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x (f x)) p z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1 (f x1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x2) (apD f p) (transportD B C p (f x1) z) =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x (f x)) p z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1 (f x1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x2) (apD f p) (transportD B C p (f x1) z) =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x (f x)) p z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke3"><span class="kn">Lemma</span> <span class="nf">transport_precompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> <span class="nv">g&#39;</span> : B -&gt; C) (<span class="nv">p</span> : g = g&#39;)
: transport (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; g o f = h o f) p <span class="mi">1</span> =
  ap (<span class="kr">fun</span> <span class="nv">h</span> =&gt; h o f) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; g o f = h o f) p <span class="mi">1</span> =
ap (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; h o f) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; g o f = h o f) p <span class="mi">1</span> =
ap (<span class="kr">fun</span> <span class="nv">h</span> : B -&gt; C =&gt; h o f) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A special case of [transport_compose] which seems to come up a lot. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_idmap_ap</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x)
: transport P p u = transport idmap (ap P p) u
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; idpath <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A combination of [transport_compose] with [transport2]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_compose_path_ap</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : Y -&gt; <span class="kt">Type</span>) (<span class="nv">g</span> : X -&gt; Y)
  {<span class="nv">x0</span> <span class="nv">x1</span> : X} {<span class="nv">p</span> : x0 = x1} {<span class="nv">r</span> : g x0 = g x1} (<span class="nv">s</span> : ap g p = r)
  (<span class="nv">z</span> : P (g x0))
  : transport (P o g) p z = transport P r z
  := transport_compose P g p z @ transport2 P s z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Sometimes, it&#39;s useful to have the goal be in terms of [ap], so we can use lemmas about [ap].  However, we can&#39;t just [rewrite !transport_idmap_ap], as that&#39;s likely to loop.  So, instead, we provide a tactic [transport_to_ap], that replaces all [transport P p u] with [transport idmap (ap P p) u] for non-[idmap] [P]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">transport_to_ap</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
           | [ |- <span class="kp">context</span>[transport <span class="nl">?P</span> <span class="nl">?p</span> <span class="nl">?u</span>] ]
             =&gt; <span class="kr">match</span> P <span class="kr">with</span>
                  | idmap =&gt; <span class="kp">fail</span> <span class="mi">1</span> <span class="c">(* we don&#39;t want to turn [transport idmap (ap _ _)] into [transport idmap (ap idmap (ap _ _))] *)</span>
                  | _ =&gt; <span class="kp">idtac</span>
                <span class="kr">end</span>;
               <span class="kp">progress</span> <span class="nb">rewrite</span> (transport_idmap_ap P p u)
         <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Transporting in a fibration dependent on two independent types commutes. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke5"><span class="kn">Definition</span> <span class="nf">transport_transport</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>)
           {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) {<span class="nv">y1</span> <span class="nv">y2</span> : B} (<span class="nv">q</span> : y1 = y2)
           (<span class="nv">c</span> : C x1 y1)
: transport (C x2) q (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x y1) p c)
  = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x y2) p (transport (C x1) q c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x2) q
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y1) p c) =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y2) p
  (transport (C x1) q c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (C x2) q
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y1) p c) =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y2) p
  (transport (C x1) q c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** The behavior of [ap] and [apD]. *)</span>

<span class="sd">(** In a constant fibration, [apD] reduces to [ap], modulo [transport_const]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke7"><span class="kn">Lemma</span> <span class="nf">apD_const</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">p</span>: x = y) :
  apD f p = transport_const p (f x) @ ap f p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f p = transport_const p (f x) @ ap f p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f p = transport_const p (f x) @ ap f p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chke9"><span class="kn">Definition</span> <span class="nf">apD_compose</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A&#39; -&gt; <span class="kt">Type</span>} (<span class="nv">g</span> : A -&gt; A&#39;)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : apD (f o g) p  = (transport_compose _ _ _ _) @ apD f (ap g p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A&#39;, B a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (f o g) p =
transport_compose B g p (f (g x)) @ apD f (ap g p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A&#39;, B a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (f o g) p =
transport_compose B g p (f (g x)) @ apD f (ap g p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkeb"><span class="kn">Definition</span> <span class="nf">apD_compose&#39;</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A&#39; -&gt; <span class="kt">Type</span>} (<span class="nv">g</span> : A -&gt; A&#39;)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : apD f (ap g p) = (transport_compose B _ _ _)^ @ apD (f o g) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A&#39;, B a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f (ap g p) =
(transport_compose B g p (f (g x)))^ @ apD (f o g) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A&#39;, B a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD f (ap g p) =
(transport_compose B g p (f (g x)))^ @ apD (f o g) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The 2-dimensional groupoid structure *)</span>

<span class="sd">(** Horizontal composition of 2-dimensional paths. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat2</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y} {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z} (<span class="nv">h</span> : p = p&#39;) (<span class="nv">h&#39;</span> : q = q&#39;)
  : p @ q = p&#39; @ q&#39;
:= <span class="kr">match</span> h, h&#39; <span class="kr">with</span> idpath, idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p @@ q&quot;</span> := (concat2 p q)%path : path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> concat2 : <span class="nb">simpl</span> nomatch.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chked"><span class="kn">Lemma</span> <span class="nf">concat2_ap_ap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x&#39;</span> <span class="nv">y&#39;</span> <span class="nv">z&#39;</span> : B}
           (<span class="nv">f</span> : A -&gt; (x&#39; = y&#39;)) (<span class="nv">g</span> : A -&gt; (y&#39; = z&#39;))
           {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
: (ap f p) @@ (ap g p) = ap (<span class="kr">fun</span> <span class="nv">u</span> =&gt; f u @ g u) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x', y', z'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; x&#39; = y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; y&#39; = z&#39;</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p @@ ap g p = ap (<span class="kr">fun</span> <span class="nv">u</span> : A =&gt; f u @ g u) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x', y', z'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; x&#39; = y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; y&#39; = z&#39;</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p @@ ap g p = ap (<span class="kr">fun</span> <span class="nv">u</span> : A =&gt; f u @ g u) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> path_induction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** 2-dimensional path inversion *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inverse2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y} (<span class="nv">h</span> : p = q)
  : p^ = q^
:= ap inverse h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Two common combinations of [ap_pp] and [ap_V]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_pV</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">a0</span> <span class="nv">a1</span> <span class="nv">a0&#39;</span> : A} (<span class="nv">p</span> : a0 = a1) (<span class="nv">q</span> : a0&#39; = a1)
  : ap f (p @ q^) = ap f p @ (ap f q)^
  := ap_pp f p q^ @ (<span class="mi">1</span> @@ ap_V f q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_Vp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">a0</span> <span class="nv">a1</span> <span class="nv">a1&#39;</span> : A} (<span class="nv">p</span> : a0 = a1) (<span class="nv">q</span> : a0 = a1&#39;)
  : ap f (p^ @ q) = (ap f p)^ @ ap f q
  := ap_pp f p^ q @ (ap_V f p @@ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Some higher coherences *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkef"><span class="kn">Lemma</span> <span class="nf">ap_pp_concat_p1</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">a</span> <span class="nv">b</span> : A} (<span class="nv">p</span> : a = b)
  : ap_pp f p <span class="mi">1</span> @ concat_p1 (ap f p) = ap (ap f) (concat_p1 p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pp f p <span class="mi">1</span> @ concat_p1 (ap f p) =
ap (ap f) (concat_p1 p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pp f p <span class="mi">1</span> @ concat_p1 (ap f p) =
ap (ap f) (concat_p1 p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf1"><span class="kn">Lemma</span> <span class="nf">ap_pp_concat_1p</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">a</span> <span class="nv">b</span> : A} (<span class="nv">p</span> : a = b)
  : ap_pp f <span class="mi">1</span> p @ concat_1p (ap f p) = ap (ap f) (concat_1p p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pp f <span class="mi">1</span> p @ concat_1p (ap f p) =
ap (ap f) (concat_1p p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pp f <span class="mi">1</span> p @ concat_1p (ap f p) =
ap (ap f) (concat_1p p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf3"><span class="kn">Lemma</span> <span class="nf">ap_pV_concat_pV</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : ap_pV f p p @ concat_pV (ap f p) = ap (ap f) (concat_pV p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pV f p p @ concat_pV (ap f p) =
ap (ap f) (concat_pV p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pV f p p @ concat_pV (ap f p) =
ap (ap f) (concat_pV p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf5"><span class="kn">Lemma</span> <span class="nf">ap_Vp_concat_Vp</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  : ap_Vp f p p @ concat_Vp (ap f p)
  = ap (ap f) (concat_Vp p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_Vp f p p @ concat_Vp (ap f p) =
ap (ap f) (concat_Vp p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_Vp f p p @ concat_Vp (ap f p) =
ap (ap f) (concat_Vp p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf7"><span class="kn">Lemma</span> <span class="nf">concat_pV_inverse2</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) (<span class="nv">r</span> : p = q)
: (r @@ inverse2 r) @ concat_pV q = concat_pV p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @@ inverse2 r) @ concat_pV q = concat_pV p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r @@ inverse2 r) @ concat_pV q = concat_pV p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> r, p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkf9"><span class="kn">Lemma</span> <span class="nf">concat_Vp_inverse2</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) (<span class="nv">r</span> : p = q)
: (inverse2 r @@ r) @ concat_Vp q = concat_Vp p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inverse2 r @@ r) @ concat_Vp q = concat_Vp p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkfa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inverse2 r @@ r) @ concat_Vp q = concat_Vp p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> r, p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Often [ap_pV_concat_pV] is combined with [concat_pV_inverse2] using a beta rule for [ap f p].  This and several above are best read from right-to-left, and the name here reflects the right-hand-side. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_ap_concat_pV</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  (<span class="nv">q</span> : f x = f y) (<span class="nv">r</span> : ap f p = q)
  : ap_pV f p p @ ((r @@ inverse2 r) @ concat_pV q) = ap (ap f) (concat_pV p)
  := (<span class="mi">1</span> @@ concat_pV_inverse2 _ q r) @ ap_pV_concat_pV f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_ap_concat_Vp</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  (<span class="nv">q</span> : f x = f y) (<span class="nv">r</span> : ap f p = q)
  : ap_Vp f p p @ ((inverse2 r @@ r) @ concat_Vp q) = ap (ap f) (concat_Vp p)
  := (<span class="mi">1</span> @@ concat_Vp_inverse2 _ q r) @ ap_Vp_concat_Vp f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Whiskering *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerL</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y)
  {<span class="nv">q</span> <span class="nv">r</span> : y = z} (<span class="nv">h</span> : q = r) : p @ q = p @ r
:= <span class="mi">1</span> @@ h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerR</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  (<span class="nv">h</span> : p = q) (<span class="nv">r</span> : y = z) : p @ r = q @ r
:= h @@ <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Unwhiskering, a.k.a. cancelling. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cancelL</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> <span class="nv">r</span> : y = z)
: (p @ q = p @ r) -&gt; (q = r)
:= <span class="kr">fun</span> <span class="nv">h</span> =&gt; (concat_V_pp p q)^ @ whiskerL p^ h @ (concat_V_pp p r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cancelR</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> <span class="nv">q</span> : x = y) (<span class="nv">r</span> : y = z)
: (p @ r = q @ r) -&gt; (p = q)
:= <span class="kr">fun</span> <span class="nv">h</span> =&gt; (concat_pp_V p r)^ @ whiskerR h r^ @ (concat_pp_V q r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Whiskering and identity paths. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerR_p1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y} (<span class="nv">h</span> : p = q) :
  (concat_p1 p)^ @ whiskerR h <span class="mi">1</span> @ concat_p1 q = h
  :=
  <span class="kr">match</span> h <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt;
      <span class="mi">1</span>
    <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerR_1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  whiskerR <span class="mi">1</span> q = <span class="mi">1</span> :&gt; (p @ q = p @ q)
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerL_p1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) :
  whiskerL p <span class="mi">1</span> = <span class="mi">1</span> :&gt; (p @ q = p @ q)
  :=
  <span class="kr">match</span> q <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiskerL_1p</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y} (<span class="nv">h</span> : p = q) :
  (concat_1p p) ^ @ whiskerL <span class="mi">1</span> h @ concat_1p q = h
  :=
  <span class="kr">match</span> h <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt;
      <span class="mi">1</span>
    <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkfb"><span class="kn">Definition</span> <span class="nf">whiskerR_p1_1</span> {<span class="nv">A</span>} {<span class="nv">x</span> : A} (<span class="nv">h</span> : idpath x = idpath x)
: whiskerR h <span class="mi">1</span> = h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR h <span class="mi">1</span> = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR h <span class="mi">1</span> = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkfd"><span class="nb">refine</span> (_ @ whiskerR_p1 h); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR h <span class="mi">1</span> = (<span class="mi">1</span> @ whiskerR h <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (concat_p1 _ @ concat_1p _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkfe"><span class="kn">Definition</span> <span class="nf">whiskerL_1p_1</span> {<span class="nv">A</span>} {<span class="nv">x</span> : A} (<span class="nv">h</span> : idpath x = idpath x)
: whiskerL <span class="mi">1</span> h = h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL <span class="mi">1</span> h = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chkff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL <span class="mi">1</span> h = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk100"><span class="nb">refine</span> (_ @ whiskerL_1p h); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL <span class="mi">1</span> h = (<span class="mi">1</span> @ whiskerL <span class="mi">1</span> h) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (concat_p1 _ @ concat_1p _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk101"><span class="kn">Definition</span> <span class="nf">cancel2L</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y} {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z}
           (<span class="nv">g</span> : p = p&#39;) (<span class="nv">h</span> <span class="nv">k</span> : q = q&#39;)
: (g @@ h = g @@ k) -&gt; (h = k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g @@ h = g @@ k -&gt; h = k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk102"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g @@ h = g @@ k -&gt; h = k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk103"><span class="nb">intro</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ h = g @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h = k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk104"><span class="nb">induction</span> g, p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> @@ h = <span class="mi">1</span> @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h = k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk105"><span class="nb">refine</span> ((whiskerL_1p h)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> @@ h = <span class="mi">1</span> @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_1p <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> h) @ concat_1p q&#39; = k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk106"><span class="nb">refine</span> (_ @ (whiskerL_1p k)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> @@ h = <span class="mi">1</span> @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_1p <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> h) @ concat_1p q&#39; =
((concat_1p <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> k) @ concat_1p q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk107"><span class="nb">refine</span> (whiskerR _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> @@ h = <span class="mi">1</span> @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_1p <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> h =
(concat_1p <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk108"><span class="nb">refine</span> (whiskerL _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> @@ h = <span class="mi">1</span> @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL <span class="mi">1</span> h = whiskerL <span class="mi">1</span> k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk109"><span class="kn">Definition</span> <span class="nf">cancel2R</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y} {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z}
           (<span class="nv">g</span> <span class="nv">h</span> : p = p&#39;) (<span class="nv">k</span> : q = q&#39;)
: (g @@ k = h @@ k) -&gt; (g = h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g @@ k = h @@ k -&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g @@ k = h @@ k -&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10b"><span class="nb">intro</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ k = h @@ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10c"><span class="nb">induction</span> k, p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ <span class="mi">1</span> = h @@ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10d"><span class="nb">refine</span> ((whiskerR_p1 g)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ <span class="mi">1</span> = h @@ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_p1 <span class="mi">1</span>)^ @ whiskerR g <span class="mi">1</span>) @ concat_p1 p&#39; = h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10e"><span class="nb">refine</span> (_ @ (whiskerR_p1 h)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ <span class="mi">1</span> = h @@ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_p1 <span class="mi">1</span>)^ @ whiskerR g <span class="mi">1</span>) @ concat_p1 p&#39; =
((concat_p1 <span class="mi">1</span>)^ @ whiskerR h <span class="mi">1</span>) @ concat_p1 p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk10f"><span class="nb">refine</span> (whiskerR _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ <span class="mi">1</span> = h @@ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_p1 <span class="mi">1</span>)^ @ whiskerR g <span class="mi">1</span> =
(concat_p1 <span class="mi">1</span>)^ @ whiskerR h <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk110"><span class="nb">refine</span> (whiskerL _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = p&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g @@ <span class="mi">1</span> = h @@ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR g <span class="mi">1</span> = whiskerR h <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** Whiskering and composition *)</span>

<span class="c">(* The naming scheme for these is a little unclear; should [pp] refer to concatenation of the 2-paths being whiskered or of the paths we are whiskering by? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk111"><span class="kn">Definition</span> <span class="nf">whiskerL_pp</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) {<span class="nv">q</span> <span class="nv">q&#39;</span> <span class="nv">q&#39;&#39;</span> : y = z}
           (<span class="nv">r</span> : q = q&#39;) (<span class="nv">s</span> : q&#39; = q&#39;&#39;)
: whiskerL p (r @ s) = whiskerL p r @ whiskerL p s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (r @ s) = whiskerL p r @ whiskerL p s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (r @ s) = whiskerL p r @ whiskerL p s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, r, s; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk113"><span class="kn">Definition</span> <span class="nf">whiskerR_pp</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> <span class="nv">p&#39;&#39;</span> : x = y} (<span class="nv">q</span> : y = z)
           (<span class="nv">r</span> : p = p&#39;) (<span class="nv">s</span> : p&#39; = p&#39;&#39;)
: whiskerR (r @ s) q = whiskerR r q @ whiskerR s q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR (r @ s) q = whiskerR r q @ whiskerR s q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk114"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR (r @ s) q = whiskerR r q @ whiskerR s q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> q, r, s; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* For now, I&#39;ve put an [L] or [R] to mark when we&#39;re referring to the whiskering paths. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk115"><span class="kn">Definition</span> <span class="nf">whiskerL_VpL</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y)
           {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z} (<span class="nv">r</span> : q = q&#39;)
: (concat_V_pp p q)^ @ whiskerL p^ (whiskerL p r) @ concat_V_pp p q&#39;
  = r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_V_pp p q)^ @ whiskerL p^ (whiskerL p r)) @
concat_V_pp p q&#39; = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_V_pp p q)^ @ whiskerL p^ (whiskerL p r)) @
concat_V_pp p q&#39; = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk117"><span class="nb">destruct</span> p, r, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_V_pp <span class="mi">1</span> <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span>^ (whiskerL <span class="mi">1</span> <span class="mi">1</span>)) @
concat_V_pp <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk118"><span class="kn">Definition</span> <span class="nf">whiskerL_pVL</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : y = x)
           {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z} (<span class="nv">r</span> : q = q&#39;)
: (concat_p_Vp p q)^ @ whiskerL p (whiskerL p^ r) @ concat_p_Vp p q&#39;
  = r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_p_Vp p q)^ @ whiskerL p (whiskerL p^ r)) @
concat_p_Vp p q&#39; = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk119"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_p_Vp p q)^ @ whiskerL p (whiskerL p^ r)) @
concat_p_Vp p q&#39; = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11a"><span class="nb">destruct</span> p, r, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_p_Vp <span class="mi">1</span> <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> (whiskerL <span class="mi">1</span>^ <span class="mi">1</span>)) @
concat_p_Vp <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11b"><span class="kn">Definition</span> <span class="nf">whiskerR_pVR</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y}
           (<span class="nv">r</span> : p = p&#39;) (<span class="nv">q</span> : y = z)
: (concat_pp_V p q)^ @ whiskerR (whiskerR r q) q^ @ concat_pp_V p&#39; q
  = r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pp_V p q)^ @ whiskerR (whiskerR r q) q^) @
concat_pp_V p&#39; q = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pp_V p q)^ @ whiskerR (whiskerR r q) q^) @
concat_pp_V p&#39; q = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11d"><span class="nb">destruct</span> p, r, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pp_V <span class="mi">1</span> <span class="mi">1</span>)^ @ whiskerR (whiskerR <span class="mi">1</span> <span class="mi">1</span>) <span class="mi">1</span>^) @
concat_pp_V <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11e"><span class="kn">Definition</span> <span class="nf">whiskerR_VpR</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y}
           (<span class="nv">r</span> : p = p&#39;) (<span class="nv">q</span> : z = y)
: (concat_pV_p p q)^ @ whiskerR (whiskerR r q^) q @ concat_pV_p p&#39; q
  = r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pV_p p q)^ @ whiskerR (whiskerR r q^) q) @
concat_pV_p p&#39; q = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk11f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>z = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pV_p p q)^ @ whiskerR (whiskerR r q^) q) @
concat_pV_p p&#39; q = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk120"><span class="nb">destruct</span> p, r, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((concat_pV_p <span class="mi">1</span> <span class="mi">1</span>)^ @ whiskerR (whiskerR <span class="mi">1</span> <span class="mi">1</span>^) <span class="mi">1</span>) @
concat_pV_p <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [concat_p_pp] in left-most argument. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk121"><span class="kn">Definition</span> <span class="nf">concat_p_pp_nat_l</span> {<span class="nv">A</span>} {<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A}
  {<span class="nv">p</span> <span class="nv">p&#39;</span> : w = x} (<span class="nv">h</span> : p = p&#39;) (<span class="nv">q</span> : x = y) (<span class="nv">r</span> : y = z)
  : whiskerR h (q @ r) @ concat_p_pp p&#39; q r
    = concat_p_pp p q r @ whiskerR (whiskerR h q) r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR h (q @ r) @ concat_p_pp p&#39; q r =
concat_p_pp p q r @ whiskerR (whiskerR h q) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerR h (q @ r) @ concat_p_pp p&#39; q r =
concat_p_pp p q r @ whiskerR (whiskerR h q) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> h, p, q, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [concat_p_pp] in middle argument. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk123"><span class="kn">Definition</span> <span class="nf">concat_p_pp_nat_m</span> {<span class="nv">A</span>} {<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A}
  (<span class="nv">p</span> : w = x) {<span class="nv">q</span> <span class="nv">q&#39;</span> : x = y} (<span class="nv">h</span> : q = q&#39;) (<span class="nv">r</span> : y = z)
  : whiskerL p (whiskerR h r) @ concat_p_pp p q&#39; r
    = concat_p_pp p q r @ whiskerR (whiskerL p h) r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (whiskerR h r) @ concat_p_pp p q&#39; r =
concat_p_pp p q r @ whiskerR (whiskerL p h) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk124"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (whiskerR h r) @ concat_p_pp p q&#39; r =
concat_p_pp p q r @ whiskerR (whiskerL p h) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> h, p, q, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naturality of [concat_p_pp] in right-most argument. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk125"><span class="kn">Definition</span> <span class="nf">concat_p_pp_nat_r</span> {<span class="nv">A</span>} {<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A}
  (<span class="nv">p</span> : w = x) (<span class="nv">q</span> : x = y) {<span class="nv">r</span> <span class="nv">r&#39;</span> : y = z} (<span class="nv">h</span> : r = r&#39;)
  : whiskerL p (whiskerL q h) @ concat_p_pp p q r&#39;
    = concat_p_pp p q r @ whiskerL (p @ q) h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r, r'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>r = r&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (whiskerL q h) @ concat_p_pp p q r&#39; =
concat_p_pp p q r @ whiskerL (p @ q) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r, r'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>r = r&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">whiskerL p (whiskerL q h) @ concat_p_pp p q r&#39; =
concat_p_pp p q r @ whiskerL (p @ q) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> h, p, q, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The interchange law for concatenation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk127"><span class="kn">Definition</span> <span class="nf">concat_concat2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} {<span class="nv">p</span> <span class="nv">p&#39;</span> <span class="nv">p&#39;&#39;</span> : x = y} {<span class="nv">q</span> <span class="nv">q&#39;</span> <span class="nv">q&#39;&#39;</span> : y = z}
  (<span class="nv">a</span> : p = p&#39;) (<span class="nv">b</span> : p&#39; = p&#39;&#39;) (<span class="nv">c</span> : q = q&#39;) (<span class="nv">d</span> : q&#39; = q&#39;&#39;) :
  (a @@ c) @ (b @@ d) = (a @ b) @@ (c @ d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a @@ c) @ (b @@ d) = (a @ b) @@ (c @ d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk128"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a @@ c) @ (b @@ d) = (a @ b) @@ (c @ d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk129"><span class="nb">case</span> d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a @@ c) @ (b @@ <span class="mi">1</span>) = (a @ b) @@ (c @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12a"><span class="nb">case</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a @@ <span class="mi">1</span>) @ (b @@ <span class="mi">1</span>) = (a @ b) @@ (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12b"><span class="nb">case</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a @@ <span class="mi">1</span>) @ (<span class="mi">1</span> @@ <span class="mi">1</span>) = (a @ <span class="mi">1</span>) @@ (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12c"><span class="nb">case</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p', p''</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q', q''</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>p&#39; = p&#39;&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>q&#39; = q&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @@ <span class="mi">1</span>) @ (<span class="mi">1</span> @@ <span class="mi">1</span>) = (<span class="mi">1</span> @ <span class="mi">1</span>) @@ (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The interchange law for whiskering.  Special case of [concat_concat2]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concat_whisker</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> <span class="nv">p&#39;</span> : x = y) (<span class="nv">q</span> <span class="nv">q&#39;</span> : y = z) (<span class="nv">a</span> : p = p&#39;) (<span class="nv">b</span> : q = q&#39;) :
  (whiskerR a q) @ (whiskerL p&#39; b) = (whiskerL p b) @ (whiskerR a q&#39;)
  :=
  <span class="kr">match</span> b <span class="kr">with</span>
    idpath =&gt;
    <span class="kr">match</span> a <span class="kr">with</span> idpath =&gt;
      (concat_1p _)^
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Structure corresponding to the coherence equations of a bicategory. *)</span>

<span class="sd">(** The &quot;pentagonator&quot;: the 3-cell witnessing the associativity pentagon. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12d"><span class="kn">Definition</span> <span class="nf">pentagon</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">v</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : v = w) (<span class="nv">q</span> : w = x) (<span class="nv">r</span> : x = y) (<span class="nv">s</span> : y = z)
  : whiskerL p (concat_p_pp q r s)
      @ concat_p_pp p (q@r) s
      @ whiskerR (concat_p_pp p q r) s
  = concat_p_pp p q (r@s) @ concat_p_pp (p@q) r s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v, w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>v = w</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(whiskerL p (concat_p_pp q r s) @
 concat_p_pp p (q @ r) s) @
whiskerR (concat_p_pp p q r) s =
concat_p_pp p q (r @ s) @ concat_p_pp (p @ q) r s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v, w, x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>v = w</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>w = x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(whiskerL p (concat_p_pp q r s) @
 concat_p_pp p (q @ r) s) @
whiskerR (concat_p_pp p q r) s =
concat_p_pp p q (r @ s) @ concat_p_pp (p @ q) r s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk12f"><span class="nb">case</span> p, q, r, s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(whiskerL <span class="mi">1</span> (concat_p_pp <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>) @
 concat_p_pp <span class="mi">1</span> (<span class="mi">1</span> @ <span class="mi">1</span>) <span class="mi">1</span>) @
whiskerR (concat_p_pp <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>) <span class="mi">1</span> =
concat_p_pp <span class="mi">1</span> <span class="mi">1</span> (<span class="mi">1</span> @ <span class="mi">1</span>) @ concat_p_pp (<span class="mi">1</span> @ <span class="mi">1</span>) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The 3-cell witnessing the left unit triangle. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk130"><span class="kn">Definition</span> <span class="nf">triangulator</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z)
  : concat_p_pp p <span class="mi">1</span> q @ whiskerR (concat_p1 p) q
  = whiskerL p (concat_1p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p_pp p <span class="mi">1</span> q @ whiskerR (concat_p1 p) q =
whiskerL p (concat_1p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk131"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p_pp p <span class="mi">1</span> q @ whiskerR (concat_p1 p) q =
whiskerL p (concat_1p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk132"><span class="nb">case</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p_pp <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> @ whiskerR (concat_p1 <span class="mi">1</span>) <span class="mi">1</span> =
whiskerL <span class="mi">1</span> (concat_1p <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Eckmann-Hilton argument *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eckmann_hilton</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span>:A} (<span class="nv">p</span> <span class="nv">q</span> : <span class="mi">1</span> = <span class="mi">1</span> :&gt; (x = x)) : p @ q = q @ p :=
  (whiskerR_p1 p @@ whiskerL_1p q)^
  @ (concat_p1 _ @@ concat_p1 _)
  @ (concat_1p _ @@ concat_1p _)
  @ (concat_whisker _ _ _ _ p q)
  @ (concat_1p _ @@ concat_1p _)^
  @ (concat_p1 _ @@ concat_p1 _)^
  @ (whiskerL_1p q @@ whiskerR_p1 p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The action of functions on 2-dimensional paths *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap02</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span>:A-&gt;B) {<span class="nv">x</span> <span class="nv">y</span>:A} {<span class="nv">p</span> <span class="nv">q</span>:x=y} (<span class="nv">r</span>:p=q) : ap f p = ap f q
  := ap (ap f) r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap02_pp</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span>:A-&gt;B) {<span class="nv">x</span> <span class="nv">y</span>:A} {<span class="nv">p</span> <span class="nv">p&#39;</span> <span class="nv">p&#39;&#39;</span>:x=y} (<span class="nv">r</span>:p=p&#39;) (<span class="nv">r&#39;</span>:p&#39;=p&#39;&#39;)
  : ap02 f (r @ r&#39;) = ap02 f r @ ap02 f r&#39;
  := ap_pp (ap f) r r&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk133"><span class="kn">Definition</span> <span class="nf">ap02_p2p</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span>:A-&gt;B) {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>:A} {<span class="nv">p</span> <span class="nv">p&#39;</span>:x=y} {<span class="nv">q</span> <span class="nv">q&#39;</span>:y=z} (<span class="nv">r</span>:p=p&#39;) (<span class="nv">s</span>:q=q&#39;)
  : ap02 f (r @@ s) = ap_pp f p q
                      @ (ap02 f r @@ ap02 f s)
                      @ (ap_pp f p&#39; q&#39;)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap02 f (r @@ s) =
(ap_pp f p q @ (ap02 f r @@ ap02 f s)) @
(ap_pp f p&#39; q&#39;)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk134"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap02 f (r @@ s) =
(ap_pp f p q @ (ap02 f r @@ ap02 f s)) @
(ap_pp f p&#39; q&#39;)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk135"><span class="nb">case</span> r, s, p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap02 f (<span class="mi">1</span> @@ <span class="mi">1</span>) =
(ap_pp f <span class="mi">1</span> <span class="mi">1</span> @ (ap02 f <span class="mi">1</span> @@ ap02 f <span class="mi">1</span>)) @
(ap_pp f <span class="mi">1</span> <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD02</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y}
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x) (<span class="nv">r</span> : p = q)
  : apD f p = transport2 B r (f x) @ apD f q
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; (concat_1p _)^ <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD02_const</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span> : A} {<span class="nv">p</span> <span class="nv">q</span> : x = y} (<span class="nv">r</span> : p = q)
  : apD02 f r = (apD_const f p)
                  @ (transport2_const r (f x) @@ ap02 f r)
                  @ (concat_p_pp _ _ _)^
                  @ (whiskerL (transport2 _ r (f x)) (apD_const f q)^)
  := <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt;
    <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span>
    <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* And now for a lemma whose statement is much longer than its proof. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk136"><span class="kn">Definition</span> <span class="nf">apD02_pp</span> {<span class="nv">A</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>:A, B x) {<span class="nv">x</span> <span class="nv">y</span> : A}
  {<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : x = y} (<span class="nv">r1</span> : p1 = p2) (<span class="nv">r2</span> : p2 = p3)
  : apD02 f (r1 @ r2)
  = apD02 f r1
  @ whiskerL (transport2 B r1 (f x)) (apD02 f r2)
  @ concat_p_pp _ _ _
  @ (whiskerR (transport2_p2p B r1 r2 (f x))^ (apD f p3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1, p2, p3</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>p1 = p2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>p2 = p3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD02 f (r1 @ r2) =
((apD02 f r1 @
  whiskerL (transport2 B r1 (f x)) (apD02 f r2)) @
 concat_p_pp (transport2 B r1 (f x))
   (transport2 B r2 (f x)) (apD f p3)) @
whiskerR (transport2_p2p B r1 r2 (f x))^ (apD f p3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk137"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1, p2, p3</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>p1 = p2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>p2 = p3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD02 f (r1 @ r2) =
((apD02 f r1 @
  whiskerL (transport2 B r1 (f x)) (apD02 f r2)) @
 concat_p_pp (transport2 B r1 (f x))
   (transport2 B r2 (f x)) (apD f p3)) @
whiskerR (transport2_p2p B r1 r2 (f x))^ (apD f p3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk138"><span class="nb">destruct</span> r1, r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD02 f (<span class="mi">1</span> @ <span class="mi">1</span>) =
((apD02 f <span class="mi">1</span> @
  whiskerL (transport2 B <span class="mi">1</span> (f x)) (apD02 f <span class="mi">1</span>)) @
 concat_p_pp (transport2 B <span class="mi">1</span> (f x))
   (transport2 B <span class="mi">1</span> (f x)) (apD f p1)) @
whiskerR (transport2_p2p B <span class="mi">1</span> <span class="mi">1</span> (f x))^ (apD f p1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk139"><span class="nb">destruct</span> p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD02 f (<span class="mi">1</span> @ <span class="mi">1</span>) =
((apD02 f <span class="mi">1</span> @
  whiskerL (transport2 B <span class="mi">1</span> (f x)) (apD02 f <span class="mi">1</span>)) @
 concat_p_pp (transport2 B <span class="mi">1</span> (f x))
   (transport2 B <span class="mi">1</span> (f x)) (apD f <span class="mi">1</span>)) @
whiskerR (transport2_p2p B <span class="mi">1</span> <span class="mi">1</span> (f x))^ (apD f <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13a"><span class="kn">Definition</span> <span class="nf">ap022</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> <span class="nv">y&#39;</span>}
  {<span class="nv">p</span> <span class="nv">p&#39;</span> : x = x&#39;} (<span class="nv">r</span> : p = p&#39;) {<span class="nv">q</span> <span class="nv">q&#39;</span> : y = y&#39;} (<span class="nv">s</span> : q = q&#39;)
  : ap011 f p q = ap011 f p&#39; q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p q = ap011 f p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f p q = ap011 f p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13c"><span class="nb">destruct</span> r, p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 f <span class="mi">1</span> q = ap011 f <span class="mi">1</span> q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13d"><span class="nb">apply</span> ap02.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q = q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q = q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> s.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** These lemmas need better names. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13e"><span class="kn">Definition</span> <span class="nf">ap_transport_Vp_idmap</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">p</span> <span class="nv">q</span> : A = B) (<span class="nv">r</span> : q = p) (<span class="nv">z</span> : A)
: ap (transport idmap q^) (ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z) r)
  @ ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s (p # z)) (inverse2 r)
  @ transport_Vp idmap p z
  = transport_Vp idmap q z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = p</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap q^)
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z) r) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
    transport idmap s (transport idmap p z))
   (inverse2 r)) @ transport_Vp idmap p z =
transport_Vp idmap q z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk13f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = p</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap q^)
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z) r) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
    transport idmap s (transport idmap p z))
   (inverse2 r)) @ transport_Vp idmap p z =
transport_Vp idmap q z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> path_induction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk140"><span class="kn">Definition</span> <span class="nf">ap_transport_pV_idmap</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">p</span> <span class="nv">q</span> : A = B) (<span class="nv">r</span> : q = p) (<span class="nv">z</span> : B)
: ap (transport idmap q) (ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s^ z) r)
  @ ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s (p^ # z)) r
  @ transport_pV idmap p z
  = transport_pV idmap q z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = p</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap q)
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z) r) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
    transport idmap s (transport idmap p^ z)) r) @
transport_pV idmap p z = transport_pV idmap q z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pathgroupoids-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="pathgroupoids-v-chk141"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>q = p</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap q)
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z) r) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
    transport idmap s (transport idmap p^ z)) r) @
transport_pV idmap p z = transport_pV idmap q z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> path_induction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Hints *)</span>

<span class="sd">(** We declare some more [Hint Resolve] hints, now in the &quot;hint database&quot; [path_hints].  In general various hints (resolve, rewrite, unfold hints) can be grouped into &quot;databases&quot;. This is necessary as sometimes different kinds of hints cannot be mixed, for example because they would cause a combinatorial explosion or rewriting cycles.  A specific [Hint Resolve] database [db] can be used with [auto with db].</span>

<span class="sd">    The hints in [path_hints] are designed to push concatenation *outwards*, eliminate identities and inverses, and associate to the left as far as possible. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span>
  inverse
  concat_1p concat_p1 concat_p_pp
  inv_pp inv_V
  : path_hints.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* First try at a paths db.  We want the RHS of the equation to become strictly simpler. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Rewrite</span>
  @concat_p1
  @concat_1p
  @concat_p_pp <span class="c">(* there is a choice here !*)</span>
  @concat_pV
  @concat_Vp
  @concat_V_pp
  @concat_p_Vp
  @concat_pp_V
  @concat_pV_p
  <span class="c">(*@inv_pp*)</span> <span class="c">(* I am not sure about this one *)</span>
  @inv_V
  @moveR_Mp
  @moveR_pM
  @moveL_Mp
  @moveL_pM
  @moveL_1M
  @moveL_M1
  @moveR_M1
  @moveR_1M
  @ap_1
  <span class="c">(* @ap_pp</span>
<span class="c">  @ap_p_pp ?*)</span>
  @inverse_ap
  @ap_idmap
  <span class="c">(* @ap_compose</span>
<span class="c">  @ap_compose&#39;*)</span>
  @ap_const
  <span class="c">(* Unsure about naturality of [ap], was absent in the old implementation. *)</span>
  @apD10_1
  : paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">hott_simpl</span> :=
  <span class="nb">autorewrite with</span> paths <span class="kr">in</span> * |- * ; <span class="nb">auto with</span> path_hints.</span></span></pre>
</div>
</div></body>
</html>
