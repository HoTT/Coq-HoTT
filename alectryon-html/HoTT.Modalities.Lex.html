<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Lex.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber Limits.Pullback Factorization Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modality Accessible Modalities.Localization Descent Separated.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> subuniverse_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Lex modalities *)</span>

<span class="sd">(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  Many equivalent characterizations of this can be found in Theorem 3.1 of RSS.</span>

<span class="sd">We choose as our definition that a lex modality to be a reflective subuniverse such that [O &lt;&lt;&lt; O], which is close to (but not quite the same as) RSS Theorem 3.1 (xiii).</span>

<span class="sd">Note that since this includes [O &lt;&lt; O] as a precondition, such an [O] must indeed be a modality (and since modalities coerce to reflective subuniverses, in the following notation [O] could be either an element of [ReflectiveSubuniverse] or of [Modality]). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">Lex</span> O := (O &lt;&lt;&lt; O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of lex modalities *)</span>

<span class="sd">(** We now show that lex modalities have all the other properties from RSS Theorem 3.1 (which are equivalent to lex-ness).  All of them are simple specializations of properties from [Descent.v] to the case [O&#39; = O] (although in the general case they are not known to be equivalent). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">LexModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : Modality) `{Lex O}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (i) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isconnected_paths</span>
             {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsConnected O A} (x y : A)
    : IsConnected O (x = y)
    := OO_isconnected_paths O O x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (iii) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">conn_map_lex</span>
             {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} `{IsConnected O Y, IsConnected O X} (f : Y -&gt; X)
    : IsConnMap O f
    := OO_conn_map_isconnected O O f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (iv) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_mapino_isconnected</span>
         {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} `{IsConnected O Y, IsConnected O X}
         (f : Y -&gt; X) `{MapIn O _ _ f}
    : IsEquiv f
    := OO_isequiv_mapino_isconnected O O f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (vi) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">conn_map_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>}
             {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
             `{IsConnMap O _ _ h, IsConnMap O _ _ k}
             (p : k o f == g o h) (b : B)
    : IsConnMap O (functor_hfiber p b)
    := OO_conn_map_functor_hfiber O O p b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (vii) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ispullback_connmap_mapino_commsq</span>
             {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
             (<span class="nv">p</span> : k o f == g o h)
             `{O_inverts O h, O_inverts O k, MapIn O _ _ f, MapIn O _ _ g}
    : IsPullback p
    := OO_ispullback_connmap_mapino O O p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (viii) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>
    <span class="nf">conn_map_functor_hfiber_to_O</span>
         {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">x</span> : X)
    : IsConnMap O (functor_hfiber (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (to_O_natural O f y)^) x)
    := OO_conn_map_functor_hfiber_to_O O O f x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_O_functor_hfiber</span>
         {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
    : IsEquiv (O_functor_hfiber O f b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_functor_hfiber O f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_functor_hfiber O f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3"><span class="nb">apply</span> (isequiv_O_rec_O_inverts O).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O
  (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
   (to O A X.<span class="mi">1</span>;
   to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4"><span class="nb">apply</span> O_inverts_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
   (to O A X.<span class="mi">1</span>;
   to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5"><span class="nb">refine</span> (conn_map_homotopic
              O (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (to_O_natural O f x)^) b)
              _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural O f x)^) b ==
(<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
 (to O A X.<span class="mi">1</span>; to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural O f x)^) b
  (a; p) =
(to O A a; to_O_natural O f a @ ap (to O B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7"><span class="nb">unfold</span> functor_hfiber, functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O A (a; p).<span class="mi">1</span>;
((to_O_natural O f (a; p).<span class="mi">1</span>)^)^ @ ap (to O B) (a; p).<span class="mi">2</span>) =
(to O A a; to_O_natural O f a @ ap (to O B) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((to_O_natural O f (a; p).<span class="mi">1</span>)^)^ @ ap (to O B) (a; p).<span class="mi">2</span> =
to_O_natural O f a @ ap (to O B) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerR, inv_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_functor_hfiber</span>
             {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
    : O (hfiber f b) &lt;~&gt; hfiber (O_functor O f) (to O B b)
    := Build_Equiv _ _ (O_functor_hfiber O f b) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (ix) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_path_O</span>
         {<span class="nv">X</span> : <span class="kt">Type</span>@{i}} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : IsEquiv (path_OO O O x y)
    := isequiv_path_OO O O x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_O</span> {<span class="nv">X</span> : <span class="kt">Type</span>@{i}} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : O (x = y) &lt;~&gt; (to O X x = to O X y)
    := equiv_path_OO O O x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9"><span class="kn">Definition</span> <span class="nf">equiv_path_O_to_O</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : (equiv_path_O x y) o (to O (x = y)) == @ap _ _ (to O X) x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_O x y o to O (x = y) == ap (to O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_O x y o to O (x = y) == ap (to O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb"><span class="nb">intros</span> p; <span class="nb">unfold</span> equiv_path_O, equiv_path_OO, path_OO; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (ap (to (modality_subuniv O) X))
  (to (modality_subuniv O) (x = y) p) =
ap (to (modality_subuniv O) X) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (x).  This justifies the term &quot;left exact&quot;. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">O_inverts_functor_pullback_to_O</span>
         {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : O_inverts O (functor_pullback f g (O_functor O f) (O_functor O g)
                                    (to O A) (to O B) (to O C)
                                    (to_O_natural O f) (to_O_natural O g))
    := OO_inverts_functor_pullback_to_O O O f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : O (Pullback f g) &lt;~&gt; Pullback (O_functor O f) (O_functor O g)
    := equiv_O_rec_O_inverts
         O (functor_pullback f g (O_functor O f) (O_functor O g)
                             (to O A) (to O B) (to O C)
                             (to_O_natural O f) (to_O_natural O g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc"><span class="kn">Definition</span> <span class="nf">O_functor_pullback</span>
             {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPullback
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPullback
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke"><span class="nb">unfold</span> IsPullback.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (pullback_corec
     (O_functor_square O pullback_pr1 pullback_pr2 f g
        (pullback_commsq f g)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkf">napply (isequiv_homotopic
               (O_rec (functor_pullback _ _ _ _ _ _ _
                                        (to_O_natural O f) (to_O_natural O g)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (O_rec
     (functor_pullback f g (O_functor O f)
        (O_functor O g) (to O A) (to O B) (to O C)
        (to_O_natural O f) (to_O_natural O g)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><label class="goal-separator" for="lex-v-chk10"><hr></label><div class="goal-conclusion">O_rec
  (functor_pullback f g (O_functor O f)
     (O_functor O g) (to O A) 
     (to O B) (to O C) (to_O_natural O f)
     (to_O_natural O g)) ==
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk11"><span class="mi">1</span>: <span class="nb">apply</span> isequiv_O_rec_O_inverts; <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (functor_pullback f g (O_functor O f)
     (O_functor O g) (to O A) (to O B) (to O C)
     (to_O_natural O f) (to_O_natural O g)) ==
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk12"><span class="nb">apply</span> O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 O_rec
   (functor_pullback f g (O_functor O f)
      (O_functor O g) (to O A) (to O B) (to O C)
      (to_O_natural O f) (to_O_natural O g))
   (to O (Pullback f g) x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 pullback_corec
   (O_functor_square O pullback_pr1 pullback_pr2 f g
      (pullback_commsq f g)) (to O (Pullback f g) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk13"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 O_rec
   (functor_pullback f g (O_functor O f)
      (O_functor O g) (to O A) (to O B) (to O C)
      (to_O_natural O f) (to_O_natural O g))
   (to O (Pullback f g) x)) == <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><label class="goal-separator" for="lex-v-chk14"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> ==
(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 pullback_corec
   (O_functor_square O pullback_pr1 pullback_pr2 f g
      (pullback_commsq f g)) 
   (to O (Pullback f g) x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk15"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="nb">apply</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_pullback f g (O_functor O f) (O_functor O g)
  (to O A) (to O B) (to O C) (to_O_natural O f)
  (to_O_natural O g) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 pullback_corec
   (O_functor_square O pullback_pr1 pullback_pr2 f g
      (pullback_commsq f g)) (to O (Pullback f g) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk16"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
 pullback_corec
   (O_functor_square O pullback_pr1 pullback_pr2 f g
      (pullback_commsq f g)) (to O (Pullback f g) x)) ==
functor_pullback f g (O_functor O f) (O_functor O g)
  (to O A) (to O B) (to O C) (to_O_natural O f)
  (to_O_natural O g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk17">snapply pullback_homotopic; <span class="nb">intros</span> [b [c e]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pullback_pr1
  (to (modality_subuniv O) (Pullback f g) (b; c; e)) =
to (modality_subuniv O) B b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="lex-v-chk18"><hr></label><div class="goal-conclusion">O_functor O pullback_pr2
  (to (modality_subuniv O) (Pullback f g) (b; c; e)) =
to (modality_subuniv O) C c</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="lex-v-chk19"><hr></label><div class="goal-conclusion">ap (O_functor O f) <span class="nl">?Goal</span> @
((to_O_natural O f b @
  ap (to (modality_subuniv O) A) e) @
 (to_O_natural O g c)^) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e)) @
ap (O_functor O g) <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1a"><span class="kp">all</span>: <span class="nb">change</span> (to (modality_subuniv O)) <span class="kr">with</span> (to O).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pullback_pr1
  (to O (Pullback f g) (b; c; e)) = to O B b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="lex-v-chk1b"><hr></label><div class="goal-conclusion">O_functor O pullback_pr2
  (to O (Pullback f g) (b; c; e)) = 
to O C c</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="lex-v-chk1c"><hr></label><div class="goal-conclusion">ap (O_functor O f) <span class="nl">?Goal</span> @
((to_O_natural O f b @ ap (to O A) e) @
 (to_O_natural O g c)^) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e)) @
ap (O_functor O g) <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pullback_pr1
  (to O (Pullback f g) (b; c; e)) = to O B b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply (to_O_natural O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pullback_pr2
  (to O (Pullback f g) (b; c; e)) = to O C c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply (to_O_natural O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e)) @
((to_O_natural O f b @ ap (to O A) e) @
 (to_O_natural O g c)^) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e)) @
ap (O_functor O g)
  (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk20"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e))
@&#39; (to_O_natural O f b
    @&#39; ap (to O A) e
    @&#39; (to_O_natural O g c)^) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk21">lhs napply concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e))
@&#39; (to_O_natural O f b
    @&#39; ap (to O A) e)
@&#39; (to_O_natural O g c)^ =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk22">lhs napply (concat_p_pp _ _ _ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e))
@&#39; to_O_natural O f b
@&#39; ap (to O A) e
@&#39; (to_O_natural O g c)^ =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk23"><span class="nb">rewrite</span> to_O_natural_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
     (b; c; e)
@&#39; ap (to O A) e
@&#39; (to_O_natural O g c)^ =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to O (Pullback f g) (b; c; e))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk24"><span class="nb">unfold</span> O_functor_square.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
     (b; c; e)
@&#39; ap (to O A) e
@&#39; (to_O_natural O g c)^ =
(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; (O_functor_homotopy O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (pullback_commsq f g)
      (to O (Pullback f g) (b; c; e))
    @&#39; O_functor_compose O pullback_pr2 g
         (to O (Pullback f g) (b; c; e)))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk25"><span class="nb">rewrite</span> O_functor_homotopy_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
     (b; c; e)
@&#39; ap (to O A) e
@&#39; (to_O_natural O g c)^ =
(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (b; c; e)
    @&#39; ap (to O A) (pullback_commsq f g (b; c; e))
    @&#39; (to_O_natural O
          (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
          (b; c; e))^
    @&#39; O_functor_compose O pullback_pr2 g
         (to O (Pullback f g) (b; c; e)))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk26"><span class="nb">rewrite</span> <span class="mi">6</span> concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (b; c; e)
    @&#39; (ap (to O A) e
        @&#39; (to_O_natural O g c)^)) =
(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (b; c; e)
    @&#39; (ap (to O A) (pullback_commsq f g (b; c; e))
        @&#39; ((to_O_natural O
               (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
                g (pullback_pr2 x)) (b; c; e))^
            @&#39; (O_functor_compose O pullback_pr2 g
                  (to O (Pullback f g) (b; c; e))
                @&#39; ap (O_functor O g)
                     (to_O_natural O pullback_pr2
                        (b; c; e))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk27"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_O_natural O g c)^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; (O_functor_compose O pullback_pr2 g
      (to O (Pullback f g) (b; c; e))
    @&#39; ap (O_functor O g)
         (to_O_natural O pullback_pr2 (b; c; e)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk28">rhs_V napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_O_natural O g c)^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to O (Pullback f g) (b; c; e))
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk29"><span class="nb">apply</span> moveL_pM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_O_natural O g c)^
@&#39; (ap (O_functor O g)
      (to_O_natural O pullback_pr2 (b; c; e)))^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to O (Pullback f g) (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2a">lhs_V napply inv_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (O_functor O g)
   (to_O_natural O pullback_pr2 (b; c; e))
 @&#39; to_O_natural O g c)^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to O (Pullback f g) (b; c; e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2b">rhs_V napply inv_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (O_functor O g)
   (to_O_natural O pullback_pr2 (b; c; e))
 @&#39; to_O_natural O g c)^ =
((O_functor_compose O pullback_pr2 g
    (to O (Pullback f g) (b; c; e)))^
 @&#39; to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (b; c; e))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2c"><span class="nb">apply</span> (ap inverse).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor O g)
  (to_O_natural O pullback_pr2 (b; c; e))
@&#39; to_O_natural O g c =
(O_functor_compose O pullback_pr2 g
   (to O (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
     (b; c; e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply to_O_natural_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2d"><span class="kn">Definition</span> <span class="nf">diagonal_O_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
    : diagonal (O_functor O f) == equiv_O_pullback f f o O_functor O (diagonal f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) ==
equiv_O_pullback f f o O_functor O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) ==
equiv_O_pullback f f o O_functor O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2f"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) (to O A x) =
equiv_O_pullback f f
  (O_functor O (diagonal f) (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk30"><span class="nb">refine</span> (_ @ (ap _ (to_O_natural _ _ _))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) (to O A x) =
equiv_O_pullback f f
  (to O (Pullback f f) (diagonal f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk31"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) (to (modality_subuniv O) A x) =
O_rec
  (functor_pullback f f (O_functor O f)
     (O_functor O f) (to (modality_subuniv O) B)
     (to (modality_subuniv O) A)
     (to (modality_subuniv O) A) (to_O_natural O f)
     (to_O_natural O f))
  (to (modality_subuniv O) (Pullback f f)
     (diagonal f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk32"><span class="nb">refine</span> (_ @ (O_rec_beta _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (O_functor O f) (to (modality_subuniv O) A x) =
functor_pullback f f (O_functor O f) (O_functor O f)
  (to (modality_subuniv O) B)
  (to (modality_subuniv O) A)
  (to (modality_subuniv O) A) (to_O_natural O f)
  (to_O_natural O f) (diagonal f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk33"><span class="nb">unfold</span> diagonal, functor_pullback, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to (modality_subuniv O) A x;
to (modality_subuniv O) A x; <span class="mi">1</span>) =
(to (modality_subuniv O) A x;
to (modality_subuniv O) A x;
(to_O_natural O f x @ <span class="mi">1</span>) @ (to_O_natural O f x)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk34"><span class="nb">apply</span> ap, ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = (to_O_natural O f x @ <span class="mi">1</span>) @ (to_O_natural O f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveL_pV; <span class="bp">exact</span> (concat_1p_p1 _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (xi) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cancelL_conn_map</span>
             {<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z)
             `{IsConnMap O _ _ (g o f)} `{IsConnMap O _ _ g}
    : IsConnMap O f
    := OO_cancelL_conn_map O O f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (xii) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_O_inverts</span>
         {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{O_inverts O f}
    : IsConnMap O f
    := conn_map_OO_inverts O O f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (xiii) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk35"><span class="kn">Definition</span> <span class="nf">modal_over_connected_isconst_lex</span>
             (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsConnected O A}
             (P : A -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, In O (P x)}
    : {Q : <span class="kt">Type</span> &amp; In O Q * <span class="kr">forall</span> <span class="nv">x</span>, Q &lt;~&gt; P x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk37"><span class="nb">pose proof</span> (O_inverts_isconnected O (<span class="kr">fun</span> <span class="nv">_</span>:A =&gt; tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk38"><span class="kr">exists</span> (<span class="nv">OO_descend_O_inverts</span> <span class="nv">O</span> <span class="nv">O</span> (<span class="kr">fun</span> <span class="nv">_</span>:A =&gt; tt) P tt); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span><br></div><label class="goal-separator" for="lex-v-chk39"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt &lt;~&gt;
P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> OO_descend_O_inverts_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt &lt;~&gt;
P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; napply OO_descend_O_inverts_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">  
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.11 (iii): in the accessible case, the universe is modal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">inO_typeO_lex</span> `{Univalence} `{IsAccRSU O}
    : In (lift_accrsu O) (Type_ O)
    := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Part of RSS Corollary 3.9: lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types.  With a little more work, this can probably be proven without [Funext]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3c">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_O_lex</span> `{Funext}
         {n : trunc_index} {A : <span class="kt">Type</span>} `{IsTrunc n A}
    : IsTrunc n (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3e"><span class="nb">generalize dependent</span> A; simple_induction n n IHn; <span class="nb">intros</span> A ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (O A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br></div><label class="goal-separator" for="lex-v-chk3f"><hr></label><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (O A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.               <span class="sd">(** Already proven for all modalities. *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk42"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : O A, IsTrunc n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk43"><span class="nb">refine</span> (O_ind (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>, IsTrunc n (x = y)) _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : O_reflector O A, IsTrunc n (to O A x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk44"><span class="nb">refine</span> (O_ind (<span class="kr">fun</span> <span class="nv">y</span> =&gt; IsTrunc n (to O A x = y)) _); <span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (to O A x = to O A y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (equiv_path_O x y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LexModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalent characterizations of lex-ness *)</span>

<span class="sd">(** We will not prove that *all* of the above properties from RSS Theorem 3.1 are equivalent to lex-ness, but we will do it for some of them. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ImpliesLex</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">O</span> : Modality}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS 3.1 (xiii) implies lexness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk45"><span class="kn">Definition</span> <span class="nf">lex_from_modal_over_connected_isconst</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">A_isC</span> : IsConnected O A)
                         (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x</span>, In O (P x)),
                 {Q : <span class="kt">Type</span> &amp; In O Q * <span class="kr">forall</span> <span class="nv">x</span>, Q &lt;~&gt; P x})
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk47"><span class="nb">intros</span> A; <span class="nb">unshelve</span> <span class="nb">econstructor</span>; <span class="nb">intros</span> P P_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_reflector O A -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><label class="goal-separator" for="lex-v-chk48"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt; 
    <span class="nl">?Goal</span>) P P_inO x)</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><label class="goal-separator" for="lex-v-chk49"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt; 
 <span class="nl">?Goal</span>) P P_inO (to O A x) &lt;~&gt; 
P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4a"><span class="kp">all</span>:<span class="nb">pose</span> (Q := <span class="kr">fun</span> <span class="nv">z</span>:O A =&gt; H (hfiber (to O A) z) _ (P o pr1) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_reflector O A -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><label class="goal-separator" for="lex-v-chk4b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
    <span class="kr">let</span> <span class="nv">Q</span> :=
      <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
      H (hfiber (to O A) z)
        (isconnected_hfiber_conn_map z) 
        (P o pr1)
        (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
    <span class="nl">?Goal</span>) P P_inO x)</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><label class="goal-separator" for="lex-v-chk4c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
 <span class="kr">let</span> <span class="nv">Q</span> :=
   <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
   H (hfiber (to O A) z)
     (isconnected_hfiber_conn_map z) 
     (P o pr1)
     (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
 <span class="nl">?Goal</span>) P P_inO (to O A x) &lt;~&gt; 
P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_reflector O A -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">z</span> =&gt; (Q z).<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
    <span class="kr">let</span> <span class="nv">Q</span> :=
      <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
      H (hfiber (to O A) z)
        (isconnected_hfiber_conn_map z) (P o pr1)
        (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
    <span class="kr">fun</span> <span class="nv">z</span> : O_reflector O A =&gt; (Q z).<span class="mi">1</span>) P P_inO x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">z</span> =&gt; fst (Q z).<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
 <span class="kr">let</span> <span class="nv">Q</span> :=
   <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
   H (hfiber (to O A) z)
     (isconnected_hfiber_conn_map z) (P o pr1)
     (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
 <span class="kr">fun</span> <span class="nv">z</span> : O_reflector O A =&gt; (Q z).<span class="mi">1</span>) P P_inO
  (to O A x) &lt;~&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk50"><span class="nb">intros</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H
   (hfiber (to (modality_subuniv O) A)
      (to (modality_subuniv O) A x))
   (isconnected_hfiber_conn_map
      (to (modality_subuniv O) A x))
   (<span class="kr">fun</span>
      <span class="nv">x</span> : {x0 : A &amp;
          to (modality_subuniv O) A x0 =
          to (modality_subuniv O) A x} =&gt; P x.<span class="mi">1</span>)
   (<span class="kr">fun</span>
      <span class="nv">x</span> : hfiber (to (modality_subuniv O) A)
            (to (modality_subuniv O) A x) =&gt; P_inO x.<span class="mi">1</span>)).<span class="mi">1</span> &lt;~&gt;
P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd (Q (to O A x)).<span class="mi">2</span> (x;<span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS 3.11 (iii), the universe is modal, implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk51"><span class="kn">Definition</span> <span class="nf">lex_from_inO_typeO</span> `{IsAccRSU O} `{In (lift_accrsu O) (Type_ O)}
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In (lift_accrsu O) (Type_ O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In (lift_accrsu O) (Type_ O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_lex_leq_inO_TypeO O O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (xi) implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk53"><span class="kn">Definition</span> <span class="nf">lex_from_cancelL_conn_map</span>
             (<span class="nv">cancel</span> : <span class="kr">forall</span> {<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z),
                 (IsConnMap O (g o f)) -&gt; (IsConnMap O g)
                 -&gt; IsConnMap O f)
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk55"><span class="nb">apply</span> lex_from_modal_over_connected_isconst; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk56"><span class="kr">exists</span> (<span class="nv">O</span> {x:A &amp; P x}); <span class="nb">split</span>; [ <span class="bp">exact</span> _ | <span class="nb">intros</span> x; <span class="nb">symmetry</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x &lt;~&gt; O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk57"><span class="nb">refine</span> (Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">p</span> =&gt; to O _ (x ; p)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk58">nrefine (isequiv_conn_map_ino O _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (P x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="lex-v-chk59"><hr></label><div class="goal-conclusion">In O (O_reflector O {x : A &amp; P x})</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="lex-v-chk5a"><hr></label><div class="goal-conclusion">IsConnMap O (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5b"><span class="mi">1</span>-<span class="mi">2</span>:<span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5c"><span class="nb">revert</span> x; <span class="nb">apply</span> conn_map_fiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O
  (functor_sigma idmap
     (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">p</span> : P a) =&gt;
      to O {x : A &amp; P x} (a; p)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5d">nrefine (cancel _ _ _ _ (<span class="kr">fun</span> <span class="nv">z</span>:{x:A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt;
   (functor_sigma idmap
      (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">p</span> : P a) =&gt;
       to O {x0 : A &amp; P x0} (a; p)) x).<span class="mi">2</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><label class="goal-separator" for="lex-v-chk5e"><hr></label><div class="goal-conclusion">IsConnMap O (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5f"><span class="mi">1</span>: <span class="nb">clear</span> cancel; <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk60"><span class="nb">intros</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O
  (hfiber (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>) z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk61"><span class="nb">refine</span> (isconnected_equiv&#39; O A _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;~&gt;
hfiber (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk62"><span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;~&gt; {x : {_ : A &amp; O {x : A &amp; P x}} &amp; x.<span class="mi">2</span> = z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk63"><span class="nb">refine</span> (equiv_adjointify (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ((x ; z) ; <span class="mi">1</span>))
                             (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y.<span class="mi">1</span>.<span class="mi">1</span>) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : {_ : A &amp; O {x : A &amp; P x}} &amp; x.<span class="mi">2</span> = z} =&gt;
 (((x.<span class="mi">1</span>).<span class="mi">1</span>; z); <span class="mi">1</span>)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><label class="goal-separator" for="lex-v-chk64"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (((x; z); <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span>) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : {_ : A &amp; O {x : A &amp; P x}} &amp; x.<span class="mi">2</span> = z} =&gt;
 (((x.<span class="mi">1</span>).<span class="mi">1</span>; z); <span class="mi">1</span>)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [[x y] []]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>cancel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_isC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>O {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (((x; z); <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (iii) implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk67"><span class="kn">Definition</span> <span class="nf">lex_from_conn_map_lex</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
                 (IsConnected O A) -&gt; (IsConnected O B) -&gt;
                 IsConnMap O f)
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk69"><span class="nb">apply</span> lex_from_cancelL_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x)) -&gt;
IsConnMap O g -&gt; IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6a"><span class="nb">intros</span> Y X Z f g gfc gc x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6b"><span class="nb">pose</span> (h := @functor_hfiber Y Z X Z (g o f) g f idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>%path)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6c"><span class="nb">assert</span> (cc := H _ _ (h (g x)) (gfc (g x)) (gc (g x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (h (g x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6d"><span class="nb">refine</span> (isconnected_equiv&#39; O _ _ (cc (x;<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (h (g x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (h (g x)) (x; <span class="mi">1</span>) &lt;~&gt; hfiber f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6e"><span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (h (g x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : {x0 : Y &amp; g (f x0) = g x} &amp; h (g x) x0 = (x; <span class="mi">1</span>)} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6f"><span class="nb">subst</span> h; <span class="nb">unfold</span> functor_hfiber, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : {x0 : Y &amp; g (f x0) = g x} &amp;
(f x0.<span class="mi">1</span>; <span class="mi">1</span> @ ap idmap x0.<span class="mi">2</span>) = (x; <span class="mi">1</span>)} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk70"><span class="nb">refine</span> (_ oE (equiv_sigma_assoc _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : Y &amp;
{p : g (f a) = g x &amp;
(f (a; p).<span class="mi">1</span>; <span class="mi">1</span> @ ap idmap (a; p).<span class="mi">2</span>) = (x; <span class="mi">1</span>)}} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk71"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> y; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : g (f y) = g x &amp; (f y; <span class="mi">1</span> @ ap idmap p) = (x; <span class="mi">1</span>)} &lt;~&gt;
f y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk72"><span class="nb">refine</span> (_ oE (equiv_functor_sigma_id _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; <span class="nl">?Goal0</span> x} &lt;~&gt; f y = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="lex-v-chk73"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : g (f y) = g x,
(f y; <span class="mi">1</span> @ ap idmap a) = (x; <span class="mi">1</span>) &lt;~&gt; <span class="nl">?Goal0</span> a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk74"><span class="mi">2</span>:<span class="nb">intros</span>; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : g (f y) = g x &amp;
{p : (f y; <span class="mi">1</span> @ ap idmap a).<span class="mi">1</span> = (x; <span class="mi">1</span>).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
  (f y; <span class="mi">1</span> @ ap idmap a).<span class="mi">2</span> = (x; <span class="mi">1</span>).<span class="mi">2</span>}} &lt;~&gt; f y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk75"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : g (f y) = g x &amp;
{p : f y = x &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
  (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}} &lt;~&gt; f y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk76"><span class="nb">refine</span> (_ oE equiv_sigma_symm _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : f y = x &amp;
{a : g (f y) = g x &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) b
  (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}} &lt;~&gt; f y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk77"><span class="nb">apply</span> equiv_sigma_contr; <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {a : g (f y) = g x &amp;
  transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
    (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk78"><span class="nb">destruct</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {a : g (f y) = g (f y) &amp; <span class="mi">1</span> @ ap idmap a = <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk79"><span class="nb">refine</span> (contr_equiv&#39; { p : g (f y) = g (f y) &amp; p = <span class="mi">1</span>%path } _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : g (f y) = g (f y) &amp; p = <span class="mi">1</span>} &lt;~&gt;
{a : g (f y) = g (f y) &amp; <span class="mi">1</span> @ ap idmap a = <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7a"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (f y) = g (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> @ ap idmap p = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7b"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span><br><span><var>Y, X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>gfc</var><span class="hyp-type"><b>: </b><span>IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>cc</var><span class="hyp-type"><b>: </b><span>IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (f y) = g (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ ap idmap p = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_1p _ @ ap_idmap _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (i) implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7c"><span class="kn">Definition</span> <span class="nf">lex_from_isconnected_paths</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">Ac</span> : IsConnected O A) (<span class="nv">x</span> <span class="nv">y</span> : A),
                 IsConnected O (x = y))
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7e"><span class="nb">apply</span> lex_from_conn_map_lex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt; IsConnected O B -&gt; IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7f"><span class="nb">intros</span> A B f Ac Bc c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Ac</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>Bc</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isconnected_sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (iv) implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk80"><span class="kn">Definition</span> <span class="nf">lex_from_isequiv_ismodal_isconnected_types</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
                 (IsConnected O A) -&gt; (IsConnected O B) -&gt; 
                 (MapIn O f) -&gt; IsEquiv f)
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk81"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk82"><span class="nb">apply</span> lex_from_conn_map_lex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt; IsConnected O B -&gt; IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk83"><span class="nb">intros</span> A B f AC BC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk84"><span class="nb">apply</span> (conn_map_homotopic O _ _ (fact_factors (image O f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   factor2 (image O f) (factor1 (image O f) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk85"><span class="nb">apply</span> conn_map_compose; [ <span class="bp">exact</span> _ | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (factor2 (image O f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk86"><span class="nb">apply</span> conn_map_isequiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (factor2 (image O f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk87"><span class="nb">apply</span> H; [ | <span class="bp">exact</span> _ | <span class="bp">exact</span> _ ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (image O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk88"><span class="nb">apply</span> isconnected_conn_map_to_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (const_tt (image O f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cancelR_conn_map O (factor1 (image O f)) (const_tt _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** RSS Theorem 3.1 (vii) implies lex-ness *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk89"><span class="kn">Definition</span> <span class="nf">lex_from_ispullback_connmap_mapino_commsq</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
                         (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
                 (IsConnMap O f) -&gt; (IsConnMap O g) -&gt;
                 (MapIn O h) -&gt; (MapIn O k) -&gt;
                 <span class="kr">forall</span> (<span class="nv">p</span> : k o f == g o h), IsPullback p)
    : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8b"><span class="nb">apply</span> lex_from_isequiv_ismodal_isconnected_types.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8c"><span class="nb">intros</span> A B f AC BC fM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8d"><span class="nb">specialize</span> (H A Unit B Unit (const_tt _) (const_tt _) f idmap _ _ _ _
                  (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPullback (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>)</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8e"><span class="nb">unfold</span> IsPullback, pullback_corec <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const_tt A a; f a; <span class="mi">1</span>))</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8f"><span class="nb">refine</span> (isequiv_compose _ (H:=H) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x.<span class="mi">2</span>.<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const_tt A a; f a; <span class="mi">1</span>))</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : Pullback idmap (const_tt B) =&gt; (x.<span class="mi">2</span>).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk90"><span class="nb">unfold</span> Pullback.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const_tt A a; f a; <span class="mi">1</span>))</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : {b : Unit &amp; {c : B &amp; b = const_tt B c}} =&gt;
   (x.<span class="mi">2</span>).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk91"><span class="nb">refine</span> (isequiv_compose (B:={b:Unit &amp; B})
              (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; pr1))
              pr2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const_tt A a; f a; <span class="mi">1</span>))</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv pr2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk92"><span class="nb">refine</span> (isequiv_compose (equiv_sigma_prod0 Unit B) snd).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const_tt A a; f a; <span class="mi">1</span>))</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br><span><var>fM</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_isequiv (prod_unit_l B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ImpliesLex</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Lex reflective subuniverses *)</span>

<span class="sd">(** A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk93"><span class="kn">Definition</span> <span class="nf">ismodality_isequiv_O_functor_hfiber</span> (<span class="nv">O</span> : ReflectiveSubuniverse)
           (<span class="nv">H</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
               IsEquiv (O_functor_hfiber O f b))
  : IsModality O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsModality O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsModality O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk95"><span class="nb">intros</span> A&#39;; rapply reflectsD_from_inO_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> : O_reflector O A&#39; -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)) -&gt;
In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk96"><span class="nb">intros</span> B B_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk97"><span class="nb">pose</span> (A := O A&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk98"><span class="nb">pose</span> (g := O_rec pr1 : O {x : A &amp; B x} -&gt; A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk99">transparent <span class="nb">assert</span> (p : (<span class="kr">forall</span> <span class="nv">x</span>, g (to O _ x) = x.<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) 
(<span class="nv">b</span> : B), IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br></div><label class="goal-separator" for="lex-v-chk9a"><hr></label><div class="goal-conclusion">In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">subst</span> g; <span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {z : O_reflector O A&#39; &amp; B z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9d"><span class="nb">apply</span> inO_isequiv_to_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to O {z : O_reflector O A&#39; &amp; B z})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9e"><span class="nb">apply</span> isequiv_contr_map; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber (to O {z : O_reflector O A&#39; &amp; B z}) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9f">snrefine (contr_equiv&#39; _ (hfiber_hfiber_compose_map _ g x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (hfiber
     (hfiber_compose_map
        (to O {z : O_reflector O A&#39; &amp; B z}) g (g x))
     (x; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka0"><span class="nb">apply</span> contr_map_isequiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (hfiber_compose_map
     (to O {z : O_reflector O A&#39; &amp; B z}) g (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka1"><span class="nb">unfold</span> hfiber_compose_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka2">transparent <span class="nb">assert</span> (h : (hfiber (@pr1 A B) (g x) &lt;~&gt; hfiber g (g x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) 
(<span class="nv">b</span> : B), IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span><br></div><label class="goal-separator" for="lex-v-chka3"><hr></label><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka5"><span class="nb">refine</span> (_ oE equiv_to_O O _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber pr1 (g x)) &lt;~&gt; hfiber g (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka6"><span class="nb">refine</span> (_ oE Build_Equiv _ _
              (O_functor_hfiber O (@pr1 A B) (g x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (O_functor O pr1) (to O A (g x)) &lt;~&gt;
hfiber g (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka7"><span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : O {x : _ &amp; B x} &amp;
O_functor O pr1 x0 = to O A (g x)} &lt;~&gt;
{x0 : O {x : A &amp; B x} &amp; g x0 = g x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka8"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : O {x : _ &amp; B x},
O_functor O pr1 a = to O A (g x) &lt;~&gt; g a = g x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka9"><span class="nb">intros</span> y; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O {x : _ &amp; B x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pr1 y = to O A (g x) &lt;~&gt; g y = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkaa"><span class="nb">refine</span> (_ oE (equiv_moveR_equiv_V _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O {x : _ &amp; B x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O A)^-<span class="mi">1</span> (O_functor O pr1 y) = g x &lt;~&gt; g y = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkab"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O {x : _ &amp; B x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g y = (to O A)^-<span class="mi">1</span> (O_functor O pr1 y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkac"><span class="nb">apply</span> moveL_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O {x : _ &amp; B x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O A (g y) = O_functor O pr1 y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkad"><span class="nb">unfold</span> g, O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O {x : _ &amp; B x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O A (O_rec pr1 y) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkae"><span class="nb">revert</span> y; <span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> [a q]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O A (O_rec pr1 (to O {x : _ &amp; B x} (a; q))) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
  (to O {x : _ &amp; B x} (a; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkaf"><span class="nb">refine</span> (_ @ (O_rec_beta _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O A (O_rec pr1 (to O {x : _ &amp; B x} (a; q))) =
to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(equiv_functor_sigma_id
   (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
    equiv_concat_l
      (moveL_equiv_V (O_functor O pr1 y) 
         (g y)
         (O_indpaths
            (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
             to O A (O_rec pr1 x))
            (O_rec
               (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
            ((<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
              (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
               ap (to O A) (O_rec_beta pr1 ...) @
               (O_rec_beta (...) (a; q))^
               :
               to O A (O_rec pr1 ...) =
               O_rec (... =&gt; ...) (to O ... ...))
                x0.<span class="mi">1</span> x0.<span class="mi">2</span>)
             :
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              to O A
                (O_rec pr1 (to O {x : _ &amp; B x} x))) ==
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              O_rec
                (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
                 to O A x0.<span class="mi">1</span>)
                (to O {x : _ &amp; B x} x))) y
          :
          to O A (g y) = O_functor O pr1 y)) 
      (g x)
    oE equiv_moveR_equiv_V 
         (O_functor O pr1 y) 
         (g x)
    :
    O_functor O pr1 y = to O A (g x) &lt;~&gt; g y = g x)
 :
 hfiber (O_functor O pr1) (to O A (g x)) &lt;~&gt;
 hfiber g (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span><span class="hyp-type"><b>: </b><span>hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb1"><span class="nb">refine</span> (isequiv_homotopic (h oE equiv_hfiber_homotopic _ _ p (g x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(equiv_functor_sigma_id
   (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
    equiv_concat_l
      (moveL_equiv_V (O_functor O pr1 y) 
         (g y)
         (O_indpaths
            (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
             to O A (O_rec pr1 x))
            (O_rec
               (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
            ((<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
              (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
               ap (to O A) (O_rec_beta pr1 ...) @
               (O_rec_beta (...) (a; q))^
               :
               to O A (O_rec pr1 ...) =
               O_rec (... =&gt; ...) (to O ... ...))
                x0.<span class="mi">1</span> x0.<span class="mi">2</span>)
             :
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              to O A
                (O_rec pr1 (to O {x : _ &amp; B x} x))) ==
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              O_rec
                (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
                 to O A x0.<span class="mi">1</span>)
                (to O {x : _ &amp; B x} x))) y
          :
          to O A (g y) = O_functor O pr1 y)) 
      (g x)
    oE equiv_moveR_equiv_V 
         (O_functor O pr1 y) 
         (g x)
    :
    O_functor O pr1 y = to O A (g x) &lt;~&gt; g y = g x)
 :
 hfiber (O_functor O pr1) (to O A (g x)) &lt;~&gt;
 hfiber g (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span><span class="hyp-type"><b>: </b><span>hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h
oE equiv_hfiber_homotopic
     (<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt;
      g (to O {x0 : A &amp; B x0} x)) pr1 p (g x) ==
(<span class="kr">fun</span>
   <span class="nv">x0</span> : hfiber
          (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
           g (to O {z : O_reflector O A&#39; &amp; B z} x))
          (g x) =&gt;
 (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb2"><span class="nb">intros</span> [[a b] q]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(equiv_functor_sigma_id
   (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
    equiv_concat_l
      (moveL_equiv_V (O_functor O pr1 y) 
         (g y)
         (O_indpaths
            (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
             to O A (O_rec pr1 x))
            (O_rec
               (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
            ((<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
              (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
               ap (to O A) (O_rec_beta pr1 ...) @
               (O_rec_beta (...) (a; q))^
               :
               to O A (O_rec pr1 ...) =
               O_rec (... =&gt; ...) (to O ... ...))
                x0.<span class="mi">1</span> x0.<span class="mi">2</span>)
             :
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              to O A
                (O_rec pr1 (to O {x : _ &amp; B x} x))) ==
             (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
              O_rec
                (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
                 to O A x0.<span class="mi">1</span>)
                (to O {x : _ &amp; B x} x))) y
          :
          to O A (g y) = O_functor O pr1 y)) 
      (g x)
    oE equiv_moveR_equiv_V 
         (O_functor O pr1 y) 
         (g x)
    :
    O_functor O pr1 y = to O A (g x) &lt;~&gt; g y = g x)
 :
 hfiber (O_functor O pr1) (to O A (g x)) &lt;~&gt;
 hfiber g (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span><span class="hyp-type"><b>: </b><span>hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_functor_hfiber O pr1 (g x)
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb3"><span class="nb">clear</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_functor_hfiber O pr1 (g x)
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb4"><span class="nb">unfold</span> O_functor_hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : hfiber pr1 (g x) =&gt;
      (to O {x : _ &amp; B x} X.<span class="mi">1</span>;
      to_O_natural O pr1 X.<span class="mi">1</span> @ ap (to O A) X.<span class="mi">2</span>))
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb5"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (to O {x : _ &amp; B x} (a; b);
  to_O_natural O pr1 (a; b) @
  ap (to O A) ((p (a; b))^ @ q)) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb6"><span class="nb">unfold</span> functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O {x : _ &amp; B x} (a; b);
moveL_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
  (g (to O {x : _ &amp; B x} (a; b)))
  (O_indpaths
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
      to O A (O_rec pr1 x))
     (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
     (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
      ap (to O A) (O_rec_beta pr1 (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>)) @
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
         (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))^) (to O {x : _ &amp; B x} (a; b))) @
moveR_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b))) (g x)
  (to_O_natural O pr1 (a; b) @
   ap (to O A) ((p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb7"><span class="nb">refine</span> (path_sigma&#39; _ <span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x0</span> : O {x : A &amp; B x} =&gt; g x0 = g x) <span class="mi">1</span>
  (moveL_equiv_V
     (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
     (g (to O {x : _ &amp; B x} (a; b)))
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))^)
        (to O {x : _ &amp; B x} (a; b))) @
   moveR_equiv_V
     (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
     (g x)
     (to_O_natural O pr1 (a; b) @
      ap (to O A) ((p (a; b))^ @ q))) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb8"><span class="nb">rewrite</span> O_indpaths_beta; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
  (g (to O {x : _ &amp; B x} (a; b)))
  (ap (to O A) (O_rec_beta pr1 (a; b)) @
   (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
      (a; b))^) @
moveR_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b))) (g x)
  (to_O_natural O pr1 (a; b) @
   ap (to O A) ((p (a; b))^ @ q)) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb9"><span class="nb">unfold</span> moveL_equiv_V, moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^ @
 ap (to O A)^-<span class="mi">1</span>
   (ap (to O A) (O_rec_beta pr1 (a; b)) @
    (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
       (a; b))^)) @
(ap (to O A)^-<span class="mi">1</span>
   (to_O_natural O pr1 (a; b) @
    ap (to O A) ((p (a; b))^ @ q)) @
 eissect (to O A) (g x)) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkba"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b))
      @&#39; (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (a; b))^)
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (to_O_natural O pr1 (a; b)
       @&#39; ap (to O A) ((p (a; b))^
                       @&#39; q))
    @&#39; eissect (to O A) (g x)) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbb"><span class="kn">Local</span> <span class="kn">Opaque</span> eissect. <span class="c">(* work around bug 4533 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b))
      @&#39; (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (a; b))^)
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (to_O_natural O pr1 (a; b)
       @&#39; ap (to O A) ((p (a; b))^
                       @&#39; q))
    @&#39; eissect (to O A) (g x)) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Even though https://github.com/coq/coq/issues/4533 is closed, this is still needed. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbc"><span class="nb">rewrite</span> !ap_pp, !concat_p_pp, !ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) (a; b)))^
@&#39; ap (to O A)^-<span class="mi">1</span> (to_O_natural O pr1 (a; b))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbd"><span class="nb">unfold</span> to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) (a; b)))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
        (a; b))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbe"><span class="nb">rewrite</span> concat_pV_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbf"><span class="nb">subst</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (ap (to O A)
         ((<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x)
            (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc0"><span class="nb">rewrite</span> concat_pp_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc1"><span class="nb">rewrite</span> concat_pp_p; <span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) =
eissect (to O A) (g (to O {x : _ &amp; B x} (a; b)))
@&#39; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc2"><span class="nb">rewrite</span> &lt;- !(ap_compose (to O A) (to O A)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>O A&#39;</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span><span class="hyp-type"><b>: </b><span>O {x : A &amp; B x} -&gt; A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to O A)^-<span class="mi">1</span> (to O A x)) q
@&#39; eissect (to O A) (g x) =
eissect (to O A) (g (to O {x : _ &amp; B x} (a; b)))
@&#39; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply @concat_A1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Transparent</span> eissect. <span class="c">(* work around bug 4533 *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Lexness via generators *)</span>

<span class="sd">(** Here the characterization of when an accessible presentation yields a lex modality from Anel-Biederman-Finster-Joyal (&quot;Higher Sheaves and Left-Exact Localizations of ‚àû-Topoi&quot;, arXiv:2101.02791): it&#39;s enough for path spaces of the generators to be connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc3"><span class="kn">Definition</span> <span class="nf">lex_gen</span> `{Univalence} (O : Modality) `{IsAccModality O}
           (lexgen : <span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O)) (<span class="nv">x</span> <span class="nv">y</span> : ngen_type (acc_ngen O) i),
               IsConnected O (x = y))
  : Lex O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lex O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc5">srapply lex_from_inO_typeO; [ <span class="bp">exact</span> _ | <span class="nb">intros</span> i ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Extensions.ooExtendableAlong 
  (acc_lgen O i)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc6">rapply ooextendable_TypeO_from_extension; <span class="nb">intros</span> P; srefine (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
(<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt; Type_ O) y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br></div><label class="goal-separator" for="lex-v-chkc7"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x) 
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc8"><span class="mi">1</span>:<span class="nb">intros</span>; <span class="kr">exists</span> (<span class="nv">forall</span> <span class="nv">x</span>, P x); <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc9"><span class="nb">assert</span> (wc : <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span>, P y &lt;~&gt; P z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i, P y &lt;~&gt; P z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br></div><label class="goal-separator" for="lex-v-chkca"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkcb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i, P y &lt;~&gt; P z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkcc"><span class="nb">intros</span> y z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y &lt;~&gt; P z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Here we use the hypothesis [lexgen] (typeclass inference finds it automatically). *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pr1 (isconnected_elim O _ (@equiv_transport _ P y z))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkcd">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkce"><span class="nb">intros</span> x; <span class="nb">apply</span> path_TypeO, path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
inO_forall O (lgen_domain (acc_lgen O) i)
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   inO_TypeO (P x))).<span class="mi">1</span> &lt;~&gt; 
(P x).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkcf"><span class="nb">refine</span> (equiv_adjointify (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f x) (<span class="kr">fun</span> <span class="nv">u</span> <span class="nv">y</span> =&gt; wc x y ((wc x x)^-<span class="mi">1</span> u)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : P x =&gt; wc x x ((wc x x)^-<span class="mi">1</span> x0)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><label class="goal-separator" for="lex-v-chkd0"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   (<span class="nv">x0</span> : <span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0)
   (<span class="nv">y</span> : lgen_domain (acc_lgen O) i) =&gt;
 wc x y ((wc x x)^-<span class="mi">1</span> (x0 x))) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : P x =&gt; wc x x ((wc x x)^-<span class="mi">1</span> x0)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   (<span class="nv">x0</span> : <span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0)
   (<span class="nv">y</span> : lgen_domain (acc_lgen O) i) =&gt;
 wc x y ((wc x x)^-<span class="mi">1</span> (x0 x))) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd3"><span class="nb">intros</span> f; <span class="nb">apply</span> path_forall; <span class="nb">intros</span> y; <span class="nb">apply</span> moveR_equiv_M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(wc x x)^-<span class="mi">1</span> (f x) = (wc x y)^-<span class="mi">1</span> (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd4"><span class="nb">destruct</span> (isconnected_elim O _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (wc x y)^-<span class="mi">1</span> (f y))) <span class="kr">as</span> [z p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>lexgen</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span><br><span><var>wc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i,
(wc x x0)^-<span class="mi">1</span> (f x0) = z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(wc x x)^-<span class="mi">1</span> (f x) = (wc x y)^-<span class="mi">1</span> (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x @ (p y)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** n-fold separation *)</span>

<span class="sd">(** A type is [n]-[O]-separated, for n &gt;= -2, if all its (n+2)-fold iterated identity types are [O]-modal.  Inductively, this means that it is (-2)-O-separated if it is O-modal, and (n+1)-O-separated if its identity types are n-O-separated. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">nSep</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">O</span> : Subuniverse) : Subuniverse
  := <span class="kr">match</span> n <span class="kr">with</span>
     | -<span class="mi">2</span> =&gt; O
     | n.+<span class="mi">1</span> =&gt; Sep (nSep n O)
     <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The reason for indexing this notion by a [trunc_index] rather than a [nat] is that when O is lex, a type is n-O-separated if and only if its O-unit is an n-truncated map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd5"><span class="kn">Definition</span> <span class="nf">nsep_iff_trunc_to_O</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">O</span> : Modality) `{Lex O} (A : <span class="kt">Type</span>)
  : In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd7"><span class="nb">revert</span> A; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> A; <span class="nb">split</span>; <span class="nb">intros</span> ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) O) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) (to O A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) (to O A)</span></span></span><br></div><label class="goal-separator" for="lex-v-chkd8"><hr></label><div class="goal-conclusion">In (nSep (-<span class="mi">2</span>) O) A</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> O) A</span></span></span><br></div><label class="goal-separator" for="lex-v-chkd9"><hr></label><div class="goal-conclusion">IsTruncMap n.+<span class="mi">1</span> (to O A)</div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br></div><label class="goal-separator" for="lex-v-chkda"><hr></label><div class="goal-conclusion">In (nSep n.+<span class="mi">1</span> O) A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) O) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contr_map_isequiv; rapply isequiv_to_O_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep (-<span class="mi">2</span>) O) A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO (O A) (to O A)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> O) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n.+<span class="mi">1</span> (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkde"><span class="nb">apply</span> istruncmap_from_ap; <span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> O) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (ap (to O A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdf"><span class="nb">pose</span> (i := fst (IHn (x = y)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> O) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>fst (IHn (x = y)) (inO_paths_SepO (nSep n O) x y)</span></span><span class="hyp-type"><b>: </b><span>IsTruncMap n (to O (x = y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (ap (to O A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istruncmap_mapinO_tr, (mapinO_homotopic _ _ (equiv_path_O_to_O O x y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n.+<span class="mi">1</span> O) A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke1"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n O) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke2"><span class="nb">apply</span> (snd (IHn (x = y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (to O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke3"><span class="nb">pose</span> (i := istruncmap_ap n (to O A) x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>istruncmap_ap n (to O A) x y</span></span><span class="hyp-type"><b>: </b><span>IsTruncMap n (ap (to O A))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (to O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke4"><span class="nb">apply</span> mapinO_tr_istruncmap <span class="kr">in</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (to O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke5"><span class="nb">apply</span> istruncmap_mapinO_tr, (mapinO_homotopic _ ((equiv_path_O O x y)^-<span class="mi">1</span> o (@ap _ _ (to O A) x y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0)) ==
to O (x = y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br></div><label class="goal-separator" for="lex-v-chke6"><hr></label><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0)) ==
to O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_path_O_to_O.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke9"><span class="nb">pose</span> mapinO_isequiv. <span class="c">(* This speeds up the next line. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to O A))</span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>mapinO_isequiv</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">O</span> : ReflectiveSubuniverse) 
(<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), 
IsEquiv f -&gt; MapIn O f</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply mapinO_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
