<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Commutator.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Tactics Basics.PathGroupoids Basics.Trunc
  Basics.Iff Basics.Equivalences Basics.Predicate.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Sigma Types.Paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Groups.Group AbGroups.Abelianization AbGroups.AbelianGroup
  Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.Core WildCat.Equiv WildCat.EquivGpd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> predicate_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutators in groups *)</span>

<span class="sd">(** ** Commutators of group elements *)</span>

<span class="sd">(** Note that this convention is chosen due to the convention we chose for group conjugation elsewhere. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_commutator</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G) : G := x * y * x^ * y^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ x , y ]&quot;</span> := (grp_commutator x y) : mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> grp_commutator {G} x y : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Easy properties of commutators *)</span>

<span class="sd">(** Commuting elements of a group have trivial commutator. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1"><span class="kn">Definition</span> <span class="nf">grp_commutator_commutes</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G) (<span class="nv">p</span> : x * y = y * x)
  : [x, y] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * y = y * x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * y = y * x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk3"><span class="nb">unfold</span> grp_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * y = y * x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * x^ * y^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4"><span class="nb">rewrite</span> p, grp_inv_gg_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * y = y * x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * y^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator of an element with itself is the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5"><span class="kn">Definition</span> <span class="nf">grp_commutator_cancel</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : [x, x] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_commutator_commutes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator of a group element with unit on the left is the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7"><span class="kn">Definition</span> <span class="nf">grp_commutator_unit_l</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G)
  : [<span class="mi">1</span>, x] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="mi">1</span>, x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[<span class="mi">1</span>, x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_commutator_commutes, grp_1g_g1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator of a group element with unit on the right is the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk9"><span class="kn">Definition</span> <span class="nf">grp_commutator_unit_r</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G)
  : [x, <span class="mi">1</span>] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, <span class="mi">1</span>] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, <span class="mi">1</span>] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_commutator_commutes, grp_g1_1g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutators in abelian groups are trivial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb"><span class="kn">Definition</span> <span class="nf">ab_commutator</span> (<span class="nv">A</span> : AbGroup) (<span class="nv">x</span> <span class="nv">y</span> : A)
  : [x, y] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_commutator_commutes, commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The commutator can be thought of as the &quot;error&quot; in the commutativity of two elements of a group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd"><span class="kn">Definition</span> <span class="nf">grp_commutator_swap_op</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : x * y = [x, y] * y * x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y = [x, y] * y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y = [x, y] * y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkf"><span class="nb">unfold</span> grp_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y = x * y * x^ * y^ * y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Inverting a commutator reverses the order. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk10"><span class="kn">Definition</span> <span class="nf">grp_commutator_inv</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : [x, y]^ = [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y]^ = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y]^ = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk12"><span class="nb">unfold</span> grp_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * y * x^ * y^)^ = y * x * y^ * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">3</span> grp_inv_op, <span class="mi">2</span> grp_inv_inv, <span class="mi">2</span> grp_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms commute with commutators. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk13"><span class="kn">Definition</span> <span class="nf">grp_homo_commutator</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : G $-&gt; H) (<span class="nv">x</span> <span class="nv">y</span> : G)
  : f [x, y] = [f x, f y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f [x, y] = [f x, f y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f [x, y] = [f x, f y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk15"><span class="nb">unfold</span> grp_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y * x^ * y^) = f x * f y * (f x)^ * (f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_homo_op, !grp_homo_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator with a product on the left side can be expanded as the product of a conjugated commutator and another commutator. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk16"><span class="kn">Definition</span> <span class="nf">grp_commutator_op_l</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G)
  : [x * y, z] = grp_conj x [y, z] * [x, z].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x * y, z] = grp_conj x [y, z] * [x, z]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x * y, z] = grp_conj x [y, z] * [x, z]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk18"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * z * (x * y)^ * z^ =
x * (y * z * y^ * z^) * x^ * (x * z * x^ * z^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_inv_op, !grp_assoc, !grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator with a product on the right side can be expanded as the product of a conjugated commutator and another commutator. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk19"><span class="kn">Definition</span> <span class="nf">grp_commutator_op_r</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G)
  : [x, y * z] = [x, y] * grp_conj y [x, z].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y * z] = [x, y] * grp_conj y [x, z]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y * z] = [x, y] * grp_conj y [x, z]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1b"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (y * z) * x^ * (y * z)^ =
x * y * x^ * y^ * (y * (x * z * x^ * z^) * y^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_inv_op, !grp_assoc, !grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator with the element on the right being multiplied on the right gives a conjugation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1c"><span class="kn">Definition</span> <span class="nf">grp_op_l_commutator</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : [x, y] * y = grp_conj x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] * y = grp_conj x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y] * y = grp_conj x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1e"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * x^ * y^ * y = x * y * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator with the inverse element on the left being multiplied on the left gives a conjugation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk1f"><span class="kn">Definition</span> <span class="nf">grp_op_r_commutator</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : x^ * [x, y] = grp_conj y x^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * [x, y] = grp_conj y x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * [x, y] = grp_conj y x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk21"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * (x * y * x^ * y^) = y * x^ * y^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- !grp_assoc, grp_inv_V_gg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutators with inverted left sides are conjugated commutators. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk22"><span class="kn">Definition</span> <span class="nf">grp_commutator_inv_l</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : [x^, y] = grp_conj x^ [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x^, y] = grp_conj x^ [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x^, y] = grp_conj x^ [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk24"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * y * (x^)^ * y^ = x^ * (y * x * y^ * x^) * (x^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_assoc, grp_inv_inv, grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutators with inverted right sides are conjugated commutators. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk25"><span class="kn">Definition</span> <span class="nf">grp_commutator_inv_r</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : [x, y^] = grp_conj y^ [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y^] = grp_conj y^ [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x, y^] = grp_conj y^ [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk27"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y^ * x^ * (y^)^ = y^ * (y * x * y^ * x^) * (y^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- !grp_assoc, grp_inv_inv, grp_inv_V_gg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk28"><span class="kn">Definition</span> <span class="nf">grp_conj_commutator_inv_l</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : grp_conj x [x^, y] = [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x [x^, y] = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x [x^, y] = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2a"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (x^ * y * (x^)^ * y^) * x^ = y * x * y^ * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_inv_inv, &lt;- !grp_assoc, grp_inv_g_Vg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2b"><span class="kn">Definition</span> <span class="nf">grp_conj_commutator_inv_r</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : grp_conj y [x, y^] = [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj y [x, y^] = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj y [x, y^] = [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2d"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * (x * y^ * x^ * (y^)^) * y^ = y * x * y^ * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_inv_inv, !grp_assoc, grp_inv_gg_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Hall-Witt identity *)</span>

<span class="sd">(** The Hall-Witt identity is a Jacobi-like identity for groups. It states that the different commutators of 3 elements (with one conjugated) assemble into an identity. The proof is purely mechanical and simply cancels all the terms. This is a rare instance where a mechanized proof is much shorter than an on-paper proof. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2e"><span class="kn">Definition</span> <span class="nf">grp_hall_witt</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G)
  : [[x, y], grp_conj y z] * [[y, z], grp_conj z x] * [[z, x], grp_conj x y] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[x, y], grp_conj y z] * [[y, z], grp_conj z x] *
[[z, x], grp_conj x y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[x, y], grp_conj y z] * [[y, z], grp_conj z x] *
[[z, x], grp_conj x y] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk30"><span class="nb">unfold</span> grp_commutator, grp_conj, grp_homo_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * x^ * y^ * (y * z * y^) * (x * y * x^ * y^)^ *
(y * z * y^)^ *
(y * z * y^ * z^ * (z * x * z^) * (y * z * y^ * z^)^ *
 (z * x * z^)^) *
(z * x * z^ * x^ * (x * y * x^) * (z * x * z^ * x^)^ *
 (x * y * x^)^) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk31"><span class="nb">rewrite</span> !grp_inv_op, !grp_inv_inv, !grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">... * y^ * z^ * z * x * z^ * z * y * z^ * y^ * z * x^ *
z^ * z * x * z^ * x^ * x * y * x^ * x * z * x^ * z^ *
x * y^ * x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk32"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> !grp_inv_gV_g, !grp_inv_gg_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This variant of the Hall-Witt identity is useful later for proving the three subgroups lemma. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk33"><span class="kn">Definition</span> <span class="nf">grp_hall_witt&#39;</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G)
  : grp_conj x [[x^, y], z] * grp_conj z [[z^, x], y] * grp_conj y [[y^, z], x] = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x [[x^, y], z] * grp_conj z [[z^, x], y] *
grp_conj y [[y^, z], x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x [[x^, y], z] * grp_conj z [[z^, x], y] *
grp_conj y [[y^, z], x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk35"><span class="nb">rewrite</span> <span class="mi">3</span> (grp_homo_commutator _ [_^, _]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[grp_conj x [x^, y], grp_conj x z] *
[grp_conj z [z^, x], grp_conj z y] *
[grp_conj y [y^, z], grp_conj y x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk36"><span class="nb">rewrite</span> <span class="mi">3</span> grp_conj_commutator_inv_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[y, x], grp_conj x z] * [[x, z], grp_conj z y] *
[[z, y], grp_conj y x] = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_hall_witt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Precomposing normal subgroups with commutators *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk37"><span class="kn">Instance</span> <span class="nf">issubgroup_precomp_commutator_l</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> : Subgroup G)
  `{!IsNormalSubgroup H} (y : G)
  : IsSubgroup (<span class="kr">fun</span> <span class="nv">x</span> =&gt; H [x, y]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; H [x, y])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; H [x, y])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk39">snapply Build_IsSubgroup; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsHProp (H [x, y])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk3a"><hr></label><div class="goal-conclusion">H [<span class="mi">1</span>, y]</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk3b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y0</span> : G,
H [x, y] -&gt; H [y0, y] -&gt; H [x * y0, y]</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk3c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, H [x, y] -&gt; H [x^, y]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsHProp (H [x, y])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [<span class="mi">1</span>, y]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk3f"><span class="nb">rewrite</span> grp_commutator_unit_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> subgroup_in_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y0</span> : G,
H [x, y] -&gt; H [y0, y] -&gt; H [x * y0, y]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk41"><span class="nb">intros</span> x z Hxy Hzy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x * z, y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk42"><span class="nb">rewrite</span> grp_commutator_op_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (grp_conj x [z, y] * [x, y])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk43"><span class="nb">apply</span> subgroup_in_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (grp_conj x [z, y])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk44"><hr></label><div class="goal-conclusion">H [x, y]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk45">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (grp_conj x [z, y])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply isnormal_conj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk46">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br><span><var>Hzy</var><span class="hyp-type"><b>: </b><span>H [z, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x, y]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, H [x, y] -&gt; H [x^, y]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk48"><span class="nb">intros</span> x Hxy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x^, y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk49"><span class="nb">rewrite</span> grp_commutator_inv_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (grp_conj x^ [y, x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4a">rapply isnormal_conj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4b"><span class="nb">rewrite</span> &lt;- grp_commutator_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>H [x, y]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x, y]^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> subgroup_in_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The condition [H [x, y]] is equivalent to the condition [H [y, x]]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4c"><span class="kn">Definition</span> <span class="nf">issubgroup_precomp_commutator_agree</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> : Subgroup G)
  (<span class="nv">x</span> <span class="nv">y</span> : G)
  : H [x, y] &lt;~&gt; H [y, x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x, y] &lt;~&gt; H [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x, y] &lt;~&gt; H [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4e"><span class="nb">refine</span> (_ oE equiv_subgroup_inv _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H [x, y]^ &lt;~&gt; H [y, x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_commutator_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** So we get this symmetrical version as well. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">issubgroup_precomp_commutator_r</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> : Subgroup G)
  `{!IsNormalSubgroup H} (x : G)
  : IsSubgroup (<span class="kr">fun</span> <span class="nv">y</span> =&gt; H [x, y])
  := issubgroup_equiv (<span class="kr">fun</span> <span class="nv">y</span> =&gt; issubgroup_precomp_commutator_agree H y x) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_precomp_commutator_l</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> : Subgroup G) (<span class="nv">y</span> : G)
  `{!IsNormalSubgroup H}
  : Subgroup G
  := Build_Subgroup _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; H [x, y]) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_precomp_commutator_r</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> : Subgroup G) (<span class="nv">x</span> : G)
  `{!IsNormalSubgroup H}
  : Subgroup G
  := Build_Subgroup _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; H [x, y]) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Commutator subgroups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_commutator</span> {<span class="nv">G</span> : Group@{i}} (<span class="nv">H</span> <span class="nv">K</span> : Subgroup@{i i} G)
  : Subgroup@{i i} G
  := subgroup_generated (<span class="kr">fun</span> <span class="nv">g</span> =&gt; <span class="kr">exists</span> (<span class="nv">x</span> : H) (<span class="nv">y</span> : K), [x.<span class="mi">1</span>, y.<span class="mi">1</span>] = g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ H , K ]&quot;</span> := (subgroup_commutator H K) : group_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> group_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [subgroup_commutator H K] is the smallest subgroup containing the commutators of elements of [H] with elements of [K]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk4f"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_rec</span> {<span class="nv">G</span> : Group} {<span class="nv">H</span> <span class="nv">K</span> : Subgroup G} (<span class="nv">J</span> : Subgroup G)
  (<span class="nv">i</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, H x -&gt; K y -&gt; J (grp_commutator x y))
  : [H, K] ‚äÜ J.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt; K y -&gt; J (grp_commutator x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, K] ‚äÜ J</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt; K y -&gt; J (grp_commutator x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, K] ‚äÜ J</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk51">rapply subgroup_generated_rec; <span class="nb">intros</span> x [[y Hy] [[z Kz] p]];
    <span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt; K y -&gt; J (grp_commutator x y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>H y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">J (grp_commutator y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Doubly iterated [subgroup_commutator]s of [H], [J] and [K] are the smallest of the normal subgroups containing the doubly iterated commutators of elements of [H], [J] and [K]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk52"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_2_rec</span> {<span class="nv">G</span> : Group} {<span class="nv">H</span> <span class="nv">J</span> <span class="nv">K</span> : Subgroup G}
  (<span class="nv">N</span> : Subgroup G) `{!IsNormalSubgroup N}
  (i : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, H x -&gt; J y -&gt; K z -&gt; N (grp_commutator (grp_commutator x y) z))
  : [[H, J], K] ‚äÜ N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[H, J], K] ‚äÜ N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[H, J], K] ‚äÜ N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk54">snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
[H, J] x -&gt; K y -&gt; N (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk55"><span class="nb">intros</span> x z HJx Kz; <span class="nb">revert</span> x HJx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, [H, J] x -&gt; N (grp_commutator x z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk56"><span class="nb">change</span> (N (grp_commutator <span class="nl">?x</span> z)) <span class="kr">with</span> (subgroup_precomp_commutator_l N z x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
[H, J] x -&gt; subgroup_precomp_commutator_l N z x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk57">rapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
H x -&gt;
J y -&gt;
K z -&gt; N (grp_commutator (grp_commutator x y) z)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt;
J y -&gt;
subgroup_precomp_commutator_l N z (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator of elements from each respective subgroup is in the commutator subgroup. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk58"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_in</span> {<span class="nv">G</span> : Group} {<span class="nv">H</span> <span class="nv">J</span> : Subgroup G} {<span class="nv">x</span> <span class="nv">y</span> : G}
  (<span class="nv">Hx</span> : H x) (<span class="nv">Jy</span> : J y)
  : subgroup_commutator H J (grp_commutator x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5a"><span class="nb">apply</span> tr, sgt_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : H &amp;
{y0 : J &amp;
grp_commutator x0.<span class="mi">1</span> y0.<span class="mi">1</span> = grp_commutator x y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">x</span>; Hx), (y; Jy).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutator subgroups are functorial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5b"><span class="kn">Definition</span> <span class="nf">functor_subgroup_commutator</span> {<span class="nv">G</span> : Group} {<span class="nv">H</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> : Subgroup G}
  (<span class="nv">f</span> : H ‚äÜ K) (<span class="nv">g</span> : J ‚äÜ L)
  : [H, J] ‚äÜ [K, L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚äÜ K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚äÜ L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚äÜ [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚äÜ K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚äÜ L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚äÜ [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5d">snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚äÜ K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚äÜ L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt; J y -&gt; [K, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5e"><span class="nb">intros</span> x y Hx Jx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚äÜ K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚äÜ L</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jx</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[K, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (subgroup_commutator_in (f _ Hx) (g _ Jx)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk5f"><span class="kn">Definition</span> <span class="nf">subgroup_eq_commutator</span> {<span class="nv">G</span> : Group} {<span class="nv">H</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> : Subgroup G}
  (<span class="nv">f</span> : H ‚Üî K) (<span class="nv">g</span> : J ‚Üî L)
  : [H, J] ‚Üî [K, L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚Üî [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚Üî [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk61">snapply pred_subset_antisymm; <span class="nb">apply</span> functor_subgroup_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H ‚äÜ K</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk62"><hr></label><div class="goal-conclusion">J ‚äÜ L</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk63"><hr></label><div class="goal-conclusion">K ‚äÜ H</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk64"><hr></label><div class="goal-conclusion">L ‚äÜ J</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk65"><span class="mi">3</span>,<span class="mi">4</span>: <span class="nb">apply</span> pred_subset_pred_eq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H ‚äÜ K</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk66"><hr></label><div class="goal-conclusion">J ‚äÜ L</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk67"><hr></label><div class="goal-conclusion">H ‚Üî K</div></blockquote><input class="alectryon-extra-goal-toggle" id="commutator-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk68"><hr></label><div class="goal-conclusion">J ‚Üî L</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk69"><span class="mi">1</span>,<span class="mi">3</span>: <span class="bp">exact</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">J ‚äÜ L</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, L</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H ‚Üî K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>J ‚Üî L</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk6a"><hr></label><div class="goal-conclusion">J ‚Üî L</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6b"><span class="kn">Definition</span> <span class="nf">subgroup_incl_commutator_symm</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> <span class="nv">J</span> : Subgroup G)
  : [H, J] ‚äÜ [J, H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚äÜ [J, H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚äÜ [J, H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6d">snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
H x -&gt; J y -&gt; [J, H] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6e"><span class="nb">intros</span> x y Hx Jy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[J, H] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk6f">napply subgroup_in_inv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[J, H] (grp_commutator x y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk70"><span class="nb">rewrite</span> grp_commutator_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[J, H] (grp_commutator y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> subgroup_commutator_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutator subgroups are symmetric in their arguments. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk71"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_symm</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> <span class="nv">J</span> : Subgroup G)
  : [H, J] ‚Üî [J, H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚Üî [J, H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, J] ‚Üî [J, H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply pred_subset_antisymm; <span class="nb">apply</span> subgroup_incl_commutator_symm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The opposite subgroup of a commutator subgroup is the commutator subgroup of the opposite subgroups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk73"><span class="kn">Definition</span> <span class="nf">subgroup_eq_commutator_grp_op</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> <span class="nv">J</span> : Subgroup G)
  : subgroup_grp_op [H, J] ‚Üî [subgroup_grp_op J, subgroup_grp_op H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_grp_op [H, J]
‚Üî [subgroup_grp_op J, subgroup_grp_op H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_grp_op [H, J]
‚Üî [subgroup_grp_op J, subgroup_grp_op H]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk75">napply (subgroup_eq_subgroup_generated_op (G:=G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g</span> : G =&gt;
 {x : H &amp; {y : J &amp; grp_commutator x.<span class="mi">1</span> y.<span class="mi">1</span> = g}})
‚Üî (<span class="kr">fun</span> <span class="nv">g</span> : grp_op G =&gt;
   {x : subgroup_grp_op J &amp;
   {y : subgroup_grp_op H &amp;
   grp_commutator x.<span class="mi">1</span> y.<span class="mi">1</span> = g}})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk76"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : H &amp; {y : J &amp; grp_commutator x0.<span class="mi">1</span> y.<span class="mi">1</span> = x}} &lt;-&gt;
{x0 : subgroup_grp_op J &amp;
{y : subgroup_grp_op H &amp; grp_commutator x0.<span class="mi">1</span> y.<span class="mi">1</span> = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk77"><span class="nb">refine</span> (iff_compose _ (equiv_sigma_symm _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : H &amp; {y : J &amp; grp_commutator x0.<span class="mi">1</span> y.<span class="mi">1</span> = x}} &lt;-&gt;
{a : subgroup_grp_op H &amp;
{b : subgroup_grp_op J &amp; grp_commutator b.<span class="mi">1</span> a.<span class="mi">1</span> = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk78"><span class="kp">do</span> <span class="mi">2</span> (snapply (equiv_functor_sigma&#39;
    (grp_iso_subgroup_group (grp_op_iso_inv G)
      (equiv_subgroup_inv (G:=grp_op G) (subgroup_grp_op _)))); <span class="nb">intro</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : J =&gt; grp_commutator a.<span class="mi">1</span> y.<span class="mi">1</span> = x) a0 &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">b</span> : subgroup_grp_op J =&gt;
 grp_commutator b.<span class="mi">1</span>
   (grp_iso_subgroup_group (grp_op_iso_inv G)
      (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       equiv_subgroup_inv (subgroup_grp_op H) x) a).<span class="mi">1</span> =
 x)
  (grp_iso_subgroup_group (grp_op_iso_inv G)
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
      equiv_subgroup_inv (subgroup_grp_op J) x) a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk79"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator a.<span class="mi">1</span> a0.<span class="mi">1</span> = x &lt;~&gt;
grp_commutator (a0.<span class="mi">1</span>)^ (a.<span class="mi">1</span>)^ = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7a"><span class="nb">apply</span> equiv_concat_l; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator a.<span class="mi">1</span> a0.<span class="mi">1</span> =
grp_commutator (a0.<span class="mi">1</span>)^ (a.<span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7b">lhs_V napply grp_commutator_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_commutator a0.<span class="mi">1</span> a.<span class="mi">1</span>)^ =
grp_commutator (a0.<span class="mi">1</span>)^ (a.<span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_commutator (grp_op_iso_inv _) a0.<span class="mi">1</span> a.<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator subgroup of an abelian group is always trivial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7c"><span class="kn">Definition</span> <span class="nf">istrivial_commutator_subgroup_ab</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">H</span> <span class="nv">K</span> : Subgroup A)
  : IsTrivialGroup [H, K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Subgroup A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup [H, K]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Subgroup A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup [H, K]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7e">rapply subgroup_commutator_rec; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Subgroup A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>K y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply ab_commutator.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commutator of normal subgroups is normal. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk7f"><span class="kn">Instance</span> <span class="nf">isnormal_subgroup_commutator</span> {<span class="nv">G</span> : Group} (<span class="nv">H</span> <span class="nv">J</span> : Subgroup G)
  `{!IsNormalSubgroup H, !IsNormalSubgroup J}
  : IsNormalSubgroup [H, J].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup [H, J]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup [H, J]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk81">snapply Build_IsNormalSubgroup&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, [H, J] x -&gt; [H, J] (y * x * y^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk82"><span class="nb">intros</span> x y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, [H, J] x -&gt; [H, J] (y * x * y^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk83"><span class="nb">apply</span> (functor_subgroup_generated _ _ (grp_conj y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g</span> : G =&gt;
 {x : H &amp; {y : J &amp; grp_commutator x.<span class="mi">1</span> y.<span class="mi">1</span> = g}})
‚äÜ (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
   {x0 : H &amp;
   {y0 : J &amp; grp_commutator x0.<span class="mi">1</span> y0.<span class="mi">1</span> = grp_conj y x}})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk84"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : H &amp; {y : J &amp; grp_commutator x0.<span class="mi">1</span> y.<span class="mi">1</span> = x}} -&gt;
{x0 : H &amp;
{y0 : J &amp; grp_commutator x0.<span class="mi">1</span> y0.<span class="mi">1</span> = grp_conj y x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk85"><span class="kp">do</span> <span class="mi">2</span> (rapply (functor_sigma (grp_iso_normal_conj _ y)); <span class="nb">intro</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator a.<span class="mi">1</span> a0.<span class="mi">1</span> = x -&gt;
grp_commutator (grp_iso_normal_conj H y a).<span class="mi">1</span>
  (grp_iso_normal_conj J y a0).<span class="mi">1</span> = grp_conj y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk86"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_commutator a.<span class="mi">1</span> a0.<span class="mi">1</span> = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator (grp_iso_normal_conj H y a).<span class="mi">1</span>
  (grp_iso_normal_conj J y a0).<span class="mi">1</span> = grp_conj y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk87">lhs_V napply (grp_homo_commutator (grp_conj y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup H</span></span></span><br><span><var>IsNormalSubgroup1</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup J</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>J</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_commutator a.<span class="mi">1</span> a0.<span class="mi">1</span> = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj y
  (grp_commutator (subgroup_incl H a)
     (subgroup_incl J a0)) = grp_conj y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (grp_conj y) p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutator subgroups distribute over products of normal subgroups on the left. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk88"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_normal_prod_l</span> {<span class="nv">G</span> : Group}
  (<span class="nv">H</span> <span class="nv">K</span> <span class="nv">L</span> : NormalSubgroup G)
  : [subgroup_product H K, L] ‚Üî subgroup_product [H, L] [K, L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L]
‚Üî subgroup_product [H, L] [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk89"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L]
‚Üî subgroup_product [H, L] [K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8a"><span class="nb">intros</span> x; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L] x -&gt;
subgroup_product [H, L] [K, L] x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk8b"><hr></label><div class="goal-conclusion">subgroup_product [H, L] [K, L] x -&gt;
[subgroup_product H K, L] x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L] x -&gt;
subgroup_product [H, L] [K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8d"><span class="nb">revert</span> x; snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
subgroup_product H K x -&gt;
L y -&gt;
subgroup_product [H, L] [K, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8e"><span class="nb">intros</span> x y HKx Ly; <span class="nb">revert</span> x HKx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
subgroup_product H K x -&gt;
subgroup_product [H, L] [K, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk8f"><span class="nb">change</span> (subgroup_product <span class="nl">?H</span> <span class="nl">?J</span> (grp_commutator <span class="nl">?x</span> y))
      <span class="kr">with</span> (subgroup_precomp_commutator_l (subgroup_product H J) y x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
subgroup_product H K x -&gt;
subgroup_precomp_commutator_l
  (subgroup_product [H, L] [K, L]) y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk90">snapply subgroup_generated_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pred_or H K
‚äÜ subgroup_precomp_commutator_l
    (subgroup_product [H, L] [K, L]) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk91"><span class="nb">intros</span> x [Hx | Kx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_precomp_commutator_l
  (subgroup_product [H, L] [K, L]) y x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kx</var><span class="hyp-type"><b>: </b><span>K x</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk92"><hr></label><div class="goal-conclusion">subgroup_precomp_commutator_l
  (subgroup_product [H, L] [K, L]) y x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk93">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_precomp_commutator_l
  (subgroup_product [H, L] [K, L]) y x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk94"><span class="nb">apply</span> subgroup_product_incl_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> subgroup_commutator_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk95">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kx</var><span class="hyp-type"><b>: </b><span>K x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_precomp_commutator_l
  (subgroup_product [H, L] [K, L]) y x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk96"><span class="nb">apply</span> subgroup_product_incl_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Ly</var><span class="hyp-type"><b>: </b><span>L y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kx</var><span class="hyp-type"><b>: </b><span>K x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[K, L] (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> subgroup_commutator_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk97">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_product [H, L] [K, L] x -&gt;
[subgroup_product H K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk98"><span class="nb">revert</span> x; snapply subgroup_generated_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pred_or [H, L] [K, L] ‚äÜ [subgroup_product H K, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk99"><span class="nb">intros</span> x [HLx | KLx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>HLx</var><span class="hyp-type"><b>: </b><span>[H, L] x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L] x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>KLx</var><span class="hyp-type"><b>: </b><span>[K, L] x</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk9a"><hr></label><div class="goal-conclusion">[subgroup_product H K, L] x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk9b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>HLx</var><span class="hyp-type"><b>: </b><span>[H, L] x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk9c"><span class="nb">revert</span> x HLx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, [H, L] x -&gt; [subgroup_product H K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk9d"><span class="nb">apply</span> functor_subgroup_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H ‚äÜ subgroup_product H K</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chk9e"><hr></label><div class="goal-conclusion">L ‚äÜ L</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chk9f"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H ‚äÜ subgroup_product H K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> subgroup_product_incl_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>KLx</var><span class="hyp-type"><b>: </b><span>[K, L] x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product H K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka1"><span class="nb">revert</span> x KLx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, [K, L] x -&gt; [subgroup_product H K, L] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka2"><span class="nb">apply</span> functor_subgroup_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K ‚äÜ subgroup_product H K</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chka3"><hr></label><div class="goal-conclusion">L ‚äÜ L</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka4"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K ‚äÜ subgroup_product H K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> subgroup_product_incl_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutator subgroups distribute over products of normal subgroups on the right. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka5"><span class="kn">Definition</span> <span class="nf">subgroup_commutator_normal_prod_r</span> {<span class="nv">G</span> : Group}
  (<span class="nv">H</span> <span class="nv">K</span> <span class="nv">L</span> : NormalSubgroup G)
  : [H, subgroup_product K L] ‚Üî subgroup_product [H, K] [H, L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, subgroup_product K L]
‚Üî subgroup_product [H, K] [H, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, subgroup_product K L]
‚Üî subgroup_product [H, K] [H, L]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka7"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, subgroup_product K L] x &lt;-&gt;
subgroup_product [H, K] [H, L] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chka8"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[H, subgroup_product K L] x &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chka9"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; subgroup_product [H, K] [H, L] x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkaa"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> subgroup_commutator_symm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product K L, H] x &lt;-&gt;
subgroup_product [H, K] [H, L] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkab"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product K L, H] x &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="commutator-v-chkac"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; subgroup_product [H, K] [H, L] x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkad"><span class="mi">2</span>: napply (subgroup_eq_functor_subgroup_product grp_iso_id
    (subgroup_commutator_symm _ _) (subgroup_commutator_symm _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, K, L</var><span class="hyp-type"><b>: </b><span>NormalSubgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_product K L, H] x &lt;-&gt;
subgroup_product [K, H] [L, H] x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (subgroup_commutator_normal_prod_l K L H x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The subgroup image of a commutator is included in the commutator of the subgroup images. The converse only generally holds for a normal [J] and [K] and a surjective [f]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkae"><span class="kn">Definition</span> <span class="nf">subgroup_image_commutator_incl</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : G $-&gt; H) (<span class="nv">J</span> <span class="nv">K</span> : Subgroup G)
  : subgroup_image f [J, K] ‚äÜ [subgroup_image f J, subgroup_image f K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_image f [J, K]
‚äÜ [subgroup_image f J, subgroup_image f K]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_image f [J, K]
‚äÜ [subgroup_image f J, subgroup_image f K]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb0">snapply subgroup_image_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[J, K]
‚äÜ subgroup_preimage f
    [subgroup_image f J, subgroup_image f K]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb1">snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
J x -&gt;
K y -&gt;
subgroup_preimage f
  [subgroup_image f J, subgroup_image f K]
  (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb2"><span class="nb">intros</span> x y Jx Ky.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Jx</var><span class="hyp-type"><b>: </b><span>J x</span></span></span><br><span><var>Ky</var><span class="hyp-type"><b>: </b><span>K y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_preimage f
  [subgroup_image f J, subgroup_image f K]
  (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb3"><span class="nb">change</span> (subgroup_preimage f [<span class="nl">?G</span>, <span class="nl">?H</span>] <span class="nl">?x</span>) <span class="kr">with</span> ([G, H] (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Jx</var><span class="hyp-type"><b>: </b><span>J x</span></span></span><br><span><var>Ky</var><span class="hyp-type"><b>: </b><span>K y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_image f J, subgroup_image f K]
  (f (grp_commutator x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb4"><span class="nb">rewrite</span> grp_homo_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Jx</var><span class="hyp-type"><b>: </b><span>J x</span></span></span><br><span><var>Ky</var><span class="hyp-type"><b>: </b><span>K y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[subgroup_image f J, subgroup_image f K]
  (grp_commutator (f x) (f y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> subgroup_commutator_in;
    <span class="bp">by</span> <span class="nb">apply</span> subgroup_image_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Derived subgroup *)</span>

<span class="sd">(** The commutator subgroup of the maximal subgroup with itself is called the derived subgroup. It is the subgroup generated by all commutators. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">normalsubgroup_derived</span> <span class="nv">G</span> : NormalSubgroup G
  := Build_NormalSubgroup G [G, G] _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can quotient a group by its derived subgroup. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_derived_quotient</span> (<span class="nv">G</span> : Group) : Group
  := QuotientGroup G (normalsubgroup_derived G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can show that the multiplication then becomes commutative. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb5"><span class="kn">Instance</span> <span class="nf">commutative_grp_derived_quotient</span> (<span class="nv">G</span> : Group)
  : Commutative (A:=grp_derived_quotient G) (.*.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb7"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>grp_derived_quotient G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : grp_derived_quotient G, x * y = y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb8">srapply grp_quotient_ind_hprop; <span class="nb">intros</span> y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : grp_derived_quotient G,
(<span class="kr">fun</span> <span class="nv">x0</span> : G / normalsubgroup_derived G =&gt;
 x * x0 = x0 * x) (grp_quotient_map y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkb9">srapply grp_quotient_ind_hprop; <span class="nb">intros</span> x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map x * grp_quotient_map y =
grp_quotient_map y * grp_quotient_map x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkba"><span class="nb">apply</span> qglue, tr, sgt_in; <span class="kr">exists</span> (<span class="nv">y</span>^; tt), (x^; tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator (y^; tt).<span class="mi">1</span> (x^; tt).<span class="mi">1</span> =
(x * y)^ * (y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkbb"><span class="nb">unfold</span> grp_commutator; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y^ * x^ * (y^)^ * (x^)^ = (x * y)^ * (y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_inv_op, !grp_inv_inv, !grp_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Hence we have a way of producing abelian groups from groups. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abgroup_derived_quotient</span> (<span class="nv">G</span> : Group) : AbGroup
  := Build_AbGroup (grp_derived_quotient G) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We get a recursion principle into abelian groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkbc"><span class="kn">Definition</span> <span class="nf">abgroup_derived_quotient_rec</span> {<span class="nv">G</span> : Group} {<span class="nv">A</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A)
  : abgroup_derived_quotient G $-&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abgroup_derived_quotient G $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkbd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abgroup_derived_quotient G $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkbe">snapply (grp_quotient_rec _ _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : G, normalsubgroup_derived G n -&gt; f n = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkbf"><span class="nb">change</span> (f <span class="nl">?n</span> = <span class="mi">1</span>) <span class="kr">with</span> (subgroup_preimage f (trivial_subgroup A) n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : G,
normalsubgroup_derived G n -&gt;
subgroup_preimage f (trivial_subgroup A) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc0">snapply subgroup_commutator_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
maximal_subgroup G x -&gt;
maximal_subgroup G y -&gt;
subgroup_preimage f (trivial_subgroup A)
  (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc1"><span class="nb">intros</span> x y _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_preimage f (trivial_subgroup A)
  (grp_commutator x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc2">lhs napply grp_homo_commutator.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_commutator (f x) (f y) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_commutator.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Furthermore, this construction is an abelianization. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc3"><span class="kn">Definition</span> <span class="nf">isabelianization_derived_quotient</span> (<span class="nv">G</span> : Group)
  : IsAbelianization (abgroup_derived_quotient G) grp_quotient_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization (abgroup_derived_quotient G)
  grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization (abgroup_derived_quotient G)
  grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc5"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (group_precomp A grp_quotient_map)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc6">snapply Build_IsSurjInj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp A grp_quotient_map)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="commutator-v-chkc7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abgroup_derived_quotient G $-&gt; A,
group_precomp A grp_quotient_map x $==
group_precomp A grp_quotient_map y -&gt; x $== y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp A grp_quotient_map)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkc9"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : abgroup_derived_quotient G $-&gt; A &amp;
group_precomp A grp_quotient_map a $== f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkca">nrefine (abgroup_derived_quotient_rec f; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp A grp_quotient_map
  (abgroup_derived_quotient_rec f) $== f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">hnf</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkcb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abgroup_derived_quotient G $-&gt; A,
group_precomp A grp_quotient_map x $==
group_precomp A grp_quotient_map y -&gt; x $== y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkcc"><span class="nb">intros</span> f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>abgroup_derived_quotient G $-&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>group_precomp A grp_quotient_map f $==
group_precomp A grp_quotient_map g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkcd">srapply grp_quotient_ind_hprop; <span class="nb">intros</span> x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>abgroup_derived_quotient G $-&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>group_precomp A grp_quotient_map f $==
group_precomp A grp_quotient_map g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (grp_quotient_map x) = g (grp_quotient_map x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Three subgroups lemma *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkce"><span class="kn">Definition</span> <span class="nf">three_subgroups_lemma</span> (<span class="nv">G</span> : Group) (<span class="nv">H</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">N</span> : Subgroup G)
  `{!IsNormalSubgroup N}
  (T1 : [[H, J], K] ‚äÜ N) (T2 : [[J, K], H] ‚äÜ N)
  : [[K, H], J] ‚äÜ N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>[[H, J], K] ‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>[[J, K], H] ‚äÜ N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[K, H], J] ‚äÜ N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>[[H, J], K] ‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>[[J, K], H] ‚äÜ N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[[K, H], J] ‚äÜ N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd0">rapply subgroup_commutator_2_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>[[H, J], K] ‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>[[J, K], H] ‚äÜ N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
K x -&gt;
H y -&gt;
J z -&gt; N (grp_commutator (grp_commutator x y) z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd1"><span class="kn">Local</span> <span class="kn">Close Scope</span> group_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, K x -&gt; H y -&gt; J z -&gt; N [[x, y], z]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd2"><span class="nb">intros</span> z x y Kz Hx Jy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[z, x], y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd3"><span class="nb">pose proof</span> (grp_hall_witt&#39; x y z^) <span class="kr">as</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj x [[x^, y], z^] *
grp_conj z^ [[(z^)^, x], y] *
grp_conj y [[y^, z^], x] = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[z, x], y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd4"><span class="nb">rewrite</span> grp_inv_inv <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj x [[x^, y], z^] * grp_conj z^ [[z, x], y] *
grp_conj y [[y^, z^], x] = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[z, x], y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd5"><span class="nb">apply</span> grp_moveL_1V <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj x [[x^, y], z^] * grp_conj z^ [[z, x], y] =
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[z, x], y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd6"><span class="nb">apply</span> grp_moveL_Vg <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[z, x], y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd7"><span class="nb">apply</span> (isnormal_conj _ (y:=z^))^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (z^ * [[z, x], y] * (z^)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd8"><span class="nb">change</span> (N (grp_conj z^ [[z, x], y])).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj z^ [[z, x], y])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkd9"><span class="nb">rewrite</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N
  ((grp_conj x [[x^, y], z^])^ *
   (grp_conj y [[y^, z^], x])^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkda"><span class="nb">apply</span> subgroup_in_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj x [[x^, y], z^])^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chkdb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><label class="goal-separator" for="commutator-v-chkdb"><hr></label><div class="goal-conclusion">N (grp_conj y [[y^, z^], x])^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkdc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj x [[x^, y], z^])^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkdd"><span class="nb">apply</span> subgroup_in_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj x [[x^, y], z^])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkde">rapply isnormal_conj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[x^, y], z^]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkdf"><span class="nb">apply</span> T1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator (subgroup_commutator H J) K
  [[x^, y], z^]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke0"><span class="nb">apply</span> tr, sgt_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : subgroup_commutator H J &amp;
{y0 : K &amp; [x0.<span class="mi">1</span>, y0.<span class="mi">1</span>] = [[x^, y], z^]}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke1"><span class="nb">unshelve</span> <span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator H J</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><label class="goal-separator" for="commutator-v-chke2"><hr></label><div class="goal-conclusion">{y0 : K &amp; [<span class="nl">?x</span>.<span class="mi">1</span>, y0.<span class="mi">1</span>] = [[x^, y], z^]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator H J</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke4"><span class="kr">exists</span> [x^, y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator H J [x^, y]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke5"><span class="nb">apply</span> subgroup_commutator_in; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> subgroup_in_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : K &amp;
[([x^, y];
 subgroup_commutator_in (subgroup_in_inv H x Hx) Jy).<span class="mi">1</span>,
y0.<span class="mi">1</span>] = [[x^, y], z^]}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">z</span>^; subgroup_in_inv _ _ Kz).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj y [[y^, z^], x])^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke8"><span class="nb">apply</span> subgroup_in_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (grp_conj y [[y^, z^], x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chke9">rapply isnormal_conj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N [[y^, z^], x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkea"><span class="nb">apply</span> T2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator (subgroup_commutator J K) H
  [[y^, z^], x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkeb"><span class="nb">apply</span> tr, sgt_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : subgroup_commutator J K &amp;
{y0 : H &amp; [x0.<span class="mi">1</span>, y0.<span class="mi">1</span>] = [[y^, z^], x]}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkec"><span class="nb">unshelve</span> <span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator J K</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="commutator-v-chked" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><label class="goal-separator" for="commutator-v-chked"><hr></label><div class="goal-conclusion">{y0 : H &amp; [<span class="nl">?x</span>.<span class="mi">1</span>, y0.<span class="mi">1</span>] = [[y^, z^], x]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkee">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator J K</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkef"><span class="kr">exists</span> [y^, z^].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_commutator J K [y^, z^]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> subgroup_commutator_in;
        <span class="bp">by</span> <span class="nb">apply</span> subgroup_in_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkf0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K, N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>IsNormalSubgroup0</var><span class="hyp-type"><b>: </b><span>IsNormalSubgroup N</span></span></span><br><span><var>T1</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator H J) K
‚äÜ N</span></span></span><br><span><var>T2</var><span class="hyp-type"><b>: </b><span>subgroup_commutator (subgroup_commutator J K) H
‚äÜ N</span></span></span><br><span><var>z, x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>Kz</var><span class="hyp-type"><b>: </b><span>K z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>Jy</var><span class="hyp-type"><b>: </b><span>J y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_conj z^ [[z, x], y] =
(grp_conj x [[x^, y], z^])^ *
(grp_conj y [[y^, z^], x])^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : H &amp;
[([y^, z^];
 subgroup_commutator_in (subgroup_in_inv J y Jy)
   (subgroup_in_inv K z Kz)).<span class="mi">1</span>, y0.<span class="mi">1</span>] = [[y^, z^], x]}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">x</span>; Hx).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> group_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkf1"><span class="kn">Definition</span> <span class="nf">three_trivial_commutators</span> (<span class="nv">G</span> : Group) (<span class="nv">H</span> <span class="nv">J</span> <span class="nv">K</span> : Subgroup G)
  : IsTrivialGroup [[H, J], K]
    -&gt; IsTrivialGroup [[J, K], H]
    -&gt; IsTrivialGroup [[K, H], J].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup [[H, J], K] -&gt;
IsTrivialGroup [[J, K], H] -&gt;
IsTrivialGroup [[K, H], J]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="commutator-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="commutator-v-chkf2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>H, J, K</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup [[H, J], K] -&gt;
IsTrivialGroup [[J, K], H] -&gt;
IsTrivialGroup [[K, H], J]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply three_subgroups_lemma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
