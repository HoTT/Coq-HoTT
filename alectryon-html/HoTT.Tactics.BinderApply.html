<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>BinderApply.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Apply a lemma under binders *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk0"><span class="kn">Require Import</span> Basics.Overture Tactics.EvalIn.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** There are some cases where [apply lem] will fail, but [intros; apply lem] will succeed.  The tactic [binder apply] is like [intros; apply lem], but it cleans up after itself by [revert]ing the things it introduced.  The tactic [binder apply lem in H] is to [binder apply lem], as [apply lem in H] is to [apply lem].  Note, however, that the implementation of [binder apply lem in H] is completely different and significantly more complicated. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">can_binder_apply</span> apply_tac fail1_tac :=
  <span class="kp">first</span> [ <span class="kp">assert_succeeds</span> apply_tac
        | <span class="kp">assert_succeeds</span> (<span class="nb">intro</span>; can_binder_apply apply_tac fail1_tac)
        | fail1_tac ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">binder_apply</span> apply_tac fail1_tac :=
  can_binder_apply apply_tac fail1_tac;
  <span class="kp">first</span> [ apply_tac
        | <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span>
          <span class="nb">intro</span> H;
            binder_apply apply_tac fail1_tac;
            <span class="nb">revert</span> H
        | <span class="kp">fail</span> <span class="mi">1</span> <span class="s2">&quot;Cannot re-revert some introduced hypothesis&quot;</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tactic [eval_under_binders tac H] is equivalent to [tac H] if [H] is not a product (lambda-abstraction), and roughly equivalent to the constr [fun x =&gt; eval_under_binders tac (H x)] if [H] is a product. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">eval_under_binders</span> tac H :=
  <span class="sd">(** Bind a convenient name for the recursive call *)</span>
  <span class="kr">let rec</span><span class="nv">_tac</span> := eval_under_binders tac <span class="kr">in</span>
  <span class="sd">(** If the hypothesis is a product ([forall]), we want to recurse under binders; if not, we&#39;re in the base case, and we simply compute the new term.  We use [match] rather than [lazymatch] so that if the tactic fails to apply under all of the binders, we try again under fewer binders.  We want to try first under as many binders as possible, in case the tactic, e.g., instantiates extra binders with evars. *)</span>
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
      <span class="sd">(** Standard pattern for recursing under binders.  We zeta-expand to work around https://coq.inria.fr/bugs/show_bug.cgi?id=3248 and https://coq.inria.fr/bugs/show_bug.cgi?id=3458; we&#39;d otherwise need globally unique name for [x].  We zeta-reduce afterwards so the user doesn&#39;t see our zeta-expansion.  We use [x] in both the pattern and the returned constructor so that we preserve the given name for the binder.  *)</span>
    | <span class="kr">forall</span> <span class="nv">x</span> : <span class="nl">?T</span>, @<span class="nl">?P</span> x
      =&gt; <span class="kr">let</span> <span class="nv">ret</span> := <span class="kp">constr</span>:(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt;
                              <span class="kr">let</span> <span class="nv">Hx</span> := H x <span class="kr">in</span>
                              <span class="kp">ltac</span>:(
                                <span class="kr">let</span> <span class="nv">ret&#39;</span> := rec_tac Hx <span class="kr">in</span>
                                <span class="bp">exact</span> ret&#39;)) <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">ret&#39;</span> := (<span class="kp">eval</span> <span class="nb">cbv</span> zeta <span class="kr">in</span> ret) <span class="kr">in</span>
         <span class="kp">constr</span>:(ret&#39;)
    <span class="sd">(** Base case - simply return [tac H]  *)</span>
    | _ =&gt; tac H
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tactic [make_tac_under_binders_using_in tac using_tac H] uses [tac] to transform a term [H], solving side-conditions (e.g., if [tac] uses [apply]) with [using_tac].  It returns the updated version of [H] as a constr; if [H] is a hypothesis in the context, it does not modify it.  Conceptually, [make_tac_under_binders_using_in tac idtac H] is the composition of two tactics: a [transform_under_binders : (constr -&gt; constr) -&gt; (constr -&gt; constr)] that runs a tactic under the binders of the constr it&#39;s given, and what would be an [eval tac in H], except for the fact that, e.g., [eval rewrite in H] doesn&#39;t actually work because it predates tactics in terms (we use [eval_in_using tac using_tac H] instead).</span>

<span class="sd">    The arguments are:</span>

<span class="sd">    - [tac] - should take the name of a hypothesis, and modify that hypothesis in place.  It could, for example, be [fun H =&gt; rewrite lem in H] to do the [rewrite H] under binders.</span>

<span class="sd">    - [using_tac] - used to solve any side-conditions that [tac] generates.  Not strictly necessary, since [tac] can always solve its own side-conditions, but it&#39;s sometimes convenient to instantiate [tac] with [fun H =&gt; eapply lem in H] or something, and solve the side-conditions with [eassumption].</span>

<span class="sd">    - [H] - the name of the hypothesis to start from.</span>

<span class="sd">    N.B. We do not require [Funext] to use this tactic; [Funext] would only required to relate the term returned by this tactic and the original term.  Note also that we only rewrite under top-level binders (e.g., under the [x] in a hypothesis of type [forall x, P x], but not under the [x] in a hypothesis of type [(fun x y =&gt; x + y) = (fun x y =&gt; y + x)]). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">make_tac_under_binders_using_in</span> tac using_tac H :=
  eval_under_binders <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H&#39;</span> =&gt; eval_in_using tac using_tac H&#39;) H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">do_tac_under_binders_using_in</span> tac using_tac H :=
  <span class="kr">let</span> <span class="nv">H&#39;</span> := make_tac_under_binders_using_in tac using_tac H <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">H&#39;&#39;</span> := <span class="kp">fresh</span> <span class="kr">in</span>
  <span class="nb">pose proof</span> H&#39; <span class="kr">as</span> H&#39;&#39;;
    <span class="nb">clear</span> H;
    <span class="nb">rename</span> H&#39;&#39; <span class="nb">into</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constrbinder&quot;</span> <span class="s2">&quot;apply&quot;</span> <span class="kp">constr</span>(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;using&quot;</span> tactic3(tac)
  := make_tac_under_binders_using_in <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H&#39;</span> =&gt; <span class="nb">apply</span> lem <span class="kr">in</span> H&#39;) tac H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constrbinder&quot;</span> <span class="s2">&quot;eapply&quot;</span> open_constr(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;using&quot;</span> tactic3(tac)
  := constrbinder <span class="nb">apply</span> lem <span class="kr">in</span> H <span class="nb">using</span> tac.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;apply&quot;</span> <span class="kp">constr</span>(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;using&quot;</span> tactic3(tac)
  := do_tac_under_binders_using_in <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H&#39;</span> =&gt; <span class="nb">apply</span> lem <span class="kr">in</span> H&#39;) tac H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;eapply&quot;</span> open_constr(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;using&quot;</span> tactic3(tac)
  := <span class="kn">binder</span> <span class="nb">apply</span> lem <span class="kr">in</span> H <span class="nb">using</span> tac.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constrbinder&quot;</span> <span class="s2">&quot;apply&quot;</span> <span class="kp">constr</span>(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) := constrbinder <span class="nb">apply</span> lem <span class="kr">in</span> H <span class="nb">using</span> <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constrbinder&quot;</span> <span class="s2">&quot;eapply&quot;</span> open_constr(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) := constrbinder <span class="nb">eapply</span> lem <span class="kr">in</span> H <span class="nb">using</span> <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;apply&quot;</span> <span class="kp">constr</span>(lem) := binder_apply <span class="kp">ltac</span>:(<span class="nb">apply</span> lem) <span class="kp">ltac</span>:(<span class="kp">fail</span> <span class="mi">1</span> <span class="s2">&quot;Cannot apply&quot;</span> lem).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;eapply&quot;</span> open_constr(lem) := binder_apply <span class="kp">ltac</span>:(<span class="nb">eapply</span> lem) <span class="kp">ltac</span>:(<span class="kp">fail</span> <span class="mi">1</span> <span class="s2">&quot;Cannot eapply&quot;</span> lem).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;apply&quot;</span> <span class="kp">constr</span>(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) := <span class="kn">binder</span> <span class="nb">apply</span> lem <span class="kr">in</span> H <span class="nb">using</span> <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;binder&quot;</span> <span class="s2">&quot;eapply&quot;</span> open_constr(lem) <span class="s2">&quot;in&quot;</span> <span class="kp">constr</span>(H) := <span class="kn">binder</span> <span class="nb">eapply</span> lem <span class="kr">in</span> H <span class="nb">using</span> <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk1"><span class="kn">Example</span> <span class="nf">basic_goal</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">HA</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">HB</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x) : <span class="kr">forall</span> <span class="nv">x</span> : A, C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** If we try to [apply HB], wanting to replace [C] with [B], we get an error about being unable to unify [B ?] with [A]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk3"><span class="kn">Fail</span> <span class="nb">apply</span> HB.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
A : <span class="kt">Type</span>
B : A -&gt; <span class="kt">Type</span>
C : A -&gt; <span class="kt">Type</span>
HA : <span class="kr">forall</span> <span class="nv">x</span> : A, B x
HB : <span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x
Unable to <span class="nb">unify</span> <span class="s2">&quot;B ?M58&quot;</span> <span class="kr">with</span> <span class="s2">&quot;A&quot;</span>.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** The tactic [binder apply] fixes this shortcoming. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk4"><span class="kn">binder</span> <span class="nb">apply</span> HB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">H</span> : A, B H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We [Abort], so that we don&#39;t get an extra constant floating around. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk5"><span class="kn">Example</span> <span class="nf">basic</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">HA</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">HB</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x) : <span class="kr">forall</span> <span class="nv">x</span> : A, C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** If we try to [apply HB in HA], wanting to replace [B] with [C], we get an error about being unable to instantiate the argument of type [A]: &quot;Error: Unable to find an instance for the variable x.&quot; *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk7"><span class="kn">Fail</span> <span class="nb">apply</span> HB <span class="kr">in</span> HA.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Unable to find an instance <span class="kr">for</span> the variable x.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** The tactic [binder apply] fixes this shortcoming. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk8"><span class="kn">binder</span> <span class="nb">apply</span> HB <span class="kr">in</span> HA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; C x</span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, C x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, C x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We [Abort], so that we don&#39;t get an extra constant floating around. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chk9"><span class="kn">Example</span> <span class="nf">ex_funext</span> `{Funext} {A} f g
        (H&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A, f x y z w = g x y z w :&gt; A)
: f = g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A, f x y z w = g x y z w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A, f x y z w = g x y z w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We need to apply [path_forall] under binders five times in [H&#39;].  We use a different variant each time to demonstrate the various ways of using this tactic.  In a normal proof, you&#39;d probably just do [do 4 binder apply (@path_forall _) in H&#39;] or just [repeat binder apply (@path_forall _) in H&#39;]. *)</span>
  <span class="sd">(** If we do [binder apply path_forall in H&#39;], we are told that Coq can&#39;t infer the argument [A] to [path_forall].  Instead, we can [binder eapply] it, to tell Coq to defer inference and use an evar for now. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chkb"><span class="kn">Fail</span> <span class="kn">binder</span> <span class="nb">apply</span> path_forall <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Cannot infer the implicit parameter A of path_forall
whose type <span class="kr">is</span> <span class="s2">&quot;Type&quot;</span> <span class="kr">in</span>
environment:
H : Funext
A : <span class="kt">Type</span>
f, g : A -&gt; A -&gt; A -&gt; A -&gt; A
H&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A, f x y z w = g x y z w</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span> : A, f x y z w = g x y z w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chkc"><span class="kn">binder</span> <span class="nb">eapply</span> path_forall <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A, f x y z = g x y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Alternatively, we can make [A] explicit.  But then we get an error about not being able to resolve the instance of [Funext].  We can either tell Coq to solve the side condition using the [assumption] tactic (or [typeclasses eauto], for that matter), or we can have typeclass inference run when we construct the lemma to apply. *)</span>
  <span class="sd">(** Some versions of Proof General are bad about noticing [Fail] within a tactic; see http://proofgeneral.inf.ed.ac.uk/trac/ticket/494.  So we comment this one out. *)</span>
  <span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">  Fail binder apply @path_forall in H&#39;.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">  Error: Tactic failure: Cannot use &lt;tactic&gt; to solve side-condition goal</span>
<span class="sd">Funext . Extended goal with context:</span>
<span class="sd">(Funext -&gt;</span>
<span class="sd"> forall (A : Type) (f g : A -&gt; A -&gt; A -&gt; A -&gt; A)</span>
<span class="sd">   (H&#39; : forall x&#39; x&#39;0 x&#39;1 : A, f x&#39; x&#39;0 x&#39;1 = g x&#39; x&#39;0 x&#39;1),</span>
<span class="sd"> let H0 := H&#39; in Funext). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chkd"><span class="kn">binder</span> <span class="nb">apply</span> @path_forall <span class="kr">in</span> H&#39; <span class="nb">using</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x y = g x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chke"><span class="kn">binder</span> <span class="nb">apply</span> @path_forall <span class="kr">in</span> H&#39; <span class="nb">using</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="binderapply-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="binderapply-v-chkf"><span class="kn">binder</span> <span class="nb">apply</span> (@path_forall _) <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A -&gt; A -&gt; A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Now we have removed all arguments to [f] and [g] in [H&#39;]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We [Abort], so that we don&#39;t get an extra constant floating around. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** N.B. [constrbinder apply] is like [binder apply], except that it constructs a new term and returns it, rather than applying a lemma in-place to a hypothesis.  It&#39;s primarily useful as plumbing for higher-level tactics. *)</span></span></pre>
</div>
</div></body>
</html>
