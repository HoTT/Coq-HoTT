<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Prod.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Theorems about cartesian products *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Equivalences Basics.PathGroupoids
               Basics.Tactics Basics.Trunc Basics.Decidable Basics.Iff.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Empty.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B f g n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: &quot;: rename&quot; is needed because the default names changed in Rocq 9.2.0.  When the minimum supported version is &gt;= 9.2.0, the &quot;: rename&quot; can be removed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme</span> <span class="nf">prod_ind</span> := <span class="kn">Induction for</span> prod <span class="kn">Sort</span> <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> prod_ind {A B} P f p : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Unpacking *)</span>

<span class="sd">(** Sometimes we would like to prove [Q u] where [u : A * B] by writing [u] as a pair [(fst u ; snd u)]. This is accomplished by [unpack_prod]. We want tight control over the proof, so we just write it down even though is looks a bit scary. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">unpack_prod</span> `{P : A * B -&gt; <span class="kt">Type</span>} (u : A * B) :
  P (fst u, snd u) -&gt; P u
  := idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> unpack_prod / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we write down the reverse. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pack_prod</span> `{P : A * B -&gt; <span class="kt">Type</span>} (u : A * B) :
  P u -&gt; P (fst u, snd u)
  := idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> pack_prod / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Eta conversion *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_prod</span> `(z : A * B) : (fst z, snd z) = z
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eta_prod / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths *)</span>

<span class="sd">(** With this version of the function, we often have to give [z] and [z&#39;] explicitly, so we make them explicit arguments. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1"><span class="kn">Definition</span> <span class="nf">path_prod_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B)
  (<span class="nv">pq</span> : (fst z = fst z&#39;) * (snd z = snd z&#39;))
  : (z = z&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>(fst z = fst z&#39;) * (snd z = snd z&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">z = z&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>(fst z = fst z&#39;) * (snd z = snd z&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">z = z&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3"><span class="nb">change</span> ((fst z, snd z) = (fst z&#39;, snd z&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>(fst z = fst z&#39;) * (snd z = snd z&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst z, snd z) = (fst z&#39;, snd z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk4"><span class="nb">case</span> (fst pq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>(fst z = fst z&#39;) * (snd z = snd z&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst z, snd z) = (fst z, snd z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5"><span class="nb">case</span> (snd pq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>(fst z = fst z&#39;) * (snd z = snd z&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst z, snd z) = (fst z, snd z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it&#39;s the uncurried one that is proven below to be an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B) :
  (fst z = fst z&#39;) -&gt; (snd z = snd z&#39;) -&gt; (z = z&#39;)
  := <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> =&gt; path_prod_uncurried z z&#39; (p,q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This version produces only paths between pairs, as opposed to paths between arbitrary inhabitants of product types.  But it has the advantage that the components of those pairs can more often be inferred. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_prod&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> <span class="nv">y&#39;</span> : B}
  : (x = x&#39;) -&gt; (y = y&#39;) -&gt; ((x,y) = (x&#39;,y&#39;))
  := <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> =&gt; path_prod (x,y) (x&#39;,y&#39;) p q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we show how these things compute. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6"><span class="kn">Definition</span> <span class="nf">ap_fst_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B}
  (<span class="nv">p</span> : fst z = fst z&#39;) (<span class="nv">q</span> : snd z = snd z&#39;) :
  ap fst (path_prod _ _ p q) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod z z&#39; p q) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod z z&#39; p q) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk8"><span class="nb">change</span> z <span class="kr">with</span> (fst z, snd z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod (fst z, snd z) z&#39; p q) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk9"><span class="nb">change</span> z&#39; <span class="kr">with</span> (fst z&#39;, snd z&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod (fst z, snd z) (fst z&#39;, snd z&#39;) p q) =
p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chka"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod (fst z, snd z) (fst z, snd z) <span class="mi">1</span> <span class="mi">1</span>) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chkb"><span class="kn">Definition</span> <span class="nf">ap_fst_path_prod&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> <span class="nv">y&#39;</span> : B}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap fst (path_prod&#39; p q) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod&#39; p q) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap fst (path_prod&#39; p q) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_fst_path_prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chkd"><span class="kn">Definition</span> <span class="nf">ap_snd_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B}
  (<span class="nv">p</span> : fst z = fst z&#39;) (<span class="nv">q</span> : snd z = snd z&#39;) :
  ap snd (path_prod _ _ p q) = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod z z&#39; p q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod z z&#39; p q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chkf"><span class="nb">change</span> z <span class="kr">with</span> (fst z, snd z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod (fst z, snd z) z&#39; p q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk10"><span class="nb">change</span> z&#39; <span class="kr">with</span> (fst z&#39;, snd z&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod (fst z, snd z) (fst z&#39;, snd z&#39;) p q) =
q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk11"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod (fst z, snd z) (fst z, snd z) <span class="mi">1</span> <span class="mi">1</span>) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk12"><span class="kn">Definition</span> <span class="nf">ap_snd_path_prod&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> <span class="nv">y&#39;</span> : B}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : y = y&#39;)
  : ap snd (path_prod&#39; p q) = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod&#39; p q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap snd (path_prod&#39; p q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_snd_path_prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk14"><span class="kn">Definition</span> <span class="nf">eta_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B} (<span class="nv">p</span> : z = z&#39;) :
  path_prod _ _(ap fst p) (ap snd p) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod z z&#39; (ap fst p) (ap snd p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>z = z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod z z&#39; (ap fst p) (ap snd p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk16"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod z z (ap fst <span class="mi">1</span>) (ap snd <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk17"><span class="kn">Definition</span> <span class="nf">ap_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C)
           {<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B} (<span class="nv">p</span> : fst z = fst z&#39;) (<span class="nv">q</span> : snd z = snd z&#39;)
: ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; f (fst z) (snd z)) (path_prod _ _ p q)
  = ap011 f p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">z</span> : A * B =&gt; f (fst z) (snd z))
  (path_prod z z&#39; p q) = ap011 f p q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">z</span> : A * B =&gt; f (fst z) (snd z))
  (path_prod z z&#39; p q) = ap011 f p q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> z, z&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we show how these compute with transport. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk19"><span class="kn">Lemma</span> <span class="nf">transport_path_prod_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A * B -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A * B}
      (<span class="nv">H</span> : (fst x = fst y) * (snd x = snd y))
      (<span class="nv">Px</span> : P x)
: transport P (path_prod_uncurried _ _ H) Px
  = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (x, snd y))
              (fst H)
              (transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; P (fst x, y))
                         (snd H)
                         Px).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(fst x = fst y) * (snd x = snd y)</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (path_prod_uncurried x y H) Px =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (x, snd y)) (fst H)
  (transport (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; P (fst x, y)) (snd H) Px)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(fst x = fst y) * (snd x = snd y)</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (path_prod_uncurried x y H) Px =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (x, snd y)) (fst H)
  (transport (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; P (fst x, y)) (snd H) Px)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1b"><span class="nb">destruct</span> x, y, H; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>fst0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>fst1</var><span class="hyp-type"><b>: </b><span>fst = fst0</span></span></span><br><span><var>snd1</var><span class="hyp-type"><b>: </b><span>snd = snd0</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P (fst, snd)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P
  <span class="kr">match</span>
    fst1 <span class="kr">in</span> (_ = a) <span class="kr">return</span> ((fst, snd) = (a, snd0))
  <span class="kr">with</span>
  | <span class="mi">1</span> =&gt;
      <span class="kr">match</span>
        snd1 <span class="kr">in</span> (_ = b) <span class="kr">return</span> ((fst, snd) = (fst, b))
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; <span class="mi">1</span>
      <span class="kr">end</span>
  <span class="kr">end</span> Px =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (x, snd0)) fst1
  (transport (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; P (fst, y)) snd1 Px)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1c">path_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P (fst, snd)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P <span class="mi">1</span> Px =
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (x, snd)) <span class="mi">1</span>
  (transport (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; P (fst, y)) <span class="mi">1</span> Px)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A * B -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A * B}
           (<span class="nv">HA</span> : fst x = fst y)
           (<span class="nv">HB</span> : snd x = snd y)
           (<span class="nv">Px</span> : P x)
: transport P (path_prod _ _ HA HB) Px
  = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (x, snd y))
              HA
              (transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; P (fst x, y))
                         HB
                         Px)
  := transport_path_prod_uncurried P (HA, HB) Px.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_prod&#39;</span>
           {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A * B -&gt; <span class="kt">Type</span>)
           {<span class="nv">x</span> <span class="nv">y</span> : A}
           {<span class="nv">x&#39;</span> <span class="nv">y&#39;</span> : B}
           (<span class="nv">HA</span> : x = y)
           (<span class="nv">HB</span> : x&#39; = y&#39;)
           (<span class="nv">Px</span> : P (x,x&#39;))
: transport P (path_prod&#39; HA HB) Px
  = transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (x, y&#39;))
              HA
              (transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; P (x, y))
                         HB
                         Px)
  := @transport_path_prod _ _ P (x, x&#39;) (y, y&#39;) HA HB Px.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This lets us identify the path space of a product type, up to equivalence. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1d"><span class="kn">Instance</span> <span class="nf">isequiv_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B}
: IsEquiv (path_prod_uncurried z z&#39;) | <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_prod_uncurried z z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_prod_uncurried z z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk1f"><span class="nb">refine</span> (Build_IsEquiv _ _ _
            (<span class="kr">fun</span> <span class="nv">r</span> =&gt; (ap fst r, ap snd r))
            eta_path_prod
            (<span class="kr">fun</span> <span class="nv">pq</span> =&gt; path_prod&#39;
                         (ap_fst_path_prod (fst pq) (snd pq))
                         (ap_snd_path_prod (fst pq) (snd pq)))
            _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : (fst z = fst z&#39;) * (snd z = snd z&#39;),
eta_path_prod (path_prod_uncurried z z&#39; x) =
ap (path_prod_uncurried z z&#39;)
  (path_prod&#39; (ap_fst_path_prod (fst x) (snd x))
     (ap_snd_path_prod (fst x) (snd x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk20"><span class="nb">destruct</span> z <span class="kr">as</span> [x y], z&#39; <span class="kr">as</span> [x&#39; y&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x0</span> : (fst (x, y) = fst (x&#39;, y&#39;)) *
     (snd (x, y) = snd (x&#39;, y&#39;)),
eta_path_prod (path_prod_uncurried (x, y) (x&#39;, y&#39;) x0) =
ap (path_prod_uncurried (x, y) (x&#39;, y&#39;))
  (path_prod&#39; (ap_fst_path_prod (fst x0) (snd x0))
     (ap_snd_path_prod (fst x0) (snd x0)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk21"><span class="nb">intros</span> [p q]; <span class="nb">simpl</span> <span class="kr">in</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta_path_prod
  (path_prod_uncurried (x, y) (x&#39;, y&#39;) (p, q)) =
ap (path_prod_uncurried (x, y) (x&#39;, y&#39;))
  (path_prod&#39;
     (ap_fst_path_prod (fst (p, q)) (snd (p, q)))
     (ap_snd_path_prod (fst (p, q)) (snd (p, q))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B)
  : (fst z = fst z&#39;) * (snd z = snd z&#39;)  &lt;~&gt;  (z = z&#39;)
  := Build_Equiv _ _ (path_prod_uncurried z z&#39;) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Path algebra *)</span>

<span class="sd">(** Composition.  The next three lemma are displayed equations in section 2.6 of the book, but they have no numbers so we can&#39;t put them into [HoTTBook.v]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk22"><span class="kn">Definition</span> <span class="nf">path_prod_pp</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">z</span> <span class="nv">z&#39;</span> <span class="nv">z&#39;&#39;</span> : A * B)
           (<span class="nv">p</span> : fst z = fst z&#39;) (<span class="nv">p&#39;</span> : fst z&#39; = fst z&#39;&#39;)
           (<span class="nv">q</span> : snd z = snd z&#39;) (<span class="nv">q&#39;</span> : snd z&#39; = snd z&#39;&#39;)
: path_prod z z&#39;&#39; (p @ p&#39;) (q @ q&#39;) = path_prod z z&#39; p q @ path_prod z&#39; z&#39;&#39; p&#39; q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z', z''</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fst z&#39; = fst z&#39;&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>snd z&#39; = snd z&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod z z&#39;&#39; (p @ p&#39;) (q @ q&#39;) =
path_prod z z&#39; p q @ path_prod z&#39; z&#39;&#39; p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z, z', z''</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fst z&#39; = fst z&#39;&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>snd z&#39; = snd z&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod z z&#39;&#39; (p @ p&#39;) (q @ q&#39;) =
path_prod z z&#39; p q @ path_prod z&#39; z&#39;&#39; p&#39; q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk24"><span class="nb">destruct</span> z, z&#39;, z&#39;&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p, p&#39;, q, q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod (fst, snd) (fst, snd) (<span class="mi">1</span> @ <span class="mi">1</span>) (<span class="mi">1</span> @ <span class="mi">1</span>) =
path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span> @
path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Associativity *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk25"><span class="kn">Definition</span> <span class="nf">path_prod_pp_p</span>  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">u</span> <span class="nv">v</span> <span class="nv">z</span> <span class="nv">w</span> : A * B)
           (<span class="nv">p</span> : fst u = fst v) (<span class="nv">q</span> : fst v = fst z) (<span class="nv">r</span> : fst z = fst w)
           (<span class="nv">p&#39;</span> : snd u = snd v) (<span class="nv">q&#39;</span> : snd v = snd z) (<span class="nv">r&#39;</span> : snd z = snd w)
: path_prod_pp u z w (p @ q) r (p&#39; @ q&#39;) r&#39;
  @ whiskerR (path_prod_pp u v z p q p&#39; q&#39;) (path_prod z w r r&#39;)
  @ concat_pp_p (path_prod u v p p&#39;) (path_prod v z q q&#39;) (path_prod z w r r&#39;)
  = ap011 (path_prod u w) (concat_pp_p p q r) (concat_pp_p p&#39; q&#39; r&#39;)
    @ path_prod_pp u v w p (q @ r) p&#39; (q&#39; @ r&#39;)
    @ whiskerL (path_prod u v p p&#39;) (path_prod_pp v z w q r q&#39; r&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u, v, z, w</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst u = fst v</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fst v = fst z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>fst z = fst w</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>snd u = snd v</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>snd v = snd z</span></span></span><br><span><var>r'</var><span class="hyp-type"><b>: </b><span>snd z = snd w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_prod_pp u z w (p @ q) r (p&#39; @ q&#39;) r&#39; @
 whiskerR (path_prod_pp u v z p q p&#39; q&#39;)
   (path_prod z w r r&#39;)) @
concat_pp_p (path_prod u v p p&#39;) (path_prod v z q q&#39;)
  (path_prod z w r r&#39;) =
(ap011 (path_prod u w) (concat_pp_p p q r)
   (concat_pp_p p&#39; q&#39; r&#39;) @
 path_prod_pp u v w p (q @ r) p&#39; (q&#39; @ r&#39;)) @
whiskerL (path_prod u v p p&#39;)
  (path_prod_pp v z w q r q&#39; r&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u, v, z, w</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst u = fst v</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fst v = fst z</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>fst z = fst w</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>snd u = snd v</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>snd v = snd z</span></span></span><br><span><var>r'</var><span class="hyp-type"><b>: </b><span>snd z = snd w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_prod_pp u z w (p @ q) r (p&#39; @ q&#39;) r&#39; @
 whiskerR (path_prod_pp u v z p q p&#39; q&#39;)
   (path_prod z w r r&#39;)) @
concat_pp_p (path_prod u v p p&#39;) (path_prod v z q q&#39;)
  (path_prod z w r r&#39;) =
(ap011 (path_prod u w) (concat_pp_p p q r)
   (concat_pp_p p&#39; q&#39; r&#39;) @
 path_prod_pp u v w p (q @ r) p&#39; (q&#39; @ r&#39;)) @
whiskerL (path_prod u v p p&#39;)
  (path_prod_pp v z w q r q&#39; r&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk27"><span class="nb">destruct</span> u, v, z, w; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p, p&#39;, q, q&#39;, r, r&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_prod_pp (fst, snd) (fst, snd) (fst, snd) (<span class="mi">1</span> @ <span class="mi">1</span>)
   <span class="mi">1</span> (<span class="mi">1</span> @ <span class="mi">1</span>) <span class="mi">1</span> @
 whiskerR
   (path_prod_pp (fst, snd) (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>
      <span class="mi">1</span> <span class="mi">1</span>) (path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>)) @
concat_pp_p (path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>)
  (path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>)
  (path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>) =
(ap011 (path_prod (fst, snd) (fst, snd))
   (concat_pp_p <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>) (concat_pp_p <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>) @
 path_prod_pp (fst, snd) (fst, snd) (fst, snd) <span class="mi">1</span>
   (<span class="mi">1</span> @ <span class="mi">1</span>) <span class="mi">1</span> (<span class="mi">1</span> @ <span class="mi">1</span>)) @
whiskerL (path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>)
  (path_prod_pp (fst, snd) (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
     <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Inversion *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk28"><span class="kn">Definition</span> <span class="nf">path_prod_V</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">u</span> <span class="nv">v</span>: A * B)
           (<span class="nv">p</span> : fst u = fst v)
           (<span class="nv">q</span> : snd u = snd v)
  : path_prod v u p^ q^ = (path_prod u v p q)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst u = fst v</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd u = snd v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod v u p^ q^ = (path_prod u v p q)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst u = fst v</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd u = snd v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod v u p^ q^ = (path_prod u v p q)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2a"><span class="nb">destruct</span> u, v; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod (fst, snd) (fst, snd) <span class="mi">1</span>^ <span class="mi">1</span>^ =
(path_prod (fst, snd) (fst, snd) <span class="mi">1</span> <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transport *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_prod</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">a</span> <span class="nv">a&#39;</span> : A} (<span class="nv">p</span> : a = a&#39;)
  (<span class="nv">z</span> : P a * Q a)
  : transport (<span class="kr">fun</span> <span class="nv">a</span> =&gt; P a * Q a) p z  =  (p # (fst z), p # (snd z))
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functorial action *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_prod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f</span>:A-&gt;A&#39;) (<span class="nv">g</span>:B-&gt;B&#39;)
  : A * B -&gt; A&#39; * B&#39;
  := <span class="kr">fun</span> <span class="nv">z</span> =&gt; (f (fst z), g (snd z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2b"><span class="kn">Definition</span> <span class="nf">ap_functor_prod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f</span>:A-&gt;A&#39;) (<span class="nv">g</span>:B-&gt;B&#39;)
  (<span class="nv">z</span> <span class="nv">z&#39;</span> : A * B) (<span class="nv">p</span> : fst z = fst z&#39;) (<span class="nv">q</span> : snd z = snd z&#39;)
  : ap (functor_prod f g) (path_prod _ _ p q)
  = path_prod (functor_prod f g z) (functor_prod f g z&#39;) (ap f p) (ap g q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_prod f g) (path_prod z z&#39; p q) =
path_prod (functor_prod f g z) (functor_prod f g z&#39;)
  (ap f p) (ap g q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>z, z'</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst z = fst z&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd z = snd z&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_prod f g) (path_prod z z&#39; p q) =
path_prod (functor_prod f g z) (functor_prod f g z&#39;)
  (ap f p) (ap g q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2d"><span class="nb">destruct</span> z <span class="kr">as</span> [a b]; <span class="nb">destruct</span> z&#39; <span class="kr">as</span> [a&#39; b&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst (a, b) = fst (a&#39;, b&#39;)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd (a, b) = snd (a&#39;, b&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_prod f g) (path_prod (a, b) (a&#39;, b&#39;) p q) =
path_prod (functor_prod f g (a, b))
  (functor_prod f g (a&#39;, b&#39;)) (ap f p) (ap g q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2e"><span class="nb">simpl</span> <span class="kr">in</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_prod f g) (path_prod (a, b) (a&#39;, b&#39;) p q) =
path_prod (functor_prod f g (a, b))
  (functor_prod f g (a&#39;, b&#39;)) (ap f p) (ap g q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk2f"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_prod f g) (path_prod (a, b) (a, b) <span class="mi">1</span> <span class="mi">1</span>) =
path_prod (functor_prod f g (a, b))
  (functor_prod f g (a, b)) (ap f <span class="mi">1</span>) (ap g <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalences *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk30"><span class="kn">Instance</span> <span class="nf">isequiv_functor_prod</span> `{IsEquiv A A&#39; f} `{IsEquiv B B&#39; g}
: IsEquiv (functor_prod f g) | <span class="mi">1000</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk32">snapply Build_IsEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A&#39; * B&#39; -&gt; A * B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><label class="goal-separator" for="prod-v-chk33"><hr></label><div class="goal-conclusion">functor_prod f g o <span class="nl">?equiv_inv</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><label class="goal-separator" for="prod-v-chk34"><hr></label><div class="goal-conclusion"><span class="nl">?equiv_inv</span> o functor_prod f g == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><label class="goal-separator" for="prod-v-chk35"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A * B,
<span class="nl">?eisretr</span> (functor_prod f g x) =
ap (functor_prod f g) (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A&#39; * B&#39; -&gt; A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod f g o functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk38"><span class="nb">intro</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A&#39; * B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod f g (functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> z) = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; (eisretr f _) (eisretr g _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> o functor_prod f g == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3a"><span class="nb">intro</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> (functor_prod f g w) = w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; (eissect f _) (eissect g _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A * B,
((<span class="kr">fun</span> <span class="nv">z</span> : A&#39; * B&#39; =&gt;
  path_prod&#39; (eisretr f (fst z)) (eisretr g (snd z)))
 :
 functor_prod f g o functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> == idmap)
  (functor_prod f g x) =
ap (functor_prod f g)
  (((<span class="kr">fun</span> <span class="nv">w</span> : A * B =&gt;
     path_prod&#39; (eissect f (fst w))
       (eissect g (snd w)))
    :
    functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> o functor_prod f g == idmap)
     x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3c"><span class="nb">intros</span> [a b]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod&#39; (eisretr f (f a)) (eisretr g (g b)) =
ap (functor_prod f g)
  (path_prod&#39; (eissect f a) (eissect g b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3d">lhs napply (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; path_prod&#39; p _) (eisadj f _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod&#39; (ap f (eissect f (fst (a, b))))
  (eisretr g (g b)) =
ap (functor_prod f g)
  (path_prod&#39; (eissect f a) (eissect g b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3e">rhs napply ap_functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod&#39; (ap f (eissect f (fst (a, b))))
  (eisretr g (g b)) =
path_prod
  (functor_prod f g
     (functor_prod f^-<span class="mi">1</span> g^-<span class="mi">1</span> (functor_prod f g (a, b))))
  (functor_prod f g (a, b)) (ap f (eissect f a))
  (ap g (eissect g b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (eisadj g _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk3f"><span class="kn">Definition</span> <span class="nf">equiv_functor_prod</span> `{IsEquiv A A&#39; f} `{IsEquiv B B&#39; g}
  : A * B &lt;~&gt; A&#39; * B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk41"><span class="kr">exists</span> (<span class="nv">functor_prod</span> <span class="nv">f</span> <span class="nv">g</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _. <span class="c">(* i.e., search the context for instances *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk42"><span class="kn">Definition</span> <span class="nf">equiv_functor_prod&#39;</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; A&#39;) (<span class="nv">g</span> : B &lt;~&gt; B&#39;)
  : A * B &lt;~&gt; A&#39; * B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk44"><span class="kr">exists</span> (<span class="nv">functor_prod</span> <span class="nv">f</span> <span class="nv">g</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;f *E g&quot;</span> := (equiv_functor_prod&#39; f g) : equiv_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_prod_l</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B &lt;~&gt; B&#39;)
  : A * B &lt;~&gt; A * B&#39;
  := <span class="mi">1</span> *E g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_prod_r</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; A&#39;)
  : A * B &lt;~&gt; A&#39; * B
  := f *E <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Logical equivalences *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iff_functor_prod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;-&gt; A&#39;) (<span class="nv">g</span> : B &lt;-&gt; B&#39;)
  : A * B &lt;-&gt; A&#39; * B&#39;
  := (functor_prod (fst f) (fst g) , functor_prod (snd f) (snd g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetry *)</span>

<span class="sd">(** This is a special property of [prod], of course, not an instance of a general family of facts about types. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk45"><span class="kn">Definition</span> <span class="nf">equiv_prod_symm</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : A * B &lt;~&gt; B * A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; B * A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B &lt;~&gt; B * A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Associativity *)</span>

<span class="sd">(** This, too, is a special property of [prod], of course, not an instance of a general family of facts about types. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk47"><span class="kn">Definition</span> <span class="nf">equiv_prod_assoc</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) : A * (B * C) &lt;~&gt; (A * B) * C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * (B * C) &lt;~&gt; A * B * C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * (B * C) &lt;~&gt; A * B * C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Unit and annihilation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_empty_r</span>@{u} (X : <span class="kt">Type</span>@{u}) : X * Empty &lt;~&gt; Empty
  := (Build_Equiv@{u u} _ _ snd _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_empty_l</span>@{u} (X : <span class="kt">Type</span>@{u}) : Empty * X &lt;~&gt; Empty
  := (Build_Equiv@{u u} _ _ fst _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk49"><span class="kn">Definition</span> <span class="nf">prod_unit_r</span> <span class="nv">X</span> : X * Unit &lt;~&gt; X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Unit &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Unit &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk4b"><span class="nb">refine</span> (Build_Equiv _ _ fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv fst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk4c"><span class="nb">simple refine</span> (Build_IsEquiv _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x,tt)) _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (x, tt)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="prod-v-chk4d"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (x, tt)) o fst == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="prod-v-chk4e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X * Unit,
<span class="nl">?eisretr</span> (fst x) = ap fst (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (x, tt)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (x, tt)) o fst == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [x []]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X * Unit,
((<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; <span class="mi">1</span>)
 :
 fst o (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; (x0, tt)) == idmap) (fst x) =
ap fst
  (((<span class="kr">fun</span> <span class="nv">x0</span> : X * Unit =&gt;
     (<span class="kr">fun</span> (<span class="nv">x1</span> : X) (<span class="nv">snd</span> : Unit) =&gt;
      <span class="kr">match</span>
        snd <span class="kr">as</span> u <span class="kr">return</span> ((fst (x1, u), tt) = (x1, u))
      <span class="kr">with</span>
      | tt =&gt; <span class="mi">1</span>
      <span class="kr">end</span>) (fst x0) (snd x0))
    :
    (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; (x0, tt)) o fst == idmap) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [x []]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk52"><span class="kn">Definition</span> <span class="nf">prod_unit_l</span> <span class="nv">X</span> : Unit * X &lt;~&gt; X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit * X &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit * X &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk54"><span class="nb">refine</span> (Build_Equiv _ _ snd _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk55"><span class="nb">simple refine</span> (Build_IsEquiv _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (tt,x)) _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (tt, x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="prod-v-chk56"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (tt, x)) o snd == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="prod-v-chk57"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Unit * X,
<span class="nl">?eisretr</span> (snd x) = ap snd (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (tt, x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (tt, x)) o snd == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [[] x]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Unit * X,
((<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; <span class="mi">1</span>)
 :
 snd o (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; (tt, x0)) == idmap) (snd x) =
ap snd
  (((<span class="kr">fun</span> <span class="nv">x0</span> : Unit * X =&gt;
     (<span class="kr">fun</span> <span class="nv">fst</span> : Unit =&gt;
      <span class="kr">match</span>
        fst <span class="kr">as</span> u
        <span class="kr">return</span>
          (<span class="kr">forall</span> <span class="nv">snd0</span> : X,
           (tt, snd (u, snd0)) = (u, snd0))
      <span class="kr">with</span>
      | tt =&gt; <span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; <span class="mi">1</span>
      <span class="kr">end</span>) (fst x0) (snd x0))
    :
    (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; (tt, x0)) o snd == idmap) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [[] x]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Universal mapping properties *)</span>

<span class="sd">(** Ordinary universal mapping properties are expressed as equivalences of sets or spaces of functions.  In type theory, we can go beyond this and express an equivalence of types of *dependent* functions.  Moreover, because the product type can expressed both positively and negatively, it has both a left universal property and a right one. *)</span>

<span class="c">(* First the positive universal property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_prod_ind</span> `(P : A * B -&gt; <span class="kt">Type</span>)
: IsEquiv (prod_ind P) | <span class="mi">0</span>
  := Build_IsEquiv
       _ _
       (prod_ind P)
       (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; f (x, y))
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_prod_ind</span> `(P : A * B -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (a, b)) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">p</span> : A * B, P p)
  := Build_Equiv _ _ (prod_ind P) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* The non-dependent version, which is a special case, is the currying equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_uncurry</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  : (A -&gt; B -&gt; C) &lt;~&gt; (A * B -&gt; C)
  := equiv_prod_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Now the negative universal property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_coind_uncurried</span> `{A : X -&gt; <span class="kt">Type</span>} `{B : X -&gt; <span class="kt">Type</span>}
  : (<span class="kr">forall</span> <span class="nv">x</span>, A x) * (<span class="kr">forall</span> <span class="nv">x</span>, B x) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, A x * B x)
  := <span class="kr">fun</span> <span class="nv">fg</span> <span class="nv">x</span> =&gt; (fst fg x, snd fg x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_coind</span> `(f : <span class="kr">forall</span> <span class="nv">x</span>:X, A x) `(g : <span class="kr">forall</span> <span class="nv">x</span>:X, B x)
  : <span class="kr">forall</span> <span class="nv">x</span>, A x * B x
  := prod_coind_uncurried (f, g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_prod_coind</span> `(A : X -&gt; <span class="kt">Type</span>) (B : X -&gt; <span class="kt">Type</span>)
: IsEquiv (@prod_coind_uncurried X A B) | <span class="mi">0</span>
  := Build_IsEquiv
       _ _
       (@prod_coind_uncurried X A B)
       (<span class="kr">fun</span> <span class="nv">h</span> =&gt; (<span class="kr">fun</span> <span class="nv">x</span> =&gt; fst (h x), <span class="kr">fun</span> <span class="nv">x</span> =&gt; snd (h x)))
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_prod_coind</span> `(A : X -&gt; <span class="kt">Type</span>) (B : X -&gt; <span class="kt">Type</span>)
  : ((<span class="kr">forall</span> <span class="nv">x</span>, A x) * (<span class="kr">forall</span> <span class="nv">x</span>, B x)) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span>, A x * B x)
  := Build_Equiv _ _ (@prod_coind_uncurried X A B) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Products preserve truncation *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5b"><span class="kn">Instance</span> <span class="nf">istrunc_prod</span> `{IsTrunc n A} `{IsTrunc n B} : IsTrunc n (A * B) | <span class="mi">100</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5d"><span class="nb">generalize dependent</span> B; <span class="nb">generalize dependent</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsTrunc n B -&gt; IsTrunc n (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk5e">simple_induction n n IH; <span class="nb">simpl</span>; (<span class="nb">intros</span> A ? B ?).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A * B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsTrunc n B -&gt; IsTrunc n (A * B)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><label class="goal-separator" for="prod-v-chk5f"><hr></label><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A * B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk60">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk61"><span class="nb">apply</span> (Build_Contr _ (center A, center B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A * B, (center A, center B) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> z; <span class="nb">apply</span> path_prod; <span class="nb">apply</span> contr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk62">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsTrunc n B -&gt; IsTrunc n (A * B)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk63"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsTrunc n B -&gt; IsTrunc n (A * B)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A * B, IsTrunc n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk64"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsTrunc n B -&gt; IsTrunc n (A * B)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (equiv_path_prod x y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">contr_prod</span> `{CA : Contr A} `{CB : Contr B} : Contr (A * B) | <span class="mi">100</span>
  := istrunc_prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decidability *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk65"><span class="kn">Instance</span> <span class="nf">decidable_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
       `{Decidable A} `{Decidable B}
: Decidable@{k} (A * B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk67"><span class="nb">destruct</span> (dec A) <span class="kr">as</span> [x1|y1]; <span class="nb">destruct</span> (dec B) <span class="kr">as</span> [x2|y2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>~ B</span></span></span><br></div><label class="goal-separator" for="prod-v-chk68"><hr></label><div class="goal-conclusion">Decidable (A * B)</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="prod-v-chk69"><hr></label><div class="goal-conclusion">Decidable (A * B)</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>~ B</span></span></span><br></div><label class="goal-separator" for="prod-v-chk6a"><hr></label><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl@{k k} (x1,x2)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>~ B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inr@{k k}; <span class="nb">intros</span> [_ x2]; <span class="bp">exact</span> (y2 x2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inr@{k k}; <span class="nb">intros</span> [x1 _]; <span class="bp">exact</span> (y1 x1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>~ B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inr@{k k}; <span class="nb">intros</span> [x1 _]; <span class="bp">exact</span> (y1 x1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Interaction of [ap] and uncurry *)</span>

<span class="sd">(** The function in [ap011] can be uncurried *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk6f"><span class="kn">Definition</span> <span class="nf">ap_uncurry</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) {<span class="nv">a</span> <span class="nv">a&#39;</span> : A} (<span class="nv">p</span> : a = a&#39;)
  {<span class="nv">b</span> <span class="nv">b&#39;</span> : B} (<span class="nv">q</span> : b = b&#39;)
  : ap (uncurry f) (path_prod&#39; p q) = ap011 f p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (uncurry f) (path_prod&#39; p q) = ap011 f p q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (uncurry f) (path_prod&#39; p q) = ap011 f p q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> q, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Fibers *)</span>

<span class="sd">(** ** Fibers of [functor_prod] *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk71"><span class="kn">Definition</span> <span class="nf">hfiber_functor_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) <span class="nv">y</span>
  : hfiber (functor_prod f g) y &lt;~&gt; (hfiber f (fst y) * hfiber g (snd y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_prod f g) y &lt;~&gt;
hfiber f (fst y) * hfiber g (snd y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_prod f g) y &lt;~&gt;
hfiber f (fst y) * hfiber g (snd y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk73"><span class="nb">unfold</span> functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y &lt;~&gt;
hfiber f (fst y) * hfiber g (snd y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk74">snrefine (equiv_adjointify _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y -&gt;
hfiber f (fst y) * hfiber g (snd y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><label class="goal-separator" for="prod-v-chk75"><hr></label><div class="goal-conclusion">hfiber f (fst y) * hfiber g (snd y) -&gt;
hfiber (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><label class="goal-separator" for="prod-v-chk76"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="prod-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><label class="goal-separator" for="prod-v-chk77"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk78">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y -&gt;
hfiber f (fst y) * hfiber g (snd y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ((fst x.<span class="mi">1</span>; ap fst x.<span class="mi">2</span>), (snd x.<span class="mi">1</span>; ap snd x.<span class="mi">2</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f (fst y) * hfiber g (snd y) -&gt;
hfiber (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7a"><span class="nb">refine</span> (<span class="kr">fun</span> <span class="nv">xs</span> =&gt; (((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>); _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>hfiber f (fst y) * hfiber g (snd y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7b"><span class="nb">apply</span> Prod.path_prod;<span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>hfiber f (fst y) * hfiber g (snd y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst xs).<span class="mi">1</span> = fst y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prod-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>hfiber f (fst y) * hfiber g (snd y)</span></span></span><br></div><label class="goal-separator" for="prod-v-chk7c"><hr></label><div class="goal-conclusion">g (snd xs).<span class="mi">1</span> = snd y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>hfiber f (fst y) * hfiber g (snd y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst xs).<span class="mi">1</span> = fst y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fst xs).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>hfiber f (fst y) * hfiber g (snd y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (snd xs).<span class="mi">1</span> = snd y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd xs).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span> : hfiber
         (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y
 =&gt; ((fst x.<span class="mi">1</span>; ap fst x.<span class="mi">2</span>), (snd x.<span class="mi">1</span>; ap snd x.<span class="mi">2</span>)))
o (<span class="kr">fun</span> <span class="nv">xs</span> : hfiber f (fst y) * hfiber g (snd y) =&gt;
   (((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>);
   path_prod
     (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
     g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) y
     ((fst xs).<span class="mi">2</span>
      :
      fst
        (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
        g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) = fst y)
     ((snd xs).<span class="mi">2</span>
      :
      snd
        (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
        g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) = snd y))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk80"><span class="nb">destruct</span> y <span class="kr">as</span> [y1 y2]; <span class="nb">intros</span> [[x1 p1] [x2 p2]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f x1 = fst (y1, y2)</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>g x2 = snd (y1, y2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fst
    (((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
     (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>);
    path_prod
      (f
         (fst
            ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
            (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>)),
      g
        (snd
           ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
           (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>))) (y1, y2)
      (fst ((x1; p1), (x2; p2))).<span class="mi">2</span>
      (snd ((x1; p1), (x2; p2))).<span class="mi">2</span>).<span class="mi">1</span>;
 ap fst
   (((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
    (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>);
   path_prod
     (f
        (fst
           ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
           (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>)),
     g
       (snd
          ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
          (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>))) (y1, y2)
     (fst ((x1; p1), (x2; p2))).<span class="mi">2</span>
     (snd ((x1; p1), (x2; p2))).<span class="mi">2</span>).<span class="mi">2</span>),
(snd
   (((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
    (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>);
   path_prod
     (f
        (fst
           ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
           (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>)),
     g
       (snd
          ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
          (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>))) (y1, y2)
     (fst ((x1; p1), (x2; p2))).<span class="mi">2</span>
     (snd ((x1; p1), (x2; p2))).<span class="mi">2</span>).<span class="mi">1</span>;
ap snd
  (((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
   (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>);
  path_prod
    (f
       (fst
          ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
          (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>)),
    g
      (snd
         ((fst ((x1; p1), (x2; p2))).<span class="mi">1</span>,
         (snd ((x1; p1), (x2; p2))).<span class="mi">1</span>))) (y1, y2)
    (fst ((x1; p1), (x2; p2))).<span class="mi">2</span>
    (snd ((x1; p1), (x2; p2))).<span class="mi">2</span>).<span class="mi">2</span>)) =
((x1; p1), (x2; p2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk81"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f x1 = y1</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>g x2 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((x1; ap fst (path_prod (f x1, g x2) (y1, y2) p1 p2)),
(x2; ap snd (path_prod (f x1, g x2) (y1, y2) p1 p2))) =
((x1; p1), (x2; p2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk82"><span class="nb">destruct</span> p1,p2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((x1;
 ap fst (path_prod (f x1, g x2) (f x1, g x2) <span class="mi">1</span> <span class="mi">1</span>)),
(x2; ap snd (path_prod (f x1, g x2) (f x1, g x2) <span class="mi">1</span> <span class="mi">1</span>))) =
((x1; <span class="mi">1</span>), (x2; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">xs</span> : hfiber f (fst y) * hfiber g (snd y) =&gt;
 (((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>);
 path_prod
   (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
   g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) y
   ((fst xs).<span class="mi">2</span>
    :
    fst
      (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
      g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) = fst y)
   ((snd xs).<span class="mi">2</span>
    :
    snd
      (f (fst ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>)),
      g (snd ((fst xs).<span class="mi">1</span>, (snd xs).<span class="mi">1</span>))) = snd y)))
o (<span class="kr">fun</span>
     <span class="nv">x</span> : hfiber
           (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z))) y
   =&gt; ((fst x.<span class="mi">1</span>; ap fst x.<span class="mi">2</span>), (snd x.<span class="mi">1</span>; ap snd x.<span class="mi">2</span>))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk84"><span class="nb">intros</span> [[x1 x2] p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B * D</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f (fst (x1, x2)), g (snd (x1, x2))) = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((fst
     ((fst ((x1, x2); p).<span class="mi">1</span>; ap fst ((x1, x2); p).<span class="mi">2</span>),
     (snd ((x1, x2); p).<span class="mi">1</span>; ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>,
 (snd
    ((fst ((x1, x2); p).<span class="mi">1</span>; ap fst ((x1, x2); p).<span class="mi">2</span>),
    (snd ((x1, x2); p).<span class="mi">1</span>; ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>);
path_prod
  (f
     (fst
        ((fst
            ((fst ((x1, x2); p).<span class="mi">1</span>;
             ap fst ((x1, x2); p).<span class="mi">2</span>),
            (snd ((x1, x2); p).<span class="mi">1</span>;
            ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>,
        (snd
           ((fst ((x1, x2); p).<span class="mi">1</span>;
            ap fst ((x1, x2); p).<span class="mi">2</span>),
           (snd ((x1, x2); p).<span class="mi">1</span>;
           ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>)),
  g
    (snd
       ((fst
           ((fst ((x1, x2); p).<span class="mi">1</span>;
            ap fst ((x1, x2); p).<span class="mi">2</span>),
           (snd ((x1, x2); p).<span class="mi">1</span>;
           ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>,
       (snd
          ((fst ((x1, x2); p).<span class="mi">1</span>;
           ap fst ((x1, x2); p).<span class="mi">2</span>),
          (snd ((x1, x2); p).<span class="mi">1</span>;
          ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">1</span>))) y
  (fst
     ((fst ((x1, x2); p).<span class="mi">1</span>; ap fst ((x1, x2); p).<span class="mi">2</span>),
     (snd ((x1, x2); p).<span class="mi">1</span>; ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">2</span>
  (snd
     ((fst ((x1, x2); p).<span class="mi">1</span>; ap fst ((x1, x2); p).<span class="mi">2</span>),
     (snd ((x1, x2); p).<span class="mi">1</span>; ap snd ((x1, x2); p).<span class="mi">2</span>))).<span class="mi">2</span>) =
((x1, x2); p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prod-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="prod-v-chk85"><span class="nb">destruct</span> p;<span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((x1, x2); <span class="mi">1</span>) = ((x1, x2); <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">istruncmap_functor_prod</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) `{!IsTruncMap n f} `{!IsTruncMap n g}
  : IsTruncMap n (Prod.functor_prod f g)
  := <span class="kr">fun</span> <span class="nv">y</span> =&gt; istrunc_equiv_istrunc _ (hfiber_functor_prod _ _ _)^-<span class="mi">1</span>.</span></span></pre>
</div>
</div></body>
</html>
