<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>IdentitySystems.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Sigma Types.Equiv Types.Paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HoTT.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Characterization of identity types by identity systems *)</span>

<span class="sd">(** See Homotopy/EncodeDecode.v for a related characterization of identity types. *)</span>

<span class="sd">(** To avoid dependencies coming from Pointed.Core, we will write out some of the definitions found there. Let [A : Type], together with a distinguished base point [a0 : A]. A pointed type family is a type family [R : A -&gt; Type], together with a distinguished point [r0 : R a0]. A pointed type family [(R; r0)] is called an identity system if it satisfies the J-rule. Given a pointed type family [(R; r0)], the fundamental theorem of identity systems (Theorem 5.8.2 from the HoTT Book) tells us that the following are equivalent: (i) an identity system structure on [(R; r0)], (ii) homotopy contractibility of the space of pointed type family maps from [(R; r0)] to any pointed type family [(S; s0)], (iii) transport along [R] being an equivalence, and (iv) the total space of [R] being contractible. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsIdentitySystem</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A} (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0) := {
    idsys_ind (D : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>) (d : D a0 r0) (a : A) (r : R a)
      : D a r;
    idsys_ind_beta (D : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>) (d : D a0 r0)
      : idsys_ind D d a0 r0 = d
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The mapping space between two pointed type families over the same pointed type is a family of maps that preserves the distinguished points. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfamMap</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A} (<span class="nv">R</span> <span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0) (<span class="nv">s0</span> : S a0)
  := {f : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; S a &amp; f a0 r0 = s0}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A pointed homotopy between maps of pointed type families is a family of homotopies that is pointed in the fiber over [a0]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfammap_homotopy</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A} {<span class="nv">R</span> <span class="nv">S</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">r0</span> : R a0} {<span class="nv">s0</span> : S a0}
  (<span class="nv">f</span> <span class="nv">g</span> : pfamMap R S r0 s0)
  := { p : <span class="kr">forall</span> <span class="nv">a</span> : A, pr1 f a == pr1 g a &amp; p a0 r0 = pr2 f @ (pr2 g)^}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1"><span class="kn">Instance</span> <span class="nf">reflexive_pfammap_homotopy</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  {<span class="nv">R</span> <span class="nv">S</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">r0</span> : R a0} {<span class="nv">s0</span> : S a0}
  : Reflexive (pfammap_homotopy (r0:=r0) (s0:=s0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive pfammap_homotopy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive pfammap_homotopy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfammap_homotopy g g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4">snrefine (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, g.<span class="mi">1</span> a == g.<span class="mi">1</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk5"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, g.<span class="mi">1</span> a == g.<span class="mi">1</span> a =&gt;
 p a0 r0 = g.<span class="mi">2</span> @ (g.<span class="mi">2</span>)^) <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, g.<span class="mi">1</span> a == g.<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, g.<span class="mi">1</span> a == g.<span class="mi">1</span> a =&gt;
 p a0 r0 = g.<span class="mi">2</span> @ (g.<span class="mi">2</span>)^) (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">x</span> : R a) =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk8"><span class="nb">cbn</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R, S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g.<span class="mi">2</span> @ (g.<span class="mi">2</span>)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_pV _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We weaken part (ii) of Theorem 5.8.2. Instead of requiring that the mapping space is contractible, we will only require it to be homotopy contractible, i.e. it is inhabited and there is a homotopy between every map and the chosen map. This allows us to avoid function extensionality. Given that a pointed type family [(R; r0)] is an identity system, then the mapping space of pointed type families from [(R; r0)] to any [(S; s0)] is homotopy contractible. This is a weak form of Theorem 5.8.2, (i) implies (ii). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk9"><span class="kn">Definition</span> <span class="nf">homocontr_pfammap_identitysystem</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0) `{!IsIdentitySystem R r0}
  (S : A -&gt; <span class="kt">Type</span>) (s0 : S a0)
  : <span class="kr">exists</span> <span class="nv">f</span> : pfamMap R S r0 s0, <span class="kr">forall</span> <span class="nv">g</span>, pfammap_homotopy f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chkb"><span class="nb">pose</span> (to_S := idsys_ind (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">_</span> =&gt; S a) s0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>to_S</var><span><span class="hyp-body"><b>:= </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a) s0</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">_</span> : R a0) =&gt; S a0) a r</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chkc"><span class="nb">pose proof</span> (to_S_beta := idsys_ind_beta (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">_</span> =&gt; S a) s0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>to_S</var><span><span class="hyp-body"><b>:= </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a) s0</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">_</span> : R a0) =&gt; S a0) a r</span></span></span></span><br><span><var>to_S_beta</var><span class="hyp-type"><b>: </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a)
  s0 a0 r0 = s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chkd">snrefine ((to_S; to_S_beta); _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>to_S</var><span><span class="hyp-body"><b>:= </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a) s0</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">_</span> : R a0) =&gt; S a0) a r</span></span></span></span><br><span><var>to_S_beta</var><span class="hyp-type"><b>: </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a)
  s0 a0 r0 = s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : pfamMap R S r0 s0 =&gt;
 <span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g)
  (to_S; to_S_beta)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chke"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>to_S</var><span><span class="hyp-body"><b>:= </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a) s0</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">_</span> : R a0) =&gt; S a0) a r</span></span></span></span><br><span><var>to_S_beta</var><span class="hyp-type"><b>: </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a)
  s0 a0 r0 = s0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfammap_homotopy (to_S; to_S_beta) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chkf"><span class="kr">exists</span> (<span class="nv">idsys_ind</span> (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">r</span> =&gt; to_S a r = pr1 g a r) (to_S_beta @ (pr2 g)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>to_S</var><span><span class="hyp-body"><b>:= </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a) s0</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">_</span> : R a0) =&gt; S a0) a r</span></span></span></span><br><span><var>to_S_beta</var><span class="hyp-type"><b>: </b><span>idsys_ind (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">_</span> : R a) =&gt; S a)
  s0 a0 r0 = s0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">idsys_ind
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a) =&gt; to_S a r = g.<span class="mi">1</span> a r)
  (to_S_beta @ (g.<span class="mi">2</span>)^) a0 r0 =
(to_S; to_S_beta).<span class="mi">2</span> @ (g.<span class="mi">2</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply idsys_ind_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a pointed type family [(R; r0)] has homotopy contractible mapping spaces in the sense above, then [fun p =&gt; transport R p r0] is a fiberwise equivalence. This is a strong form of Theorem 5.8.2, (ii) implies (iii). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk10"><span class="kn">Definition</span> <span class="nf">equiv_path_homocontr_pfammap</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">S</span> : A -&gt; <span class="kt">Type</span>, <span class="kr">forall</span> <span class="nv">s0</span> : S a0,
    <span class="kr">exists</span> <span class="nv">f</span> : pfamMap R S r0 s0, <span class="kr">forall</span> <span class="nv">g</span>, pfammap_homotopy f g)
  (<span class="nv">a</span> : A)
  : IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk12"><span class="nb">pose</span> (inv := (H (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>.<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk13"><span class="nb">pose proof</span> (inv_beta := (H (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>.<span class="mi">2</span>); <span class="nb">cbn</span> <span class="kr">in</span> inv_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk14">snapply (isequiv_adjointify _ (inv a)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk15"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : a0 = a =&gt; inv a (transport R x r0)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk17"><span class="nb">destruct</span> (H R r0) <span class="kr">as</span> [[f fp] h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>f a0 r0 = r0</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0,
pfammap_homotopy (f; fp) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk18"><span class="nb">pose proof</span> (h&#39; := <span class="kr">fun</span> <span class="nv">g</span> =&gt; (h g).<span class="mi">1</span> a); <span class="nb">cbn</span> <span class="kr">in</span> h&#39;; <span class="nb">clear</span> h fp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Both sides are the underlying maps of [pfammap]s, so [h&#39;] says that both are homotopic to [f a]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk19"><span class="nb">transitivity</span> (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == f a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk1a"><hr></label><div class="goal-conclusion">f a == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0) == f a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1c"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a == (<span class="kr">fun</span> <span class="nv">x</span> : R a =&gt; transport R (inv a x) r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1d">nrefine (h&#39; (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; transport R (inv _ _) r0; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport R (inv a0 r0) r0 = r0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; transport R x r0) inv_beta).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; R a</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : pfamMap R R r0 r0, f a == g.<span class="mi">1</span> a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (h&#39; (_; idpath)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>inv</var><span><span class="hyp-body"><b>:= </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; a0 = a1) a</span></span></span></span><br><span><var>inv_beta</var><span class="hyp-type"><b>: </b><span>((H (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a0 = a) <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span> a0 r0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : a0 = a =&gt; inv a (transport R x r0)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given that some type family [R] is fiberwise equivalent to identity types based at [a0], then the total space [sig R] is contractible. This is a stronger form of Theorem 5.8.2, (iii) implies (iv). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk20"><span class="kn">Definition</span> <span class="nf">contr_sigma_equiv_path</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, (a0 = a) &lt;~&gt; R a)
  : Contr (sig R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a &lt;~&gt; R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {x : _ &amp; R x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a &lt;~&gt; R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {x : _ &amp; R x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk22">rapply contr_equiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a &lt;~&gt; R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; {x : _ &amp; R x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a &lt;~&gt; R a</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk23"><hr></label><div class="goal-conclusion">Contr <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk24"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_functor_sigma_id f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a &lt;~&gt; R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {x : _ &amp; a0 = x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any pointed type family [(R; r0)] with contractible total space is an identity system. This is Theorem 5.8.2, (iv) implies (i). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk25"><span class="kn">Definition</span> <span class="nf">identitysystem_contr_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A} (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">r0</span> : R a0) {<span class="nv">C</span> : Contr (sig R)}
  : IsIdentitySystem R r0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIdentitySystem R r0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIdentitySystem R r0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk27">snapply Build_IsIdentitySystem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>,
D a0 r0 -&gt; <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a), D a r</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk28"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>) (<span class="nv">d</span> : D a0 r0),
<span class="nl">?idsys_ind</span> D d a0 r0 = d</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>,
D a0 r0 -&gt; <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a), D a r</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2a"><span class="nb">intros</span> D d0 a r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>D a0 r0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D a r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport (<span class="kr">fun</span> <span class="nv">ar</span> : sig R =&gt; D (pr1 ar) (pr2 ar))
             (path_contr (a0; r0) (a; r)) d0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>) (<span class="nv">d</span> : D a0 r0),
(<span class="kr">fun</span> (<span class="nv">D0</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span>) (<span class="nv">d0</span> : D0 a0 r0)
   (<span class="nv">a</span> : A) (<span class="nv">r</span> : R a) =&gt;
 transport (<span class="kr">fun</span> <span class="nv">ar</span> : {x : _ &amp; R x} =&gt; D0 ar.<span class="mi">1</span> ar.<span class="mi">2</span>)
   (path_contr (a0; r0) (a; r)) d0) D d a0 r0 = d</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2c"><span class="nb">intros</span> D d0; <span class="nb">cbn</span>; <span class="nb">unfold</span> path_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr {x : _ &amp; R x}</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>D a0 r0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">ar</span> : {x : _ &amp; R x} =&gt; D ar.<span class="mi">1</span> ar.<span class="mi">2</span>)
  ((contr (a0; r0))^ @ contr (a0; r0)) d0 = d0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (transport2 _ (concat_Vp _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Assuming function extensionality, pointed homotopy contractible fiberwise mapping spaces of pointed type families are contractible. We thus obtain the proper statement of Theorem 5.8.2. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2d"><span class="kn">Definition</span> <span class="nf">contr_pfammap_homocontr</span> `{Funext} {A : <span class="kt">Type</span>} {a0 : A}
  (R : A -&gt; <span class="kt">Type</span>) (r0 : R a0)
  (S : A -&gt; <span class="kt">Type</span>) (s0 : S a0)
  (fH : <span class="kr">exists</span> <span class="nv">f</span> : pfamMap R S r0 s0, <span class="kr">forall</span> <span class="nv">g</span>, pfammap_homotopy f g)
  : Contr (pfamMap R S r0 s0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (pfamMap R S r0 s0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (pfamMap R S r0 s0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk2f">snapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfamMap R S r0 s0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk30"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : pfamMap R S r0 s0, <span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfamMap R S r0 s0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> fH.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : pfamMap R S r0 s0, fH.<span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk33"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fH.<span class="mi">1</span> = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk34">snapply path_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">1</span> = g.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk35"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; S a =&gt; f a0 r0 = s0)
  <span class="nl">?Goal</span> (fH.<span class="mi">1</span>).<span class="mi">2</span> = g.<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk36">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">1</span> = g.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk37">funext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">1</span> a = g.<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk38">napply path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">1</span> a == g.<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fH.<span class="mi">2</span> g).<span class="mi">1</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk39">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, R a -&gt; S a =&gt; f a0 r0 = s0)
  (path_forall (fH.<span class="mi">1</span>).<span class="mi">1</span> g.<span class="mi">1</span>
     ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       path_forall ((fH.<span class="mi">1</span>).<span class="mi">1</span> a) (g.<span class="mi">1</span> a) ((fH.<span class="mi">2</span> g).<span class="mi">1</span> a))
      :
      (fH.<span class="mi">1</span>).<span class="mi">1</span> == g.<span class="mi">1</span>)) (fH.<span class="mi">1</span>).<span class="mi">2</span> = g.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3a">transport_path_forall_hammer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : S a0 =&gt; y = s0) ((fH.<span class="mi">2</span> g).<span class="mi">1</span> a0 r0)
  (fH.<span class="mi">1</span>).<span class="mi">2</span> = g.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3b">lhs napply transport_paths_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fH.<span class="mi">2</span> g).<span class="mi">1</span> a0 r0)^ @ (fH.<span class="mi">1</span>).<span class="mi">2</span> = g.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3c">napply moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">2</span> = (fH.<span class="mi">2</span> g).<span class="mi">1</span> a0 r0 @ g.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3d">napply moveL_pM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">1</span>).<span class="mi">2</span> @ (g.<span class="mi">2</span>)^ = (fH.<span class="mi">2</span> g).<span class="mi">1</span> a0 r0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>fH</var><span class="hyp-type"><b>: </b><span>{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0,
pfammap_homotopy f g}</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fH.<span class="mi">2</span> g).<span class="mi">1</span> a0 r0 = (fH.<span class="mi">1</span>).<span class="mi">2</span> @ (g.<span class="mi">2</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fH.<span class="mi">2</span> g).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The fiberwise mapping spaces of pointed type families are pointed homotopy contractible if they are contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk3f"><span class="kn">Definition</span> <span class="nf">homocontr_pfammap_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0)
  (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">s0</span> : S a0)
  (<span class="nv">cp</span> : Contr (pfamMap R S r0 s0))
  : <span class="kr">exists</span> <span class="nv">f</span> : pfamMap R S r0 s0, <span class="kr">forall</span> <span class="nv">g</span>, pfammap_homotopy f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk41">snrefine (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfamMap R S r0 s0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk42"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : pfamMap R S r0 s0 =&gt;
 <span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g)
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfamMap R S r0 s0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@center _ cp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk44">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : pfamMap R S r0 s0 =&gt;
 <span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g)
  (center (pfamMap R S r0 s0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk45"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>S a0</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr (pfamMap R S r0 s0)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>pfamMap R S r0 s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfammap_homotopy (center (pfamMap R S r0 s0)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (@contr _ cp g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The fundamental theorem of identity systems is now proven. It is useful to write down some of the composite implications. Given an identity system [(R; r0)], transporting the point [r0] induces a fiberwise equivalence between the based path type [a0 = x] and [R x]. This is Theorem 5.8.2 (i) implies (iii). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk46"><span class="kn">Instance</span> <span class="nf">isequiv_transport_identitysystem</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0) `{!IsIdentitySystem _ r0} (a : A)
  : IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : a0 = a =&gt; transport R p r0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk48">napply equiv_path_homocontr_pfammap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>R a0</span></span></span><br><span><var>IsIdentitySystem0</var><span class="hyp-type"><b>: </b><span>IsIdentitySystem R r0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">S</span> : A -&gt; <span class="kt">Type</span>) 
(<span class="nv">s0</span> : S a0),
{f : pfamMap R S r0 s0 &amp;
<span class="kr">forall</span> <span class="nv">g</span> : pfamMap R S r0 s0, pfammap_homotopy f g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> napply homocontr_pfammap_identitysystem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_transport_identitysystem</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> : A}
  (<span class="nv">R</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">r0</span> : R a0) `{!IsIdentitySystem _ r0} (a : A)
  : (a0 = a) &lt;~&gt; R a
  := Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">p</span> =&gt; transport R p r0) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A more general version of Theorem 5.8.2 (iii) implies (i) is proven in Basics/Equivalences.v as [equiv_path_ind]. The original statement is recovered if [e] is assumed to be [fun p =&gt; transport R p r0]. *)</span>

<span class="sd">(** Theorem 5.8.2, (iv) implies (iii), can be proven with a nice method due to Rijke. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk49"><span class="kn">Definition</span> <span class="nf">equiv_path_from_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">Prefl</span> : P a)
  (<span class="nv">cp</span> : Contr {y:A &amp; P y} )
  (<span class="nv">b</span> : A)
  : P b &lt;~&gt; a = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P b &lt;~&gt; a = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P b &lt;~&gt; a = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4b"><span class="nb">apply</span> equiv_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = b &lt;~&gt; P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4c">srefine (Build_Equiv _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = b -&gt; P b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="identitysystems-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="identitysystems-v-chk4d"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = b -&gt; P b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">exact</span> Prefl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk4f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">X</span> : a = b =&gt;
   <span class="kr">match</span> X <span class="kr">in</span> (_ = a0) <span class="kr">return</span> (P a0) <span class="kr">with</span>
   | <span class="mi">1</span> =&gt; Prefl
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk50"><span class="nb">revert</span> b; <span class="nb">apply</span> isequiv_from_functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span>Contr {y : A &amp; P y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (functor_sigma idmap
     (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">X</span> : a = a0) =&gt;
      <span class="kr">match</span> X <span class="kr">in</span> (_ = a1) <span class="kr">return</span> (P a1) <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; Prefl
      <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isequiv_contr_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is another result for characterizing the path types of [A] when given an equivalence [e : B &lt;~&gt; A], such as an [issig] lemma for [A]. It can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk51"><span class="kn">Definition</span> <span class="nf">equiv_path_along_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; A -&gt; <span class="kt">Type</span>}
  (<span class="nv">e</span> : B &lt;~&gt; A)
  (<span class="nv">K</span> : <span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1)
  : <span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk53">equiv_intros e b0 b1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (e b0) (e b1) &lt;~&gt; e b0 = e b1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk54">nrefine (_ oE K b0 b1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b0 = b1 &lt;~&gt; e b0 = e b1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_ap&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This simply combines the two previous results, a common idiom. Again, it can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk55"><span class="kn">Definition</span> <span class="nf">equiv_path_issig_contr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; A -&gt; <span class="kt">Type</span>}
  (<span class="nv">e</span> : B &lt;~&gt; A)
  (<span class="nv">Prefl</span> : <span class="kr">forall</span> <span class="nv">b</span>, P (e b) (e b))
  (<span class="nv">cp</span> : <span class="kr">forall</span> <span class="nv">b1</span>, Contr {b2 : B &amp; P (e b1) (e b2)})
  : <span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (e b) (e b)</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b1</span> : B, Contr {b2 : B &amp; P (e b1) (e b2)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (e b) (e b)</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b1</span> : B, Contr {b2 : B &amp; P (e b1) (e b2)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">a1</span> : A, P a0 a1 &lt;~&gt; a0 = a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk57"><span class="nb">apply</span> (equiv_path_along_equiv e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (e b) (e b)</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b1</span> : B, Contr {b2 : B &amp; P (e b1) (e b2)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b0</span> <span class="nv">b1</span> : B, P (e b0) (e b1) &lt;~&gt; b0 = b1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk58"><span class="nb">intro</span> a0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (e b) (e b)</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b1</span> : B, Contr {b2 : B &amp; P (e b1) (e b2)}</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b1</span> : B, P (e a0) (e b1) &lt;~&gt; a0 = b1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk59">srapply equiv_path_from_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; A</span></span></span><br><span><var>Prefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (e b) (e b)</span></span></span><br><span><var>cp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b1</span> : B, Contr {b2 : B &amp; P (e b1) (e b2)}</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; P (e a0) (e b)) a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Prefl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** After [equiv_path_issig_contr], we are left showing the contractibility of a sigma-type whose base and fibers are large nested sigma-types of the same depth.  Moreover, we expect that the types appearing in those two large nested sigma-types &quot;pair up&quot; to form contractible based &quot;path-types&quot;.  The following lemma &quot;peels off&quot; the first such pair, whose contractibility can often be found with typeclass search.  The remaining contractibility goal is then simplified by substituting the center of contraction of that first based &quot;path-type&quot;, or more precisely a *specific* center that may or may not be the one given by the contractibility instance; the latter freedom sometimes makes things faster and simpler. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5a"><span class="kn">Definition</span> <span class="nf">contr_sigma_sigma</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">C</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a -&gt; C a -&gt; <span class="kt">Type</span>)
  {<span class="nv">cac</span> : Contr {x:A &amp; C x} }
  (<span class="nv">a</span> : A) (<span class="nv">c</span> : C a)
  {<span class="nv">ccd</span> : Contr {y:B a &amp; D a y c } }
  : Contr {ab : {x:A &amp; B x} &amp; {y:C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y} }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {ab : {x : A &amp; B x} &amp; {y : C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {ab : {x : A &amp; B x} &amp; {y : C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5c"><span class="nb">pose</span> (d := (center {y:B a &amp; D a y c}).<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">y</span> : B a =&gt; D a y c)
  (center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {ab : {x : A &amp; B x} &amp; {y : C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5d"><span class="nb">set</span> (b := (center {y:B a &amp; D a y c}).<span class="mi">1</span>) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">y</span> : B a =&gt; D a y c) b</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {ab : {x : A &amp; B x} &amp; {y : C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5e"><span class="nb">apply</span> (Build_Contr _ ((a;b);(c;d))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">y</span> : B a =&gt; D a y c) b</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {ab : {x : A &amp; B x} &amp;
    {y : C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y}}, ((a; b); c; d) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk5f"><span class="nb">intros</span> [[a&#39; b&#39;] [c&#39; d&#39;]]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B a&#39;</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C a&#39;</span></span></span><br><span><var>d'</var><span class="hyp-type"><b>: </b><span>D a&#39; b&#39; c&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = ((a&#39;; b&#39;); c&#39;; d&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk60"><span class="nb">pose</span> (ac&#39; := (a&#39;;c&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B a&#39;</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C a&#39;</span></span></span><br><span><var>d'</var><span class="hyp-type"><b>: </b><span>D a&#39; b&#39; c&#39;</span></span></span><br><span><var>ac'</var><span><span class="hyp-body"><b>:= </b><span>(a&#39;; c&#39;)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; C x}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = ((a&#39;; b&#39;); c&#39;; d&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk61"><span class="nb">pose</span> (bd&#39; := (b&#39;;d&#39;) : {y:B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B a&#39;</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C a&#39;</span></span></span><br><span><var>d'</var><span class="hyp-type"><b>: </b><span>D a&#39; b&#39; c&#39;</span></span></span><br><span><var>ac'</var><span><span class="hyp-body"><b>:= </b><span>(a&#39;; c&#39;)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; C x}</span></span></span></span><br><span><var>bd'</var><span><span class="hyp-body"><b>:= </b><span>(b&#39;; d&#39;) : {y : B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}</span></span><span class="hyp-type"><b>: </b><span>{y : B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = ((a&#39;; b&#39;); c&#39;; d&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk62"><span class="nb">change</span> (((a;b);(c;d)) = ((ac&#39;.<span class="mi">1</span>;bd&#39;.<span class="mi">1</span>);(ac&#39;.<span class="mi">2</span>;bd&#39;.<span class="mi">2</span>))
          :&gt; {ab : {x:A &amp; B x} &amp; {y:C ab.<span class="mi">1</span> &amp; D ab.<span class="mi">1</span> ab.<span class="mi">2</span> y} }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B a&#39;</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C a&#39;</span></span></span><br><span><var>d'</var><span class="hyp-type"><b>: </b><span>D a&#39; b&#39; c&#39;</span></span></span><br><span><var>ac'</var><span><span class="hyp-body"><b>:= </b><span>(a&#39;; c&#39;)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; C x}</span></span></span></span><br><span><var>bd'</var><span><span class="hyp-body"><b>:= </b><span>(b&#39;; d&#39;) : {y : B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}</span></span><span class="hyp-type"><b>: </b><span>{y : B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = ((ac&#39;.<span class="mi">1</span>; bd&#39;.<span class="mi">1</span>); ac&#39;.<span class="mi">2</span>; bd&#39;.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk63"><span class="nb">clearbody</span> ac&#39; bd&#39;; <span class="nb">clear</span> a&#39; b&#39; c&#39; d&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>ac'</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; C x}</span></span></span><br><span><var>bd'</var><span class="hyp-type"><b>: </b><span>{y : B ac&#39;.<span class="mi">1</span> &amp; D ac&#39;.<span class="mi">1</span> y ac&#39;.<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = ((ac&#39;.<span class="mi">1</span>; bd&#39;.<span class="mi">1</span>); ac&#39;.<span class="mi">2</span>; bd&#39;.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk64"><span class="nb">destruct</span> (@path_contr {x:A &amp; C x} _ (a;c) ac&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br><span><var>bd'</var><span class="hyp-type"><b>: </b><span>{y : B (a; c).<span class="mi">1</span> &amp; D (a; c).<span class="mi">1</span> y (a; c).<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) = (((a; c).<span class="mi">1</span>; bd&#39;.<span class="mi">1</span>); (a; c).<span class="mi">2</span>; bd&#39;.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="identitysystems-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="identitysystems-v-chk65"><span class="nb">destruct</span> (@path_contr {y:B a &amp; D a y c} _ (b;d) bd&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>cac</var><span class="hyp-type"><b>: </b><span>Contr {x : A &amp; C x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C a</span></span></span><br><span><var>ccd</var><span class="hyp-type"><b>: </b><span>Contr {y : B a &amp; D a y c}</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>B a</span></span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span>(center {y : B a &amp; D a y c}).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>D a b c</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; b); c; d) =
(((a; c).<span class="mi">1</span>; (b; d).<span class="mi">1</span>); (a; c).<span class="mi">2</span>; (b; d).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This tactic just applies the previous lemma, using a match to figure out the appropriate type families so the user doesn&#39;t have to specify them. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">contr_sigsig</span> a c :=
  <span class="kr">match goal with</span>
  | [ |- Contr (@sig (@sig <span class="nl">?A</span> <span class="nl">?B</span>) (<span class="kr">fun</span> <span class="nv">ab</span> =&gt; @sig (@<span class="nl">?C</span> ab) (@<span class="nl">?D</span> ab))) ] =&gt;
    <span class="c">(* The lemma only applies when C depends only on the first component of ab, so we need to factor it somehow through pr1. *)</span>
    <span class="kr">let</span> <span class="nv">C&#39;</span> := <span class="kp">fresh</span> <span class="kr">in</span>
    transparent <span class="nb">assert</span> (C&#39; : {C&#39; : A -&gt; <span class="kt">Type</span> &amp; <span class="kr">forall</span> <span class="nv">ab</span>, C&#39; ab.<span class="mi">1</span> = C ab});
    [ <span class="nb">eexists</span>; <span class="nb">intros</span> ab; <span class="bp">reflexivity</span>
    | nrefine (contr_sigma_sigma A B C&#39;.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; D (a;b)) a c);
      <span class="sd">(** In practice, usually the first [Contr] hypothesis can be found by typeclass search, so we try that.  But we don&#39;t try on the second one, since often it can&#39;t be, and trying can be slow. *)</span>
      [ <span class="kp">try</span> <span class="bp">exact</span> _ | <span class="nb">subst</span> C&#39; ] ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For examples of the use of this tactic, see for instance [Factorization] and [Idempotents]. *)</span></span></pre>
</div>
</div></body>
</html>
