<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>BarInduction.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Bar induction *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.NatSeq.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.List.Core Spaces.List.Theory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> BoundedSearch.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The basic definitions *)</span>

<span class="sd">(** A family [B] on a type of lists is a bar if every infinite sequence restricts to a finite sequence satisfying [B]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsBar</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  := <span class="kr">forall</span> (<span class="nv">s</span> : nat -&gt; A), {n : nat &amp; B (list_restrict s n)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A family [B] is a uniform bar if it is a bar such that there is an upper bound for the lengths of the restrictions needed to satisfy the bar condition. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsUniformBar</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  := {M : nat &amp; <span class="kr">forall</span> (<span class="nv">s</span> : nat -&gt; A),
                  {n : nat &amp; (n &lt;= M) * B (list_restrict s n)}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A family [B] on a type of finite sequences is inductive if, for every list [l], if the concatenation of [l] with any term satisfies [B], then the list satisfies [B]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsInductive</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  := <span class="kr">forall</span> (<span class="nv">l</span> : list A), (<span class="kr">forall</span> (<span class="nv">a</span> : A), B (l ++ [a])) -&gt; B l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A family [B] on a type of finite sequences is monotone if for every list satisfying [B], the concatenation with any other list still satisfies [B]. Equivalently, we can just check the concatenations with lists of length one. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsMonotone</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  := <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A), B l1 -&gt; B (l1 ++ l2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsMonotoneSingleton</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  := <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A), B l -&gt; B (l ++ [a]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1"><span class="kn">Definition</span> <span class="nf">ismonotone_ismonotonesingleton</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">mon</span> : IsMonotoneSingleton B)
  : IsMonotone B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3"><span class="nb">intros</span> l1 l2; <span class="nb">induction</span> l2 <span class="kr">as</span> [|a l2 IHl2] <span class="kr">in</span> l1 |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B l1 -&gt; B (l1 ++ nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A, B l1 -&gt; B (l1 ++ l2)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk4"><hr></label><div class="goal-conclusion">B l1 -&gt; B (l1 ++ a :: l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B l1 -&gt; B (l1 ++ nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A, B l1 -&gt; B (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B l1 -&gt; B (l1 ++ a :: l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7"><span class="nb">intro</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A, B l1 -&gt; B (l1 ++ l2)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l1 ++ a :: l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk8"><span class="nb">rewrite</span> (app_assoc l1 [a] l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mon</var><span class="hyp-type"><b>: </b><span>IsMonotoneSingleton B</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A, B l1 -&gt; B (l1 ++ l2)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B ((l1 ++ [a]) ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl2, mon, h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We state three forms of bar induction: (full) bar induction, monotone bar induction and decidable bar induction. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">DecidableBarInduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">dec</span> : <span class="kr">forall</span> (<span class="nv">l</span> : list A), Decidable (B l))
  (<span class="nv">ind</span> : IsInductive B)
  (<span class="nv">bar</span> : IsBar B),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">MonotoneBarInduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">mon</span> : IsMonotone B)
  (<span class="nv">ind</span> : IsInductive B)
  (<span class="nv">bar</span> : IsBar B),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BarInduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">ind</span> : IsInductive B)
  (<span class="nv">bar</span> : IsBar B),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The three bar induction principles can be more generally stated for two families. It&#39;s clear that the two-family versions imply the one-family versions. We show the reverse implications for full bar induction and monotone bar induction. We do not know if the definitions are equivalent in the decidable case yet. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">DecidableBarInduction&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">sub</span> : <span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l)
  (<span class="nv">dC</span> : <span class="kr">forall</span> (<span class="nv">l</span> : list A), Decidable (C l))
  (<span class="nv">ind</span> : IsInductive B)
  (<span class="nv">bar</span> : IsBar C),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">MonotoneBarInduction&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">sub</span> : <span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l)
  (<span class="nv">monC</span> : IsMonotone C)
  (<span class="nv">indB</span> : IsInductive B)
  (<span class="nv">barC</span> : IsBar C),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BarInduction&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">sub</span> : <span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l)
  (<span class="nv">indB</span> : IsInductive B)
  (<span class="nv">barC</span> : IsBar C),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">barinduction&#39;_barinduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">BI</span> : BarInduction A)
  : BarInduction&#39; A
  := <span class="kr">fun</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">sub</span> <span class="nv">indB</span> <span class="nv">barC</span> =&gt; BI B indB (<span class="kr">fun</span> <span class="nv">s</span> =&gt; ((barC s).<span class="mi">1</span>; sub _ (barC s).<span class="mi">2</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9"><span class="kn">Definition</span> <span class="nf">monotonebarinduction&#39;_monotonebarinduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">MBI</span> : MonotoneBarInduction A)
  : MonotoneBarInduction&#39; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb"><span class="nb">intros</span> B C sub monC indB barC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkc"><span class="nb">pose</span> (P := <span class="kr">fun</span> <span class="nv">v</span> =&gt; <span class="kr">forall</span> <span class="nv">w</span>, B (v ++ w)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkd"><span class="nb">apply</span> (MBI P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chke"><hr></label><div class="goal-conclusion">IsInductive P</div></blockquote><input class="alectryon-extra-goal-toggle" id="barinduction-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chkf"><hr></label><div class="goal-conclusion">IsBar P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk11"><span class="nb">intros</span> u v H w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P u</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B ((u ++ v) ++ w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- app_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk13"><span class="nb">intros</span> l1 H [|a l2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l1 ++ nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk14"><hr></label><div class="goal-conclusion">B (l1 ++ a :: l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk15">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l1 ++ nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk16"><span class="nb">apply</span> indB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, B ((l1 ++ nil) ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk17"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B ((l1 ++ nil) ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk18"><span class="nb">specialize</span> (H a nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>B ((l1 ++ [a]) ++ nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B ((l1 ++ nil) ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_nil <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk19">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (l1 ++ [a])</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l1 ++ a :: l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1a"><span class="nb">specialize</span> (H a l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>B ((l1 ++ [a]) ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l1 ++ a :: l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- app_assoc <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1c"><span class="nb">intro</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1d"><span class="kr">exists</span> (<span class="nv">barC</span> <span class="nv">s</span>).<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (list_restrict s (barC s).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1e"><span class="nb">intro</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>monC</var><span class="hyp-type"><b>: </b><span>IsMonotone C</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">v</span> : list A =&gt; <span class="kr">forall</span> <span class="nv">w</span> : list A, B (v ++ w)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (list_restrict s (barC s).<span class="mi">1</span> ++ w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sub, monC, barC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since decidable bar induction uses decidable predicates, we can state a logically equivalent form based on families of decidable propositions. This form has the advantage of being a proposition. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">HPropDecidableBarInduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  <span class="kr">forall</span> (<span class="nv">B</span> : list A -&gt; <span class="kt">Type</span>)
  (<span class="nv">prop</span> : <span class="kr">forall</span> (<span class="nv">l</span> : list A), IsHProp (B l))
  (<span class="nv">dec</span> : <span class="kr">forall</span> (<span class="nv">l</span> : list A), Decidable (B l))
  (<span class="nv">ind</span> : IsInductive B)
  (<span class="nv">bar</span> : IsBar B),
  B nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ishprop_hpropdecidablebarinduction</span> `{Funext} (A : <span class="kt">Type</span>)
  : IsHProp (HPropDecidableBarInduction A)
  := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk1f"><span class="kn">Definition</span> <span class="nf">decidablebarinduction_hpropdecidablebarinduction</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">pDBI</span> : HPropDecidableBarInduction A)
  : DecidableBarInduction A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk21"><span class="nb">intros</span> P dP iP bP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk22"><span class="nb">apply</span> merely_inhabited_iff_inhabited_stable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (P nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk23">rapply (pDBI (Tr (-<span class="mi">1</span>) o P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive (<span class="kr">fun</span> <span class="nv">x</span> : list A =&gt; Tr (-<span class="mi">1</span>) (P x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk24"><hr></label><div class="goal-conclusion">IsBar (<span class="kr">fun</span> <span class="nv">x</span> : list A =&gt; Tr (-<span class="mi">1</span>) (P x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive (<span class="kr">fun</span> <span class="nv">x</span> : list A =&gt; Tr (-<span class="mi">1</span>) (P x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk26"><span class="nb">intros</span> l q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Tr (-<span class="mi">1</span>) (P (l ++ [a]))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk27"><span class="nb">refine</span> (tr (iP _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Tr (-<span class="mi">1</span>) (P (l ++ [a]))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, P (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; <span class="nb">apply</span> merely_inhabited_iff_inhabited_stable, (q a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar (<span class="kr">fun</span> <span class="nv">x</span> : list A =&gt; Tr (-<span class="mi">1</span>) (P x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk29"><span class="nb">intros</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; Tr (-<span class="mi">1</span>) (P (list_restrict s n))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2a"><span class="kr">exists</span> (<span class="nv">bP</span> <span class="nv">s</span>).<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pDBI</var><span class="hyp-type"><b>: </b><span>HPropDecidableBarInduction A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (P l)</span></span></span><br><span><var>iP</var><span class="hyp-type"><b>: </b><span>IsInductive P</span></span></span><br><span><var>bP</var><span class="hyp-type"><b>: </b><span>IsBar P</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (P (list_restrict s (bP s).<span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr (bP s).<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Relations between the three forms of bar induction *)</span>

<span class="sd">(** Full bar induction clearly implies the other two. We now show that monotone bar induction implies decidable bar induction, by passing through the two-family versions. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2b"><span class="kn">Definition</span> <span class="nf">decidablebarinduction&#39;_monotone_bar_induction&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">MBI</span> : MonotoneBarInduction&#39; A)
  : DecidableBarInduction&#39; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2d"><span class="nb">intros</span> B C sub dC indB barC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The [n &lt;= length l] part is redundant, but makes it clear that [P l] is decidable, which is used below. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2e"><span class="nb">pose</span> (P l := {n : nat &amp; (n &lt;= length l) * C (take n l)}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk2f"><span class="nb">pose</span> (Q l := B l + P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* First we show that it is enough to prove [Q nil] (two cases), and then we prove [Q nil]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk30"><span class="nb">enough</span> (Q nil) <span class="kr">as</span> [b0 | [n [hn hc]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length nil</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n nil)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk31"><hr></label><div class="goal-conclusion">B nil</div></blockquote><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk32"><hr></label><div class="goal-conclusion">Q nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk33"><span class="mi">1</span>: <span class="bp">exact</span> b0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length nil</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk34"><hr></label><div class="goal-conclusion">Q nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk35"><span class="mi">1</span>: <span class="bp">exact</span> (sub _ (take_nil _ # hc)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk36"><span class="nb">apply</span> (MBI Q P (<span class="kr">fun</span> <span class="nv">l</span> <span class="nv">pl</span> =&gt; inr pl)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk37"><hr></label><div class="goal-conclusion">IsInductive Q</div></blockquote><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk38"><hr></label><div class="goal-conclusion">IsBar P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonotone P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3a"><span class="nb">intros</span> l1 l2 [n (cn1, cn2)].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>cn1</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br><span><var>cn2</var><span class="hyp-type"><b>: </b><span>C (take n l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3b"><span class="kr">exists</span> <span class="nv">n</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>cn1</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br><span><var>cn2</var><span class="hyp-type"><b>: </b><span>C (take n l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length (l1 ++ l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>cn1</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br><span><var>cn2</var><span class="hyp-type"><b>: </b><span>C (take n l1)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk3c"><hr></label><div class="goal-conclusion">C (take n (l1 ++ l2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>cn1</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br><span><var>cn2</var><span class="hyp-type"><b>: </b><span>C (take n l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> length_app; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>cn1</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br><span><var>cn2</var><span class="hyp-type"><b>: </b><span>C (take n l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C (take n (l1 ++ l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (take_app l1 l2 cn1 # cn2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk40"><span class="nb">intros</span> l hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk41"><span class="nb">assert</span> (dP : Decidable (P l)) <span class="bp">by</span> rapply decidable_search.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>dP</var><span class="hyp-type"><b>: </b><span>Decidable (P l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk42"><span class="nb">destruct</span> dP <span class="kr">as</span> [t|f].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk43"><hr></label><div class="goal-conclusion">Q l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk44"><span class="mi">1</span>: <span class="bp">exact</span> (inr t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk45"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk46"><span class="nb">apply</span> indB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, B (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk47"><span class="nb">intro</span> a; <span class="nb">destruct</span> (hl a) <span class="kr">as</span> [b | [n [hn hc]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l ++ [a])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length (l ++ [a])</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk48"><hr></label><div class="goal-conclusion">B (l ++ [a])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk49"><span class="mi">1</span>: <span class="bp">exact</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length (l ++ [a])</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk4a"><span class="nb">destruct</span> (equiv_leq_lt_or_eq hn) <span class="kr">as</span> [hn1 | hn2]; <span class="nb">clear</span> hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l ++ [a])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn2</var><span class="hyp-type"><b>: </b><span>n = length (l ++ [a])</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk4b"><hr></label><div class="goal-conclusion">B (l ++ [a])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk4c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk4d"><span class="bp">contradiction</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk4e"><span class="nb">assert</span> (hln : n &lt;= length l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk4f"><hr></label><div class="goal-conclusion">P l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk50">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk51"><span class="nb">rewrite</span> length_app, nat_add_comm <span class="kr">in</span> hn1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length [a] + length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk52"><span class="nb">cbn</span> <span class="kr">in</span> hn1; <span class="nb">unfold</span> <span class="s2">&quot;&lt;&quot;</span> <span class="kr">in</span> hn1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= (length l).+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (leq_pred&#39; hn1).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk53">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk54"><span class="kr">exists</span> <span class="nv">n</span>; <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk55"><hr></label><div class="goal-conclusion">C (take n l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk56">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hln.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk57">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ [a])</span></span></span><br><span><var>hln</var><span class="hyp-type"><b>: </b><span>n &lt;= length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C (take n l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((take_app l [a] hln)^ # hc).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk58">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn2</var><span class="hyp-type"><b>: </b><span>n = length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk59"><span class="nb">refine</span> (sub _ ((take_length_leq _ _ _) # hc)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q (l ++ [a])</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>~ P l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hc</var><span class="hyp-type"><b>: </b><span>C (take n (l ++ [a]))</span></span></span><br><span><var>hn2</var><span class="hyp-type"><b>: </b><span>n = length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (l ++ [a]) &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> hn2^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5b"><span class="nb">intro</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5c"><span class="nb">pose</span> (n := (barC s).<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5d"><span class="kr">exists</span> <span class="nv">n</span>; <span class="kr">exists</span> <span class="nv">n</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n &lt;= length (list_restrict s n)) *
C (take n (list_restrict s n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk5e"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length (list_restrict s n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk5f"><hr></label><div class="goal-conclusion">C (take n (list_restrict s n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk60">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= length (list_restrict s n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> length_list_restrict.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk61">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C (take n (list_restrict s n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk62"><span class="nb">rewrite</span> take_length_leq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C (list_restrict s n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk63"><hr></label><div class="goal-conclusion">length (list_restrict s n) &lt;= n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk64"><span class="mi">1</span>: <span class="bp">exact</span> (barC s).<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>MBI</var><span class="hyp-type"><b>: </b><span>MonotoneBarInduction&#39; A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, C l -&gt; B l</span></span></span><br><span><var>dC</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (C l)</span></span></span><br><span><var>indB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>barC</var><span class="hyp-type"><b>: </b><span>IsBar C</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
{n : nat &amp; (n &lt;= length l) * C (take n l)}</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B l + P l</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span><span class="hyp-body"><b>:= </b><span>(barC s).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_restrict s n) &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> length_list_restrict.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decidable_bar_induction_monotone_bar_induction</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">MBI</span> : MonotoneBarInduction A)
  : DecidableBarInduction A
  := <span class="kr">fun</span> <span class="nv">B</span> <span class="nv">dec</span> <span class="nv">ind</span> <span class="nv">bar</span> =&gt;
      (decidablebarinduction&#39;_monotone_bar_induction&#39; A
        (monotonebarinduction&#39;_monotonebarinduction A MBI))
      B B (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap) dec ind bar.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Examples of types that satisfy forms of bar induction *)</span>

<span class="sd">(** The empty type and all contractible types satisfy full bar induction. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk65"><span class="kn">Definition</span> <span class="nf">barinduction_empty</span> : BarInduction Empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">BarInduction Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">BarInduction Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk67"><span class="nb">intros</span> B iB _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span>list Empty -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk68">rapply iB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span>list Empty -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Empty, B (nil ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; <span class="bp">contradiction</span> a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk69"><span class="kn">Definition</span> <span class="nf">barinduction_contr</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{Contr A} : BarInduction A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6b"><span class="nb">intros</span> B iB bB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6c"><span class="nb">pose</span> (c := <span class="kr">fun</span> (<span class="nv">n</span> : nat) =&gt; center A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6d"><span class="nb">specialize</span> (bB c) <span class="kr">as</span> [n hn]; <span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk6e"><hr></label><div class="goal-conclusion">B nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk6f"><span class="mi">1</span>: <span class="bp">exact</span> hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk70"><span class="nb">apply</span> IHn, iB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, B (list_restrict c n ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk71"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (list_restrict c n ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk72">nrefine (_ # hn).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_restrict c n.+<span class="mi">1</span> = list_restrict c n ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk73"><span class="nb">rewrite</span> (path_contr x (center A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; center A</span></span><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>B (list_restrict c n) -&gt; B nil</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_restrict c n.+<span class="mi">1</span> = list_restrict c n ++ [center A]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply list_restrict_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a type satisfies decidable bar induction assuming that it is pointed, then it satisfies decidable bar induction. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk74"><span class="kn">Definition</span> <span class="nf">decidablebarinduction_pointed_decidablebarinduction</span>
  (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : A -&gt; DecidableBarInduction A)
  : DecidableBarInduction A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidableBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk76"><span class="nb">intros</span> B dB iB bB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk77"><span class="nb">destruct</span> (dec (B nil)) <span class="kr">as</span> [b | n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk78"><hr></label><div class="goal-conclusion">B nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk79"><span class="mi">1</span>: <span class="bp">exact</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7a"><span class="nb">apply</span> iB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, B (nil ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7b"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7c"><span class="nb">pose</span> (B&#39; l := B (a :: l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7d"><span class="nb">apply</span> (p a B&#39; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive B&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk7e"><hr></label><div class="goal-conclusion">IsBar B&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk80"><span class="nb">intros</span> l; <span class="nb">unfold</span> B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a0</span> : A, B (a :: l ++ [a0])) -&gt; B (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (iB (a :: l)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk82"><span class="nb">intro</span> s; <span class="nb">unfold</span> B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk83"><span class="nb">destruct</span> (bB (seq_cons a s)) <span class="kr">as</span> [m r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk84"><span class="nb">destruct</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk85"><hr></label><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk86">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span> (n r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk87">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; B (a :: list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk88"><span class="kr">exists</span> <span class="nv">m</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (a :: list_restrict s m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk89">nrefine (_ # r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_restrict (seq_cons a s) m.+<span class="mi">1</span> =
a :: list_restrict s m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk8a">snapply path_list_nth&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) =
length (a :: list_restrict s m)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk8b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n0</span> : nat)
(<span class="nv">H</span> : n0 &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)),
nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) n0 H =
nth&#39; (a :: list_restrict s m) n0
  (transport (lt n0) <span class="nl">?p</span> H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk8c"><span class="mi">1</span>: <span class="nb">cbn</span>; <span class="bp">by</span> <span class="nb">rewrite</span> !length_list_restrict.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat)
(<span class="nv">H</span> : n &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)),
nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) n H =
nth&#39; (a :: list_restrict s m) n
  (transport (lt n)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H0</span> : k &lt; m) =&gt;
                        leq_succ_r H0))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n1}) nil
                       (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n1})
                        =&gt;
                        (n1; leq_refl n1.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (...)) IHn) m)))) =
         n0.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; n0 = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)
      :
      length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) =
      length (a :: list_restrict s m)) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk8d"><span class="nb">intros</span> k hk; <span class="nb">destruct</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) <span class="mi">0</span> hk =
nth&#39; (a :: list_restrict s m) <span class="mi">0</span>
  (transport (lt <span class="mi">0</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; m) =&gt;
                        leq_succ_r H))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n0}) nil
                       (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n0})
                        =&gt;
                        (n0; leq_refl n0.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (<span class="kr">fun</span> ... ... =&gt;
                                 leq_succ_r H)) IHn) m)))) =
         n.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)) hk)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk8e"><hr></label><div class="goal-conclusion">nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) k.+<span class="mi">1</span> hk =
nth&#39; (a :: list_restrict s m) k.+<span class="mi">1</span>
  (transport (lt k.+<span class="mi">1</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; m) =&gt;
                        leq_succ_r H))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n0}) nil
                       (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n0})
                        =&gt;
                        (n0; leq_refl n0.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (<span class="kr">fun</span> ... ... =&gt;
                                 leq_succ_r H)) IHn) m)))) =
         n.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)) hk)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk8f"><span class="mi">1</span>: <span class="nb">cbn</span>; <span class="bp">by</span> <span class="nb">rewrite</span> nth&#39;_list_restrict.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) k.+<span class="mi">1</span> hk =
nth&#39; (a :: list_restrict s m) k.+<span class="mi">1</span>
  (transport (lt k.+<span class="mi">1</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; m) =&gt;
                        leq_succ_r H))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n0}) nil
                       (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n0})
                        =&gt;
                        (n0; leq_refl n0.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (<span class="kr">fun</span> ... ... =&gt;
                                 leq_succ_r H)) IHn) m)))) =
         n.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)) hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk90"><span class="nb">assert</span> (hk&#39; : k &lt; length (list_restrict s m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt; length (list_restrict s m)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>hk'</var><span class="hyp-type"><b>: </b><span>k &lt; length (list_restrict s m)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk91"><hr></label><div class="goal-conclusion">nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) k.+<span class="mi">1</span> hk =
nth&#39; (a :: list_restrict s m) k.+<span class="mi">1</span>
  (transport (lt k.+<span class="mi">1</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; m) =&gt;
                        leq_succ_r H))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n0}) nil
                       (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n0})
                        =&gt;
                        (n0; leq_refl n0.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (<span class="kr">fun</span> ... ... =&gt;
                                 leq_succ_r H)) IHn) m)))) =
         n.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)) hk)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk92">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt; length (list_restrict s m)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk93"><span class="nb">rewrite</span> length_list_restrict <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; m.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk94">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; DecidableBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, Decidable (B l)</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ B nil</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; B (a :: l)</span></span><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hk</var><span class="hyp-type"><b>: </b><span>k.+<span class="mi">1</span> &lt; length (list_restrict (seq_cons a s) m.+<span class="mi">1</span>)</span></span></span><br><span><var>hk'</var><span class="hyp-type"><b>: </b><span>k &lt; length (list_restrict s m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_restrict (seq_cons a s) m.+<span class="mi">1</span>) k.+<span class="mi">1</span> hk =
nth&#39; (a :: list_restrict s m) k.+<span class="mi">1</span>
  (transport (lt k.+<span class="mi">1</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         length
           (list_map
              (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; m.+<span class="mi">1</span>} =&gt;
               seq_cons a s pat.<span class="mi">1</span>)
              (reverse_acc [(m; leq_refl m.+<span class="mi">1</span>)]
                 (list_map
                    (functor_sigma idmap
                       (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; m) =&gt;
                        leq_succ_r H))
                    (nat_rec
                       (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                        list {k : nat &amp; k &lt; n0}) nil
                       (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                          (<span class="nv">IHn</span> : list
                                   {k : nat &amp; k &lt; n0})
                        =&gt;
                        (n0; leq_refl n0.+<span class="mi">1</span>)
                        :: list_map
                             (functor_sigma idmap
                                (<span class="kr">fun</span> ... ... =&gt;
                                 leq_succ_r H)) IHn) m)))) =
         n.+<span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n = m.+<span class="mi">1</span>) <span class="mi">1</span>
           (length_list_restrict (seq_cons a s) m.+<span class="mi">1</span>))
        (length_list_restrict s m)) hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (nth&#39;_cons _ _ _ hk&#39;), !nth&#39;_list_restrict.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The same is true for monotone bar induction. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk95"><span class="kn">Definition</span> <span class="nf">monotonebarinduction_pointed_monotonebarinduction</span>
  (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : A -&gt; MonotoneBarInduction A)
  : MonotoneBarInduction A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; MonotoneBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; MonotoneBarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk97"><span class="nb">intros</span> B mB iB bB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; MonotoneBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mB</var><span class="hyp-type"><b>: </b><span>IsMonotone B</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk98"><span class="nb">apply</span> iB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; MonotoneBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mB</var><span class="hyp-type"><b>: </b><span>IsMonotone B</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, B (nil ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk99"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A -&gt; MonotoneBarInduction A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mB</var><span class="hyp-type"><b>: </b><span>IsMonotone B</span></span></span><br><span><var>iB</var><span class="hyp-type"><b>: </b><span>IsInductive B</span></span></span><br><span><var>bB</var><span class="hyp-type"><b>: </b><span>IsBar B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (mB nil), (p a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Combining [monotonebarinduction_pointed_monotonebarinduction] and [barinduction_contr], we prove that any proposition satisfies monotone bar induction. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9a"><span class="kn">Definition</span> <span class="nf">monotonebarinduction_hprop</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsHProp A}
  : MonotoneBarInduction A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9c"><span class="nb">apply</span> monotonebarinduction_pointed_monotonebarinduction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9d"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chk9e"><span class="nb">enough</span> (BarInduction A) <span class="kr">as</span> BI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonotoneBarInduction A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chk9f"><hr></label><div class="goal-conclusion">BarInduction A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka0"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">B</span> <span class="nv">_</span> <span class="nv">iB</span> <span class="nv">bB</span> =&gt; BI B iB bB).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BarInduction A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> barinduction_contr, (contr_inhabited_hprop A a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that [monotone_bar_induction_pointed_monotone_bar_induction] does not have an analogue for full bar induction. We prove below that every type satisfying full bar induction is Sigma-compact and therefore decidable. Then, as in [monotone_bar_induction_hprop], we would be able to prove that any proposition satisfies bar induction and therefore that every proposition is decidable. *)</span>

<span class="sd">(** ** Implications of bar induction *)</span>

<span class="sd">(** Full bar induction for a type [A] implies that it is Sigma-compact, in the sense that any decidable family over [A] has a decidable Sigma-type. To prove this, we begin by defining a type family [P] on [list A] so that [P nil] is our goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BI_sig_family</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A) : <span class="kt">Type</span>
  := <span class="kr">match</span> l <span class="kr">with</span>
      | nil =&gt; Decidable {a : A &amp; P a}
      | a :: l&#39; =&gt; ~(P a)
     <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka1"><span class="kn">Definition</span> <span class="nf">is_bar_BI_sig_family</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  (<span class="nv">dec</span> : <span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n))
  : IsBar (BI_sig_family P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar (BI_sig_family P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBar (BI_sig_family P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka3"><span class="nb">intro</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; BI_sig_family P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka4"><span class="nb">destruct</span> (dec (s <span class="mi">0</span>)) <span class="kr">as</span> [p|p&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; BI_sig_family P (list_restrict s n)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>~ P (s <span class="mi">0</span>)</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chka5"><hr></label><div class="goal-conclusion">{n : nat &amp; BI_sig_family P (list_restrict s n)}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; BI_sig_family P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka7"><span class="kr">exists</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BI_sig_family P (list_restrict s <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable {a : A &amp; P a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl (s <span class="mi">0</span>; p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>~ P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; BI_sig_family P (list_restrict s n)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkaa"><span class="kr">exists</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>~ P (s <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BI_sig_family P (list_restrict s <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkab"><span class="kn">Definition</span> <span class="nf">isinductive_BI_sig_family</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  : IsInductive (BI_sig_family P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive (BI_sig_family P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInductive (BI_sig_family P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkad"><span class="nb">intros</span> [|a l] h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, BI_sig_family P (nil ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BI_sig_family P nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A, BI_sig_family P ((a :: l) ++ [a0])</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chkae"><hr></label><div class="goal-conclusion">BI_sig_family P (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkaf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, BI_sig_family P (nil ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BI_sig_family P nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb0"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, BI_sig_family P (nil ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ {a : A &amp; P a}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">pa</span> =&gt; h pa.<span class="mi">1</span> pa.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A, BI_sig_family P ((a :: l) ++ [a0])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BI_sig_family P (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (h a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issigcompact_barinduction</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">BI</span> : BarInduction A)
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">dec</span> : <span class="kr">forall</span> <span class="nv">n</span> : A, Decidable (P n))
  : Decidable {a : A &amp; P a}
  := BI (BI_sig_family P)
          (isinductive_BI_sig_family P) (is_bar_BI_sig_family dec).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Full bar induction for [nat] implies the limited principle of omniscience, i.e., for every sequence of natural numbers we can decide whether every term is zero or there exists a non-zero term. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb2"><span class="kn">Definition</span> <span class="nf">LPO_barinduction</span> {<span class="nv">BI</span> : BarInduction nat} (<span class="nv">s</span> : nat -&gt; nat)
  : (<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb4"><span class="nb">destruct</span> (issigcompact_barinduction BI (<span class="kr">fun</span> <span class="nv">n</span> =&gt; s n &lt;&gt; <span class="mi">0</span>) _) <span class="kr">as</span> [l|r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>{a : nat &amp; s a &lt;&gt; <span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="barinduction-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>~ {a : nat &amp; s a &lt;&gt; <span class="mi">0</span>}</span></span></span><br></div><label class="goal-separator" for="barinduction-v-chkb5"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>{a : nat &amp; s a &lt;&gt; <span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">exact</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="barinduction-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="barinduction-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>BI</var><span class="hyp-type"><b>: </b><span>BarInduction nat</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>~ {a : nat &amp; s a &lt;&gt; <span class="mi">0</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, s n = <span class="mi">0</span>) + {n : nat &amp; s n &lt;&gt; <span class="mi">0</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; stable (<span class="kr">fun</span> <span class="nv">z</span> : s n &lt;&gt; <span class="mi">0</span> =&gt; r (n; z))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
