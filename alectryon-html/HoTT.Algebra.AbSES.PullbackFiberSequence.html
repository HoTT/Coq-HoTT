<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>PullbackFiberSequence.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types HSet HFiber Limits.Pullback.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core NatTrans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core Homotopy.ExactSequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbGroups.AbelianGroup AbGroups.AbPullback AbGroups.Biproduct.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbSES.Core AbSES.Pullback.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Identity Modalities.Modality Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The fiber sequence induced by pulling back along a short exact sequence *)</span>

<span class="sd">(** We show that pulling back along a short exact sequence [E : AbSES C B] produces a fiber sequence [AbSES C A -&gt; AbSES E A -&gt; AbSES B A]. The associated long exact sequence of homotopy groups recovers the usual (contravariant) six-term exact sequence of Ext groups.</span>

<span class="sd">We will prove the analog of exactness in terms of path data, and deduce the usual notion. *)</span>

<span class="sd">(** If a short exact sequence [A -&gt; F -&gt; E] becomes trivial after pulling back along an inclusion [i : B -&gt; E], then there is a &quot;transpose&quot; short exact sequence [B -&gt; F -&gt; F/B]. We begin by constructing the map [B -&gt; F]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion_transpose_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span> : AbGroup}
      (<span class="nv">i</span> : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback i F $== pt)
  : B $-&gt; F
  := grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span> $o ab_biprod_inr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The comparison map [A + B $-&gt; F] is an embedding.  This comes up twice so we factor it out as a lemma. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1"><span class="kn">Local Instance</span> <span class="nf">abses_pullback_inclusion_lemma</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span> : AbGroup}
      (<span class="nv">i</span> : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback i F $== pt)
  : IsEmbedding (grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3">napply (istruncmap_compose (-<span class="mi">1</span>) p^$.<span class="mi">1</span> (grp_pullback_pr1 (projection F) i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (grp_pullback_pr1 (projection F) i)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk4"><hr></label><div class="goal-conclusion">IsEmbedding (p^$).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: rapply istruncmap_mapinO_tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The map [B -&gt; F] is an inclusion. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5"><span class="kn">Local Instance</span> <span class="nf">abses_pullback_inclusion_transpose_embedding</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span> : AbGroup}
      (<span class="nv">i</span> : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback i F $== pt)
  : IsEmbedding (abses_pullback_inclusion_transpose_map i F p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (abses_pullback_inclusion_transpose_map i F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (abses_pullback_inclusion_transpose_map i F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (istruncmap_compose _ (ab_biprod_inr)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We define the cokernel [F/B], which is what we need below. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion_transpose_endpoint&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span> : AbGroup}
           (<span class="nv">i</span> : B $-&gt; E) `{IsEmbedding i}
           (F : AbSES E A) (p : abses_pullback i F $== pt)
  : AbGroup
  := ab_cokernel_embedding (abses_pullback_inclusion_transpose_map i F p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The composite map [B -&gt; F -&gt; E] is homotopic to the original inclusion [i : B -&gt; E]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7"><span class="kn">Lemma</span> <span class="nf">abses_pullback_inclusion_transpose_beta</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span> : AbGroup}
      (<span class="nv">i</span> : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback i F $== pt)
  : projection F $o (abses_pullback_inclusion_transpose_map i F p) == i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
abses_pullback_inclusion_transpose_map i F p == i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
abses_pullback_inclusion_transpose_map i F p == i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection F $o
 abses_pullback_inclusion_transpose_map i F p) b = 
i b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka"><span class="nb">change</span> b <span class="kr">with</span> (ab_biprod_pr2 (A:=A) (mon_unit, b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection F $o
 abses_pullback_inclusion_transpose_map i F p)
  (ab_biprod_pr2 (<span class="mi">0</span>, b)) = 
i (ab_biprod_pr2 (<span class="mi">0</span>, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb"><span class="nb">refine</span> (pullback_commsq _ _ _ @ ap i _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback i F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_pr2
  ((p^$).<span class="mi">1</span> (ab_biprod_inr (ab_biprod_pr2 (<span class="mi">0</span>, b)))) =
ab_biprod_pr2 (<span class="mi">0</span>, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd p^$.<span class="mi">2</span> _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Short exact sequences in the fiber of [inclusion E] descend along [projection E]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc"><span class="kn">Definition</span> <span class="nf">abses_pullback_trivial_preimage</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
           (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
  : AbSES C A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES C A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES C A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke">snapply Build_AbSES.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkf"><hr></label><div class="goal-conclusion">A $-&gt; <span class="nl">?middle</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk10"><hr></label><div class="goal-conclusion"><span class="nl">?middle</span> $-&gt; C</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk11"><hr></label><div class="goal-conclusion">IsEmbedding <span class="nl">?inclusion</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk12"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) <span class="nl">?projection</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk13"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) <span class="nl">?inclusion</span> <span class="nl">?projection</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pullback_inclusion_transpose_endpoint&#39; (inclusion E) F p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt;
abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_quotient_map $o inclusion F).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk17">srapply (ab_cokernel_embedding_rec _ (projection E $o projection F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose (projection E $o projection F)
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) $== grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk18"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose (projection E $o projection F)
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) b = grp_homo_const b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk19"><span class="nb">refine</span> (ap (projection E) (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E b) = grp_homo_const b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (grp_quotient_map $o inclusion F)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1b"><span class="nb">apply</span> isembedding_istrivial_kernel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup
  (grp_kernel (grp_quotient_map $o inclusion F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1c"><span class="nb">intros</span> a q0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Since [inclusion F a] is killed by [grp_quotient_map], its in the image of [B]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1d"><span class="nb">pose proof</span> (in_coset := related_quotient_paths _ _ _ q0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>in_coset</var><span class="hyp-type"><b>: </b><span>in_cosetL
  {|
    normalsubgroup_subgroup :=
      grp_image_embedding
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p);
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (grp_image_embedding
           (abses_pullback_inclusion_transpose_map
              (inclusion E) F p))
  |} (inclusion F a) <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Cleaning up the context facilitates later steps. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1e"><span class="nb">destruct</span> in_coset <span class="kr">as</span> [b q1]; <span class="nb">rewrite</span> grp_unit_r <span class="kr">in</span> q1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Since both [inclusion F] and [B -&gt; F] factor through the mono [ab_biprod A B -&gt; F], we can lift [q1] to [ab_biprod A B]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1f"><span class="nb">assert</span> (q2 : ab_biprod_inr  b = ab_biprod_inl (-a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_inr b = ab_biprod_inl (- a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk20"><hr></label><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk21"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_inr b = ab_biprod_inl (- a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk22"><span class="nb">apply</span> (isinj_embedding (grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (grp_pullback_pr1 (projection F) (inclusion E) $o
   (p^$).<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk23"><hr></label><div class="goal-conclusion">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inr b) =
(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (grp_pullback_pr1 (projection F) (inclusion E) $o
   (p^$).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk25"><span class="nb">apply</span> abses_pullback_inclusion_lemma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (inclusion E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inr b) =
(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk27">nrefine (q1 @ _); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a)) = 
- inclusion F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk28"><span class="nb">refine</span> (ap (grp_pullback_pr1 _ _) (fst p^$.<span class="mi">2</span> (-a)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pullback_pr1 (projection F) 
  (inclusion E)
  (inclusion (abses_pullback (inclusion E) F) (- a)) =
- inclusion F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_inv _ _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk29">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Using [q2], we conclude. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2a"><span class="nb">pose proof</span> (q3 := ap (-) (fst ((equiv_path_prod _ _)^-<span class="mi">1</span> q2))); <span class="nb">cbn</span> <span class="kr">in</span> q3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_kernel (grp_quotient_map $o inclusion F) a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_map
  (inclusion E) F p b = 
- inclusion F a</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span><br><span><var>q3</var><span class="hyp-type"><b>: </b><span>- group_unit = - - a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((inverse_involutive _)^ @ q3^ @ grp_inv_unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
       ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X E b))
      :
      grp_homo_compose 
        (projection E $o projection F)
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p) $== grp_homo_const))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2c"><span class="nb">apply</span> (cancelR_conn_map (Tr (-<span class="mi">1</span>)) grp_quotient_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk2d"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt;
   ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
      ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p b) @
      (<span class="kr">let</span> <span class="nv">X</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X E b)) (grp_quotient_map x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2e"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt;
   ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
      ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p b) @
      (<span class="kr">let</span> <span class="nv">X</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X E b)) (grp_quotient_map x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt; projection E (projection F x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (grp_quotient_map $o inclusion F)
  (ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
       ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X E b))
      :
      grp_homo_compose 
        (projection E $o projection F)
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p) $== grp_homo_const))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk31">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (grp_quotient_map $o inclusion F)
  (ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
       ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X E b))
      :
      grp_homo_compose 
        (projection E $o projection F)
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p) $== grp_homo_const))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk32"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk33">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (grp_quotient_map $o inclusion F)
  (ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
       ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X E b))
      :
      grp_homo_compose 
        (projection E $o projection F)
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p) $== grp_homo_const))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk34">srapply phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) 
  (projection E $o projection F)
  ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
    ap (projection E)
      (abses_pullback_inclusion_transpose_beta
         (inclusion E) F p b) @
    (<span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
       pointed_fun (iscomplex_abses E) <span class="kr">in</span>
     X E b))
   :
   grp_homo_compose (projection E $o projection F)
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p) $== grp_homo_const)
o* (grp_quotient_map $o inclusion F) == pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk35"><span class="nb">intro</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (projection F (inclusion F a)) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk36"><span class="nb">refine</span> (ap (projection E) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (inclusion F a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk37"><hr></label><div class="goal-conclusion">projection E <span class="nl">?Goal</span> = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk38"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (pconst a) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk39">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
          ap (projection E)
            (<span class="kr">let</span> <span class="nv">X</span> :=
               <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
               pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
             X F a) @ grp_homo_unit (projection E)
          :
          (ab_cokernel_embedding_rec
             (abses_pullback_inclusion_transpose_map
                (inclusion E) F p)
             (projection E $o projection F)
             (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
              ap (projection E)
                (abses_pullback_inclusion_transpose_beta
                   (inclusion E) F p b) @
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                 pointed_fun (iscomplex_abses E) <span class="kr">in</span>
               X E b))
           o* (grp_quotient_map $o inclusion F)) a =
          pconst a)
         :
         ab_cokernel_embedding_rec
           (abses_pullback_inclusion_transpose_map
              (inclusion E) F p)
           (projection E $o projection F)
           ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
             ap (projection E)
               (abses_pullback_inclusion_transpose_beta
                  (inclusion E) F p b) @
             (<span class="kr">let</span> <span class="nv">X</span> :=
                <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                pointed_fun (iscomplex_abses E) <span class="kr">in</span>
              X E b))
            :
            grp_homo_compose
              (projection E $o projection F)
              (abses_pullback_inclusion_transpose_map
                 (inclusion E) F p) $== grp_homo_const)
         o* (grp_quotient_map $o inclusion F) ==
         pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3a"><span class="nb">intros</span> [y q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3b"><span class="nb">apply</span> (@contr_inhabited_hprop _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* We choose a preimage by [grp_quotient_map]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3c"><span class="nb">assert</span> (f : merely (hfiber grp_quotient_map y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber grp_quotient_map y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>merely (hfiber grp_quotient_map y)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk3d"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3e"><span class="mi">1</span>: <span class="nb">apply</span> center, issurj_class_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>merely (hfiber grp_quotient_map y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3f">revert_opaque f; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [f q0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* Since [projection F f] is in the kernel of [projection E], we find a preimage in [B]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk40"><span class="nb">assert</span> (b : merely (hfiber (inclusion E) (projection F f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber (inclusion E) (projection F f))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>merely (hfiber (inclusion E) (projection F f))</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk41"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk42"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber (inclusion E) (projection F f))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk43">tapply isexact_preimage.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (projection F f) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ q0 @ q).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk44">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>merely (hfiber (inclusion E) (projection F f))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk45">revert_opaque b; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [b q1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* The difference [f - b] in [F] is in the kernel of [projection F], hence lies in [A]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk46"><span class="nb">assert</span> (a : merely (hfiber (inclusion F)
                                 (sg_op f (-(grp_pullback_pr1 _ _ (p^$.<span class="mi">1</span> (ab_biprod_inr b))))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  (hfiber (inclusion F)
     (f -
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>merely
  (hfiber (inclusion F)
     (f -
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))))</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk47"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk48"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  (hfiber (inclusion F)
     (f -
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk49">tapply isexact_preimage.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F
  (f -
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4a"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f +
projection F
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4b"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + x) (grp_homo_inv _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f -
projection F
  (grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4c"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ - x) (abses_pullback_inclusion_transpose_beta (inclusion E) F p b @ q1) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f - projection F f = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> right_inverse.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>merely
  (hfiber (inclusion F)
     (f -
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4e">revert_opaque a; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [a q2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E)))) 
     (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* It remains to show that [a] is the desired preimage. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4f"><span class="nb">refine</span> (tr (a; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib
  (phomotopy_homotopy_hset
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
      ap (projection E)
        (<span class="kr">let</span> <span class="nv">X</span> :=
           <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
           pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
         X F a) @ grp_homo_unit (projection E))) a =
(y; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk50"><span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> y <span class="kr">in</span> <span class="nb">apply</span> (@path_sigma_hprop T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : abses_pullback_inclusion_transpose_endpoint&#39;
      (inclusion E) F p,
IsHProp
  (ab_cokernel_embedding_rec
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p)
     (projection E $o projection F)
     (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
      ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p b) @
      (<span class="kr">let</span> <span class="nv">X</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X E b)) x = pt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk51"><hr></label><div class="goal-conclusion">(cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ap (projection E)
         (<span class="kr">let</span> <span class="nv">X</span> :=
            <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
            pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
          X F a) @ grp_homo_unit (projection E))) a).<span class="mi">1</span> =
(y; q).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk52"><span class="mi">1</span>: <span class="nb">intros</span> ?; <span class="nb">apply</span> istrunc_paths; <span class="nb">apply</span> group_isgroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ap (projection E)
         (<span class="kr">let</span> <span class="nv">X</span> :=
            <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
            pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
          X F a) @ grp_homo_unit (projection E))) a).<span class="mi">1</span> =
(y; q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk53"><span class="nb">refine</span> (ap grp_quotient_map q2 @ _ @ q0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map
  (f -
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
grp_quotient_map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk54"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map f +
grp_quotient_map
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
grp_quotient_map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk55"><span class="nb">apply</span> grp_moveR_Mg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
- grp_quotient_map f + grp_quotient_map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk56"><span class="nb">refine</span> (_ @ (left_inverse _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk57"><span class="nb">apply</span> qglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_cosetL
  {|
    normalsubgroup_subgroup :=
      grp_image_embedding
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p);
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (grp_image_embedding
           (abses_pullback_inclusion_transpose_map
              (inclusion E) F p))
  |}
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk58"><span class="kr">exists</span> <span class="nv">b</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_inclusion_transpose_map 
  (inclusion E) F p b =
-
-
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)) + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk59"><span class="nb">refine</span> (_ @ (grp_unit_r _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (projection E $o projection F)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap (projection E)
     (abses_pullback_inclusion_transpose_beta
        (inclusion E) F p b) @
   (<span class="kr">let</span> <span class="nv">X</span> :=
      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
      pointed_fun (iscomplex_abses E) <span class="kr">in</span>
    X E b)) y = pt</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>grp_quotient_map f = y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>inclusion E b = projection F f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>inclusion F a =
f -
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_inclusion_transpose_map 
  (inclusion E) F p b =
-
-
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inverse_involutive _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** That [abses_pullback_trivial_preimage E F p] pulls back to [F] is immediate from [abses_pullback_component1_id] and the following map. As such, we&#39;ve shown that sequences which become trivial after pulling back along [inclusion E] are in the image of pullback along [projection E]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5a"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion0_map&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
           (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
  : AbSESMorphism F (abses_pullback_trivial_preimage E F p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism F
  (abses_pullback_trivial_preimage E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism F
  (abses_pullback_trivial_preimage E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5c">srapply Build_AbSESMorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk5d"><hr></label><div class="goal-conclusion">F $-&gt; abses_pullback_trivial_preimage E F p</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk5e"><hr></label><div class="goal-conclusion">E $-&gt; C</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk5f"><hr></label><div class="goal-conclusion">inclusion (abses_pullback_trivial_preimage E F p) $o
<span class="nl">?component1</span> == <span class="nl">?component2</span> $o inclusion F</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk60"><hr></label><div class="goal-conclusion">projection (abses_pullback_trivial_preimage E F p) $o
<span class="nl">?component2</span> == <span class="nl">?component3</span> $o projection F</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_homo_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F $-&gt; abses_pullback_trivial_preimage E F p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_quotient_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (projection E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pullback_trivial_preimage E F p) $o
grp_homo_id == grp_quotient_map $o inclusion F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback_trivial_preimage E F p) $o
grp_quotient_map == projection E $o projection F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For exactness we need not only a preimage of [F] but a preimage of [(F,p)] along [cxfib]. We now define and prove this in terms of path data. *)</span>

<span class="sd">(** The analog of [cxfib] induced by pullback in terms of path data. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk66"><span class="kn">Definition</span> <span class="nf">cxfib&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup} (<span class="nv">E</span> : AbSES C B)
  : AbSES C A -&gt; graph_hfiber (abses_pullback (A:=A) (inclusion E)) pt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES C A -&gt;
graph_hfiber (abses_pullback (inclusion E)) pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES C A -&gt;
graph_hfiber (abses_pullback (inclusion E)) pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk68"><span class="nb">intro</span> Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_hfiber (abses_pullback (inclusion E)) pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk69"><span class="kr">exists</span> (<span class="nv">abses_pullback</span> (projection E) Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (inclusion E)
  (abses_pullback (projection E) Y) $-&gt; pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6a"><span class="nb">refine</span> (abses_pullback_compose&#39; _ _ Y $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (projection E $o inclusion E) Y $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6b"><span class="nb">refine</span> (abses_pullback_homotopic&#39; _ grp_homo_const _ Y $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o inclusion E == grp_homo_const</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk6c"><hr></label><div class="goal-conclusion">abses_pullback grp_homo_const Y $== pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6d"><span class="mi">1</span>: rapply iscomplex_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_const Y $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> abses_pullback_const&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hfiber_cxfib&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup} (<span class="nv">E</span> : AbSES C B)
           (<span class="nv">F</span> : AbSES (middle E) A) (<span class="nv">p</span> : abses_pullback (inclusion E) F $== pt)
  := {Y : AbSES C A &amp; hfiber_abses_path (cxfib&#39; E Y) (F; p)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* This is just [idpath], but Coq takes too long to see that. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6e"><span class="kn">Local Definition</span> <span class="nf">pr2_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B} (U : AbSES C A)
  : equiv_ptransformation_phomotopy (iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)) U
    = equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk70"><span class="nb">change</span> (equiv_ptransformation_phomotopy (iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)) U)
    <span class="kr">with</span> (equiv_path_abses_iso ((iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)).<span class="mi">1</span> U)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso
  ((iscomplex_abses_pullback&#39; (inclusion E)
      (projection E) (iscomplex_abses E)).<span class="mi">1</span> U) =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk71"><span class="nb">apply</span> (ap equiv_path_abses_iso).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(iscomplex_abses_pullback&#39; (inclusion E)
   (projection E) (iscomplex_abses E)).<span class="mi">1</span> U =
(cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk72">tapply path_hom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(iscomplex_abses_pullback&#39; (inclusion E)
   (projection E) (iscomplex_abses E)).<span class="mi">1</span> U $==
(cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk73"><span class="nb">refine</span> (_ $@R abses_pullback_compose&#39; (inclusion E) (projection E) U);
    <span class="nb">unfold</span> trans_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_pullback_pconst&#39; ^*$).<span class="mi">1</span> U $o
(abses_pullback_phomotopic&#39;
   (projection E $o inclusion E) grp_homo_const
   (iscomplex_abses E)).<span class="mi">1</span> U $==
abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E) U $@
symmetric_GpdHom pt (abses_pullback grp_homo_const U)
  (abses_pullback_const&#39; U)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk74"><span class="nb">refine</span> (_ $@R abses_pullback_homotopic&#39; (projection E $o inclusion E) grp_homo_const (iscomplex_abses E) U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_pullback_pconst&#39;.<span class="mi">1</span> U)^$ $==
symmetric_GpdHom pt (abses_pullback grp_homo_const U)
  (abses_pullback_const&#39; U)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Making [abses_pullback&#39;] opaque speeds up the following proof. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> abses_pullback&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk75"><span class="kn">Local Definition</span> <span class="nf">eq_cxfib_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B} (U : AbSES C A)
  : cxfib (iscomplex_pullback_abses E) U = equiv_hfiber_abses _ _ (cxfib&#39; E U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (cxfib&#39; E U)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (cxfib&#39; E U)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk77">srapply path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cxfib (iscomplex_pullback_abses E) U).<span class="mi">1</span> =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk78"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES E A =&gt;
   abses_pullback_pmap (inclusion E) x = pt) <span class="nl">?p</span>
  (cxfib (iscomplex_pullback_abses E) U).<span class="mi">2</span> =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk79"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES E A =&gt;
   abses_pullback_pmap (inclusion E) x = pt) <span class="mi">1</span>
  (cxfib (iscomplex_pullback_abses E) U).<span class="mi">2</span> =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7a">nrefine (concat_p1 _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_pointed_compose (abses_pullback&#39; (projection E))
   (abses_pullback&#39; (inclusion E)) @*
 (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_ptransformation_phomotopy
    <span class="kr">in</span>
  X
    (iscomplex_abses_pullback&#39; (inclusion E)
       (projection E) (iscomplex_abses E)))) U =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7b">nrefine (concat_1p _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_ptransformation_phomotopy <span class="kr">in</span>
 X
   (iscomplex_abses_pullback&#39; (inclusion E)
      (projection E) (iscomplex_abses E))) U =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7c"><span class="nb">cbn</span> zeta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
(equiv_hfiber_abses (abses_pullback (inclusion E)) pt
   (cxfib&#39; E U)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7d"><span class="nb">unfold</span> equiv_hfiber_abses, equiv_functor_sigma_id, equiv_functor_sigma&#39;, equiv_functor_sigma, equiv_fun, functor_sigma, <span class="s2">&quot;.2&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The goal looks identical to [pr2_cxfib&#39;], but the implicit argument to [@paths] is expressed differently, which is why the next line isn&#39;t faster. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@pr2_cxfib&#39; _ A B C E U).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Transparent</span> abses_pullback&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7e"><span class="kn">Definition</span> <span class="nf">equiv_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
  : hfiber_cxfib&#39; E F p &lt;~&gt; hfiber (cxfib (iscomplex_pullback_abses E))
                  (equiv_hfiber_abses _ pt (F;p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39; E F p &lt;~&gt;
hfiber (cxfib (iscomplex_pullback_abses E))
  (equiv_hfiber_abses (abses_pullback (inclusion E))
     pt (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39; E F p &lt;~&gt;
hfiber (cxfib (iscomplex_pullback_abses E))
  (equiv_hfiber_abses (abses_pullback (inclusion E))
     pt (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk80">srapply equiv_functor_sigma_id; <span class="nb">intro</span> U; <span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_abses_path (cxfib&#39; E U) (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk81"><span class="nb">refine</span> (_ oE equiv_hfiber_abses_pullback _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib&#39; E U = (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk82"><span class="nb">refine</span> (_ oE equiv_ap&#39; (equiv_hfiber_abses _ pt) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (cxfib&#39; E U) =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk83"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback (inclusion E)) pt
  (cxfib&#39; E U)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eq_cxfib_cxfib&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The type of paths in [hfiber_cxfib&#39;] in terms of path data. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk84"><span class="kn">Definition</span> <span class="nf">path_hfiber_cxfib&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup} {<span class="nv">E</span> : AbSES C B}
           {<span class="nv">F</span> : AbSES (middle E) A} {<span class="nv">p</span> : abses_pullback (inclusion E) F $== pt}
           (<span class="nv">X</span> <span class="nv">Y</span> : hfiber_cxfib&#39; (B:=B) E F p)
  : <span class="kt">Type</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk86"><span class="nb">refine</span> (sig (<span class="kr">fun</span> <span class="nv">q0</span> : X.<span class="mi">1</span> $== Y.<span class="mi">1</span> =&gt; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>X.<span class="mi">1</span> $== Y.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fmap (abses_pullback (projection E)) q0)^$ $@ X.<span class="mi">2</span>.<span class="mi">1</span> $== Y.<span class="mi">2</span>.<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk87"><span class="kn">Definition</span> <span class="nf">transport_hfiber_abses_path_cxfib&#39;_l</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
           (U V : hfiber_cxfib&#39; E F p) (q : U.<span class="mi">1</span> = V.<span class="mi">1</span>)
  : (transport (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt; hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span>
    = fmap (abses_pullback (projection E)) (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ U.<span class="mi">2</span>.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>U.<span class="mi">1</span> = V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>U.<span class="mi">1</span> = V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk89"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) <span class="mi">1</span> U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8a"><span class="nb">refine</span> (ap pr1 (transport_1 _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8b"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; fmap (abses_pullback (projection E)) x $@ _) equiv_path_absesV_1^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback (projection E)) (Id U.<span class="mi">1</span>) $@
(U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8c"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x $@ _) (fmap_id_strong _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(U.<span class="mi">2</span>).<span class="mi">1</span> =
Id (abses_pullback (projection E) U.<span class="mi">1</span>) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cat_idr_strong _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8d"><span class="kn">Definition</span> <span class="nf">equiv_path_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
           (U V : hfiber_cxfib&#39; E F p)
  : path_hfiber_cxfib&#39; U V &lt;~&gt; U = V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; U V &lt;~&gt; U = V</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; U V &lt;~&gt; U = V</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8f"><span class="nb">refine</span> (equiv_path_sigma _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; U V &lt;~&gt;
{p0 : U.<span class="mi">1</span> = V.<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
   hfiber_abses_path (cxfib&#39; E Y) (F; p)) p0 U.<span class="mi">2</span> = V.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk90">srapply (equiv_functor_sigma&#39; equiv_path_abses_iso);
    <span class="nb">intro</span> q; <span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
   hfiber_abses_path (cxfib&#39; E Y) (F; p))
  (equiv_path_abses_iso q) U.<span class="mi">2</span> = V.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk91"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p))
   (equiv_path_abses_iso q) U.<span class="mi">2</span>).<span class="mi">1</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk92"><span class="nb">refine</span> (equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p))
   (equiv_path_abses_iso q) U.<span class="mi">2</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk93"><hr></label><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk94"><span class="mi">1</span>: <span class="nb">apply</span> transport_hfiber_abses_path_cxfib&#39;_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
fmap (abses_pullback (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
(U.<span class="mi">2</span>).<span class="mi">1</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk95"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
 (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk96"><hr></label><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = ((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk97"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
 (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk98"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (fmap (abses_pullback _) x $@ _).<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^ =
<span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk99">nrefine (ap _ (abses_path_data_V q) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span>
  (equiv_path_abses_iso (abses_path_data_inverse q)) =
<span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
(fmap (abses_pullback (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> =
((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9b"><span class="nb">refine</span> (equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk9c"><hr></label><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = ((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9d"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9e"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x $@ _).<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback (projection E))
  (abses_path_data_inverse q) = <span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input">tapply gpd_strong_1functor_V.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
((fmap (abses_pullback (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> =
((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The fibre of [cxfib&#39;] over [(F;p)] is inhabited. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka0"><span class="kn">Definition</span> <span class="nf">hfiber_cxfib&#39;_inhabited</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
  : hfiber_cxfib&#39; E F p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39; E F p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39; E F p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka2"><span class="kr">exists</span> (<span class="nv">abses_pullback_trivial_preimage</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">p</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_abses_path
  (cxfib&#39; E (abses_pullback_trivial_preimage E F p))
  (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka3">srefine (_^$; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(F; p).<span class="mi">1</span> $-&gt;
(cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chka4"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">p0</span> : (cxfib&#39; E
           (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $-&gt;
        (F; p).<span class="mi">1</span> =&gt;
 (fmap (abses_pullback (inclusion E)) p0)^$ $@
 (cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
 (F; p).<span class="mi">2</span>) <span class="nl">?Goal</span>^$</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka5"><span class="mi">1</span>: <span class="bp">by</span> rapply (abses_pullback_component1_id&#39; (abses_pullback_inclusion0_map&#39; E F p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">p0</span> : (cxfib&#39; E
           (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $-&gt;
        (F; p).<span class="mi">1</span> =&gt;
 (fmap (abses_pullback (inclusion E)) p0)^$ $@
 (cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
 (F; p).<span class="mi">2</span>)
  (abses_pullback_component1_id&#39;
     (abses_pullback_inclusion0_map&#39; E F p)
     (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka6"><span class="nb">lazy</span> beta; <span class="nb">unfold</span> pr2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (inclusion E))
   (abses_pullback_component1_id&#39;
      (abses_pullback_inclusion0_map&#39; E F p)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$ $@
(cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka7"><span class="nb">refine</span> (cat_assoc _ _ _ $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $@
symmetric_GpdHom pt
  (abses_pullback grp_homo_const
     (abses_pullback_trivial_preimage E F p))
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback (inclusion E))
    (abses_pullback_component1_id&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$) $== p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka8"><span class="nb">refine</span> (cat_assoc _ _ _ $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">symmetric_GpdHom pt
  (abses_pullback grp_homo_const
     (abses_pullback_trivial_preimage E F p))
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)) $o
(abses_pullback_homotopic&#39;
   (projection E $o inclusion E) grp_homo_const
   (iscomplex_abses E)
   (abses_pullback_trivial_preimage E F p) $o
 (abses_pullback_compose&#39; (inclusion E) (projection E)
    (abses_pullback_trivial_preimage E F p) $o
  (fmap (abses_pullback (inclusion E))
     (abses_pullback_component1_id&#39;
        (abses_pullback_inclusion0_map&#39; E F p)
        (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$)) $== p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka9"><span class="nb">apply</span> gpd_moveR_Vh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback (inclusion E))
    (abses_pullback_component1_id&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$) $==
abses_pullback_const&#39;
  (abses_pullback_trivial_preimage E F p) $o p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkaa"><span class="nb">apply</span> gpd_moveL_hM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback (inclusion E))
    (abses_pullback_component1_id&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$) $o p^$ $==
abses_pullback_const&#39;
  (abses_pullback_trivial_preimage E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkab"><span class="nb">apply</span> equiv_ab_biprod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((abses_pullback_homotopic&#39;
     (projection E $o inclusion E) grp_homo_const
     (iscomplex_abses E)
     (abses_pullback_trivial_preimage E F p) $o
   (abses_pullback_compose&#39; (inclusion E)
      (projection E)
      (abses_pullback_trivial_preimage E F p) $o
    (fmap (abses_pullback (inclusion E))
       (abses_pullback_component1_id&#39;
          (abses_pullback_inclusion0_map&#39; E F p)
          (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$) $o p^$).<span class="mi">1</span> $o
  ab_biprod_inl ==
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $o
  ab_biprod_inl) *
 ((abses_pullback_homotopic&#39;
     (projection E $o inclusion E) grp_homo_const
     (iscomplex_abses E)
     (abses_pullback_trivial_preimage E F p) $o
   (abses_pullback_compose&#39; (inclusion E)
      (projection E)
      (abses_pullback_trivial_preimage E F p) $o
    (fmap (abses_pullback (inclusion E))
       (abses_pullback_component1_id&#39;
          (abses_pullback_inclusion0_map&#39; E F p)
          (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))^$)^$) $o p^$).<span class="mi">1</span> $o
  ab_biprod_inr ==
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $o
  ab_biprod_inr))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkac"><span class="nb">split</span>; <span class="nb">apply</span> equiv_path_pullback_rec_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, group_unit)))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y)) (inclusion F x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkad"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, group_unit))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; group_unit)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkae"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x)))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x0)))
      (- x + y)) (inclusion F group_unit))</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkaf"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x))) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, group_unit)))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y)) (inclusion F x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb1"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
   hfiber
     (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
      pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x0)))
     (- x + y))
  (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, group_unit))) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
   hfiber
     (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
      pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x0)))
     (- x + y)) (inclusion F a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (class_of _ o pullback_pr1) (fst p^$.<span class="mi">2</span> a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, group_unit))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb3"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, group_unit)) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((snd p^$.<span class="mi">2</span> _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x1)))
      (- x0 + y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x)))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x0)))
      (- x + y)) (inclusion F group_unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb5"><span class="nb">intro</span> b; <span class="nb">apply</span> qglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_cosetL
  {|
    normalsubgroup_subgroup :=
      grp_image_embedding
        (abses_pullback_inclusion_transpose_map
           (inclusion E) F p);
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (grp_image_embedding
           (abses_pullback_inclusion_transpose_map
              (inclusion E) F p))
  |} (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, b)))
  (inclusion F group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb6"><span class="kr">exists</span> (-b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_inclusion_transpose_map (inclusion E) F
  p (- b) =
- pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, b)) +
inclusion F group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb7"><span class="nb">apply</span> grp_moveL_Vg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, b)) +
abses_pullback_inclusion_transpose_map (inclusion E) F
  p (- b) = inclusion F group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb8"><span class="nb">refine</span> ((grp_homo_op (grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span> $o ab_biprod_inr) _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span> $o ab_biprod_inr) (b - b) =
inclusion F group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (right_inverse _) @ grp_homo_unit _ @ (grp_homo_unit _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, x))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkba"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (group_unit, b)) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd p^$.<span class="mi">2</span> _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** To conclude exactness in terms of path data, we show that the fibre is a proposition, hence contractible. *)</span>

<span class="sd">(** Given a point [(Y;Q)] in the fiber of [cxfib&#39;] over [(F;p)] there is an induced map as follows. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbb"><span class="kn">Local Definition</span> <span class="nf">hfiber_cxfib&#39;_induced_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup} (<span class="nv">E</span> : AbSES C B)
      (<span class="nv">F</span> : AbSES (middle E) A) (<span class="nv">p</span> : abses_pullback (inclusion E) F $== pt)
      (<span class="nv">Y</span> : hfiber_cxfib&#39; E F p)
  : ab_biprod A B $-&gt; abses_pullback (projection E) Y.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod A B $-&gt; abses_pullback (projection E) Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod A B $-&gt; abses_pullback (projection E) Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbd"><span class="nb">destruct</span> Y <span class="kr">as</span> [Y q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod A B $-&gt;
abses_pullback (projection E) (Y; q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbe"><span class="nb">refine</span> (grp_homo_compose _ (grp_iso_inverse p.<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (abses_pullback (inclusion E) F)
  (abses_pullback (projection E) (Y; q).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbf"><span class="nb">refine</span> (_ $o grp_pullback_pr1 _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F $-&gt; abses_pullback (projection E) (Y; q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q.<span class="mi">1</span>^$.<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** There is &quot;another&quot; obvious induced map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc0"><span class="kn">Definition</span> <span class="nf">abses_pullback_splits_induced_map&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
           (<span class="nv">E</span> : AbSES C B) (<span class="nv">Y</span> : AbSES C A)
  : ab_biprod A B $-&gt; abses_pullback (projection E) Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod A B $-&gt; abses_pullback (projection E) Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod A B $-&gt; abses_pullback (projection E) Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc2">srapply (ab_biprod_rec (inclusion _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; abses_pullback (projection E) Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc3">srapply grp_pullback_corec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkc4"><hr></label><div class="goal-conclusion">B $-&gt; E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkc5"><hr></label><div class="goal-conclusion">projection Y o <span class="nl">?b</span> == projection E o <span class="nl">?c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_homo_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inclusion E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection Y o grp_homo_const ==
projection E o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc9"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection Y (grp_homo_const x) =
projection E (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkca"><span class="nb">refine</span> (grp_homo_unit _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = projection E (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcb"><span class="kn">Lemma</span> <span class="nf">fmap_hfiber_abses_lemma</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B)
           (X Y : graph_hfiber (abses_pullback (A:=A) f) pt) (Q : hfiber_abses_path X Y)
  : fmap (abses_pullback f) Q.<span class="mi">1</span>^$ $o Y.<span class="mi">2</span>^$ $== X.<span class="mi">2</span>^$.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcd"><span class="nb">generalize</span> Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Q</span> : hfiber_abses_path X Y,
fmap (abses_pullback f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkce">equiv_intro (equiv_hfiber_abses_pullback _ X Y)^-<span class="mi">1</span>%equiv p;
    <span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $o
(X.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcf"><span class="nb">refine</span> ((_ $@R _) $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $==
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkd0"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> $o (X.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $==
<span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd2"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $==
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkd3"><hr></label><div class="goal-conclusion">abses_pullback f X.<span class="mi">1</span> $-&gt; abses_pullback f X.<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd4"><span class="mi">2</span>: <span class="bp">exact</span> (Id _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $==
Id (abses_pullback f X.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd5"><span class="nb">refine</span> (fmap2 _ _ $@ fmap_id _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((equiv_hfiber_abses_pullback pt X X)^-<span class="mi">1</span>%equiv <span class="mi">1</span>).<span class="mi">1</span>)^$ $==
Id X.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) pt</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path X X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Id (abses_pullback f X.<span class="mi">1</span>) $o (X.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cat_idl _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd7"><span class="kn">Lemma</span> <span class="nf">induced_map_eq</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
      (Y : hfiber_cxfib&#39; E F p)
  : hfiber_cxfib&#39;_induced_map E F p Y == abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39;_induced_map E F p Y ==
abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39;_induced_map E F p Y ==
abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd9"><span class="nb">intros</span> [a b]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((Y.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span>)^-<span class="mi">1</span> (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, b))) =
grp_pullback_sgop (projection Y.<span class="mi">1</span>) (projection E)
  (inclusion Y.<span class="mi">1</span> a; group_unit;
  cx_isexact a @ (grp_homo_unit (projection E))^)
  (group_unit; inclusion E b;
  grp_homo_unit (projection Y.<span class="mi">1</span>) @
  (iscomplex_abses E b)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkda"><span class="nb">refine</span> (ap pullback_pr1 (fmap_hfiber_abses_lemma _ _ (F;p) Y.<span class="mi">2</span> _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_pr1 ((((cxfib&#39; E Y.<span class="mi">1</span>).<span class="mi">2</span>)^$).<span class="mi">1</span> (a, b)) =
grp_pullback_sgop (projection Y.<span class="mi">1</span>) (projection E)
  (inclusion Y.<span class="mi">1</span> a; group_unit;
  cx_isexact a @ (grp_homo_unit (projection E))^)
  (group_unit; inclusion E b;
  grp_homo_unit (projection Y.<span class="mi">1</span>) @
  (iscomplex_abses E b)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdb">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion Y.<span class="mi">1</span> a = inclusion Y.<span class="mi">1</span> a + group_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkdc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkdc"><hr></label><div class="goal-conclusion">inclusion E b = group_unit + inclusion E b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion Y.<span class="mi">1</span> a = inclusion Y.<span class="mi">1</span> a + group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_r _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkde">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E b = group_unit + inclusion E b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_l _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given another point [(Y,Q)] in the fibre of [cxfib&#39;] over [(F;p)], we get path data in [AbSES C A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdf"><span class="kn">Lemma</span> <span class="nf">hfiber_cxfib&#39;_induced_path&#39;0</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
      (Y : hfiber_cxfib&#39; E F p)
  : abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke1"><span class="nb">destruct</span> Y <span class="kr">as</span> [Y Q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_trivial_preimage E F p $== (Y; Q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke2"><span class="nb">apply</span> abses_path_data_to_iso;
    srefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_trivial_preimage E F p $-&gt; (Y; Q).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chke3"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o
inclusion (abses_pullback_trivial_preimage E F p) ==
inclusion (Y; Q).<span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chke4"><hr></label><div class="goal-conclusion">projection (abses_pullback_trivial_preimage E F p) ==
projection (Y; Q).<span class="mi">1</span> $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_trivial_preimage E F p $-&gt; (Y; Q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke6">snapply (ab_cokernel_embedding_rec _ (grp_pullback_pr1 _ _$o (Q.<span class="mi">1</span>^$).<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is01Cat Group</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chke7"><hr></label><div class="goal-conclusion">Is01Cat (AbSES E A)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chke8"><hr></label><div class="goal-conclusion">Is0Gpd (AbSES E A)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chke9"><hr></label><div class="goal-conclusion">grp_homo_compose
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) $== grp_homo_const</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkea"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) $== grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkeb"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p) f = grp_homo_const f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkec">nrefine (ap _ (induced_map_eq E F p (Y;Q) _) @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion Y group_unit + group_unit = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_r _ @ grp_homo_unit _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  ((<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y)
     :
     grp_pullback_pr1 (projection Y) (projection E)
       (abses_pullback_splits_induced_map&#39; E (Y; Q).<span class="mi">1</span>
          (ab_biprod_inr f)) = grp_homo_const f))
   :
   grp_homo_compose
     (grp_pullback_pr1 (projection Y) (projection E) $o
      ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p) $== grp_homo_const) $o
inclusion (abses_pullback_trivial_preimage E F p) ==
inclusion (Y; Q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkee"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))) $o
 inclusion (abses_pullback_trivial_preimage E F p)) a =
inclusion (Y; Q).<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkef"><span class="nb">refine</span> (_ @ ap (grp_pullback_pr1 _ _) (fst (Q.<span class="mi">1</span>^$).<span class="mi">2</span> a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))) $o
 inclusion (abses_pullback_trivial_preimage E F p)) a =
grp_pullback_pr1 (projection Y) (projection E)
  ((((Q.<span class="mi">1</span>)^$).<span class="mi">1</span> $o inclusion (F; p).<span class="mi">1</span>) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_quotient_rec_beta&#39; _ F _ _ (inclusion F a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback_trivial_preimage E F p) ==
projection (Y; Q).<span class="mi">1</span> $o
ab_cokernel_embedding_rec
  (abses_pullback_inclusion_transpose_map
     (inclusion E) F p)
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  ((<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y)
     :
     grp_pullback_pr1 (projection Y) (projection E)
       (abses_pullback_splits_induced_map&#39; E (Y; Q).<span class="mi">1</span>
          (ab_biprod_inr f)) = grp_homo_const f))
   :
   grp_homo_compose
     (grp_pullback_pr1 (projection Y) (projection E) $o
      ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
     (abses_pullback_inclusion_transpose_map
        (inclusion E) F p) $== grp_homo_const)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf1">napply (conn_map_elim _ grp_quotient_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap <span class="nl">?Goal</span> grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkf2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : QuotientGroup F
      {|
        normalsubgroup_subgroup :=
          grp_image_embedding
            (abses_pullback_inclusion_transpose_map
               (inclusion E) F p);
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (grp_image_embedding
               (abses_pullback_inclusion_transpose_map
                  (inclusion E) F p))
      |},
In <span class="nl">?Goal</span>
  (projection (abses_pullback_trivial_preimage E F p)
     b =
   (projection (Y; Q).<span class="mi">1</span> $o
    ab_cokernel_embedding_rec
      (abses_pullback_inclusion_transpose_map
         (inclusion E) F p)
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
      (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
       ap
         (grp_pullback_pr1 (projection Y)
            (projection E))
         (induced_map_eq E F p (Y; Q)
            (ab_biprod_inr f)) @
       (grp_unit_r (inclusion Y <span class="mi">0</span>) @
        grp_homo_unit (inclusion Y)))) b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkf3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))))
  (grp_quotient_map a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf4"><span class="mi">1</span>: <span class="nb">apply</span> issurj_class_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : QuotientGroup F
      {|
        normalsubgroup_subgroup :=
          grp_image_embedding
            (abses_pullback_inclusion_transpose_map
               (inclusion E) F p);
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (grp_image_embedding
               (abses_pullback_inclusion_transpose_map
                  (inclusion E) F p))
      |},
In (Tr (-<span class="mi">1</span>))
  (projection (abses_pullback_trivial_preimage E F p)
     b =
   (projection (Y; Q).<span class="mi">1</span> $o
    ab_cokernel_embedding_rec
      (abses_pullback_inclusion_transpose_map
         (inclusion E) F p)
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
      (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
       ap
         (grp_pullback_pr1 (projection Y)
            (projection E))
         (induced_map_eq E F p (Y; Q)
            (ab_biprod_inr f)) @
       (grp_unit_r (inclusion Y <span class="mi">0</span>) @
        grp_homo_unit (inclusion Y)))) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chkf5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))))
  (grp_quotient_map a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf6"><span class="mi">1</span>: <span class="nb">intros</span> ?; <span class="nb">apply</span> istrunc_paths; <span class="nb">apply</span> group_isgroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))))
  (grp_quotient_map a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf7"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map f) =
(projection (Y; Q).<span class="mi">1</span> $o
 ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))))
  (grp_quotient_map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf8"><span class="nb">refine</span> (ap (projection E) (snd (Q.<span class="mi">1</span>^$).<span class="mi">2</span> f) @ _); <span class="nb">unfold</span> pr1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E
  ((projection (cxfib&#39; E Y).<span class="mi">1</span> $o ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) f) =
(projection Y $o
 ab_cokernel_embedding_rec
   (abses_pullback_inclusion_transpose_map
      (inclusion E) F p)
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">f</span> : B =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E))
      (induced_map_eq E F p (Y; Q) (ab_biprod_inr f)) @
    (grp_unit_r (inclusion Y <span class="mi">0</span>) @
     grp_homo_unit (inclusion Y))))
  (grp_quotient_map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pullback_commsq _ _ ((Q.<span class="mi">1</span>^$).<span class="mi">1</span> f))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf9"><span class="kn">Lemma</span> <span class="nf">hfiber_cxfib&#39;_induced_path&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
      (Y : hfiber_cxfib&#39; E F p)
  : path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfb"><span class="kr">exists</span> (<span class="nv">hfiber_cxfib&#39;_induced_path&#39;0</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">p</span> <span class="nv">Y</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $@
((hfiber_cxfib&#39;_inhabited E F p).<span class="mi">2</span>).<span class="mi">1</span> $== (Y.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfc">tapply gpd_moveR_Vh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $==
abses_pullback_component1_id&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o (Y.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfd">tapply gpd_moveL_hM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $o
((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$ $==
abses_pullback_component1_id&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfe">rapply gpd_moveR_Vh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$ $==
fmap (abses_pullback (projection E))
  (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
abses_pullback_component1_id&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkff"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F; p).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x =
(fmap (abses_pullback (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
 abses_pullback_component1_id&#39;
   (abses_pullback_inclusion0_map&#39; E F p)
   (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)).<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk100">srapply equiv_path_pullback_hset; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F; p).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">1</span> =
((fmap (abses_pullback (projection E))
    (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
  abses_pullback_component1_id&#39;
    (abses_pullback_inclusion0_map&#39; E F p)
    (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)).<span class="mi">1</span> x).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F; p).<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk101"><hr></label><div class="goal-conclusion">(((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">2</span>).<span class="mi">1</span> =
(((fmap (abses_pullback (projection E))
     (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
   abses_pullback_component1_id&#39;
     (abses_pullback_inclusion0_map&#39; E F p)
     (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)).<span class="mi">1</span> x).<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk102"><span class="mi">2</span>: <span class="bp">exact</span> (snd Y.<span class="mi">2</span>.<span class="mi">1</span>^$.<span class="mi">2</span> x)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>hfiber_cxfib&#39; E F p</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F; p).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">1</span> =
((fmap (abses_pullback (projection E))
    (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
  abses_pullback_component1_id&#39;
    (abses_pullback_inclusion0_map&#39; E F p)
    (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)).<span class="mi">1</span> x).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that [hfiber_cxfib&#39;] is contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk103"><span class="kn">Lemma</span> <span class="nf">contr_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== pt)
  : Contr (hfiber_cxfib&#39; E F p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber_cxfib&#39; E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk104"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber_cxfib&#39; E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk105">srapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39; E F p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk106" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk106"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : hfiber_cxfib&#39; E F p, <span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk107"><span class="mi">1</span>: <span class="nb">apply</span> hfiber_cxfib&#39;_inhabited.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : hfiber_cxfib&#39; E F p,
hfiber_cxfib&#39;_inhabited E F p = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk108"><span class="nb">intros</span> [Y q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_cxfib&#39;_inhabited E F p = (Y; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk109"><span class="nb">apply</span> equiv_path_hfiber_cxfib&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $== pt</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES C A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p)
  (Y; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> hfiber_cxfib&#39;_induced_path&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** From this we deduce exactness. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10a"><span class="kn">Instance</span> <span class="nf">isexact_abses_pullback</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
  : IsExact purely (abses_pullback_pmap (A:=A) (projection E)) (abses_pullback_pmap (inclusion E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact purely (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact purely (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10c">srapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk10d"><hr></label><div class="goal-conclusion">IsConnMap purely (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10e"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_pullback_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap purely (cxfib (iscomplex_pullback_abses E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10f">srapply (equiv_ind (equiv_hfiber_abses (abses_pullback (inclusion E)) (point (AbSES B A)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : graph_hfiber (abses_pullback (inclusion E)) pt,
(<span class="kr">fun</span> <span class="nv">y</span> : hfiber (abses_pullback (inclusion E)) pt =&gt;
 IsConnected purely
   (hfiber (cxfib (iscomplex_pullback_abses E)) y))
  (equiv_hfiber_abses (abses_pullback (inclusion E))
     pt x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk110"><span class="nb">intros</span> [F p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $-&gt; pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected purely
  (hfiber (cxfib (iscomplex_pullback_abses E))
     (equiv_hfiber_abses
        (abses_pullback (inclusion E)) pt (F; p)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk111">rapply contr_equiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $-&gt; pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt;
purely
  (hfiber (cxfib (iscomplex_pullback_abses E))
     (equiv_hfiber_abses
        (abses_pullback (inclusion E)) pt (F; p)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk112" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $-&gt; pt</span></span></span><br></div><label class="goal-separator" for="pullbackfibersequence-v-chk112"><hr></label><div class="goal-conclusion">Contr <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk113"><span class="mi">1</span>: <span class="nb">apply</span> equiv_hfiber_cxfib&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES E A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (inclusion E) F $-&gt; pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber_cxfib&#39; E F p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contr_hfiber_cxfib&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
