<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>BlakersMassey.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types HFiber.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Pushout.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.SpanPushout.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.Suspension.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Limits.Pullback.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.Join.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The Generalized Blakers-Massey Theorem *)</span>

<span class="sd">(** This file follows the paper &quot;A Generalized Blakers-Massey Theorem&quot; (https://arxiv.org/abs/1703.09050) by Mathieu Anel, Georg Biedermann, Eric Finster, Andr√© Joyal, hereafter referred to as ABFJ. We also follow &quot;A Mechanization of the Blakers-Massey Connectivity Theorem in Homotopy Type Theory&quot; by Favonia, Eric Finster, Dan Licata, and Peter LeFanu Lumsdaine, hereafter referred to as HFLL. *)</span>

<span class="sd">(** ** Path algebra helper lemma *)</span>

<span class="sd">(** Here is a strange-looking path algebra helper lemma that is easier to prove by lifting to a general case and doing a path-induction blast.  It says something about what happens when we transport from the center of a based path-space to some other point, assuming we know a particular way to &quot;compute&quot; the action of the type family in question. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1"><span class="kn">Definition</span> <span class="nf">transport_singleton</span> `{Univalence}
           {A : <span class="kt">Type</span>} {x : A} (B : <span class="kr">forall</span> (<span class="nv">y</span> : A), (x = y) -&gt; <span class="kt">Type</span>)
           {y : A} (p : x = y) (u : B x idpath)
           (f : <span class="kr">forall</span> (<span class="nv">q</span>:x=x), B x q &lt;~&gt; B y (q @ p))
           (ev : ap10 (apD B p) p =
   transport_arrow_toconst p (B x) p @
   path_universe_uncurried
     (@equiv_transport _ (B y) ((p @ p^) @ p) p (concat_pV_p p p)
      oE (f (p @ p^))
      oE @equiv_transport _ (B x)
           (transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; x = y) p^ p)
           (p @ p^) (transport_paths_r p^ p)))
  : transport (<span class="kr">fun</span> <span class="nv">yp</span>:{y:A &amp; x=y} =&gt; B yp.<span class="mi">1</span> yp.<span class="mi">2</span>)
              (path_contr (A := {y:A &amp; x=y}) (x;idpath) (y;p)) u
    = transport (B y) (concat_1p _) (f idpath u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B y (q @ p)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>ap10 (apD B p) p =
transport_arrow_toconst p (B x) p @
path_universe_uncurried
  (equiv_transport (B y) (concat_pV_p p p)
   oE f (p @ p^)
   oE equiv_transport (B x)
        (transport_paths_r p^ p))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">yp</span> : {y : A &amp; x = y} =&gt; B yp.<span class="mi">1</span> yp.<span class="mi">2</span>)
  (path_contr (x; <span class="mi">1</span>) (y; p)) u =
transport (B y) (concat_1p p) (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B y (q @ p)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>ap10 (apD B p) p =
transport_arrow_toconst p (B x) p @
path_universe_uncurried
  (equiv_transport (B y) (concat_pV_p p p)
   oE f (p @ p^)
   oE equiv_transport (B x)
        (transport_paths_r p^ p))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">yp</span> : {y : A &amp; x = y} =&gt; B yp.<span class="mi">1</span> yp.<span class="mi">2</span>)
  (path_contr (x; <span class="mi">1</span>) (y; p)) u =
transport (B y) (concat_1p p) (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3"><span class="nb">destruct</span> p; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> =
<span class="mi">1</span> @
path_universe_uncurried
  (equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
   oE equiv_transport (B x) <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4"><span class="nb">apply</span> (<span class="kr">fun</span> <span class="nv">e</span> =&gt; e @ concat_1p _) <span class="kr">in</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> =
path_universe_uncurried
  (equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
   oE equiv_transport (B x) <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk5"><span class="nb">apply</span> moveR_equiv_V <span class="kr">in</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>((equiv_path (B x <span class="mi">1</span>) (B x <span class="mi">1</span>))^-<span class="mi">1</span> o idmap)^-<span class="mi">1</span> <span class="mi">1</span> =
equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
oE equiv_transport (B x) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6"><span class="nb">apply</span> (ap equiv_fun) <span class="kr">in</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>((equiv_path (B x <span class="mi">1</span>) (B x <span class="mi">1</span>))^-<span class="mi">1</span> o idmap)^-<span class="mi">1</span> <span class="mi">1</span> =
equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
oE equiv_transport (B x) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7"><span class="nb">apply</span> ap10 <span class="kr">in</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>((equiv_path (B x <span class="mi">1</span>) (B x <span class="mi">1</span>))^-<span class="mi">1</span> o idmap)^-<span class="mi">1</span> <span class="mi">1</span> ==
equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
oE equiv_transport (B x) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8"><span class="nb">specialize</span> (ev u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>((equiv_path (B x <span class="mi">1</span>) (B x <span class="mi">1</span>))^-<span class="mi">1</span> o idmap)^-<span class="mi">1</span> <span class="mi">1</span> u =
(equiv_transport (B x) <span class="mi">1</span> oE f <span class="mi">1</span>%path
 oE equiv_transport (B x) <span class="mi">1</span>) u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9"><span class="nb">cbn</span> <span class="kr">in</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B x <span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : x = x, B x q &lt;~&gt; B x (q @ <span class="mi">1</span>)</span></span></span><br><span><var>ev</var><span class="hyp-type"><b>: </b><span>u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = transport (B x) <span class="mi">1</span> (f <span class="mi">1</span> u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ev.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Setup *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GBM</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">Q</span> : X -&gt; Y -&gt; <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here&#39;s the hypothesis of ABFJ&#39;s generalized Blakers-Massey theorem.  It works for any reflective subuniverse, not only modalities!  In the application, [O] will be [Tr (n +2+ m)] and we&#39;ll use [isconnected_join] to verify [isconnected_cogap]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : ReflectiveSubuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      (<span class="nv">isconnected_cogap</span> :
         <span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) (<span class="nv">y2</span> <span class="nv">y4</span> : Y)
                (<span class="nv">q12</span> : Q x1 y2) (<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
           IsConnected O (Join ((x1;q12) = (x3;q32) :&gt; {x:X &amp; Q x y2})
                               ((y2;q32) = (y4;q34) :&gt; {y:Y &amp; Q x3 y}))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">P</span> := SPushout Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">left</span> := (spushl Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">right</span> := (spushr Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">glue</span> := (spglue Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here&#39;s a lemma that&#39;s a sort of &quot;singleton contractibility&quot; equivalence, but expressed in a particularly strange way.  As we&#39;ll see, this form of the lemma comes up naturally *twice* in the proof, and proving it once here to use in both places is crucial so that the two uses can be identified later on. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka"><span class="kn">Local Definition</span> <span class="nf">frobnicate</span> {<span class="nv">x0</span> <span class="nv">x1</span> : X} (<span class="nv">r</span> : <span class="nb">left</span> x0 = <span class="nb">left</span> x1)
          (<span class="nv">s</span> : x0 = x1) (<span class="nv">y</span> : Y) (<span class="nv">q1</span> : Q x1 y)
      : {q0 : Q x0 y &amp;
              {w : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x y) s q0 = q1 &amp;
                   glue q0 @ (glue q1)^ = r } }
          &lt;~&gt; ap <span class="nb">left</span> s = r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q0 : Q x0 y &amp;
{_ : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y) s q0 = q1 &amp;
glue q0 @ (glue q1)^ = r}} &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q0 : Q x0 y &amp;
{_ : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y) s q0 = q1 &amp;
glue q0 @ (glue q1)^ = r}} &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc"><span class="nb">refine</span> (_ oE equiv_sigma_assoc&#39; _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{ap
: {a : Q x0 y &amp;
  transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y) s a = q1} &amp;
glue ap.<span class="mi">1</span> @ (glue q1)^ = r} &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkd"><span class="nb">refine</span> (_ oE equiv_functor_sigma&#39;
                (Q := <span class="kr">fun</span> <span class="nv">qt</span> =&gt; glue qt.<span class="mi">1</span> @ (glue q1)^ = r)
                (equiv_functor_sigma_id
                   (<span class="kr">fun</span> <span class="nv">q0</span> : Q x0 y =&gt;
                      equiv_moveL_transport_V
                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x y) s q0 q1))
                (<span class="kr">fun</span> <span class="nv">qt</span> =&gt; equiv_idmap)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{qt
: {q0 : Q x0 y &amp;
  q0 = transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y) s^ q1} &amp;
glue qt.<span class="mi">1</span> @ (glue q1)^ = r} &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chke"><span class="nb">refine</span> (_ oE equiv_contr_sigma _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue (transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y) s^ q1) @
(glue q1)^ = r &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkf"><span class="nb">rewrite</span> (ap_transport s^ (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">q</span> =&gt; glue q) q1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="nb">left</span> x = <span class="nb">right</span> y) s^ (glue q1) @
(glue q1)^ = r &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk10"><span class="nb">rewrite</span> (transport_paths_FlFr s^ (glue q1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((ap <span class="nb">left</span> s^)^ @ glue q1) @
 ap (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; <span class="nb">right</span> y) s^) @ (glue q1)^ = r &lt;~&gt;
ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk11"><span class="nb">rewrite</span> ap_V, inv_V, ap_const, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>Q x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap <span class="nb">left</span> s @ glue q1) @ (glue q1)^ = r &lt;~&gt;
ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_concat_l (concat_pp_V _ _)^ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Although we proved this lemma with [rewrite], we make it transparent, not so that *we* can reason about it, but so that Coq can evaluate it. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* But except in one place, we don&#39;t want it to try (otherwise things get really slow). *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> frobnicate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Codes *)</span>

    <span class="sd">(** *** Right-hand codes *)</span>

    <span class="sd">(** The right-hand codes family is easy. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">coderight</span> {<span class="nv">x0</span> : X} {<span class="nv">y</span> : Y} (<span class="nv">r</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y) : <span class="kt">Type</span>
      := O (hfiber glue r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** *** Left-hand codes *)</span>

    <span class="sd">(** We enhance the HFLL and ABFJ theorems by defining a version of code-left that doesn&#39;t depend on one map being surjective. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CodeLeft</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">x0</span> <span class="nv">x1</span> : X} (<span class="nv">r</span> : <span class="nb">left</span> x0 = <span class="nb">left</span> x1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
      <span class="sd">(** The left codes are themselves a pushout, of what is morally also a dependent span, but we formulate it as an ordinary pushout of projections between iterated Sigma-types, most of which we express as records for performance reasons.  The span is [codeleft1] &lt;- [codeleft0] -&gt; [codeleft2]. *)</span>

</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeleft1</span> : <span class="kt">Type</span>
        := { s : x0 = x1 &amp;
          <span class="c">(* v : *)</span> ap <span class="nb">left</span> s = r}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">codeleft2</span>
        := { codeleft2_y0  : Y ;
             codeleft2_q00 : Q x0 codeleft2_y0 ;
             codeleft2_q10 : Q x1 codeleft2_y0 ;
             codeleft2_u   : glue codeleft2_q00 @ (glue codeleft2_q10)^ = r }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">codeleft0</span>
        := { codeleft0_s   : x0 = x1 ;
             codeleft0_y0  : Y ;
             codeleft0_v   : ap <span class="nb">left</span> codeleft0_s = r ;
             codeleft0_q00 : Q x0 codeleft0_y0 ;
             codeleft0_q10 : Q x1 codeleft0_y0 ;
             codeleft0_w   : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x codeleft0_y0) codeleft0_s codeleft0_q00
                             = codeleft0_q10 ;
             codeleft0_u   : glue codeleft0_q00 @ (glue codeleft0_q10)^ = r ;
                   <span class="sd">(** Note the first use of frobnicate here. *)</span>
             codeleft0_d   : frobnicate r codeleft0_s codeleft0_y0 codeleft0_q10
                                        (codeleft0_q00 ; codeleft0_w ; codeleft0_u) = codeleft0_v }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk12"><span class="kn">Definition</span> <span class="nf">codeleft01</span> : codeleft0 -&gt; codeleft1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 -&gt; codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 -&gt; codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk14"><span class="nb">intros</span> [s y0 v q00 q10 w u d].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> s = r</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>q10</var><span class="hyp-type"><b>: </b><span>Q x1 y0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y0) s q00 = q10</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>glue q00 @ (glue q10)^ = r</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>frobnicate r s y0 q10 (q00; w; u) = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (s;v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk15"><span class="kn">Definition</span> <span class="nf">codeleft02</span> : codeleft0 -&gt; codeleft2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 -&gt; codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 -&gt; codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk17"><span class="nb">intros</span> [s y0 v q00 q10 w u d].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> s = r</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>q10</var><span class="hyp-type"><b>: </b><span>Q x1 y0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y0) s q00 = q10</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>glue q00 @ (glue q10)^ = r</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>frobnicate r s y0 q10 (q00; w; u) = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_codeleft2 y0 q00 q10 u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeleft</span> : <span class="kt">Type</span>
        := O (Pushout codeleft01 codeleft02).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
      <span class="sd">(** *** Codes for glue *)</span>

</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CodeGlue</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">y1</span> : Y} (<span class="nv">q11</span> : Q x1 y1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** We prove that codes respect glue as a chain of equivalences between types built from pushouts and double-pushouts.  The first step is to add the data of our hypothesized-to-be-connected type inside [codeleft2]. *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeleft2plus</span> :=
          {yqqu : codeleft2 &amp;
                  Join ((x0; codeleft2_q00 yqqu) = (x1; codeleft2_q10 yqqu)
                                           :&gt; {x:X &amp; Q x (codeleft2_y0 yqqu)})
                       ((codeleft2_y0 yqqu; codeleft2_q10 yqqu) = (y1; q11)
                                           :&gt; {y:Y &amp; Q x1 y})}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** Since this connected type is itself a join, hence a pushout, the second step is to distribute this and re-express the whole thing as another pushout of iterated Sigma-types (again mostly expressed as records for performance reasons). *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Ocodeleft2b</span>
        := { Ocodeleft2b_s   : x0 = x1 ;
             Ocodeleft2b_y0  : Y ;
             Ocodeleft2b_q00 : Q x0 Ocodeleft2b_y0 ;
             Ocodeleft2b_q10 : Q x1 Ocodeleft2b_y0 ;
             Ocodeleft2b_w   : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x Ocodeleft2b_y0) Ocodeleft2b_s Ocodeleft2b_q00
                               = Ocodeleft2b_q10 ;
             Ocodeleft2b_u   : glue Ocodeleft2b_q00 @ (glue Ocodeleft2b_q10)^ = r }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Ocodeleft2c</span>
          := { q01 : Q x0 y1 &amp;
            <span class="c">(* u: *)</span> glue q01 @ (glue q11)^ = r }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Ocodeleft2a</span>
        := { Ocodeleft2a_s   : x0 = x1 ;
             Ocodeleft2a_q01 : Q x0 y1 ;
             Ocodeleft2a_w   : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x y1) Ocodeleft2a_s Ocodeleft2a_q01 = q11 ;
             Ocodeleft2a_u   : glue Ocodeleft2a_q01 @ (glue q11)^ = r }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk18"><span class="kn">Definition</span> <span class="nf">Ocodeleft2ab</span> : Ocodeleft2a -&gt; Ocodeleft2b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a -&gt; Ocodeleft2b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a -&gt; Ocodeleft2b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1a"><span class="nb">intros</span> [s q01 w u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) s q01 = q11</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>glue q01 @ (glue q11)^ = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_Ocodeleft2b s y1 q01 q11 w u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1b"><span class="kn">Definition</span> <span class="nf">Ocodeleft2ac</span> : Ocodeleft2a -&gt; Ocodeleft2c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a -&gt; Ocodeleft2c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a -&gt; Ocodeleft2c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1d"><span class="nb">intros</span> [s q01 w u].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) s q01 = q11</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>glue q01 @ (glue q11)^ = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q01;u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** This proof is basically just rearranging Sigma-types/records and paths in Sigma-types and contracting based path spaces. *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1e"><span class="kn">Definition</span> <span class="nf">equiv_Ocodeleft2plus</span>
          : Pushout Ocodeleft2ab Ocodeleft2ac &lt;~&gt; codeleft2plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pushout Ocodeleft2ab Ocodeleft2ac &lt;~&gt; codeleft2plus</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pushout Ocodeleft2ab Ocodeleft2ac &lt;~&gt; codeleft2plus</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk20"><span class="nb">refine</span> ((equiv_sigma_pushout _ _ _ _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pushout Ocodeleft2ab Ocodeleft2ac &lt;~&gt;
Pushout
  (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; fst))
  (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk21">srefine (equiv_pushout _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt;
{x : codeleft2 &amp;
((x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)) *
((codeleft2_y0 x; codeleft2_q10 x) = (y1; q11))}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk22"><hr></label><div class="goal-conclusion">Ocodeleft2b &lt;~&gt;
{x : codeleft2 &amp;
(x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk23"><hr></label><div class="goal-conclusion">Ocodeleft2c &lt;~&gt;
{x : codeleft2 &amp;
(codeleft2_y0 x; codeleft2_q10 x) = (y1; q11)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk24"><hr></label><div class="goal-conclusion"><span class="nl">?eB</span> o Ocodeleft2ab ==
functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; fst) o <span class="nl">?eA</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk25"><hr></label><div class="goal-conclusion"><span class="nl">?eC</span> o Ocodeleft2ac ==
functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; snd) o <span class="nl">?eA</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt;
{x : codeleft2 &amp;
((x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)) *
((codeleft2_y0 x; codeleft2_q10 x) = (y1; q11))}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk27">srefine (equiv_functor_sigma_id _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft2 -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk28"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : codeleft2,
<span class="nl">?P</span> a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
 ((x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)) *
 ((codeleft2_y0 x; codeleft2_q10 x) = (y1; q11))) a</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk29"><hr></label><div class="goal-conclusion">Ocodeleft2a &lt;~&gt; {x : _ &amp; <span class="nl">?P</span> x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk2a"><span class="mi">2</span>:<span class="nb">intro</span>; <span class="nb">refine</span> (equiv_functor_prod&#39; _ _); <span class="nb">apply</span> equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt;
{a : codeleft2 &amp;
{p : (x0; codeleft2_q00 a).<span class="mi">1</span> = (x1; codeleft2_q10 a).<span class="mi">1</span>
&amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
  (x0; codeleft2_q00 a).<span class="mi">2</span> = (x1; codeleft2_q10 a).<span class="mi">2</span>} *
{p : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> = (y1; q11).<span class="mi">1</span>
&amp;
transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> = (y1; q11).<span class="mi">2</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2b &lt;~&gt;
{x : codeleft2 &amp;
(x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk2c">srefine (equiv_functor_sigma_id _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft2 -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk2d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : codeleft2,
<span class="nl">?P</span> a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
 (x0; codeleft2_q00 x) = (x1; codeleft2_q10 x)) a</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk2e"><hr></label><div class="goal-conclusion">Ocodeleft2b &lt;~&gt; {x : _ &amp; <span class="nl">?P</span> x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk2f"><span class="mi">2</span>:<span class="nb">intro</span>; <span class="nb">apply</span> equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2b &lt;~&gt;
{a : codeleft2 &amp;
{p : (x0; codeleft2_q00 a).<span class="mi">1</span> = (x1; codeleft2_q10 a).<span class="mi">1</span>
&amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
  (x0; codeleft2_q00 a).<span class="mi">2</span> = (x1; codeleft2_q10 a).<span class="mi">2</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2c &lt;~&gt;
{x : codeleft2 &amp;
(codeleft2_y0 x; codeleft2_q10 x) = (y1; q11)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk31">srefine (equiv_functor_sigma_id _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft2 -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk32"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : codeleft2,
<span class="nl">?P</span> a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
 (codeleft2_y0 x; codeleft2_q10 x) = (y1; q11)) a</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk33"><hr></label><div class="goal-conclusion">Ocodeleft2c &lt;~&gt; {x : _ &amp; <span class="nl">?P</span> x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk34"><span class="mi">2</span>:<span class="nb">intro</span>; <span class="nb">apply</span> equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2c &lt;~&gt;
{a : codeleft2 &amp;
{p : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> = (y1; q11).<span class="mi">1</span>
&amp;
transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> = (y1; q11).<span class="mi">2</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_sigma_id
  (<span class="kr">fun</span> <span class="nv">a</span> : codeleft2 =&gt;
   equiv_path_sigma
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
     (x0; codeleft2_q00 a) (x1; codeleft2_q10 a))
oE equiv_adjointify
     (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2b =&gt;
      (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
         (<span class="nv">H3</span> : Q x1 H1)
         (<span class="nv">H4</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H0 H2 =
               H3) (<span class="nv">H5</span> : glue H2 @ (glue H3)^ = r) =&gt;
       ({|
          codeleft2_y0 := H1 : Y;
          codeleft2_q00 := H2 : Q x0 (H1 : Y);
          codeleft2_q10 := H3 : Q x1 (H1 : Y);
          codeleft2_u :=
            H5
            :
            glue (H2 : Q x0 (H1 : Y)) @
            (glue (H3 : Q x1 (H1 : Y)))^ = r
        |}
        :
        codeleft2;
       (H0 : x0 = x1;
       H4
       :
       transport
         (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
          Q x
            (codeleft2_y0
               {|
                 codeleft2_y0 := H1;
                 codeleft2_q00 := H2;
                 codeleft2_q10 := H3;
                 codeleft2_u := H5
               |})) (H0 : x0 = x1)
         (codeleft2_q00
            {|
              codeleft2_y0 := H1;
              codeleft2_q00 := H2;
              codeleft2_q10 := H3;
              codeleft2_u := H5
            |}) =
       codeleft2_q10
         {|
           codeleft2_y0 := H1;
           codeleft2_q00 := H2;
           codeleft2_q10 := H3;
           codeleft2_u := H5
         |})
       :
       {p : x0 = x1 &amp;
       transport
         (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
          Q x
            (codeleft2_y0
               ({|
                  codeleft2_y0 := H1 : Y;
                  codeleft2_q00 := H2 : Q x0 ...;
                  codeleft2_q10 := H3 : Q x1 ...;
                  codeleft2_u := H5 : ... = r
                |}
                :
                codeleft2))) p
         (codeleft2_q00
            ({|
               codeleft2_y0 := H1 : Y;
               codeleft2_q00 := H2 : Q x0 (H1 : Y);
               codeleft2_q10 := H3 : Q x1 (H1 : Y);
               codeleft2_u :=
                 H5 : glue (...) @ (glue ...)^ = r
             |}
             :
             codeleft2)) =
       codeleft2_q10
         ({|
            codeleft2_y0 := H1 : Y;
            codeleft2_q00 := H2 : Q x0 (H1 : Y);
            codeleft2_q10 := H3 : Q x1 (H1 : Y);
            codeleft2_u :=
              H5
              :
              glue (H2 : Q x0 ...) @
              (glue (H3 : ...))^ = r
          |}
          :
          codeleft2)})
       :
       {a : codeleft2 &amp;
       {p
       : (x0; codeleft2_q00 a).<span class="mi">1</span> =
         (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
       transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
         (x0; codeleft2_q00 a).<span class="mi">2</span> =
       (x1; codeleft2_q10 a).<span class="mi">2</span>}}) (Ocodeleft2b_s H)
        (Ocodeleft2b_y0 H) (Ocodeleft2b_q00 H)
        (Ocodeleft2b_q10 H) (Ocodeleft2b_w H)
        (Ocodeleft2b_u H))
     (<span class="kr">fun</span>
        <span class="nv">H</span> : {a : codeleft2 &amp;
            {p
            : (x0; codeleft2_q00 a).<span class="mi">1</span> =
              (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
            transport
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
              (x0; codeleft2_q00 a).<span class="mi">2</span> =
            (x1; codeleft2_q10 a).<span class="mi">2</span>}} =&gt;
      (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
       (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
          (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
          (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                transport
                  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                   Q x
                     (codeleft2_y0
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |})) p
                  (codeleft2_q00
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |}) =
                codeleft2_q10
                  {|
                    codeleft2_y0 := H1;
                    codeleft2_q00 := H2;
                    codeleft2_q10 := H3;
                    codeleft2_u := H4
                  |}}) =&gt;
        (<span class="kr">fun</span> (<span class="nv">H6</span> : x0 = x1)
           (<span class="nv">H7</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H6 H2 =
                 H3) =&gt;
         {|
           Ocodeleft2b_s := H6 : x0 = x1;
           Ocodeleft2b_y0 := H1 : Y;
           Ocodeleft2b_q00 := H2 : Q x0 (H1 : Y);
           Ocodeleft2b_q10 := H3 : Q x1 (H1 : Y);
           Ocodeleft2b_w :=
             H7
             :
             transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (H1 : Y))
               (H6 : x0 = x1) (H2 : Q x0 (H1 : Y)) =
             (H3 : Q x1 (H1 : Y));
           Ocodeleft2b_u :=
             H4
             :
             glue (H2 : Q x0 (...)) @
             (glue (H3 : Q x1 ...))^ = r
         |}
         :
         Ocodeleft2b) H5.<span class="mi">1</span> H5.<span class="mi">2</span>) (codeleft2_y0 H0)
         (codeleft2_q00 H0) (codeleft2_q10 H0)
         (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
     ((<span class="kr">fun</span>
         <span class="nv">H</span> : {a : codeleft2 &amp;
             {p
             : (x0; codeleft2_q00 a).<span class="mi">1</span> =
               (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
               (x0; codeleft2_q00 a).<span class="mi">2</span> =
             (x1; codeleft2_q10 a).<span class="mi">2</span>}} =&gt;
       (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
        (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
           (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
           (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                 transport
                   (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                    Q x
                      (codeleft2_y0
                         {|
                           codeleft2_y0 := H1;
                           codeleft2_q00 := H2;
                           codeleft2_q10 := H3;
                           codeleft2_u := H4
                         |})) p
                   (codeleft2_q00
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}) =
                 codeleft2_q10
                   {|
                     codeleft2_y0 := H1;
                     codeleft2_q00 := H2;
                     codeleft2_q10 := H3;
                     codeleft2_u := H4
                   |}}) =&gt;
         (<span class="kr">fun</span> (<span class="nv">H6</span> : x0 = x1)
            (<span class="nv">H7</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H6
                    H2 = H3) =&gt; <span class="mi">1</span>%path) H5.<span class="mi">1</span> H5.<span class="mi">2</span>)
          (codeleft2_y0 H0) (codeleft2_q00 H0)
          (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
      :
      (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2b =&gt;
       (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
          (<span class="nv">H3</span> : Q x1 H1)
          (<span class="nv">H4</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H0 H2 =
                H3) (<span class="nv">H5</span> : glue H2 @ (glue H3)^ = r) =&gt;
        ({|
           codeleft2_y0 := H1 : Y;
           codeleft2_q00 := H2 : Q x0 (H1 : Y);
           codeleft2_q10 := H3 : Q x1 (H1 : Y);
           codeleft2_u :=
             H5
             :
             glue (H2 : Q x0 (...)) @
             (glue (H3 : Q x1 ...))^ = r
         |}
         :
         codeleft2;
        (H0 : x0 = x1;
        H4
        :
        transport
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
           Q x (codeleft2_y0 {| ...; ...; ...; ... |}))
          (H0 : x0 = x1)
          (codeleft2_q00
             {|
               codeleft2_y0 := H1;
               codeleft2_q00 := H2;
               codeleft2_q10 := H3;
               codeleft2_u := H5
             |}) =
        codeleft2_q10
          {|
            codeleft2_y0 := H1;
            codeleft2_q00 := H2;
            codeleft2_q10 := H3;
            codeleft2_u := H5
          |})
        :
        {p : x0 = x1 &amp;
        transport
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
           Q x (codeleft2_y0 ({| ... |} : codeleft2)))
          p
          (codeleft2_q00
             ({|
                codeleft2_y0 := H1 : Y;
                codeleft2_q00 := H2 : ...;
                codeleft2_q10 := H3 : ...;
                codeleft2_u := H5 : ...
              |}
              :
              codeleft2)) =
        codeleft2_q10
          ({|
             codeleft2_y0 := H1 : Y;
             codeleft2_q00 := H2 : Q x0 (...);
             codeleft2_q10 := H3 : Q x1 (...);
             codeleft2_u := H5 : ... @ ...^ = r
           |}
           :
           codeleft2)})
        :
        {a : codeleft2 &amp;
        {p
        : (x0; codeleft2_q00 a).<span class="mi">1</span> =
          (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
        transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
          p (x0; codeleft2_q00 a).<span class="mi">2</span> =
        (x1; codeleft2_q10 a).<span class="mi">2</span>}}) (Ocodeleft2b_s H)
         (Ocodeleft2b_y0 H) (Ocodeleft2b_q00 H)
         (Ocodeleft2b_q10 H) (Ocodeleft2b_w H)
         (Ocodeleft2b_u H))
      o (<span class="kr">fun</span>
           <span class="nv">H</span> : {a : codeleft2 &amp;
               {p
               : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                 (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
               transport
                 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
                 (x0; codeleft2_q00 a).<span class="mi">2</span> =
               (x1; codeleft2_q10 a).<span class="mi">2</span>}} =&gt;
         (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
          (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
             (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
             (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                   transport
                     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                      Q x (codeleft2_y0 {| ... |})) p
                     (codeleft2_q00
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) =
                   codeleft2_q10
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |}}) =&gt;
           (<span class="kr">fun</span> (<span class="nv">H6</span> : x0 = x1)
              (<span class="nv">H7</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H6
                      H2 = H3) =&gt;
            {|
              Ocodeleft2b_s := H6 : x0 = x1;
              Ocodeleft2b_y0 := H1 : Y;
              Ocodeleft2b_q00 := H2 : Q x0 (H1 : Y);
              Ocodeleft2b_q10 := H3 : Q x1 (H1 : Y);
              Ocodeleft2b_w :=
                H7
                :
                transport (...) (...) (...) =
                (H3 : ...);
              Ocodeleft2b_u :=
                H4 : glue ... @ (...)^ = r
            |}
            :
            Ocodeleft2b) H5.<span class="mi">1</span> H5.<span class="mi">2</span>) (codeleft2_y0 H0)
            (codeleft2_q00 H0) (codeleft2_q10 H0)
            (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>) == idmap)
     ((<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2b =&gt;
       (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
          (<span class="nv">H3</span> : Q x1 H1)
          (<span class="nv">H4</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H0 H2 =
                H3) (<span class="nv">H5</span> : glue H2 @ (glue H3)^ = r) =&gt;
        <span class="mi">1</span>%path) (Ocodeleft2b_s H) (Ocodeleft2b_y0 H)
         (Ocodeleft2b_q00 H) (Ocodeleft2b_q10 H)
         (Ocodeleft2b_w H) (Ocodeleft2b_u H))
      :
      (<span class="kr">fun</span>
         <span class="nv">H</span> : {a : codeleft2 &amp;
             {p
             : (x0; codeleft2_q00 a).<span class="mi">1</span> =
               (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
               (x0; codeleft2_q00 a).<span class="mi">2</span> =
             (x1; codeleft2_q10 a).<span class="mi">2</span>}} =&gt;
       (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
        (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
           (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
           (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                 transport
                   (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                    Q x (codeleft2_y0 {| ... |})) p
                   (codeleft2_q00
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}) =
                 codeleft2_q10
                   {|
                     codeleft2_y0 := H1;
                     codeleft2_q00 := H2;
                     codeleft2_q10 := H3;
                     codeleft2_u := H4
                   |}}) =&gt;
         (<span class="kr">fun</span> (<span class="nv">H6</span> : x0 = x1)
            (<span class="nv">H7</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H6
                    H2 = H3) =&gt;
          {|
            Ocodeleft2b_s := H6 : x0 = x1;
            Ocodeleft2b_y0 := H1 : Y;
            Ocodeleft2b_q00 := H2 : Q x0 (H1 : Y);
            Ocodeleft2b_q10 := H3 : Q x1 (H1 : Y);
            Ocodeleft2b_w :=
              H7
              :
              transport (...) (...) (...) = (H3 : ...);
            Ocodeleft2b_u :=
              H4 : glue ... @ (...)^ = r
          |}
          :
          Ocodeleft2b) H5.<span class="mi">1</span> H5.<span class="mi">2</span>) (codeleft2_y0 H0)
          (codeleft2_q00 H0) (codeleft2_q10 H0)
          (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
      o (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2b =&gt;
         (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
            (<span class="nv">H3</span> : Q x1 H1)
            (<span class="nv">H4</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) H0
                    H2 = H3)
            (<span class="nv">H5</span> : glue H2 @ (glue H3)^ = r) =&gt;
          ({|
             codeleft2_y0 := H1 : Y;
             codeleft2_q00 := H2 : Q x0 (H1 : Y);
             codeleft2_q10 := H3 : Q x1 (H1 : Y);
             codeleft2_u :=
               H5
               :
               glue (H2 : Q x0 (...)) @
               (glue (H3 : Q x1 ...))^ = r
           |}
           :
           codeleft2;
          (H0 : x0 = x1;
          H4
          :
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
             Q x
               (codeleft2_y0 {| ...; ...; ...; ... |}))
            (H0 : x0 = x1)
            (codeleft2_q00
               {|
                 codeleft2_y0 := H1;
                 codeleft2_q00 := H2;
                 codeleft2_q10 := H3;
                 codeleft2_u := H5
               |}) =
          codeleft2_q10
            {|
              codeleft2_y0 := H1;
              codeleft2_q00 := H2;
              codeleft2_q10 := H3;
              codeleft2_u := H5
            |})
          :
          {p : x0 = x1 &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
             Q x
               (codeleft2_y0 ({| ... |} : codeleft2)))
            p
            (codeleft2_q00
               ({|
                  codeleft2_y0 := H1 : Y;
                  codeleft2_q00 := H2 : ...;
                  codeleft2_q10 := H3 : ...;
                  codeleft2_u := H5 : ...
                |}
                :
                codeleft2)) =
          codeleft2_q10
            ({|
               codeleft2_y0 := H1 : Y;
               codeleft2_q00 := H2 : Q x0 (...);
               codeleft2_q10 := H3 : Q x1 (...);
               codeleft2_u := H5 : ... @ ...^ = r
             |}
             :
             codeleft2)})
          :
          {a : codeleft2 &amp;
          {p
          : (x0; codeleft2_q00 a).<span class="mi">1</span> =
            (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
            (x0; codeleft2_q00 a).<span class="mi">2</span> =
          (x1; codeleft2_q10 a).<span class="mi">2</span>}}) (Ocodeleft2b_s H)
           (Ocodeleft2b_y0 H) (Ocodeleft2b_q00 H)
           (Ocodeleft2b_q10 H) (Ocodeleft2b_w H)
           (Ocodeleft2b_u H)) == idmap) o Ocodeleft2ab ==
functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; fst)
o (equiv_functor_sigma_id
     (<span class="kr">fun</span> <span class="nv">a</span> : codeleft2 =&gt;
      equiv_path_sigma
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
        (x0; codeleft2_q00 a) (x1; codeleft2_q10 a) *E
      equiv_path_sigma (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
        (codeleft2_y0 a; codeleft2_q10 a) (y1; q11))
   oE equiv_adjointify
        (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
         (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
            (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                    H1 = q11)
            (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
          ({|
             codeleft2_y0 := y1 : Y;
             codeleft2_q00 := H1 : Q x0 (y1 : Y);
             codeleft2_q10 := q11 : Q x1 (y1 : Y);
             codeleft2_u :=
               H3
               :
               glue (H1 : Q x0 (y1 : Y)) @
               (glue (q11 : Q x1 (y1 : Y)))^ = r
           |}
           :
           codeleft2;
          ((H0 : x0 = x1;
           H2
           :
           transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
             (H0 : x0 = x1) H1 = q11)
           :
           {p : x0 = x1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 = q11},
          (<span class="mi">1</span>%path : y1 = y1;
          <span class="mi">1</span>%path
          :
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
            (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
          :
          {p : y1 = y1 &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 = q11})
          :
          {p : x0 = x1 &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
             Q x
               (codeleft2_y0
                  ({|
                     codeleft2_y0 := ...;
                     codeleft2_q00 := ...;
                     codeleft2_q10 := ...;
                     codeleft2_u := ...
                   |}
                   :
                   codeleft2))) p
            (codeleft2_q00
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : Q x0 (...);
                  codeleft2_q10 := q11 : Q x1 (...);
                  codeleft2_u := H3 : ... @ ...^ = r
                |}
                :
                codeleft2)) =
          codeleft2_q10
            ({|
               codeleft2_y0 := y1 : Y;
               codeleft2_q00 := H1 : Q x0 (y1 : Y);
               codeleft2_q10 := q11 : Q x1 (y1 : Y);
               codeleft2_u :=
                 H3 : glue (...) @ (glue ...)^ = r
             |}
             :
             codeleft2)} *
          {p
          : codeleft2_y0
              ({|
                 codeleft2_y0 := y1 : Y;
                 codeleft2_q00 := H1 : Q x0 (y1 : Y);
                 codeleft2_q10 := q11 : Q x1 (y1 : Y);
                 codeleft2_u :=
                   H3 : glue (...) @ (glue ...)^ = r
               |}
               :
               codeleft2) = y1 &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_q10
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : Q x0 (...);
                  codeleft2_q10 := q11 : Q x1 (...);
                  codeleft2_u := H3 : ... @ ...^ = r
                |}
                :
                codeleft2)) = q11})
          :
          {a : codeleft2 &amp;
          {p
          : (x0; codeleft2_q00 a).<span class="mi">1</span> =
            (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
            (x0; codeleft2_q00 a).<span class="mi">2</span> =
          (x1; codeleft2_q10 a).<span class="mi">2</span>} *
          {p
          : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
            (y1; q11).<span class="mi">1</span> &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
          (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
           (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
           (Ocodeleft2a_u H))
        (<span class="kr">fun</span>
           <span class="nv">H</span> : {a : codeleft2 &amp;
               {p
               : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                 (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
               transport
                 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
                 (x0; codeleft2_q00 a).<span class="mi">2</span> =
               (x1; codeleft2_q10 a).<span class="mi">2</span>} *
               {p
               : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                 (y1; q11).<span class="mi">1</span> &amp;
               transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                 (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
               (y1; q11).<span class="mi">2</span>}} =&gt;
         (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
          (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
             (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
             (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                   transport
                     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                      Q x
                        (codeleft2_y0
                           {|
                             codeleft2_y0 := H1;
                             codeleft2_q00 := H2;
                             codeleft2_q10 := H3;
                             codeleft2_u := H4
                           |})) p
                     (codeleft2_q00
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) =
                   codeleft2_q10
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |}} *
                   {p
                   : codeleft2_y0
                       {|
                         codeleft2_y0 := H1;
                         codeleft2_q00 := H2;
                         codeleft2_q10 := H3;
                         codeleft2_u := H4
                       |} = y1 &amp;
                   transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                     (codeleft2_q10
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) = q11}) =&gt;
           (<span class="kr">fun</span>
              <span class="nv">H6</span> : {p : x0 = x1 &amp;
                   transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) p
                     H2 = H3} =&gt;
            (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
               (<span class="nv">H8</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1)
                       H7 H2 = H3)
               (<span class="nv">H9</span> : {p : H1 = y1 &amp;
                     transport (<span class="kr">fun</span> ... =&gt; Q x1 y) p
                       H3 = q11}) =&gt;
             (<span class="kr">fun</span> <span class="nv">H10</span> : H1 = y1 =&gt;
              paths_ind_r y1
                (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : ...) =&gt;
                 <span class="kr">forall</span> (<span class="nv">H11</span> : ...) (<span class="nv">H12</span> : ...),
                 ... -&gt; ...)
                (<span class="kr">fun</span> (<span class="nv">H11</span> : ...) (<span class="nv">H12</span> : ...)
                   (<span class="nv">H13</span> : ...) (<span class="nv">H14</span> : ...) (<span class="nv">H15</span> : ...)
                 =&gt;
                 paths_ind_r q11 (...) (...) H12 H15
                   H13 H14) H1 H10 H2 H3 H4 H8) H9.<span class="mi">1</span>
               H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5) (snd H5))
            (codeleft2_y0 H0) (codeleft2_q00 H0)
            (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span>
           H.<span class="mi">2</span>)
        ((<span class="kr">fun</span>
            <span class="nv">H</span> : {a : codeleft2 &amp;
                {p
                : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                  (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                transport
                  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                  p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                {p
                : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                  (y1; q11).<span class="mi">1</span> &amp;
                transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                (y1; q11).<span class="mi">2</span>}} =&gt;
          (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
           (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
              (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
              (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                    transport
                      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                       Q x (codeleft2_y0 {| ... |})) p
                      (codeleft2_q00
                         {|
                           codeleft2_y0 := H1;
                           codeleft2_q00 := H2;
                           codeleft2_q10 := H3;
                           codeleft2_u := H4
                         |}) =
                    codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}} *
                    {p
                    : codeleft2_y0
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |} = y1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                      (codeleft2_q10
                         {|
                           codeleft2_y0 := H1;
                           codeleft2_q00 := H2;
                           codeleft2_q10 := H3;
                           codeleft2_u := H4
                         |}) = q11}) =&gt;
            (<span class="kr">fun</span>
               <span class="nv">H6</span> : {p : x0 = x1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) p
                      H2 = H3} =&gt;
             (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                (<span class="nv">H8</span> : transport (... =&gt; ...) H7 H2 =
                      H3)
                (<span class="nv">H9</span> : {p : H1 = y1 &amp;
                      transport (...) p H3 = q11}) =&gt;
              (<span class="kr">fun</span> <span class="nv">H10</span> : H1 = y1 =&gt;
               paths_ind_r y1 (... =&gt; ...)
                 (... =&gt; ...) H1 H10 H2 H3 H4 H8) H9.<span class="mi">1</span>
                H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5) (snd H5))
             (codeleft2_y0 H0) (codeleft2_q00 H0)
             (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span>
            H.<span class="mi">2</span>)
         :
         (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
          (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
             (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                     H1 = q11)
             (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
           ({|
              codeleft2_y0 := y1 : Y;
              codeleft2_q00 := H1 : Q x0 (y1 : Y);
              codeleft2_q10 := q11 : Q x1 (y1 : Y);
              codeleft2_u :=
                H3
                :
                glue (H1 : Q x0 ...) @
                (glue (q11 : ...))^ = r
            |}
            :
            codeleft2;
           ((H0 : x0 = x1;
            H2
            :
            transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
              (H0 : x0 = x1) H1 = q11)
            :
            {p : x0 = x1 &amp;
            transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 = q11},
           (<span class="mi">1</span>%path : y1 = y1;
           <span class="mi">1</span>%path
           :
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
             (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
           :
           {p : y1 = y1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 = q11})
           :
           {p : x0 = x1 &amp;
           transport
             (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 (...))) p
             (codeleft2_q00
                ({| ...; ...; ...; ... |} : codeleft2)) =
           codeleft2_q10
             ({|
                codeleft2_y0 := y1 : Y;
                codeleft2_q00 := H1 : ...;
                codeleft2_q10 := q11 : ...;
                codeleft2_u := H3 : ...
              |}
              :
              codeleft2)} *
           {p
           : codeleft2_y0
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : ...;
                  codeleft2_q10 := q11 : ...;
                  codeleft2_u := H3 : ...
                |}
                :
                codeleft2) = y1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
             (codeleft2_q10
                ({| ...; ...; ...; ... |} : codeleft2)) =
           q11})
           :
           {a : codeleft2 &amp;
           {p
           : (x0; codeleft2_q00 a).<span class="mi">1</span> =
             (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
           transport
             (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
             (x0; codeleft2_q00 a).<span class="mi">2</span> =
           (x1; codeleft2_q10 a).<span class="mi">2</span>} *
           {p
           : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
             (y1; q11).<span class="mi">1</span> &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
             (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
           (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
            (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
            (Ocodeleft2a_u H))
         o (<span class="kr">fun</span>
              <span class="nv">H</span> : {a : codeleft2 &amp;
                  {p
                  : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                    (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                  transport
                    (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                    p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                  (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                  {p
                  : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                    (y1; q11).<span class="mi">1</span> &amp;
                  transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                    (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                  (y1; q11).<span class="mi">2</span>}} =&gt;
            (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
             (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
                (<span class="nv">H3</span> : Q x1 H1)
                (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
                (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                      transport
                        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (...)) p
                        (codeleft2_q00
                           {| ...; ...; ...; ... |}) =
                      codeleft2_q10
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}} *
                      {p
                      : codeleft2_y0
                          {|
                            codeleft2_y0 := H1;
                            codeleft2_q00 := H2;
                            codeleft2_q10 := H3;
                            codeleft2_u := H4
                          |} = y1 &amp;
                      transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
                        p
                        (codeleft2_q10
                           {| ...; ...; ...; ... |}) =
                      q11}) =&gt;
              (<span class="kr">fun</span>
                 <span class="nv">H6</span> : {p : x0 = x1 &amp;
                      transport (... =&gt; ...) p H2 = H3}
               =&gt;
               (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                  (<span class="nv">H8</span> : transport ... H7 H2 = H3)
                  (<span class="nv">H9</span> : {p : H1 = y1 &amp; ... = q11}) =&gt;
                (<span class="kr">fun</span> ... =&gt;
                 paths_ind_r y1 ... ... H1 H10 H2 H3
                   H4 H8) H9.<span class="mi">1</span> H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>)
                (fst H5) (snd H5)) (codeleft2_y0 H0)
               (codeleft2_q00 H0) (codeleft2_q10 H0)
               (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>) == idmap)
        ((<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
          (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
             (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                     H1 = q11)
             (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
           <span class="mi">1</span>%path) (Ocodeleft2a_s H)
            (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
            (Ocodeleft2a_u H))
         :
         (<span class="kr">fun</span>
            <span class="nv">H</span> : {a : codeleft2 &amp;
                {p
                : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                  (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                transport
                  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                  p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                {p
                : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                  (y1; q11).<span class="mi">1</span> &amp;
                transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                (y1; q11).<span class="mi">2</span>}} =&gt;
          (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
           (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
              (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
              (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (...))
                      p
                      (codeleft2_q00
                         {| ...; ...; ...; ... |}) =
                    codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}} *
                    {p
                    : codeleft2_y0
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |} = y1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                      (codeleft2_q10
                         {| ...; ...; ...; ... |}) =
                    q11}) =&gt;
            (<span class="kr">fun</span>
               <span class="nv">H6</span> : {p : x0 = x1 &amp;
                    transport (... =&gt; ...) p H2 = H3}
             =&gt;
             (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                (<span class="nv">H8</span> : transport ... H7 H2 = H3)
                (<span class="nv">H9</span> : {p : H1 = y1 &amp; ... = q11}) =&gt;
              (<span class="kr">fun</span> ... =&gt;
               paths_ind_r y1 ... ... H1 H10 H2 H3 H4
                 H8) H9.<span class="mi">1</span> H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5)
              (snd H5)) (codeleft2_y0 H0)
             (codeleft2_q00 H0) (codeleft2_q10 H0)
             (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
         o (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
            (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
               (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
                       H0 H1 = q11)
               (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
             ({|
                codeleft2_y0 := y1 : Y;
                codeleft2_q00 := H1 : Q x0 (y1 : Y);
                codeleft2_q10 := q11 : Q x1 (y1 : Y);
                codeleft2_u :=
                  H3
                  :
                  glue (H1 : Q x0 ...) @
                  (glue (q11 : ...))^ = r
              |}
              :
              codeleft2;
             ((H0 : x0 = x1;
              H2
              :
              transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
                (H0 : x0 = x1) H1 = q11)
              :
              {p : x0 = x1 &amp;
              transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 =
              q11},
             (<span class="mi">1</span>%path : y1 = y1;
             <span class="mi">1</span>%path
             :
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
               (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
             :
             {p : y1 = y1 &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 =
             q11})
             :
             {p : x0 = x1 &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 (...)))
               p
               (codeleft2_q00
                  ({| ...; ...; ...; ... |}
                   :
                   codeleft2)) =
             codeleft2_q10
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : ...;
                  codeleft2_q10 := q11 : ...;
                  codeleft2_u := H3 : ...
                |}
                :
                codeleft2)} *
             {p
             : codeleft2_y0
                 ({|
                    codeleft2_y0 := y1 : Y;
                    codeleft2_q00 := H1 : ...;
                    codeleft2_q10 := q11 : ...;
                    codeleft2_u := H3 : ...
                  |}
                  :
                  codeleft2) = y1 &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_q10
                  ({| ...; ...; ...; ... |}
                   :
                   codeleft2)) = q11})
             :
             {a : codeleft2 &amp;
             {p
             : (x0; codeleft2_q00 a).<span class="mi">1</span> =
               (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
               (x0; codeleft2_q00 a).<span class="mi">2</span> =
             (x1; codeleft2_q10 a).<span class="mi">2</span>} *
             {p
             : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
               (y1; q11).<span class="mi">1</span> &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
             (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
              (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
              (Ocodeleft2a_u H)) == idmap))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_sigma_id
  (<span class="kr">fun</span> <span class="nv">a</span> : codeleft2 =&gt;
   equiv_path_sigma (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
     (codeleft2_y0 a; codeleft2_q10 a) (y1; q11))
oE equiv_adjointify
     (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2c =&gt;
      (<span class="kr">fun</span> (<span class="nv">H0</span> : Q x0 y1)
         (<span class="nv">H1</span> : glue H0 @ (glue q11)^ = r) =&gt;
       ({|
          codeleft2_y0 := y1 : Y;
          codeleft2_q00 := H0 : Q x0 (y1 : Y);
          codeleft2_q10 := q11 : Q x1 (y1 : Y);
          codeleft2_u :=
            H1
            :
            glue (H0 : Q x0 (y1 : Y)) @
            (glue (q11 : Q x1 (y1 : Y)))^ = r
        |}
        :
        codeleft2;
       (<span class="mi">1</span>%path : y1 = y1;
       <span class="mi">1</span>%path
       :
       transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
         (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
       :
       {p
       : codeleft2_y0
           ({|
              codeleft2_y0 := y1 : Y;
              codeleft2_q00 := H0 : Q x0 (y1 : Y);
              codeleft2_q10 := q11 : Q x1 (y1 : Y);
              codeleft2_u :=
                H1
                :
                glue (H0 : Q x0 ...) @
                (glue (q11 : ...))^ = r
            |}
            :
            codeleft2) = y1 &amp;
       transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
         (codeleft2_q10
            ({|
               codeleft2_y0 := y1 : Y;
               codeleft2_q00 := H0 : Q x0 (y1 : Y);
               codeleft2_q10 := q11 : Q x1 (y1 : Y);
               codeleft2_u :=
                 H1 : glue (...) @ (glue ...)^ = r
             |}
             :
             codeleft2)) = q11})
       :
       {a : codeleft2 &amp;
       {p
       : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
         (y1; q11).<span class="mi">1</span> &amp;
       transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
         (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
       (y1; q11).<span class="mi">2</span>}}) H.<span class="mi">1</span> H.<span class="mi">2</span>)
     (<span class="kr">fun</span>
        <span class="nv">H</span> : {a : codeleft2 &amp;
            {p
            : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
              (y1; q11).<span class="mi">1</span> &amp;
            transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
              (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
            (y1; q11).<span class="mi">2</span>}} =&gt;
      (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
       (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
          (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
          (<span class="nv">H5</span> : {p
                : codeleft2_y0
                    {|
                      codeleft2_y0 := H1;
                      codeleft2_q00 := H2;
                      codeleft2_q10 := H3;
                      codeleft2_u := H4
                    |} = y1 &amp;
                transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                  (codeleft2_q10
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |}) = q11}) =&gt;
        (<span class="kr">fun</span> <span class="nv">H6</span> : H1 = y1 =&gt;
         paths_ind_r y1
           (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : y = y1) =&gt;
            <span class="kr">forall</span> (<span class="nv">H7</span> : Q x0 y) (<span class="nv">H8</span> : Q x1 y),
            glue H7 @ (glue H8)^ = r -&gt;
            transport (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt; Q x1 y0) p H8 =
            q11 -&gt; Ocodeleft2c)
           (<span class="kr">fun</span> (<span class="nv">H7</span> : Q x0 y1) (<span class="nv">H8</span> : Q x1 y1)
              (<span class="nv">H9</span> : glue H7 @ (glue H8)^ = r)
              (<span class="nv">H10</span> : transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) <span class="mi">1</span>
                       H8 = q11) =&gt;
            paths_ind_r q11
              (<span class="kr">fun</span> (<span class="nv">y</span> : Q x1 y1) (<span class="nv">_</span> : y = q11) =&gt;
               glue H7 @ (glue y)^ = r -&gt; Ocodeleft2c)
              (<span class="kr">fun</span> <span class="nv">H11</span> : glue H7 @ (glue q11)^ = r =&gt;
               (H7 : Q x0 y1;
               H11 : glue ... @ (...)^ = r)
               :
               Ocodeleft2c) H8 H10 H9) H1 H6 H2 H3 H4)
          H5.<span class="mi">1</span> H5.<span class="mi">2</span>) (codeleft2_y0 H0)
         (codeleft2_q00 H0) (codeleft2_q10 H0)
         (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
     ((<span class="kr">fun</span>
         <span class="nv">H</span> : {a : codeleft2 &amp;
             {p
             : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
               (y1; q11).<span class="mi">1</span> &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
             (y1; q11).<span class="mi">2</span>}} =&gt;
       (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
        (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
           (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
           (<span class="nv">H5</span> : {p
                 : codeleft2_y0
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |} = y1 &amp;
                 transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                   (codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}) = q11}) =&gt;
         (<span class="kr">fun</span> <span class="nv">H6</span> : H1 = y1 =&gt;
          paths_ind_r y1
            (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : y = y1) =&gt;
             <span class="kr">forall</span> (<span class="nv">H7</span> : Q x0 y) (<span class="nv">H8</span> : Q x1 y)
             (<span class="nv">H9</span> : glue H7 @ (glue H8)^ = r)
             (<span class="nv">proj2</span> : transport (<span class="kr">fun</span> ... =&gt; Q x1 y0) p
                        H8 = q11),
             ({|
                codeleft2_y0 := y1;
                codeleft2_q00 := (...).<span class="mi">1</span>;
                codeleft2_q10 := q11;
                codeleft2_u := (...).<span class="mi">2</span>
              |}; <span class="mi">1</span>%path; <span class="mi">1</span>%path) =
             ({|
                codeleft2_y0 := y;
                codeleft2_q00 := H7;
                codeleft2_q10 := H8;
                codeleft2_u := H9
              |}; p; proj2))
            (<span class="kr">fun</span> (<span class="nv">H7</span> : Q x0 y1) (<span class="nv">H8</span> : Q x1 y1)
               (<span class="nv">H9</span> : glue H7 @ (glue H8)^ = r)
               (<span class="nv">H10</span> : transport (<span class="kr">fun</span> ... =&gt; Q x1 y) <span class="mi">1</span>
                        H8 = q11) =&gt;
             paths_ind_r q11
               (<span class="kr">fun</span> (<span class="nv">y</span> : Q x1 y1) (<span class="nv">p</span> : y = q11) =&gt;
                <span class="kr">forall</span> <span class="nv">H11</span> : ... @ ...^ = r,
                ({| ... |}; <span class="mi">1</span>%path; <span class="mi">1</span>%path) =
                ({| ... |}; <span class="mi">1</span>%path; p))
               (<span class="kr">fun</span> <span class="nv">H11</span> : ... @ ...^ = r =&gt; <span class="mi">1</span>%path) H8
               H10 H9) H1 H6 H2 H3 H4) H5.<span class="mi">1</span> H5.<span class="mi">2</span>)
          (codeleft2_y0 H0) (codeleft2_q00 H0)
          (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
      :
      (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2c =&gt;
       (<span class="kr">fun</span> (<span class="nv">H0</span> : Q x0 y1)
          (<span class="nv">H1</span> : glue H0 @ (glue q11)^ = r) =&gt;
        ({|
           codeleft2_y0 := y1 : Y;
           codeleft2_q00 := H0 : Q x0 (y1 : Y);
           codeleft2_q10 := q11 : Q x1 (y1 : Y);
           codeleft2_u :=
             H1
             :
             glue (H0 : Q x0 (...)) @
             (glue (q11 : Q x1 ...))^ = r
         |}
         :
         codeleft2;
        (<span class="mi">1</span>%path : y1 = y1;
        <span class="mi">1</span>%path
        :
        transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
          (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
        :
        {p
        : codeleft2_y0
            ({|
               codeleft2_y0 := y1 : Y;
               codeleft2_q00 := H0 : Q x0 (...);
               codeleft2_q10 := q11 : Q x1 (...);
               codeleft2_u := H1 : ... @ ...^ = r
             |}
             :
             codeleft2) = y1 &amp;
        transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
          (codeleft2_q10
             ({|
                codeleft2_y0 := y1 : Y;
                codeleft2_q00 := H0 : ...;
                codeleft2_q10 := q11 : ...;
                codeleft2_u := H1 : ...
              |}
              :
              codeleft2)) = q11})
        :
        {a : codeleft2 &amp;
        {p
        : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
          (y1; q11).<span class="mi">1</span> &amp;
        transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
          (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
        (y1; q11).<span class="mi">2</span>}}) H.<span class="mi">1</span> H.<span class="mi">2</span>)
      o (<span class="kr">fun</span>
           <span class="nv">H</span> : {a : codeleft2 &amp;
               {p
               : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                 (y1; q11).<span class="mi">1</span> &amp;
               transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                 (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
               (y1; q11).<span class="mi">2</span>}} =&gt;
         (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
          (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
             (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
             (<span class="nv">H5</span> : {p
                   : codeleft2_y0
                       {|
                         codeleft2_y0 := H1;
                         codeleft2_q00 := H2;
                         codeleft2_q10 := H3;
                         codeleft2_u := H4
                       |} = y1 &amp;
                   transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                     (codeleft2_q10
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) = q11}) =&gt;
           (<span class="kr">fun</span> <span class="nv">H6</span> : H1 = y1 =&gt;
            paths_ind_r y1
              (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : y = y1) =&gt;
               <span class="kr">forall</span> (<span class="nv">H7</span> : Q x0 y) (<span class="nv">H8</span> : Q x1 y),
               glue H7 @ (...)^ = r -&gt;
               transport ... p H8 = q11 -&gt; Ocodeleft2c)
              (<span class="kr">fun</span> (<span class="nv">H7</span> : Q x0 y1) (<span class="nv">H8</span> : Q x1 y1)
                 (<span class="nv">H9</span> : glue H7 @ (...)^ = r)
                 (<span class="nv">H10</span> : transport (...) <span class="mi">1</span> H8 = q11) =&gt;
               paths_ind_r q11
                 (<span class="kr">fun</span> (<span class="nv">y</span> : ...) (<span class="nv">_</span> : ...) =&gt;
                  ... = r -&gt; Ocodeleft2c)
                 (<span class="kr">fun</span> <span class="nv">H11</span> : ... =&gt;
                  (...; ...) : Ocodeleft2c) H8 H10 H9)
              H1 H6 H2 H3 H4) H5.<span class="mi">1</span> H5.<span class="mi">2</span>)
            (codeleft2_y0 H0) (codeleft2_q00 H0)
            (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span>
           H.<span class="mi">2</span>) == idmap)
     ((<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2c =&gt;
       (<span class="kr">fun</span> (<span class="nv">H0</span> : Q x0 y1)
          (<span class="nv">H1</span> : glue H0 @ (glue q11)^ = r) =&gt; <span class="mi">1</span>%path)
         H.<span class="mi">1</span> H.<span class="mi">2</span>)
      :
      (<span class="kr">fun</span>
         <span class="nv">H</span> : {a : codeleft2 &amp;
             {p
             : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
               (y1; q11).<span class="mi">1</span> &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
             (y1; q11).<span class="mi">2</span>}} =&gt;
       (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
        (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
           (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
           (<span class="nv">H5</span> : {p
                 : codeleft2_y0
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |} = y1 &amp;
                 transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                   (codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}) = q11}) =&gt;
         (<span class="kr">fun</span> <span class="nv">H6</span> : H1 = y1 =&gt;
          paths_ind_r y1
            (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : y = y1) =&gt;
             <span class="kr">forall</span> (<span class="nv">H7</span> : Q x0 y) (<span class="nv">H8</span> : Q x1 y),
             glue H7 @ (...)^ = r -&gt;
             transport ... p H8 = q11 -&gt; Ocodeleft2c)
            (<span class="kr">fun</span> (<span class="nv">H7</span> : Q x0 y1) (<span class="nv">H8</span> : Q x1 y1)
               (<span class="nv">H9</span> : glue H7 @ (...)^ = r)
               (<span class="nv">H10</span> : transport (...) <span class="mi">1</span> H8 = q11) =&gt;
             paths_ind_r q11
               (<span class="kr">fun</span> (<span class="nv">y</span> : ...) (<span class="nv">_</span> : ...) =&gt;
                ... = r -&gt; Ocodeleft2c)
               (<span class="kr">fun</span> <span class="nv">H11</span> : ... =&gt;
                (...; ...) : Ocodeleft2c) H8 H10 H9)
            H1 H6 H2 H3 H4) H5.<span class="mi">1</span> H5.<span class="mi">2</span>)
          (codeleft2_y0 H0) (codeleft2_q00 H0)
          (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
      o (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2c =&gt;
         (<span class="kr">fun</span> (<span class="nv">H0</span> : Q x0 y1)
            (<span class="nv">H1</span> : glue H0 @ (glue q11)^ = r) =&gt;
          ({|
             codeleft2_y0 := y1 : Y;
             codeleft2_q00 := H0 : Q x0 (y1 : Y);
             codeleft2_q10 := q11 : Q x1 (y1 : Y);
             codeleft2_u :=
               H1
               :
               glue (H0 : Q x0 (...)) @
               (glue (q11 : Q x1 ...))^ = r
           |}
           :
           codeleft2;
          (<span class="mi">1</span>%path : y1 = y1;
          <span class="mi">1</span>%path
          :
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
            (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
          :
          {p
          : codeleft2_y0
              ({|
                 codeleft2_y0 := y1 : Y;
                 codeleft2_q00 := H0 : Q x0 (...);
                 codeleft2_q10 := q11 : Q x1 (...);
                 codeleft2_u := H1 : ... @ ...^ = r
               |}
               :
               codeleft2) = y1 &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_q10
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H0 : ...;
                  codeleft2_q10 := q11 : ...;
                  codeleft2_u := H1 : ...
                |}
                :
                codeleft2)) = q11})
          :
          {a : codeleft2 &amp;
          {p
          : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
            (y1; q11).<span class="mi">1</span> &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
          (y1; q11).<span class="mi">2</span>}}) H.<span class="mi">1</span> H.<span class="mi">2</span>) == idmap)
o Ocodeleft2ac ==
functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt; snd)
o (equiv_functor_sigma_id
     (<span class="kr">fun</span> <span class="nv">a</span> : codeleft2 =&gt;
      equiv_path_sigma
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
        (x0; codeleft2_q00 a) (x1; codeleft2_q10 a) *E
      equiv_path_sigma (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
        (codeleft2_y0 a; codeleft2_q10 a) (y1; q11))
   oE equiv_adjointify
        (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
         (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
            (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                    H1 = q11)
            (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
          ({|
             codeleft2_y0 := y1 : Y;
             codeleft2_q00 := H1 : Q x0 (y1 : Y);
             codeleft2_q10 := q11 : Q x1 (y1 : Y);
             codeleft2_u :=
               H3
               :
               glue (H1 : Q x0 (y1 : Y)) @
               (glue (q11 : Q x1 (y1 : Y)))^ = r
           |}
           :
           codeleft2;
          ((H0 : x0 = x1;
           H2
           :
           transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
             (H0 : x0 = x1) H1 = q11)
           :
           {p : x0 = x1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 = q11},
          (<span class="mi">1</span>%path : y1 = y1;
          <span class="mi">1</span>%path
          :
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
            (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
          :
          {p : y1 = y1 &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 = q11})
          :
          {p : x0 = x1 &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
             Q x
               (codeleft2_y0
                  ({|
                     codeleft2_y0 := ...;
                     codeleft2_q00 := ...;
                     codeleft2_q10 := ...;
                     codeleft2_u := ...
                   |}
                   :
                   codeleft2))) p
            (codeleft2_q00
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : Q x0 (...);
                  codeleft2_q10 := q11 : Q x1 (...);
                  codeleft2_u := H3 : ... @ ...^ = r
                |}
                :
                codeleft2)) =
          codeleft2_q10
            ({|
               codeleft2_y0 := y1 : Y;
               codeleft2_q00 := H1 : Q x0 (y1 : Y);
               codeleft2_q10 := q11 : Q x1 (y1 : Y);
               codeleft2_u :=
                 H3 : glue (...) @ (glue ...)^ = r
             |}
             :
             codeleft2)} *
          {p
          : codeleft2_y0
              ({|
                 codeleft2_y0 := y1 : Y;
                 codeleft2_q00 := H1 : Q x0 (y1 : Y);
                 codeleft2_q10 := q11 : Q x1 (y1 : Y);
                 codeleft2_u :=
                   H3 : glue (...) @ (glue ...)^ = r
               |}
               :
               codeleft2) = y1 &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_q10
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : Q x0 (...);
                  codeleft2_q10 := q11 : Q x1 (...);
                  codeleft2_u := H3 : ... @ ...^ = r
                |}
                :
                codeleft2)) = q11})
          :
          {a : codeleft2 &amp;
          {p
          : (x0; codeleft2_q00 a).<span class="mi">1</span> =
            (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
          transport
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
            (x0; codeleft2_q00 a).<span class="mi">2</span> =
          (x1; codeleft2_q10 a).<span class="mi">2</span>} *
          {p
          : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
            (y1; q11).<span class="mi">1</span> &amp;
          transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
            (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
          (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
           (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
           (Ocodeleft2a_u H))
        (<span class="kr">fun</span>
           <span class="nv">H</span> : {a : codeleft2 &amp;
               {p
               : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                 (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
               transport
                 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
                 (x0; codeleft2_q00 a).<span class="mi">2</span> =
               (x1; codeleft2_q10 a).<span class="mi">2</span>} *
               {p
               : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                 (y1; q11).<span class="mi">1</span> &amp;
               transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                 (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
               (y1; q11).<span class="mi">2</span>}} =&gt;
         (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
          (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
             (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
             (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                   transport
                     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                      Q x
                        (codeleft2_y0
                           {|
                             codeleft2_y0 := H1;
                             codeleft2_q00 := H2;
                             codeleft2_q10 := H3;
                             codeleft2_u := H4
                           |})) p
                     (codeleft2_q00
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) =
                   codeleft2_q10
                     {|
                       codeleft2_y0 := H1;
                       codeleft2_q00 := H2;
                       codeleft2_q10 := H3;
                       codeleft2_u := H4
                     |}} *
                   {p
                   : codeleft2_y0
                       {|
                         codeleft2_y0 := H1;
                         codeleft2_q00 := H2;
                         codeleft2_q10 := H3;
                         codeleft2_u := H4
                       |} = y1 &amp;
                   transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                     (codeleft2_q10
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}) = q11}) =&gt;
           (<span class="kr">fun</span>
              <span class="nv">H6</span> : {p : x0 = x1 &amp;
                   transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) p
                     H2 = H3} =&gt;
            (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
               (<span class="nv">H8</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1)
                       H7 H2 = H3)
               (<span class="nv">H9</span> : {p : H1 = y1 &amp;
                     transport (<span class="kr">fun</span> ... =&gt; Q x1 y) p
                       H3 = q11}) =&gt;
             (<span class="kr">fun</span> <span class="nv">H10</span> : H1 = y1 =&gt;
              paths_ind_r y1
                (<span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">p</span> : ...) =&gt;
                 <span class="kr">forall</span> (<span class="nv">H11</span> : ...) (<span class="nv">H12</span> : ...),
                 ... -&gt; ...)
                (<span class="kr">fun</span> (<span class="nv">H11</span> : ...) (<span class="nv">H12</span> : ...)
                   (<span class="nv">H13</span> : ...) (<span class="nv">H14</span> : ...) (<span class="nv">H15</span> : ...)
                 =&gt;
                 paths_ind_r q11 (...) (...) H12 H15
                   H13 H14) H1 H10 H2 H3 H4 H8) H9.<span class="mi">1</span>
               H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5) (snd H5))
            (codeleft2_y0 H0) (codeleft2_q00 H0)
            (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span>
           H.<span class="mi">2</span>)
        ((<span class="kr">fun</span>
            <span class="nv">H</span> : {a : codeleft2 &amp;
                {p
                : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                  (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                transport
                  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                  p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                {p
                : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                  (y1; q11).<span class="mi">1</span> &amp;
                transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                (y1; q11).<span class="mi">2</span>}} =&gt;
          (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
           (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
              (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
              (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                    transport
                      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
                       Q x (codeleft2_y0 {| ... |})) p
                      (codeleft2_q00
                         {|
                           codeleft2_y0 := H1;
                           codeleft2_q00 := H2;
                           codeleft2_q10 := H3;
                           codeleft2_u := H4
                         |}) =
                    codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}} *
                    {p
                    : codeleft2_y0
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |} = y1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                      (codeleft2_q10
                         {|
                           codeleft2_y0 := H1;
                           codeleft2_q00 := H2;
                           codeleft2_q10 := H3;
                           codeleft2_u := H4
                         |}) = q11}) =&gt;
            (<span class="kr">fun</span>
               <span class="nv">H6</span> : {p : x0 = x1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x H1) p
                      H2 = H3} =&gt;
             (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                (<span class="nv">H8</span> : transport (... =&gt; ...) H7 H2 =
                      H3)
                (<span class="nv">H9</span> : {p : H1 = y1 &amp;
                      transport (...) p H3 = q11}) =&gt;
              (<span class="kr">fun</span> <span class="nv">H10</span> : H1 = y1 =&gt;
               paths_ind_r y1 (... =&gt; ...)
                 (... =&gt; ...) H1 H10 H2 H3 H4 H8) H9.<span class="mi">1</span>
                H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5) (snd H5))
             (codeleft2_y0 H0) (codeleft2_q00 H0)
             (codeleft2_q10 H0) (codeleft2_u H0)) H.<span class="mi">1</span>
            H.<span class="mi">2</span>)
         :
         (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
          (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
             (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                     H1 = q11)
             (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
           ({|
              codeleft2_y0 := y1 : Y;
              codeleft2_q00 := H1 : Q x0 (y1 : Y);
              codeleft2_q10 := q11 : Q x1 (y1 : Y);
              codeleft2_u :=
                H3
                :
                glue (H1 : Q x0 ...) @
                (glue (q11 : ...))^ = r
            |}
            :
            codeleft2;
           ((H0 : x0 = x1;
            H2
            :
            transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
              (H0 : x0 = x1) H1 = q11)
            :
            {p : x0 = x1 &amp;
            transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 = q11},
           (<span class="mi">1</span>%path : y1 = y1;
           <span class="mi">1</span>%path
           :
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
             (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
           :
           {p : y1 = y1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 = q11})
           :
           {p : x0 = x1 &amp;
           transport
             (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 (...))) p
             (codeleft2_q00
                ({| ...; ...; ...; ... |} : codeleft2)) =
           codeleft2_q10
             ({|
                codeleft2_y0 := y1 : Y;
                codeleft2_q00 := H1 : ...;
                codeleft2_q10 := q11 : ...;
                codeleft2_u := H3 : ...
              |}
              :
              codeleft2)} *
           {p
           : codeleft2_y0
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : ...;
                  codeleft2_q10 := q11 : ...;
                  codeleft2_u := H3 : ...
                |}
                :
                codeleft2) = y1 &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
             (codeleft2_q10
                ({| ...; ...; ...; ... |} : codeleft2)) =
           q11})
           :
           {a : codeleft2 &amp;
           {p
           : (x0; codeleft2_q00 a).<span class="mi">1</span> =
             (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
           transport
             (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
             (x0; codeleft2_q00 a).<span class="mi">2</span> =
           (x1; codeleft2_q10 a).<span class="mi">2</span>} *
           {p
           : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
             (y1; q11).<span class="mi">1</span> &amp;
           transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
             (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
           (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
            (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
            (Ocodeleft2a_u H))
         o (<span class="kr">fun</span>
              <span class="nv">H</span> : {a : codeleft2 &amp;
                  {p
                  : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                    (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                  transport
                    (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                    p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                  (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                  {p
                  : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                    (y1; q11).<span class="mi">1</span> &amp;
                  transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                    (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                  (y1; q11).<span class="mi">2</span>}} =&gt;
            (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
             (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1)
                (<span class="nv">H3</span> : Q x1 H1)
                (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
                (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                      transport
                        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (...)) p
                        (codeleft2_q00
                           {| ...; ...; ...; ... |}) =
                      codeleft2_q10
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |}} *
                      {p
                      : codeleft2_y0
                          {|
                            codeleft2_y0 := H1;
                            codeleft2_q00 := H2;
                            codeleft2_q10 := H3;
                            codeleft2_u := H4
                          |} = y1 &amp;
                      transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
                        p
                        (codeleft2_q10
                           {| ...; ...; ...; ... |}) =
                      q11}) =&gt;
              (<span class="kr">fun</span>
                 <span class="nv">H6</span> : {p : x0 = x1 &amp;
                      transport (... =&gt; ...) p H2 = H3}
               =&gt;
               (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                  (<span class="nv">H8</span> : transport ... H7 H2 = H3)
                  (<span class="nv">H9</span> : {p : H1 = y1 &amp; ... = q11}) =&gt;
                (<span class="kr">fun</span> ... =&gt;
                 paths_ind_r y1 ... ... H1 H10 H2 H3
                   H4 H8) H9.<span class="mi">1</span> H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>)
                (fst H5) (snd H5)) (codeleft2_y0 H0)
               (codeleft2_q00 H0) (codeleft2_q10 H0)
               (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>) == idmap)
        ((<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
          (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
             (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) H0
                     H1 = q11)
             (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
           <span class="mi">1</span>%path) (Ocodeleft2a_s H)
            (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
            (Ocodeleft2a_u H))
         :
         (<span class="kr">fun</span>
            <span class="nv">H</span> : {a : codeleft2 &amp;
                {p
                : (x0; codeleft2_q00 a).<span class="mi">1</span> =
                  (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
                transport
                  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a))
                  p (x0; codeleft2_q00 a).<span class="mi">2</span> =
                (x1; codeleft2_q10 a).<span class="mi">2</span>} *
                {p
                : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
                  (y1; q11).<span class="mi">1</span> &amp;
                transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                  (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
                (y1; q11).<span class="mi">2</span>}} =&gt;
          (<span class="kr">fun</span> <span class="nv">H0</span> : codeleft2 =&gt;
           (<span class="kr">fun</span> (<span class="nv">H1</span> : Y) (<span class="nv">H2</span> : Q x0 H1) (<span class="nv">H3</span> : Q x1 H1)
              (<span class="nv">H4</span> : glue H2 @ (glue H3)^ = r)
              (<span class="nv">H5</span> : {p : x0 = x1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (...))
                      p
                      (codeleft2_q00
                         {| ...; ...; ...; ... |}) =
                    codeleft2_q10
                      {|
                        codeleft2_y0 := H1;
                        codeleft2_q00 := H2;
                        codeleft2_q10 := H3;
                        codeleft2_u := H4
                      |}} *
                    {p
                    : codeleft2_y0
                        {|
                          codeleft2_y0 := H1;
                          codeleft2_q00 := H2;
                          codeleft2_q10 := H3;
                          codeleft2_u := H4
                        |} = y1 &amp;
                    transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
                      (codeleft2_q10
                         {| ...; ...; ...; ... |}) =
                    q11}) =&gt;
            (<span class="kr">fun</span>
               <span class="nv">H6</span> : {p : x0 = x1 &amp;
                    transport (... =&gt; ...) p H2 = H3}
             =&gt;
             (<span class="kr">fun</span> (<span class="nv">H7</span> : x0 = x1)
                (<span class="nv">H8</span> : transport ... H7 H2 = H3)
                (<span class="nv">H9</span> : {p : H1 = y1 &amp; ... = q11}) =&gt;
              (<span class="kr">fun</span> ... =&gt;
               paths_ind_r y1 ... ... H1 H10 H2 H3 H4
                 H8) H9.<span class="mi">1</span> H9.<span class="mi">2</span>) H6.<span class="mi">1</span> H6.<span class="mi">2</span>) (fst H5)
              (snd H5)) (codeleft2_y0 H0)
             (codeleft2_q00 H0) (codeleft2_q10 H0)
             (codeleft2_u H0)) H.<span class="mi">1</span> H.<span class="mi">2</span>)
         o (<span class="kr">fun</span> <span class="nv">H</span> : Ocodeleft2a =&gt;
            (<span class="kr">fun</span> (<span class="nv">H0</span> : x0 = x1) (<span class="nv">H1</span> : Q x0 y1)
               (<span class="nv">H2</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
                       H0 H1 = q11)
               (<span class="nv">H3</span> : glue H1 @ (glue q11)^ = r) =&gt;
             ({|
                codeleft2_y0 := y1 : Y;
                codeleft2_q00 := H1 : Q x0 (y1 : Y);
                codeleft2_q10 := q11 : Q x1 (y1 : Y);
                codeleft2_u :=
                  H3
                  :
                  glue (H1 : Q x0 ...) @
                  (glue (q11 : ...))^ = r
              |}
              :
              codeleft2;
             ((H0 : x0 = x1;
              H2
              :
              transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1)
                (H0 : x0 = x1) H1 = q11)
              :
              {p : x0 = x1 &amp;
              transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x y1) p H1 =
              q11},
             (<span class="mi">1</span>%path : y1 = y1;
             <span class="mi">1</span>%path
             :
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y)
               (<span class="mi">1</span>%path : y1 = y1) q11 = q11)
             :
             {p : y1 = y1 &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p q11 =
             q11})
             :
             {p : x0 = x1 &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 (...)))
               p
               (codeleft2_q00
                  ({| ...; ...; ...; ... |}
                   :
                   codeleft2)) =
             codeleft2_q10
               ({|
                  codeleft2_y0 := y1 : Y;
                  codeleft2_q00 := H1 : ...;
                  codeleft2_q10 := q11 : ...;
                  codeleft2_u := H3 : ...
                |}
                :
                codeleft2)} *
             {p
             : codeleft2_y0
                 ({|
                    codeleft2_y0 := y1 : Y;
                    codeleft2_q00 := H1 : ...;
                    codeleft2_q10 := q11 : ...;
                    codeleft2_u := H3 : ...
                  |}
                  :
                  codeleft2) = y1 &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_q10
                  ({| ...; ...; ...; ... |}
                   :
                   codeleft2)) = q11})
             :
             {a : codeleft2 &amp;
             {p
             : (x0; codeleft2_q00 a).<span class="mi">1</span> =
               (x1; codeleft2_q10 a).<span class="mi">1</span> &amp;
             transport
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x (codeleft2_y0 a)) p
               (x0; codeleft2_q00 a).<span class="mi">2</span> =
             (x1; codeleft2_q10 a).<span class="mi">2</span>} *
             {p
             : (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">1</span> =
               (y1; q11).<span class="mi">1</span> &amp;
             transport (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; Q x1 y) p
               (codeleft2_y0 a; codeleft2_q10 a).<span class="mi">2</span> =
             (y1; q11).<span class="mi">2</span>}}) (Ocodeleft2a_s H)
              (Ocodeleft2a_q01 H) (Ocodeleft2a_w H)
              (Ocodeleft2a_u H)) == idmap))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** Now we combine this equivalence with the insertion of our connected type. *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk37"><span class="kn">Definition</span> <span class="nf">equiv_Ocodeleft2</span>
          : O (Pushout Ocodeleft2ab Ocodeleft2ac) &lt;~&gt; O codeleft2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pushout Ocodeleft2ab Ocodeleft2ac) &lt;~&gt; O codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pushout Ocodeleft2ab Ocodeleft2ac) &lt;~&gt; O codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk39"><span class="nb">refine</span> (_ oE equiv_O_functor O equiv_Ocodeleft2plus).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O codeleft2plus &lt;~&gt; O codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3a"><span class="nb">refine</span> (_ oE (equiv_O_sigma_O O _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  {x : codeleft2 &amp;
  O
    (Join
       ((x0; codeleft2_q00 x) = (x1; codeleft2_q10 x))
       ((codeleft2_y0 x; codeleft2_q10 x) = (y1; q11)))} &lt;~&gt;
O codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3b"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : codeleft2 &amp;
O
  (Join
     ((x0; codeleft2_q00 x) = (x1; codeleft2_q10 x))
     ((codeleft2_y0 x; codeleft2_q10 x) = (y1; q11)))} &lt;~&gt;
codeleft2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_sigma_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** The next step is to reassociate the resulting double-pushout and &quot;contract&quot; both of them, one after the other, because they are pushouts along equivalences.  In order to do this, we need first of all to know that the resulting map from [codeleft0] to the above pushout factors through [Ocodeleft2b] via an equivalence.  Here&#39;s the equivalence: *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3c"><span class="kn">Definition</span> <span class="nf">Ocodeleft02b</span> : codeleft0 &lt;~&gt; Ocodeleft2b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 &lt;~&gt; Ocodeleft2b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft0 &lt;~&gt; Ocodeleft2b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Ocodeleft02</span> (<span class="nv">c</span> : codeleft0)
          : Pushout Ocodeleft2ab Ocodeleft2ac
          := pushl&#39; Ocodeleft2ab Ocodeleft2ac (Ocodeleft02b c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3e"><span class="kn">Definition</span> <span class="nf">Ocodeleft02plus_02b</span> (<span class="nv">c</span> : codeleft0)
          : (equiv_Ocodeleft2plus (Ocodeleft02 c)).<span class="mi">1</span> = codeleft02 c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>codeleft0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_Ocodeleft2plus (Ocodeleft02 c)).<span class="mi">1</span> =
codeleft02 c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>codeleft0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_Ocodeleft2plus (Ocodeleft02 c)).<span class="mi">1</span> =
codeleft02 c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> c; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** And here we show that this equivalence is indeed a factor of the relevant map in the original pushout. *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk40"><span class="kn">Definition</span> <span class="nf">Ocodeleft02_02b</span> (<span class="nv">c</span> : codeleft0)
          : equiv_Ocodeleft2 (to O _ (Ocodeleft02 c)) = to O _ (codeleft02 c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>codeleft0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Ocodeleft2
  (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
     (Ocodeleft02 c)) = to O codeleft2 (codeleft02 c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>codeleft0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Ocodeleft2
  (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
     (Ocodeleft02 c)) = to O codeleft2 (codeleft02 c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk42"><span class="nb">destruct</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Ocodeleft2
  (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
     (Ocodeleft02
        {|
          codeleft0_s := codeleft0_s0;
          codeleft0_y0 := codeleft0_y1;
          codeleft0_v := codeleft0_v0;
          codeleft0_q00 := codeleft0_q01;
          codeleft0_q10 := codeleft0_q11;
          codeleft0_w := codeleft0_w0;
          codeleft0_u := codeleft0_u0;
          codeleft0_d := codeleft0_d0
        |})) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk43"><span class="nb">unfold</span> equiv_Ocodeleft2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_O_functor O
   (equiv_sigma_contr
      (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
       O
         (Join
            ((x0; codeleft2_q00 x) =
             (x1; codeleft2_q10 x))
            ((codeleft2_y0 x; codeleft2_q10 x) =
             (y1; q11)))))
 oE (equiv_O_sigma_O O
       (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
        Join
          ((x0; codeleft2_q00 x) =
           (x1; codeleft2_q10 x))
          ((codeleft2_y0 x; codeleft2_q10 x) =
           (y1; q11))))^-<span class="mi">1</span>
 oE equiv_O_functor O equiv_Ocodeleft2plus)
  (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
     (Ocodeleft02
        {|
          codeleft0_s := codeleft0_s0;
          codeleft0_y0 := codeleft0_y1;
          codeleft0_v := codeleft0_v0;
          codeleft0_q00 := codeleft0_q01;
          codeleft0_q10 := codeleft0_q11;
          codeleft0_w := codeleft0_w0;
          codeleft0_u := codeleft0_u0;
          codeleft0_d := codeleft0_d0
        |})) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk44"><span class="kn">Opaque</span> equiv_Ocodeleft2plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_O_functor O
   (equiv_sigma_contr
      (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
       O
         (Join
            ((x0; codeleft2_q00 x) =
             (x1; codeleft2_q10 x))
            ((codeleft2_y0 x; codeleft2_q10 x) =
             (y1; q11)))))
 oE (equiv_O_sigma_O O
       (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
        Join
          ((x0; codeleft2_q00 x) =
           (x1; codeleft2_q10 x))
          ((codeleft2_y0 x; codeleft2_q10 x) =
           (y1; q11))))^-<span class="mi">1</span>
 oE equiv_O_functor O equiv_Ocodeleft2plus)
  (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
     (Ocodeleft02
        {|
          codeleft0_s := codeleft0_s0;
          codeleft0_y0 := codeleft0_y1;
          codeleft0_v := codeleft0_v0;
          codeleft0_q00 := codeleft0_q01;
          codeleft0_q10 := codeleft0_q11;
          codeleft0_w := codeleft0_w0;
          codeleft0_u := codeleft0_u0;
          codeleft0_d := codeleft0_d0
        |})) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk45"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pr1
  (O_functor O
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
         to O
           (Join
              ((x0; codeleft2_q00 x) =
               (x1; codeleft2_q10 x))
              ((codeleft2_y0 x; codeleft2_q10 x) =
               (y1; q11)))))
     (O_functor O equiv_Ocodeleft2plus
        (to O (Pushout Ocodeleft2ab Ocodeleft2ac)
           (Ocodeleft02
              {|
                codeleft0_s := codeleft0_s0;
                codeleft0_y0 := codeleft0_y1;
                codeleft0_v := codeleft0_v0;
                codeleft0_q00 := codeleft0_q01;
                codeleft0_q10 := codeleft0_q11;
                codeleft0_w := codeleft0_w0;
                codeleft0_u := codeleft0_u0;
                codeleft0_d := codeleft0_d0
              |})))) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk46"><span class="nb">refine</span> (ap _ (ap _ (to_O_natural _ _ _)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pr1
  (O_functor O
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
         to O
           (Join
              ((x0; codeleft2_q00 x) =
               (x1; codeleft2_q10 x))
              ((codeleft2_y0 x; codeleft2_q10 x) =
               (y1; q11)))))
     (to O codeleft2plus
        (equiv_Ocodeleft2plus
           (Ocodeleft02
              {|
                codeleft0_s := codeleft0_s0;
                codeleft0_y0 := codeleft0_y1;
                codeleft0_v := codeleft0_v0;
                codeleft0_q00 := codeleft0_q01;
                codeleft0_q10 := codeleft0_q11;
                codeleft0_w := codeleft0_w0;
                codeleft0_u := codeleft0_u0;
                codeleft0_d := codeleft0_d0
              |})))) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk47"><span class="nb">refine</span> (ap _ (to_O_natural _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O pr1
  (to O
     {x : codeleft2 &amp;
     O
       (Join
          ((x0; codeleft2_q00 x) =
           (x1; codeleft2_q10 x))
          ((codeleft2_y0 x; codeleft2_q10 x) =
           (y1; q11)))}
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
         to O
           (Join
              ((x0; codeleft2_q00 x) =
               (x1; codeleft2_q10 x))
              ((codeleft2_y0 x; codeleft2_q10 x) =
               (y1; q11))))
        (equiv_Ocodeleft2plus
           (Ocodeleft02
              {|
                codeleft0_s := codeleft0_s0;
                codeleft0_y0 := codeleft0_y1;
                codeleft0_v := codeleft0_v0;
                codeleft0_q00 := codeleft0_q01;
                codeleft0_q10 := codeleft0_q11;
                codeleft0_w := codeleft0_w0;
                codeleft0_u := codeleft0_u0;
                codeleft0_d := codeleft0_d0
              |})))) =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk48"><span class="nb">refine</span> (to_O_natural _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O codeleft2
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
      to O
        (Join
           ((x0; codeleft2_q00 x) =
            (x1; codeleft2_q10 x))
           ((codeleft2_y0 x; codeleft2_q10 x) =
            (y1; q11))))
     (equiv_Ocodeleft2plus
        (Ocodeleft02
           {|
             codeleft0_s := codeleft0_s0;
             codeleft0_y0 := codeleft0_y1;
             codeleft0_v := codeleft0_v0;
             codeleft0_q00 := codeleft0_q01;
             codeleft0_q10 := codeleft0_q11;
             codeleft0_w := codeleft0_w0;
             codeleft0_u := codeleft0_u0;
             codeleft0_d := codeleft0_d0
           |}))).<span class="mi">1</span> =
to O codeleft2
  (codeleft02
     {|
       codeleft0_s := codeleft0_s0;
       codeleft0_y0 := codeleft0_y1;
       codeleft0_v := codeleft0_v0;
       codeleft0_q00 := codeleft0_q01;
       codeleft0_q10 := codeleft0_q11;
       codeleft0_w := codeleft0_w0;
       codeleft0_u := codeleft0_u0;
       codeleft0_d := codeleft0_d0
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk49"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>codeleft0_s0</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br><span><var>codeleft0_y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>codeleft0_v0</var><span class="hyp-type"><b>: </b><span>ap <span class="nb">left</span> codeleft0_s0 = r</span></span></span><br><span><var>codeleft0_q01</var><span class="hyp-type"><b>: </b><span>Q x0 codeleft0_y1</span></span></span><br><span><var>codeleft0_q11</var><span class="hyp-type"><b>: </b><span>Q x1 codeleft0_y1</span></span></span><br><span><var>codeleft0_w0</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x codeleft0_y1)
  codeleft0_s0 codeleft0_q01 =
codeleft0_q11</span></span></span><br><span><var>codeleft0_u0</var><span class="hyp-type"><b>: </b><span>glue codeleft0_q01 @
(glue codeleft0_q11)^ = r</span></span></span><br><span><var>codeleft0_d0</var><span class="hyp-type"><b>: </b><span>frobnicate r codeleft0_s0 codeleft0_y1
  codeleft0_q11
  (codeleft0_q01; codeleft0_w0;
  codeleft0_u0) = codeleft0_v0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_sigma idmap
   (<span class="kr">fun</span> <span class="nv">x</span> : codeleft2 =&gt;
    to O
      (Join
         ((x0; codeleft2_q00 x) =
          (x1; codeleft2_q10 x))
         ((codeleft2_y0 x; codeleft2_q10 x) =
          (y1; q11))))
   (equiv_Ocodeleft2plus
      (Ocodeleft02
         {|
           codeleft0_s := codeleft0_s0;
           codeleft0_y0 := codeleft0_y1;
           codeleft0_v := codeleft0_v0;
           codeleft0_q00 := codeleft0_q01;
           codeleft0_q10 := codeleft0_q11;
           codeleft0_w := codeleft0_w0;
           codeleft0_u := codeleft0_u0;
           codeleft0_d := codeleft0_d0
         |}))).<span class="mi">1</span> =
codeleft02
  {|
    codeleft0_s := codeleft0_s0;
    codeleft0_y0 := codeleft0_y1;
    codeleft0_v := codeleft0_v0;
    codeleft0_q00 := codeleft0_q01;
    codeleft0_q10 := codeleft0_q11;
    codeleft0_w := codeleft0_w0;
    codeleft0_u := codeleft0_u0;
    codeleft0_d := codeleft0_d0
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">rapply Ocodeleft02plus_02b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** Thus, our pushout in which one vertex is itself a pushout can be written as a &quot;double pushout&quot;</span>

<span class="sd">[codeleft1] &lt;- [codeleft0] -&gt; [codeleft2b] &lt;- [codeleft2a] -&gt; [codeleft2c].</span>

<span class="sd">Since the map [codeleft0] -&gt; [codeleft2b] is an equivalence, the pushout of the left-hand span is equivalent to [codeleft1], and thus the whole thing is equivalent to a pushout</span>

<span class="sd">[codeleft1] &lt;- [codeleft2a] -&gt; [codeleft2c]</span>

<span class="sd">Now we claim that the left-hand map of this span is also an equivalence.  Rather than showing this directly, it seems to be much easier to first construct *an* equivalence from [codeleft2a] to [codeleft1] and then show that it is equal (as a function) to the induced one.  Here&#39;s the equivalence: *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4a"><span class="kn">Definition</span> <span class="nf">Ocodeleft2a1</span> : Ocodeleft2a &lt;~&gt; codeleft1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt; codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt; codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4c"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk4d"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; codeleft1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4e"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; codeleft1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk4f">rapply equiv_functor_sigma_id; <span class="nb">intros</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> s &lt;~&gt; ap <span class="nb">left</span> s = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              <span class="sd">(** Here&#39;s frobnicate showing up again! *)</span>
</span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> frobnicate.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk50">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a &lt;~&gt;
{s : x0 = x1 &amp;
{q0 : Q x0 <span class="nl">?y</span> &amp;
{_ : transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; Q x <span class="nl">?y</span>) s q0 = <span class="nl">?q1</span> &amp;
glue q0 @ (glue <span class="nl">?q1</span>)^ = r}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** And now we check that the two are equal.  Because we used the same proof of [frobnicate] in two places, this equality becomes definitional after simply decomposing up a Sigma-type! *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk51"><span class="kn">Definition</span> <span class="nf">Ocodeleft2a1_through_2b0</span>
          : Ocodeleft2a1 == codeleft01 o Ocodeleft02b^-<span class="mi">1</span> o Ocodeleft2ab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a1 ==
codeleft01 o Ocodeleft02b^-<span class="mi">1</span> o Ocodeleft2ab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ocodeleft2a1 ==
codeleft01 o Ocodeleft02b^-<span class="mi">1</span> o Ocodeleft2ab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="sd">(** Now we&#39;re finally ready to prove the glue equivalence.  Since later on we&#39;ll have to compute its action on inputs from [codeleft1], we decompose it into seven steps, each of which with a corresponding computation lemma.  (These lemmas seem to be much easier to prove step-by-step than all at once if we proved the whole equivalence in a big shebang.) *)</span>

</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue1</span>
          : codeleft &lt;~&gt; O (Pushout (O_functor O codeleft01)
                                    (O_functor O codeleft02))
        := equiv_O_pushout O _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue1_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue1 (to O _ (pushl (s;v))) =
            to O _ (pushl (to O _ (s; v)))
          := equiv_O_pushout_to_O_pushl _ _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk53"><span class="kn">Definition</span> <span class="nf">codeglue2</span>
          : O (Pushout (O_functor O codeleft01) (O_functor O codeleft02))
        &lt;~&gt; O (Pushout (O_functor O codeleft01) (O_functor O Ocodeleft02)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  (Pushout (O_functor O codeleft01)
     (O_functor O codeleft02)) &lt;~&gt;
O
  (Pushout (O_functor O codeleft01)
     (O_functor O Ocodeleft02))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  (Pushout (O_functor O codeleft01)
     (O_functor O codeleft02)) &lt;~&gt;
O
  (Pushout (O_functor O codeleft01)
     (O_functor O Ocodeleft02))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk55">srefine (equiv_O_functor O
                    (equiv_inverse
                    (equiv_pushout (f := O_functor O codeleft01)
                                   (g := O_functor O Ocodeleft02)
                                   <span class="mi">1</span>%equiv <span class="mi">1</span>%equiv equiv_Ocodeleft2 _ _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%equiv o O_functor O codeleft01 ==
O_functor O codeleft01 o <span class="mi">1</span>%equiv</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk56"><hr></label><div class="goal-conclusion">equiv_Ocodeleft2 o O_functor O Ocodeleft02 ==
O_functor O codeleft02 o <span class="mi">1</span>%equiv</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%equiv o O_functor O codeleft01 ==
O_functor O codeleft01 o <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Ocodeleft2 o O_functor O Ocodeleft02 ==
O_functor O codeleft02 o <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk59"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>codeleft0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Ocodeleft2
  (O_functor O Ocodeleft02 (to O codeleft0 x)) =
O_functor O codeleft02 (<span class="mi">1</span>%equiv (to O codeleft0 x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">rewrite</span> !to_O_natural; <span class="nb">apply</span> Ocodeleft02_02b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue2_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue2 (to O _ (pushl (to O _ (s;v))))
            = to O _ (pushl (to O _ (s;v)))
          := to_O_equiv_natural _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue3</span>
          : O (Pushout (O_functor O codeleft01) (O_functor O Ocodeleft02))
              &lt;~&gt; O (Pushout codeleft01 Ocodeleft02)
          := equiv_inverse (equiv_O_pushout O _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue3_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue3 (to O _ (pushl (to O _ (s;v))))
            = to O _ (pushl (s;v))
          := inverse_equiv_O_pushout_to_O_pushl _ _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue4</span>
          : O (Pushout codeleft01 Ocodeleft02)
            &lt;~&gt; O (Pushout
                     (<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
                        pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
                     Ocodeleft2ac)
          := equiv_O_functor O (equiv_inverse (equiv_pushout_assoc _ _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue4_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue4 (to O _ (pushl (s;v)))
            = to O _ (pushl (pushl (s;v)))
          := to_O_equiv_natural _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk5a"><span class="kn">Definition</span> <span class="nf">codeglue5</span>
          : O (Pushout
                 (<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
                    pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
                 Ocodeleft2ac)
        &lt;~&gt; O (Pushout Ocodeleft2a1 Ocodeleft2ac).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  (Pushout
     (<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
      pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
     Ocodeleft2ac) &lt;~&gt;
O (Pushout Ocodeleft2a1 Ocodeleft2ac)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  (Pushout
     (<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
      pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
     Ocodeleft2ac) &lt;~&gt;
O (Pushout Ocodeleft2a1 Ocodeleft2ac)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk5c">srefine (equiv_O_functor O
                     (equiv_inverse
                        (equiv_pushout (f := Ocodeleft2a1) (g := Ocodeleft2ac)
                                       <span class="mi">1</span>%equiv _ <span class="mi">1</span>%equiv _ _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft1 &lt;~&gt; Pushout codeleft01 Ocodeleft02b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk5d"><hr></label><div class="goal-conclusion"><span class="nl">?eB</span> o Ocodeleft2a1 ==
(<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
 pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
o <span class="mi">1</span>%equiv</div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk5e"><hr></label><div class="goal-conclusion"><span class="mi">1</span>%equiv o Ocodeleft2ac == Ocodeleft2ac o <span class="mi">1</span>%equiv</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft1 &lt;~&gt; Pushout codeleft01 Ocodeleft02b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_Equiv _ _ (pushl&#39; codeleft01 Ocodeleft02b) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  equiv_fun := pushl&#39; codeleft01 Ocodeleft02b;
  equiv_isequiv :=
    isequiv_pushout_isequiv&#39; codeleft01 Ocodeleft02b
|} o Ocodeleft2a1 ==
(<span class="kr">fun</span> <span class="nv">x</span> : Ocodeleft2a =&gt;
 pushr&#39; codeleft01 Ocodeleft02b (Ocodeleft2ab x))
o <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk61"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Ocodeleft2a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  equiv_fun := pushl&#39; codeleft01 Ocodeleft02b;
  equiv_isequiv :=
    isequiv_pushout_isequiv&#39; codeleft01 Ocodeleft02b
|} (Ocodeleft2a1 x) =
pushr&#39; codeleft01 Ocodeleft02b
  (Ocodeleft2ab (<span class="mi">1</span>%equiv x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk62"><span class="nb">refine</span> (ap _ (Ocodeleft2a1_through_2b0 x) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Ocodeleft2a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  equiv_fun := pushl&#39; codeleft01 Ocodeleft02b;
  equiv_isequiv :=
    isequiv_pushout_isequiv&#39; codeleft01 Ocodeleft02b
|} (codeleft01 (Ocodeleft02b^-<span class="mi">1</span> (Ocodeleft2ab x))) =
pushr&#39; codeleft01 Ocodeleft02b
  (Ocodeleft2ab (<span class="mi">1</span>%equiv x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk63"><span class="nb">refine</span> (pglue&#39; codeleft01 Ocodeleft02b _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Ocodeleft2a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pushr
  (Ocodeleft02b (Ocodeleft02b^-<span class="mi">1</span> (Ocodeleft2ab x))) =
pushr&#39; codeleft01 Ocodeleft02b
  (Ocodeleft2ab (<span class="mi">1</span>%equiv x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%equiv o Ocodeleft2ac == Ocodeleft2ac o <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue5_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue5 (to O _ (pushl (pushl (s;v))))
            = to O _ (pushl (s;v))
        := to_O_equiv_natural _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue6</span>
          : O (Pushout Ocodeleft2a1 Ocodeleft2ac) &lt;~&gt; O Ocodeleft2c
          := equiv_O_functor
               O (equiv_inverse
                    (Build_Equiv _ _ (pushr&#39; Ocodeleft2a1 Ocodeleft2ac) _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue6_pushl</span> (<span class="nv">s</span> : x0 = x1) (<span class="nv">v</span> : ap <span class="nb">left</span> s = r)
          : codeglue6 (to O _ (pushl (s;v)))
            = <span class="kr">let</span> <span class="nv">z</span> := (frobnicate r s y1 q11)^-<span class="mi">1</span> v <span class="kr">in</span>
              to O Ocodeleft2c (Ocodeleft2ac (Build_Ocodeleft2a s z.<span class="mi">1</span> z.<span class="mi">2</span>.<span class="mi">1</span> z.<span class="mi">2</span>.<span class="mi">2</span>))
          := to_O_equiv_natural _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk65"><span class="kn">Definition</span> <span class="nf">codeglue7</span>
          : O Ocodeleft2c &lt;~&gt; coderight (r @ glue q11).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O Ocodeleft2c &lt;~&gt; coderight (r @ glue q11)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O Ocodeleft2c &lt;~&gt; coderight (r @ glue q11)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk67"><span class="nb">unfold</span> coderight, Ocodeleft2c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {q01 : Q x0 y1 &amp; glue q01 @ (glue q11)^ = r} &lt;~&gt;
O (hfiber glue (r @ glue q11))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk68"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q01 : Q x0 y1 &amp; glue q01 @ (glue q11)^ = r} &lt;~&gt;
hfiber glue (r @ glue q11)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk69"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> q01.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">left</span> x1</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue q01 @ (glue q11)^ = r &lt;~&gt; glue q01 = r @ glue q11</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_moveL_pM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue7_to_O</span>
                   (<span class="nv">q01</span> : Q x0 y1) (<span class="nv">u</span> : glue q01 @ (glue q11)^ = r)
          : codeglue7 (to O _ (q01;u))
            = to O (hfiber glue (r @ glue q11))
                 (q01 ; moveL_pM (glue q11) (glue q01) r u)
          := to_O_equiv_natural _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeglue</span>
          : codeleft &lt;~&gt; coderight (r @ glue q11)
          := codeglue7 oE
             codeglue6 oE
             codeglue5 oE
             codeglue4 oE
             codeglue3 oE
             codeglue2 oE
             codeglue1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CodeGlue</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CodeLeft</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** *** Completion of codes *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">x0</span> : X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The equivalence [codeglue] requires a bit of massaging to put it into the form needed by the actual definition of [code] from pushout-induction and univalence. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6a"><span class="kn">Definition</span> <span class="nf">ap_code_glue</span> (<span class="nv">x1</span> : X) (<span class="nv">y1</span> : Y) (<span class="nv">q11</span> : Q x1 y1)
      : transport (<span class="kr">fun</span> <span class="nv">p</span> : SPushout Q =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
                  (glue q11) codeleft
        = coderight.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">p</span> : SPushout Q =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
  (glue q11) codeleft = coderight</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">p</span> : SPushout Q =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
  (glue q11) codeleft = coderight</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6c"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">p</span> : SPushout Q =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
  (glue q11) codeleft z = coderight z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6d"><span class="nb">refine</span> ((transport_arrow_toconst _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft (transport (paths (<span class="nb">left</span> x0)) (glue q11)^ z) =
coderight z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6e"><span class="nb">apply</span> path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft (transport (paths (<span class="nb">left</span> x0)) (glue q11)^ z) &lt;~&gt;
coderight z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk6f"><span class="nb">refine</span> (_ oE equiv_transport codeleft (transport_paths_r _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft (z @ (glue q11)^) &lt;~&gt; coderight z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk70"><span class="nb">refine</span> (_ oE codeglue _ q11).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coderight ((z @ (glue q11)^) @ glue q11) &lt;~&gt;
coderight z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk71"><span class="nb">refine</span> (equiv_transport coderight _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(z @ (glue q11)^) @ glue q11 = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_pV_p z (glue q11)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here&#39;s the final definition of [code]. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">code</span> (<span class="nv">p</span> : P) (<span class="nv">r</span> : <span class="nb">left</span> x0 = p) : <span class="kt">Type</span>
        := spushout_ind Q (<span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
                        (@codeleft x0) (@coderight x0)
                        ap_code_glue p r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** When we compute with [code], we&#39;ll need to extract from it the actual behavior of the function [codeglue].  Here&#39;s the mess of path algebra that we &quot;naturally&quot; get out when we try to do that; later we&#39;ll see how to deal with it. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk72"><span class="kn">Definition</span> <span class="nf">code_beta_glue</span> (<span class="nv">x1</span> : X) (<span class="nv">y1</span> : Y) (<span class="nv">q11</span> : Q x1 y1)
               (<span class="nv">r</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1)
      : ap10 (apD code (glue q11)) r
        = transport_arrow_toconst (glue q11) codeleft r
        @ path_universe_uncurried
           (@equiv_transport _ coderight ((r @ (glue q11)^) @ glue q11) r
                            (concat_pV_p r (glue q11))
            oE (codeglue (r @ (glue q11)^) q11)
            oE @equiv_transport _ codeleft
                 (transport (<span class="kr">fun</span> <span class="nv">y</span> : SPushout Q =&gt; <span class="nb">left</span> x0 = y) (glue q11)^ r)
                 (r @ (glue q11)^) (transport_paths_r (glue q11)^ r)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (apD code (glue q11)) r =
transport_arrow_toconst (glue q11) codeleft r @
path_universe_uncurried
  (equiv_transport coderight
     (concat_pV_p r (glue q11))
   oE codeglue (r @ (glue q11)^) q11
   oE equiv_transport codeleft
        (transport_paths_r (glue q11)^ r))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (apD code (glue q11)) r =
transport_arrow_toconst (glue q11) codeleft r @
path_universe_uncurried
  (equiv_transport coderight
     (concat_pV_p r (glue q11))
   oE codeglue (r @ (glue q11)^) q11
   oE equiv_transport codeleft
        (transport_paths_r (glue q11)^ r))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk74"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">h</span> =&gt; ap10 h r)
             (spushout_ind_beta_spglue Q (<span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="nb">left</span> x0 = p -&gt; <span class="kt">Type</span>)
                                  (@codeleft x0) (@coderight x0)
                                  ap_code_glue
                                  x1 y1 q11) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q11</var><span class="hyp-type"><b>: </b><span>Q x1 y1</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (ap_code_glue x1 y1 q11) r =
transport_arrow_toconst (glue q11) codeleft r @
path_universe_uncurried
  (equiv_transport coderight
     (concat_pV_p r (glue q11))
   oE codeglue (r @ (glue q11)^) q11
   oE equiv_transport codeleft
        (transport_paths_r (glue q11)^ r))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap10_path_arrow _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Contractibility of codes *)</span>

    <span class="sd">(** To construct a center for every type of codes, we construct one in an easy case and transport it around. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk75"><span class="kn">Definition</span> <span class="nf">center_code1</span> : code (<span class="nb">left</span> x0) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">code (<span class="nb">left</span> x0) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">code (<span class="nb">left</span> x0) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk77"><span class="nb">change</span> (codeleft (idpath (<span class="nb">left</span> x0))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk78"><span class="nb">unfold</span> codeleft.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pushout (codeleft01 <span class="mi">1</span>) (codeleft02 <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk79"><span class="nb">apply</span> to, pushl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codeleft1 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7a"><span class="nb">unfold</span> codeleft1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : x0 = x0 &amp; ap <span class="nb">left</span> s = <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (idpath; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">center_code</span> (<span class="nv">p</span> : P) (<span class="nv">r</span> : <span class="nb">left</span> x0 = p) : code p r
      := transport (<span class="kr">fun</span> (<span class="nv">pr</span> : {p : P &amp; <span class="nb">left</span> x0 = p}) =&gt; code pr.<span class="mi">1</span> pr.<span class="mi">2</span>)
                   (path_contr (A := {p : P &amp; <span class="nb">left</span> x0 = p})
                               (<span class="nb">left</span> x0; idpath) (p;r))
                   center_code1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** As in HFLL, we first construct a contraction in the &quot;partially general&quot; case of an arbitrary path from left to right. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7b"><span class="kn">Definition</span> <span class="nf">contraction_code_right</span> (<span class="nv">y1</span> : Y) (<span class="nv">r</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1)
               (<span class="nv">c</span> : code (<span class="nb">right</span> y1) r)
      : center_code (<span class="nb">right</span> y1) r = c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>code (<span class="nb">right</span> y1) r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y1) r = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>code (<span class="nb">right</span> y1) r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y1) r = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7d"><span class="nb">change</span> (coderight r) <span class="kr">in</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>coderight r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y1) r = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7e"><span class="nb">unfold</span> coderight <span class="kr">in</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>O (hfiber glue r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y1) r = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk7f"><span class="nb">revert</span> c; <span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> [q01 t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>glue q01 = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y1) r =
to O (hfiber glue r) (q01; t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk80"><span class="nb">unfold</span> center_code, center_code1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = <span class="nb">right</span> y1</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>glue q01 = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">pr</span> : {p : P &amp; <span class="nb">left</span> x0 = p} =&gt; code pr.<span class="mi">1</span> pr.<span class="mi">2</span>)
  (path_contr (<span class="nb">left</span> x0; <span class="mi">1</span>) (<span class="nb">right</span> y1; r))
  (to O (Pushout (codeleft01 <span class="mi">1</span>) (codeleft02 <span class="mi">1</span>))
     (pushl (<span class="mi">1</span>; <span class="mi">1</span>))) = to O (hfiber glue r) (q01; t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Here&#39;s how we use the apparently-unmanageable [code_beta_glue].  First we destruct the path [t] to make things simpler. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk81"><span class="nb">destruct</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">pr</span> : {p : P &amp; <span class="nb">left</span> x0 = p} =&gt; code pr.<span class="mi">1</span> pr.<span class="mi">2</span>)
  (path_contr (<span class="nb">left</span> x0; <span class="mi">1</span>) (<span class="nb">right</span> y1; glue q01))
  (to O (Pushout (codeleft01 <span class="mi">1</span>) (codeleft02 <span class="mi">1</span>))
     (pushl (<span class="mi">1</span>; <span class="mi">1</span>))) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Then we notice that if we tried rewriting with [code_beta_glue] here, the unmanageable-looking result is actually fully general over the path [glue q01], so we can prove by path induction that it equals the nicer expression we&#39;d like to see.  This is the purpose of the lemma [transport_singleton]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk82"><span class="nb">rewrite</span> (transport_singleton
                 code (glue q01) _
                 (<span class="kr">fun</span> <span class="nv">r</span> =&gt; @codeglue x0 x0 r y1 q01)
                 (code_beta_glue x0 y1 q01 (glue q01))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (code (<span class="nb">right</span> y1)) (concat_1p (glue q01))
  (codeglue <span class="mi">1</span> q01
     (to O (Pushout (codeleft01 <span class="mi">1</span>) (codeleft02 <span class="mi">1</span>))
        (pushl (<span class="mi">1</span>; <span class="mi">1</span>)))) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk83"><span class="nb">unfold</span> codeglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (code (<span class="nb">right</span> y1)) (concat_1p (glue q01))
  ((codeglue7 <span class="mi">1</span> q01 oE codeglue6 <span class="mi">1</span> q01
    oE codeglue5 <span class="mi">1</span> q01 oE codeglue4 <span class="mi">1</span> q01
    oE codeglue3 <span class="mi">1</span> q01 oE codeglue2 <span class="mi">1</span> q01
    oE codeglue1 <span class="mi">1</span>)
     (to O (Pushout (codeleft01 <span class="mi">1</span>) (codeleft02 <span class="mi">1</span>))
        (pushl (<span class="mi">1</span>; <span class="mi">1</span>)))) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Now we evaluate [codeglue] step by step using our lemmas. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk84"><span class="kp">do</span> <span class="mi">6</span> change_apply_equiv_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (code (<span class="nb">right</span> y1)) (concat_1p (glue q01))
  (codeglue7 <span class="mi">1</span> q01
     (codeglue6 <span class="mi">1</span> q01
        (codeglue5 <span class="mi">1</span> q01
           (codeglue4 <span class="mi">1</span> q01
              (codeglue3 <span class="mi">1</span> q01
                 (codeglue2 <span class="mi">1</span> q01
                    (codeglue1 <span class="mi">1</span>
                       (to O
                          (Pushout (codeleft01 <span class="mi">1</span>)
                             (codeleft02 <span class="mi">1</span>))
                          (pushl (<span class="mi">1</span>; <span class="mi">1</span>)))))))))) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk85"><span class="nb">rewrite</span> codeglue1_pushl, codeglue2_pushl, codeglue3_pushl,
      codeglue4_pushl, codeglue5_pushl, codeglue6_pushl, codeglue7_to_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (code (<span class="nb">right</span> y1)) (concat_1p (glue q01))
  (to O (hfiber glue (<span class="mi">1</span> @ glue q01))
     ((Ocodeleft2ac <span class="mi">1</span> q01
         {|
           Ocodeleft2a_s := <span class="mi">1</span>;
           Ocodeleft2a_q01 :=
             ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
           Ocodeleft2a_w :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
           Ocodeleft2a_u :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
         |}).<span class="mi">1</span>;
     moveL_pM (glue q01)
       (glue
          (Ocodeleft2ac <span class="mi">1</span> q01
             {|
               Ocodeleft2a_s := <span class="mi">1</span>;
               Ocodeleft2a_q01 :=
                 ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
               Ocodeleft2a_w :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
               Ocodeleft2a_u :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
             |}).<span class="mi">1</span>) <span class="mi">1</span>
       (Ocodeleft2ac <span class="mi">1</span> q01
          {|
            Ocodeleft2a_s := <span class="mi">1</span>;
            Ocodeleft2a_q01 :=
              ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
            Ocodeleft2a_w :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
            Ocodeleft2a_u :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
          |}).<span class="mi">2</span>)) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk86"><span class="nb">rewrite</span> &lt;- (ap_transport (concat_1p (glue q01))
                               (<span class="kr">fun</span> <span class="nv">r</span> =&gt; to O (hfiber glue r)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (hfiber glue (glue q01))
  (transport (hfiber glue) (concat_1p (glue q01))
     ((Ocodeleft2ac <span class="mi">1</span> q01
         {|
           Ocodeleft2a_s := <span class="mi">1</span>;
           Ocodeleft2a_q01 :=
             ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
           Ocodeleft2a_w :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
           Ocodeleft2a_u :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
         |}).<span class="mi">1</span>;
     moveL_pM (glue q01)
       (glue
          (Ocodeleft2ac <span class="mi">1</span> q01
             {|
               Ocodeleft2a_s := <span class="mi">1</span>;
               Ocodeleft2a_q01 :=
                 ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
               Ocodeleft2a_w :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
               Ocodeleft2a_u :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
             |}).<span class="mi">1</span>) <span class="mi">1</span>
       (Ocodeleft2ac <span class="mi">1</span> q01
          {|
            Ocodeleft2a_s := <span class="mi">1</span>;
            Ocodeleft2a_q01 :=
              ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
            Ocodeleft2a_w :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
            Ocodeleft2a_u :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
          |}).<span class="mi">2</span>)) =
to O (hfiber glue (glue q01)) (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk87"><span class="nb">apply</span> ap; <span class="nb">unfold</span> hfiber; <span class="nb">rewrite</span> transport_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((Ocodeleft2ac <span class="mi">1</span> q01
     {|
       Ocodeleft2a_s := <span class="mi">1</span>;
       Ocodeleft2a_q01 :=
         ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
       Ocodeleft2a_w :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
       Ocodeleft2a_u :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
     |}).<span class="mi">1</span>;
 moveL_pM (glue q01)
   (glue
      (Ocodeleft2ac <span class="mi">1</span> q01
         {|
           Ocodeleft2a_s := <span class="mi">1</span>;
           Ocodeleft2a_q01 :=
             ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
           Ocodeleft2a_w :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
           Ocodeleft2a_u :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
         |}).<span class="mi">1</span>) <span class="mi">1</span>
   (Ocodeleft2ac <span class="mi">1</span> q01
      {|
        Ocodeleft2a_s := <span class="mi">1</span>;
        Ocodeleft2a_q01 :=
          ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
        Ocodeleft2a_w :=
          (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
        Ocodeleft2a_u :=
          (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
      |}).<span class="mi">2</span>).<span class="mi">1</span>;
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1 =&gt;
   glue
     ((Ocodeleft2ac <span class="mi">1</span> q01
         {|
           Ocodeleft2a_s := <span class="mi">1</span>;
           Ocodeleft2a_q01 :=
             ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
           Ocodeleft2a_w :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
           Ocodeleft2a_u :=
             (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
         |}).<span class="mi">1</span>;
     moveL_pM (glue q01)
       (glue
          (Ocodeleft2ac <span class="mi">1</span> q01
             {|
               Ocodeleft2a_s := <span class="mi">1</span>;
               Ocodeleft2a_q01 :=
                 ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
               Ocodeleft2a_w :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
               Ocodeleft2a_u :=
                 (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
             |}).<span class="mi">1</span>) <span class="mi">1</span>
       (Ocodeleft2ac <span class="mi">1</span> q01
          {|
            Ocodeleft2a_s := <span class="mi">1</span>;
            Ocodeleft2a_q01 :=
              ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
            Ocodeleft2a_w :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
            Ocodeleft2a_u :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
          |}).<span class="mi">2</span>).<span class="mi">1</span> = x) (concat_1p (glue q01))
  ((Ocodeleft2ac <span class="mi">1</span> q01
      {|
        Ocodeleft2a_s := <span class="mi">1</span>;
        Ocodeleft2a_q01 :=
          ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
        Ocodeleft2a_w :=
          (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
        Ocodeleft2a_u :=
          (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
      |}).<span class="mi">1</span>;
  moveL_pM (glue q01)
    (glue
       (Ocodeleft2ac <span class="mi">1</span> q01
          {|
            Ocodeleft2a_s := <span class="mi">1</span>;
            Ocodeleft2a_q01 :=
              ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
            Ocodeleft2a_w :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
            Ocodeleft2a_u :=
              (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
          |}).<span class="mi">1</span>) <span class="mi">1</span>
    (Ocodeleft2ac <span class="mi">1</span> q01
       {|
         Ocodeleft2a_s := <span class="mi">1</span>;
         Ocodeleft2a_q01 :=
           ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
         Ocodeleft2a_w :=
           (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
         Ocodeleft2a_u :=
           (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
       |}).<span class="mi">2</span>).<span class="mi">2</span>) = (q01; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk88"><span class="nb">apply</span> ap; <span class="nb">rewrite</span> transport_paths_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Ocodeleft2ac <span class="mi">1</span> q01
    {|
      Ocodeleft2a_s := <span class="mi">1</span>;
      Ocodeleft2a_q01 :=
        ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
      Ocodeleft2a_w :=
        (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
      Ocodeleft2a_u :=
        (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
    |}).<span class="mi">1</span>;
moveL_pM (glue q01)
  (glue
     (Ocodeleft2ac <span class="mi">1</span> q01
        {|
          Ocodeleft2a_s := <span class="mi">1</span>;
          Ocodeleft2a_q01 :=
            ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
          Ocodeleft2a_w :=
            (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
          Ocodeleft2a_u :=
            (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
        |}).<span class="mi">1</span>) <span class="mi">1</span>
  (Ocodeleft2ac <span class="mi">1</span> q01
     {|
       Ocodeleft2a_s := <span class="mi">1</span>;
       Ocodeleft2a_q01 :=
         ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
       Ocodeleft2a_w :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
       Ocodeleft2a_u :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
     |}).<span class="mi">2</span>).<span class="mi">2</span> @ concat_1p (glue q01) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Finally, we have another terrible-looking thing involving [frobnicate].  However, there are enough identity paths that [frobnicate] evaluates to something we can prove with path-induction. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk89"><span class="kn">Transparent</span> frobnicate.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Ocodeleft2ac <span class="mi">1</span> q01
    {|
      Ocodeleft2a_s := <span class="mi">1</span>;
      Ocodeleft2a_q01 :=
        ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
      Ocodeleft2a_w :=
        (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
      Ocodeleft2a_u :=
        (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
    |}).<span class="mi">1</span>;
moveL_pM (glue q01)
  (glue
     (Ocodeleft2ac <span class="mi">1</span> q01
        {|
          Ocodeleft2a_s := <span class="mi">1</span>;
          Ocodeleft2a_q01 :=
            ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
          Ocodeleft2a_w :=
            (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
          Ocodeleft2a_u :=
            (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
        |}).<span class="mi">1</span>) <span class="mi">1</span>
  (Ocodeleft2ac <span class="mi">1</span> q01
     {|
       Ocodeleft2a_s := <span class="mi">1</span>;
       Ocodeleft2a_q01 :=
         ((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">1</span>;
       Ocodeleft2a_w :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">1</span>;
       Ocodeleft2a_u :=
         (((frobnicate <span class="mi">1</span> <span class="mi">1</span> y1 q01)^-<span class="mi">1</span> <span class="mi">1</span>).<span class="mi">2</span>).<span class="mi">2</span>
     |}).<span class="mi">2</span>).<span class="mi">2</span> @ concat_1p (glue q01) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_pM (glue q01) (glue q01) <span class="mi">1</span>
  ((internal_paths_rew_r
      (<span class="kr">fun</span> <span class="nv">p</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1 =&gt;
       p @ (glue q01)^ = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> = <span class="mi">1</span>)
      (internal_paths_rew_r
         (<span class="kr">fun</span> <span class="nv">p</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1 =&gt;
          p @ (glue q01)^ = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> = <span class="mi">1</span>)
         (equiv_concat_l (concat_pp_V <span class="mi">1</span> (glue q01))^ <span class="mi">1</span>)
         (concat_p1 (<span class="mi">1</span> @ glue q01)))
      ((concat_1p (glue q01))^ @
       (concat_p1 (<span class="mi">1</span> @ glue q01))^))^-<span class="mi">1</span> <span class="mi">1</span>) @
concat_1p (glue q01) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8b"><span class="kn">Opaque</span> frobnicate.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q01</var><span class="hyp-type"><b>: </b><span>Q x0 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_pM (glue q01) (glue q01) <span class="mi">1</span>
  ((internal_paths_rew_r
      (<span class="kr">fun</span> <span class="nv">p</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1 =&gt;
       p @ (glue q01)^ = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> = <span class="mi">1</span>)
      (internal_paths_rew_r
         (<span class="kr">fun</span> <span class="nv">p</span> : <span class="nb">left</span> x0 = <span class="nb">right</span> y1 =&gt;
          p @ (glue q01)^ = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> = <span class="mi">1</span>)
         (equiv_concat_l (concat_pp_V <span class="mi">1</span> (glue q01))^ <span class="mi">1</span>)
         (concat_p1 (<span class="mi">1</span> @ glue q01)))
      ((concat_1p (glue q01))^ @
       (concat_p1 (<span class="mi">1</span> @ glue q01))^))^-<span class="mi">1</span> <span class="mi">1</span>) @
concat_1p (glue q01) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (glue q01); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** It should be possible to prove an analogous [contraction_code_left] directly, but for now we follow HFLL and ABFJ by introducing a surjectivity assumption. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8c"><span class="kn">Definition</span> <span class="nf">contraction_code</span> {<span class="nv">y0</span> : Y} (<span class="nv">q00</span> : Q x0 y0)
               (<span class="nv">pr</span> : { p : P &amp; <span class="nb">left</span> x0 = p }) (<span class="nv">c</span> : code pr.<span class="mi">1</span> pr.<span class="mi">2</span>)
      : center_code pr.<span class="mi">1</span> pr.<span class="mi">2</span> = c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>{p : P &amp; <span class="nb">left</span> x0 = p}</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>code pr.<span class="mi">1</span> pr.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code pr.<span class="mi">1</span> pr.<span class="mi">2</span> = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>{p : P &amp; <span class="nb">left</span> x0 = p}</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>code pr.<span class="mi">1</span> pr.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code pr.<span class="mi">1</span> pr.<span class="mi">2</span> = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8e"><span class="nb">revert</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>{p : P &amp; <span class="nb">left</span> x0 = p}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : code pr.<span class="mi">1</span> pr.<span class="mi">2</span>, center_code pr.<span class="mi">1</span> pr.<span class="mi">2</span> = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk8f">srefine (transport (<span class="kr">fun</span> <span class="nv">pr&#39;</span> =&gt; <span class="kr">forall</span> <span class="nv">c</span>, center_code pr&#39;.<span class="mi">1</span> pr&#39;.<span class="mi">2</span> = c)
                         (path_contr (<span class="nb">right</span> y0 ; glue q00) pr) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>{p : P &amp; <span class="nb">left</span> x0 = p}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">pr&#39;</span> : {p : P &amp; <span class="nb">left</span> x0 = p} =&gt;
 <span class="kr">forall</span> <span class="nv">c</span> : code pr&#39;.<span class="mi">1</span> pr&#39;.<span class="mi">2</span>,
 center_code pr&#39;.<span class="mi">1</span> pr&#39;.<span class="mi">2</span> = c) (<span class="nb">right</span> y0; glue q00)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk90"><span class="nb">clear</span> pr; <span class="nb">cbn</span>; <span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>code (<span class="nb">right</span> y0) (glue q00)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_code (<span class="nb">right</span> y0) (glue q00) = c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contraction_code_right.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk91"><span class="kn">Definition</span> <span class="nf">contr_code_inhab</span> (<span class="nv">inh</span> : merely { y0 : Y &amp; Q x0 y0 })
               (<span class="nv">p</span> : P) (<span class="nv">r</span> : <span class="nb">left</span> x0 = p)
      : Contr (code p r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span>merely {y0 : Y &amp; Q x0 y0}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (code p r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span>merely {y0 : Y &amp; Q x0 y0}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (code p r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk93">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = p</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span>{y0 : Y &amp; Q x0 y0}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (code p r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk94"><span class="nb">destruct</span> inh <span class="kr">as</span> [y0 q00].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>isconnected_cogap</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x3</span> : X) 
(<span class="nv">y2</span> <span class="nv">y4</span> : Y) (<span class="nv">q12</span> : Q x1 y2)
(<span class="nv">q32</span> : Q x3 y2) (<span class="nv">q34</span> : Q x3 y4),
IsConnected O
  (Join ((x1; q12) = (x3; q32))
     ((y2; q32) = (y4; q34)))</span></span></span><br><span><var>P</var><span><span class="hyp-body"><b>:= </b><span>SPushout Q</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> x0 = p</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>q00</var><span class="hyp-type"><b>: </b><span>Q x0 y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (code p r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_Contr _ (center_code p r) (contraction_code q00 (p;r))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This version is sufficient for the classical Blakers-Massey theorem, as we&#39;ll see below, since its leg-wise connectivity hypothesis implies the above surjectivity assumption.  Anel-Biedermann-Finster-Joyal have a different method for eliminating the surjectivity assumption using a lemma about pushouts of monos also being pullbacks, though it seems to only work for coderight. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GBM</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The classical Blakers-Massey Theorem *)</span>

<span class="sd">(** We first state a version that gracefully extends to the bottom by assuming that path types in [{ x : X &amp; Q x y }] are connected rather than the types themselves. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">blakers_massey_connected_paths</span> `{Univalence}
  (m n : trunc_index) {X Y : <span class="kt">Type</span>} (Q : X -&gt; Y -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsConnected m.+<span class="mi">1</span> { y : Y &amp; Q x y }}
  `{<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x1</span> <span class="nv">qx1y</span> <span class="nv">x2</span> <span class="nv">qx2y</span>, IsConnected n ((x1; qx1y) = (x2; qx2y) :&gt; { x : X &amp; Q x y })}
  (x : X) (y : Y)
  : IsConnMap (n +<span class="mi">2</span>+ m) (@spglue X Y Q x y)
  := contr_code_inhab Q (n +<span class="mi">2</span>+ m) _ x (merely_isconnected m _) (spushr Q y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Typeclass search finds [isconnected_join]. *)</span>

<span class="sd">(** Here is the classical statement where we instead assume that the types are connected.  [m] and [n] here match the usage in the previous result. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">blakers_massey</span> `{Univalence}
  (m n : trunc_index) {X Y : <span class="kt">Type</span>} (Q : X -&gt; Y -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsConnected m.+<span class="mi">1</span> { y : Y &amp; Q x y }}
  `{<span class="kr">forall</span> <span class="nv">y</span>, IsConnected n.+<span class="mi">1</span> { x : X &amp; Q x y }}
  (x : X) (y : Y)
  : IsConnMap (n +<span class="mi">2</span>+ m) (@spglue X Y Q x y)
  := blakers_massey_connected_paths m n Q x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can in fact reduce [m] by one in both the statement and the conclusion.  When [m] is [-2], this is one step weaker than what [blakers_massey_connected_paths] gives, but it is convenient to have this uniform statement.  We&#39;ll use this convention for the later results as well. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk95"><span class="kn">Instance</span> <span class="nf">blakers_massey&#39;</span> `{Univalence}
  (m n : trunc_index) {X Y : <span class="kt">Type</span>} (Q : X -&gt; Y -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsConnected m.+<span class="mi">1</span> { y : Y &amp; Q x y }}
  `{<span class="kr">forall</span> <span class="nv">y</span>, IsConnected n { x : X &amp; Q x y }}
  (x : X) (y : Y)
  : IsConnMap (n +<span class="mi">2</span>+ m).-<span class="mi">1</span> (@spglue X Y Q x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsConnected (Tr n) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsConnected (Tr n) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk97"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y,
IsConnected (Tr (-<span class="mi">2</span>)) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">2</span> +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chk98" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y,
IsConnected (Tr n.+<span class="mi">1</span>) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chk98"><hr></label><div class="goal-conclusion">IsConnMap (Tr (n.+<span class="mi">1</span> +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y,
IsConnected (Tr (-<span class="mi">2</span>)) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">2</span> +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9a"><span class="nb">apply</span> isconnmap_pred&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y,
IsConnected (Tr (-<span class="mi">2</span>)) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">2</span> +<span class="mi">2</span>+ m)) (spglue Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply blakers_massey_connected_paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
IsConnected (Tr m.+<span class="mi">1</span>) {y : Y &amp; Q x y}</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y,
IsConnected (Tr n.+<span class="mi">1</span>) {x : X &amp; Q x y}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n.+<span class="mi">1</span> +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spglue Q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply blakers_massey_connected_paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A sigma functor is connected if its fibers are, so we have the following. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">blakers_massey_total_map</span> `{Univalence} (m n : trunc_index)
  {X Y : <span class="kt">Type</span>} (Q : X -&gt; Y -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsConnected m.+<span class="mi">1</span> { y : Y &amp; Q x y } }
  `{<span class="kr">forall</span> <span class="nv">y</span>, IsConnected n { x : X &amp; Q x y } }
  : IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spushout_sjoin_map Q)
  := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9c"><span class="kn">Definition</span> <span class="nf">blakers_massey_po</span> `{Univalence} (m n : trunc_index)
  {X Y Z : <span class="kt">Type</span>} (f : X -&gt; Y) (g : X -&gt; Z)
  `{H1 : !IsConnMap m.+<span class="mi">1</span> f} `{H2 : !IsConnMap n g}
  : IsConnMap (n +<span class="mi">2</span>+ m).-<span class="mi">1</span> (pullback_corec (pglue (f:=f) (g:=g))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We postcompose our map with an equivalence from the pullback of the pushout of [f] and [g] to the pullback of an equivalent [SPushout] over a family [Q]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9e"><span class="nb">pose</span> (Q := <span class="kr">fun</span> <span class="nv">y</span> <span class="nv">z</span> =&gt; {x : X &amp; f x = y /\ g x = z}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chk9f">snapply cancelL_equiv_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chka0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chka0"><hr></label><div class="goal-conclusion">Pullback pushl pushr &lt;~&gt; <span class="nl">?C</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chka1"><hr></label><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>)
  (<span class="nl">?g</span> o pullback_corec pglue)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka2"><span class="mi">1</span>: <span class="bp">exact</span> (Pullback (spushl Q) (spushr Q)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pullback pushl pushr &lt;~&gt;
Pullback (spushl Q) (spushr Q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chka3"><hr></label><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>)
  (<span class="nl">?g</span> o pullback_corec pglue)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka4"><span class="mi">1</span>: <span class="bp">by</span> snapply (equiv_pullback (equiv_pushout_spushout _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>)
  (equiv_pullback (equiv_pushout_spushout f g) <span class="mi">1</span> <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>)
   o pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Next we precompose with the equivalence from the total space of [Q] to [X]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka5">rapply (cancelR_conn_map _ (equiv_double_fibration_replacement f g)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>)
  (<span class="kr">fun</span>
     <span class="nv">x</span> : {y : Y &amp;
         {z : Z &amp; {x : X &amp; (f x = y) * (g x = z)}}} =&gt;
   equiv_pullback (equiv_pushout_spushout f g) <span class="mi">1</span> <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>)
     (pullback_corec pglue
        ((equiv_double_fibration_replacement f g)^-<span class="mi">1</span>%equiv
           x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Next we prove that this composition is homotopic to [spushout_sjoin_map Q]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka6">snapply (conn_map_homotopic _ (spushout_sjoin_map Q)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spushout_sjoin_map Q ==
(<span class="kr">fun</span>
   <span class="nv">x</span> : {y : Y &amp;
       {z : Z &amp; {x : X &amp; (f x = y) * (g x = z)}}} =&gt;
 equiv_pullback (equiv_pushout_spushout f g) <span class="mi">1</span> <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>)
   (pullback_corec pglue
      ((equiv_double_fibration_replacement f g)^-<span class="mi">1</span>%equiv
         x)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chka7"><hr></label><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spushout_sjoin_map Q)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spushout_sjoin_map Q ==
(<span class="kr">fun</span>
   <span class="nv">x</span> : {y : Y &amp;
       {z : Z &amp; {x : X &amp; (f x = y) * (g x = z)}}} =&gt;
 equiv_pullback (equiv_pushout_spushout f g) <span class="mi">1</span> <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>)
   (pullback_corec pglue
      ((equiv_double_fibration_replacement f g)^-<span class="mi">1</span>%equiv
         x)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chka9"><span class="nb">intros</span> [y [z [x [[] []]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spushout_sjoin_map Q (f x; g x; x; (<span class="mi">1</span>, <span class="mi">1</span>)) =
equiv_pullback (equiv_pushout_spushout f g) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>)
  (pullback_corec pglue
     ((equiv_double_fibration_replacement f g)^-<span class="mi">1</span>%equiv
        (f x; g x; x; (<span class="mi">1</span>, <span class="mi">1</span>))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkaa">snapply (path_sigma&#39; _ <span class="mi">1</span> (path_sigma&#39; _ <span class="mi">1</span> _)); <span class="nb">simpl</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  ap
    (functor_coeq
       (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ((f x, g x); x; (<span class="mi">1</span>, <span class="mi">1</span>)))
       (functor_sum idmap idmap) (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)) (pglue x) @ <span class="mi">1</span> <span class="kr">in</span> (_ = a)
  <span class="kr">return</span> (spushl Q (f x) = a)
<span class="kr">with</span>
| <span class="mi">1</span> =&gt; <span class="mi">1</span>
<span class="kr">end</span> = spglue Q (x; (<span class="mi">1</span>, <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkab">lhs napply concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_coeq (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ((f x, g x); x; (<span class="mi">1</span>, <span class="mi">1</span>)))
     (functor_sum idmap idmap) (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)) (pglue x) @ <span class="mi">1</span> =
spglue Q (x; (<span class="mi">1</span>, <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkac">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_coeq (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ((f x, g x); x; (<span class="mi">1</span>, <span class="mi">1</span>)))
     (functor_sum idmap idmap) (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>)) (pglue x) =
spglue Q (x; (<span class="mi">1</span>, <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkad">lhs napply functor_coeq_beta_cglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap coeq <span class="mi">1</span> @ cglue ((f x, g x); x; (<span class="mi">1</span>, <span class="mi">1</span>))) @
ap coeq <span class="mi">1</span>^ = spglue Q (x; (<span class="mi">1</span>, <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkae">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap coeq <span class="mi">1</span> @ cglue ((f x, g x); x; (<span class="mi">1</span>, <span class="mi">1</span>)) =
spglue Q (x; (<span class="mi">1</span>, <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply concat_1p.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkaf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (spushout_sjoin_map Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb0">rapply blakers_massey_total_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Y, IsConnected (Tr m.+<span class="mi">1</span>) {y : Z &amp; Q x y}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chkb1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Z, IsConnected (Tr n) {x : Y &amp; Q x y}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** What&#39;s left is to check that the partial total spaces of [Q] are connected, which we get since [f] and [g] are connected maps. We just have to strip off the irrelevant parts of [Q] to get the hfiber in each case. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Y, IsConnected (Tr m.+<span class="mi">1</span>) {y : Z &amp; Q x y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb3"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m.+<span class="mi">1</span>) {y0 : Z &amp; Q y y0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb4">nrefine (isconnected_equiv&#39; _ _ _ (H1 y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y &lt;~&gt; {y0 : Z &amp; Q y y0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Z, IsConnected (Tr n) {x : Y &amp; Q x y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb6"><span class="nb">intros</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) {x : Y &amp; Q x z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb7">nrefine (isconnected_equiv&#39; _ _ _ (H2 z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m.+<span class="mi">1</span>) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) g</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">y</span> : Y) (<span class="nv">z</span> : Z) =&gt;
{x : X &amp; (f x = y) * (g x = z)}</span></span><span class="hyp-type"><b>: </b><span>Y -&gt; Z -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber g z &lt;~&gt; {x : Y &amp; Q x z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version that requires [g] to be surjective instead of [f]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb8"><span class="kn">Definition</span> <span class="nf">blakers_massey_po&#39;</span> `{Univalence} (m n : trunc_index)
  {X Y Z : <span class="kt">Type</span>} (f : X -&gt; Y) (g : X -&gt; Z)
  `{H1 : !IsConnMap m f} `{H2 : !IsConnMap n.+<span class="mi">1</span> g}
  : IsConnMap (n +<span class="mi">2</span>+ m).-<span class="mi">1</span> (pullback_corec (pglue (f:=f) (g:=g))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ m).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkba"><span class="nb">rewrite</span> trunc_index_add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>) (pullback_corec pglue)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We will postcompose with an equivalence to the symmetrical pullback. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkbb">snapply cancelL_equiv_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chkbc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chkbc"><hr></label><div class="goal-conclusion">Pullback pushl pushr &lt;~&gt; <span class="nl">?C</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chkbd"><hr></label><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  (<span class="nl">?g</span> o pullback_corec pglue)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* And we&#39;ll show that the composite is homotopic to the symmetrical [pullback_corec] map, which we already know is connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkbe"><span class="mi">3</span>: rapply (conn_map_homotopic _ _ _ _ (blakers_massey_po n m g f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pullback pushl pushr &lt;~&gt; Pullback pushl pushr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="blakersmassey-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><label class="goal-separator" for="blakersmassey-v-chkbf"><hr></label><div class="goal-conclusion">pullback_corec pglue ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="nl">?g</span> (pullback_corec pglue x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc0">- <span class="c">(* We give the equivalence between the pullbacks. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pullback pushl pushr &lt;~&gt; Pullback pushl pushr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc1"><span class="nb">refine</span> (_ oE equiv_pullback_symm _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pullback pushr pushl &lt;~&gt; Pullback pushl pushr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">snapply (equiv_pullback pushout_sym equiv_idmap equiv_idmap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc2">- <span class="c">(* We show that the composite is homotopic to the symmetrical [pullback_corec] map. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_corec pglue ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 (equiv_pullback pushout_sym <span class="mi">1</span> <span class="mi">1</span>
    (<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>%path) (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt; <span class="mi">1</span>%path)
  oE equiv_pullback_symm pushl pushr)
   (pullback_corec pglue x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc3"><span class="nb">intro</span> x; <span class="nb">cbn</span>; <span class="nb">unfold</span> pullback_corec, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g x; f x; pglue x) =
(g x; f x; <span class="mi">1</span> @ (ap pushout_sym_map (pglue x)^ @ <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc4"><span class="nb">apply</span> (ap (<span class="kr">fun</span> <span class="nv">w</span> =&gt; (g x; f x; w))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pglue x = <span class="mi">1</span> @ (ap pushout_sym_map (pglue x)^ @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc5"><span class="nb">symmetry</span>; lhs napply concat_1p; lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pushout_sym_map (pglue x)^ = pglue x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc6">lhs napply (ap_V pushout_sym_map (pglue x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap pushout_sym_map (pglue x))^ = pglue x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc7">rhs_V napply inv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap pushout_sym_map (pglue x))^ = ((pglue x)^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc8"><span class="nb">apply</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr m) f</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n.+<span class="mi">1</span>) g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pushout_sym_map (pglue x) = (pglue x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply Pushout_rec_beta_pglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The Freudenthal Suspension Theorem *)</span>

<span class="sd">(** The Freudenthal suspension theorem is a fairly trivial corollary of the Blakers-Massey theorem.  It says that [merid : X -&gt; North = South] is highly connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkc9"><span class="kn">Instance</span> <span class="nf">freudenthal</span> `{Univalence} (n : trunc_index)
           (X : <span class="kt">Type</span>@{u}) `{IsConnected n.+<span class="mi">1</span> X}
  : IsConnMap (n +<span class="mi">2</span>+ n) (@merid X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ n)) merid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ n)) merid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* If we post-compose [merid : X -&gt; North = South] with an equivalence [North = South &lt;~&gt; P], where [P] is the pullback of the inclusions [Unit -&gt; Susp X] hitting [North] and [South], we get the canonical comparison map [X -&gt; P] whose connectivity follows from the Blakers-Massey theorem. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="blakersmassey-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="blakersmassey-v-chkcb">rapply (cancelL_equiv_conn_map _ _ (equiv_pullback_unit_unit_paths _ _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ n))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   (equiv_pullback_unit_unit_paths pushl pushr)^-<span class="mi">1</span>%equiv
     (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (blakers_massey_po n n.+<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
