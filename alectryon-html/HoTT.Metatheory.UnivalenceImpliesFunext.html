<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>UnivalenceImpliesFunext.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk0"><span class="kn">Require Import</span> HoTT.Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.<span class="kn">Universe</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Metatheory.Core Metatheory.FunextVarieties.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Univalence Implies Functional Extensionality *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UnivalenceImpliesFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{ua : Univalence_type}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Exponentiation preserves equivalences, i.e., if [e] is an equivalence then so is post-composition by [e]. *)</span>

  <span class="c">(* Should this go somewhere else? *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk1"><span class="kn">Theorem</span> <span class="nf">univalence_isequiv_postcompose</span> `{H0 : IsEquiv A B w} C : IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span>:C-&gt;A) =&gt; w o g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv w</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : C -&gt; A =&gt; w o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv w</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : C -&gt; A =&gt; w o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk3"><span class="nb">unfold</span> Univalence_type <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, IsEquiv (equiv_path A B)</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv w</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span> : C -&gt; A) (<span class="nv">x</span> : C) =&gt; w (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (isequiv_adjointify
              (<span class="kr">fun</span> (<span class="nv">g</span>:C-&gt;A) =&gt; w o g)
              (<span class="kr">fun</span> (<span class="nv">g</span>:C-&gt;B) =&gt; w^-<span class="mi">1</span> o g)
              _
              _);
    <span class="nb">intro</span>;
    <span class="nb">pose</span> (Build_Equiv _ _ w _) <span class="kr">as</span> w&#39;;
    <span class="nb">change</span> H0 <span class="kr">with</span> (@equiv_isequiv _ _ w&#39;);
    <span class="nb">change</span> w <span class="kr">with</span> (@equiv_fun _ _ w&#39;);
    <span class="nb">clearbody</span> w&#39;; <span class="nb">clear</span> H0 w;
    <span class="nb">rewrite</span> &lt;- (@eisretr _ _ (@equiv_path A B) (ua A B) w&#39;);
    <span class="nb">generalize</span> ((@equiv_inv _ _ (equiv_path A B) (ua A B)) w&#39;);
    <span class="nb">intro</span> p;
    <span class="nb">clear</span> w&#39;;
    <span class="nb">destruct</span> p;
    <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We are ready to prove functional extensionality, starting with the naive non-dependent version. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk4"><span class="kn">Local Instance</span> <span class="nf">isequiv_src_compose</span> <span class="nv">A</span> <span class="nv">B</span>
  : @IsEquiv (A -&gt; {xy : B * B &amp; fst xy = snd xy})
             (A -&gt; B)
             (<span class="kr">fun</span> <span class="nv">g</span> =&gt; (fst o pr1) o g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
   fst o pr1 o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
   fst o pr1 o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk6">rapply @univalence_isequiv_postcompose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : {xy : B * B &amp; fst xy = snd xy} =&gt; fst x.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (isequiv_adjointify
              (fst o pr1) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ((x, x); idpath))
              (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath)
              _);
      <span class="kr">let</span> <span class="nv">p</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">intros</span> [[? ?] p];
        <span class="nb">simpl</span> <span class="kr">in</span> p; <span class="nb">destruct</span> p;
        <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk7"><span class="kn">Local Instance</span> <span class="nf">isequiv_tgt_compose</span> <span class="nv">A</span> <span class="nv">B</span>
  : @IsEquiv (A -&gt; {xy : B * B &amp; fst xy = snd xy})
             (A -&gt; B)
             (<span class="kr">fun</span> <span class="nv">g</span> =&gt; (snd o pr1) o g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
   snd o pr1 o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
   snd o pr1 o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk9">rapply @univalence_isequiv_postcompose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : {xy : B * B &amp; fst xy = snd xy} =&gt; snd x.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (isequiv_adjointify
              (snd o pr1) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ((x, x); idpath))
              (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath)
              _);
      <span class="kr">let</span> <span class="nv">p</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">intros</span> [[? ?] p];
        <span class="nb">simpl</span> <span class="kr">in</span> p; <span class="nb">destruct</span> p;
        <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chka"><span class="kn">Theorem</span> <span class="nf">Univalence_implies_FunextNondep</span> : NaiveNondepFunext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveNondepFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveNondepFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chkc"><span class="nb">intros</span> A B f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Consider the following maps. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chkd"><span class="nb">pose</span> (d := <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; exist (<span class="kr">fun</span> <span class="nv">xy</span> =&gt; fst xy = snd xy) (f x, f x) (idpath (f x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chke"><span class="nb">pose</span> (e := <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; exist (<span class="kr">fun</span> <span class="nv">xy</span> =&gt; fst xy = snd xy) (f x, g x) (p x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** If we compose [d] and [e] with [free_path_target], we get [f] and [g], respectively. So, if we had a path from [d] to [e], we would get one from [f] to [g]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chkf"><span class="nb">change</span> f <span class="kr">with</span> ((snd o pr1) o d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd o pr1 o d = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk10"><span class="nb">change</span> g <span class="kr">with</span> ((snd o pr1) o e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd o pr1 o d = snd o pr1 o e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk11">rapply (ap (<span class="kr">fun</span> <span class="nv">g</span> =&gt; snd o pr1 o g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">d = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Since composition with [src] is an equivalence, we can freely compose with [src]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk12"><span class="nb">pose</span> (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">x</span> <span class="nv">y</span>=&gt; @equiv_inv _ _ _ (@isequiv_ap _ _ _ (@isequiv_src_compose A B) x y)) <span class="kr">as</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>H'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy}) =&gt;
(ap
   (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
    fst o pr1 o g))^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
(<span class="nv">x</span> <span class="nv">y</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy}),
(<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
 fst o pr1 o g) x =
(<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
 fst o pr1 o g) y -&gt; x = y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">d = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="univalenceimpliesfunext-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="univalenceimpliesfunext-v-chk13"><span class="nb">apply</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence_type</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br><span><var>d</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, f x); <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((f x, g x); p x)</span></span><span class="hyp-type"><b>: </b><span>A -&gt; {xy : B * B &amp; fst xy = snd xy}</span></span></span></span><br><span><var>H'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy}) =&gt;
(ap
   (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
    fst o pr1 o g))^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
(<span class="nv">x</span> <span class="nv">y</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy}),
(<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
 fst o pr1 o g) x =
(<span class="kr">fun</span> <span class="nv">g</span> : A -&gt; {xy : B * B &amp; fst xy = snd xy} =&gt;
 fst o pr1 o g) y -&gt; x = y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; fst (d x).<span class="mi">1</span>) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; fst (e x).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UnivalenceImpliesFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we use this to prove strong dependent funext.  Again only the codomain universe must be univalent, but the domain universe must be no larger than it is.  Thus practically speaking this means that a univalent universe satisfies funext only for functions between two types in that same universe. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Univalence_implies_WeakFunext</span> : Univalence_type -&gt; WeakFunext
  := NaiveNondepFunext_implies_WeakFunext o @Univalence_implies_FunextNondep.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Univalence_type_implies_Funext_type</span>
           `{ua : Univalence_type@{j jplusone} }
  : Funext_type@{i j j}
  := NaiveNondepFunext_implies_Funext
       (@Univalence_implies_FunextNondep ua).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The above proof justifies assuming [Univalence -&gt; Funext], which we did axiomatically in [Types/Universe.v]. *)</span></span></pre>
</div>
</div></body>
</html>
