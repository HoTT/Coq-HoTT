<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Core.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types Truncations.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet WildCat Pointed.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Groups.QuotientGroup Groups.ShortExactSequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbelianGroup AbGroups.Biproduct AbHom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.ExactSequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Short exact sequences of abelian groups *)</span>

<span class="sd">(** A short exact sequence of abelian groups consists of a monomorphism [i : A -&gt; E] and an epimorphism [p : E -&gt; B] such that the image of [i] equals the kernel of [p]. Later we will consider short exact sequences up to isomorphism by 0-truncating the type [AbSES] defined below. An isomorphism class of short exact sequences is called an extension. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> abses_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> abses_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The type of short exact sequences [A -&gt; E -&gt; B] of abelian groups. We decorate it with (&#39;) to reserve the undecorated name for the structured version. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">AbSES&#39;</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} := Build_AbSES {
    middle :  AbGroup@{u};
    inclusion : A $-&gt; middle;
    projection : middle $-&gt; B;
    isembedding_inclusion :: IsEmbedding inclusion;
    issurjection_projection :: IsSurjection projection;
    isexact_inclusion_projection :: IsExact (Tr (-<span class="mi">1</span>)) inclusion projection;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a short exact sequence [A -&gt; E -&gt; B : AbSES B A], we coerce it to [E]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">middle</span> : AbSES&#39; &gt;-&gt; AbGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> AbSES&#39; B A : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_AbSES {B A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO Figure out why printing this term eats memory and seems to never finish. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">issig_abses_do_not_print</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} : _ &lt;~&gt; AbSES&#39; B A := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [make_equiv] is slow if used in the context of the next result, so we give the abstract form of the goal here. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">issig_abses_helper</span> {<span class="nv">AG</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : AG -&gt; <span class="kt">Type</span>} {<span class="nv">Q</span> : AG -&gt; <span class="kt">Type</span>}
      {<span class="nv">R</span> : <span class="kr">forall</span> <span class="nv">E</span>, P E -&gt; <span class="kt">Type</span>} {<span class="nv">S</span> : <span class="kr">forall</span> <span class="nv">E</span>, Q E -&gt; <span class="kt">Type</span>} {<span class="nv">T</span> : <span class="kr">forall</span> <span class="nv">E</span>, P E -&gt; Q E -&gt; <span class="kt">Type</span>}
  : {X : {E : AG &amp; P E * Q E} &amp; R _ (fst X.<span class="mi">2</span>) * S _ (snd X.<span class="mi">2</span>) * T _ (fst X.<span class="mi">2</span>) (snd X.<span class="mi">2</span>)}
      &lt;~&gt; {E : AG &amp; {H0 : P E &amp; {H1 : Q E &amp; {_ : R _ H0 &amp; {_ : S _ H1 &amp; T _ H0 H1}}}}}
  := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A more useful organization of [AbSES&#39;] as a sigma-type. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_abses</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup}
  : {X : {E : AbGroup &amp; (A $-&gt; E) * (E $-&gt; B)} &amp;
           (IsEmbedding (fst X.<span class="mi">2</span>)
            * IsSurjection (snd X.<span class="mi">2</span>)
            * IsExact (Tr (-<span class="mi">1</span>)) (fst X.<span class="mi">2</span>) (snd X.<span class="mi">2</span>))}
      &lt;~&gt; AbSES&#39; B A
  := issig_abses_do_not_print oE issig_abses_helper.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iscomplex_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">E</span> : AbSES&#39; B A)
  : IsComplex (inclusion E) (projection E)
  := cx_isexact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [AbSES&#39; B A] is pointed by the split sequence [A -&gt; A+B -&gt; B]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1"><span class="kn">Instance</span> <span class="nf">ispointed_abses</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}}
  : IsPointed (AbSES&#39; B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointed (AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointed (AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3">rapply (Build_AbSES (ab_biprod A B) ab_biprod_inl ab_biprod_pr2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) ab_biprod_inl ab_biprod_pr2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex ab_biprod_inl ab_biprod_pr2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk5"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex ab_biprod_inl ab_biprod_pr2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply phomotopy_homotopy_hset; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib (phomotopy_homotopy_hset (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8"><span class="nb">intros</span> [[a b] p]; <span class="nb">cbn</span>; <span class="nb">cbn</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = ispointed_group B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((x, group_unit); <span class="mi">1</span>))
     ((a, b); p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = ispointed_group B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((x, group_unit); <span class="mi">1</span>))
     ((a, b); p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = ispointed_group B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ((x, group_unit); <span class="mi">1</span>)) ((a, b); p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb"><span class="kr">exists</span> <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = ispointed_group B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a, group_unit); <span class="mi">1</span>) = ((a, b); p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc">rapply path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = ispointed_group B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, group_unit) = (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; idpath p^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The pointed type of short exact sequences. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">AbSES</span> (<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}) : pType
  := [AbSES&#39; B A, _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths in [AbSES B A] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_path_data_iso</span>
  {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span> : AbSES B A)
  := {phi : GroupIsomorphism E F
            &amp; (phi $o inclusion _ == inclusion _)
              * (projection _ == projection _ $o phi)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Having the path data in a slightly different form is useful for [equiv_path_abses_iso]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd"><span class="kn">Local Lemma</span> <span class="nf">shuffle_abses_path_data_iso</span> `{Funext}
  {B A : AbGroup@{u}} (E F : AbSES B A)
  : (abses_path_data_iso E F)
      &lt;~&gt; {phi : GroupIsomorphism E F
                 &amp; (phi $o inclusion _ == inclusion _)
                   * (projection _ $o grp_iso_inverse phi
                      == projection _)}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F &lt;~&gt;
{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F &lt;~&gt;
{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf">srapply equiv_functor_sigma_id; <span class="nb">intro</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">phi</span> : GroupIsomorphism E F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E == projection F $o phi)) phi &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">phi</span> : GroupIsomorphism E F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E $o grp_iso_inverse phi == projection F))
  phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10">srapply equiv_functor_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi $o inclusion E == inclusion F &lt;~&gt;
phi $o inclusion E == inclusion F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk11"><hr></label><div class="goal-conclusion">projection E == projection F $o phi &lt;~&gt;
projection E $o grp_iso_inverse phi == projection F</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12"><span class="mi">1</span>: <span class="bp">exact</span> equiv_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E == projection F $o phi &lt;~&gt;
projection E $o grp_iso_inverse phi == projection F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13">srapply (equiv_functor_forall&#39; phi^-<span class="mi">1</span>); <span class="nb">intro</span> e; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (phi^-<span class="mi">1</span> e) =
projection F (phi (phi^-<span class="mi">1</span> e)) &lt;~&gt;
projection E (phi^-<span class="mi">1</span> e) = projection F e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14"><span class="nb">apply</span> equiv_concat_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (phi (phi^-<span class="mi">1</span> e)) = projection F e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (eisretr _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Paths in [AbSES] correspond to isomorphisms between the [middle]s respecting [inclusion] and [projection]. Below we prove the stronger statement [equiv_path_abses], which uses this result. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15"><span class="kn">Proposition</span> <span class="nf">equiv_path_abses_iso</span> `{Univalence}
  {B A : AbGroup@{u}} {E F : AbSES&#39; B A}
  : abses_path_data_iso E F &lt;~&gt; E = F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F &lt;~&gt; E = F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F &lt;~&gt; E = F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk17"><span class="nb">refine</span> (_ oE shuffle_abses_path_data_iso E F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)} &lt;~&gt;
E = F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18"><span class="nb">refine</span> (equiv_ap_inv issig_abses _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)} &lt;~&gt;
issig_abses^-<span class="mi">1</span> E = issig_abses^-<span class="mi">1</span> F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)} &lt;~&gt;
(issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span> = (issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a"><span class="nb">refine</span> (equiv_path_sigma _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupIsomorphism E F &amp;
(phi $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse phi == projection F)} &lt;~&gt;
{p
: ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">1</span> = ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span>
&amp;
transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B)) p
  ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> = ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b">srapply equiv_functor_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E F &lt;~&gt;
((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">1</span> = ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk1c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : GroupIsomorphism E F,
(<span class="kr">fun</span> <span class="nv">phi</span> : GroupIsomorphism E F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E $o grp_iso_inverse phi == projection F))
  a &lt;~&gt;
(<span class="kr">fun</span>
   <span class="nv">p</span> : ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">1</span> =
       ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span> =&gt;
 transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
   p ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> =
 ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span>) (<span class="nl">?f</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d"><span class="mi">1</span>: <span class="bp">exact</span> equiv_path_abgroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : GroupIsomorphism E F,
(<span class="kr">fun</span> <span class="nv">phi</span> : GroupIsomorphism E F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E $o grp_iso_inverse phi == projection F))
  a &lt;~&gt;
(<span class="kr">fun</span>
   <span class="nv">p</span> : ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">1</span> =
       ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span> =&gt;
 transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
   p ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> =
 ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span>) (equiv_path_abgroup a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e"><span class="nb">intro</span> q; <span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse q == projection F) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
  (equiv_path_abgroup q) ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> =
((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f">snrefine (equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A $-&gt; ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span>) *
(((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">1</span> $-&gt; B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk20"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
  (equiv_path_abgroup q) ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> = 
<span class="nl">?y</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk21"><hr></label><div class="goal-conclusion">(q $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse q == projection F) &lt;~&gt;
<span class="nl">?y</span> = ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk22"><span class="mi">1</span>: <span class="bp">exact</span> (q $o inclusion _, projection _ $o grp_iso_inverse q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
  (equiv_path_abgroup q) ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> =
(q $o inclusion E, projection E $o grp_iso_inverse q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk23"><hr></label><div class="goal-conclusion">(q $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse q == projection F) &lt;~&gt;
(q $o inclusion E, projection E $o grp_iso_inverse q) =
((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk24"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse q == projection F) &lt;~&gt;
(q $o inclusion E, projection E $o grp_iso_inverse q) =
((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk25"><span class="nb">refine</span> (equiv_path_prod _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $o inclusion E == inclusion F) *
(projection E $o grp_iso_inverse q == projection F) &lt;~&gt;
(fst
   (q $o inclusion E,
   projection E $o grp_iso_inverse q) =
 fst ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span>) *
(snd
   (q $o inclusion E,
   projection E $o grp_iso_inverse q) =
 snd ((issig_abses^-<span class="mi">1</span> F).<span class="mi">1</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_functor_prod&#39;
                equiv_path_grouphomomorphism
                equiv_path_grouphomomorphism).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk26">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">E</span> : AbGroup =&gt; (A $-&gt; E) * (E $-&gt; B))
  (equiv_path_abgroup q) ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span> =
(q $o inclusion E, projection E $o grp_iso_inverse q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk27"><span class="nb">refine</span> (transport_prod _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport (Hom A) (equiv_path_abgroup q)
   (fst ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>),
transport (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt; a $-&gt; B)
  (equiv_path_abgroup q)
  (snd ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>)) =
(q $o inclusion E, projection E $o grp_iso_inverse q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk28"><span class="nb">apply</span> path_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup q)
  (fst ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>) = q $o inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk29"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt; a $-&gt; B)
  (equiv_path_abgroup q)
  (snd ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>) =
projection E $o grp_iso_inverse q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup q)
  (fst ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>) = q $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_iso_abgrouphomomorphism_from_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES&#39; B A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt; a $-&gt; B)
  (equiv_path_abgroup q)
  (snd ((issig_abses^-<span class="mi">1</span> E).<span class="mi">1</span>).<span class="mi">2</span>) =
projection E $o grp_iso_inverse q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_iso_abgrouphomomorphism_to_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that [AbSES B A] is 1-truncated. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2c"><span class="kn">Instance</span> <span class="nf">istrunc_abses</span> `{Univalence} {B A : AbGroup@{u}}
  : IsTrunc <span class="mi">1</span> (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2e"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : AbSES B A, IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk2f"><span class="nb">intros</span> E F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (E = F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk30"><span class="nb">refine</span> (istrunc_equiv_istrunc _ equiv_path_abses_iso (n:=<span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (abses_path_data_iso E F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk31">rapply istrunc_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupIsomorphism E F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ishset_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_abses_iso</span> `{Univalence} {B A : AbGroup@{u}}
  {E F : AbSES B A}
  (phi : GroupIsomorphism E F) (p : phi $o inclusion _ == inclusion _)
  (q : projection _ == projection _ $o phi)
  : E = F := equiv_path_abses_iso (phi; (p,q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given [p] and [q], the map [phi] just above is automatically an isomorphism. Showing this requires the &quot;short five lemma.&quot; *)</span>

<span class="sd">(** A special case of the &quot;short 5-lemma&quot; where the two outer maps are (definitionally) identities. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk32"><span class="kn">Lemma</span> <span class="nf">short_five_lemma</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}}
  {<span class="nv">E</span> <span class="nv">F</span> : AbSES B A} (<span class="nv">phi</span> : Hom (A:=AbGroup) E F)
  (<span class="nv">p0</span> : phi $o inclusion E == inclusion F) (<span class="nv">p1</span> : projection E == projection F $o phi)
  : IsEquiv phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk34"><span class="nb">apply</span> isequiv_surj_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) phi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><label class="goal-separator" for="core-v-chk35"><hr></label><div class="goal-conclusion">IsEmbedding phi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk37"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk38">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Since [projection E] is epi, we can pull [projection F f] back to [e0 : E].*)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk39"><span class="nb">assert</span> (e0 : Tr (-<span class="mi">1</span>) (hfiber (projection E) (projection F f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (projection E) (projection F f))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (projection E) (projection F f))</span></span></span><br></div><label class="goal-separator" for="core-v-chk3a"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3b"><span class="mi">1</span>: <span class="nb">apply</span> center, issurjection_projection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (projection E) (projection F f))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3c">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** The difference [f - (phi e0.1)] is sent to [0] by [projection F], hence lies in [A]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3d"><span class="nb">assert</span> (a : Tr (-<span class="mi">1</span>) (hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>))</span></span></span><br></div><label class="goal-separator" for="core-v-chk3e"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40"><span class="nb">refine</span> (isexact_preimage (Tr (-<span class="mi">1</span>)) (inclusion F) (projection F) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (f - phi e0.<span class="mi">1</span>) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f + projection F (- phi e0.<span class="mi">1</span>) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42"><span class="nb">refine</span> (ap _ (grp_homo_inv _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f - projection F (phi e0.<span class="mi">1</span>) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43"><span class="nb">apply</span> (grp_moveL_1M)^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F f = projection F (phi e0.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (e0.<span class="mi">2</span>^ @ p1 e0.<span class="mi">1</span>).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk45">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber phi f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46"><span class="nb">refine</span> (tr (inclusion E a.<span class="mi">1</span> + e0.<span class="mi">1</span>; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi (inclusion E a.<span class="mi">1</span> + e0.<span class="mi">1</span>) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi (inclusion E a.<span class="mi">1</span>) + phi e0.<span class="mi">1</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk48"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x + phi e0.<span class="mi">1</span>) (p0 a.<span class="mi">1</span> @ a.<span class="mi">2</span>) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f - phi e0.<span class="mi">1</span> + phi e0.<span class="mi">1</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49"><span class="nb">refine</span> ((grp_assoc _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f + (- phi e0.<span class="mi">1</span> + phi e0.<span class="mi">1</span>) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a"><span class="nb">refine</span> (ap _ (left_inverse (phi e0.<span class="mi">1</span>)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>hfiber (projection E) (projection F f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion F) (f - phi e0.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f + <span class="mi">0</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c"><span class="nb">apply</span> isembedding_istrivial_kernel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrivialGroup (grp_kernel phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d"><span class="nb">intros</span> e p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e"><span class="nb">assert</span> (a : Tr (-<span class="mi">1</span>) (hfiber (inclusion E) e)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (inclusion E) e)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (inclusion E) e)</span></span></span><br></div><label class="goal-separator" for="core-v-chk4f"><hr></label><div class="goal-conclusion">trivial_subgroup E e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (inclusion E) e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk51"><span class="nb">refine</span> (isexact_preimage _ (inclusion E) (projection E) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E e = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p1 e @ ap (projection F) p @ grp_homo_unit _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (inclusion E) e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion E) e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trivial_subgroup E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54"><span class="nb">refine</span> (a.<span class="mi">2</span>^ @ ap (inclusion E ) _ @ grp_homo_unit (inclusion E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion E) e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55">rapply (isinj_embedding (inclusion F) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_kernel phi e</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion E) e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F a.<span class="mi">1</span> = inclusion F <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((p0 a.<span class="mi">1</span>)^ @ (ap phi a.<span class="mi">2</span>) @ p @ (grp_homo_unit _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Below we prove that homomorphisms respecting [projection] and [inclusion] correspond to paths in [AbSES B A]. We refer to such homomorphisms simply as path data in [AbSES B A]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_path_data</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span> : AbSES B A)
  := {phi : Hom (A:=AbGroup) E F
            &amp; (phi $o inclusion _ == inclusion _)
              * (projection _ == projection _ $o phi)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56"><span class="kn">Definition</span> <span class="nf">abses_path_data_to_iso</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span>: AbSES B A)
  : abses_path_data E F -&gt; abses_path_data_iso E F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F -&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F -&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F -&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59"><span class="nb">intros</span> [phi [p q]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ({| grp_iso_homo := phi; isequiv_group_iso := short_five_lemma phi p q |}; (p, q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a"><span class="kn">Proposition</span> <span class="nf">equiv_path_abses_data</span> `{Funext} {B A : AbGroup@{u}} (E F: AbSES B A)
  : abses_path_data E F &lt;~&gt; abses_path_data_iso E F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F &lt;~&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F &lt;~&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c">srapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F -&gt; abses_path_data_iso E F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk5d"><hr></label><div class="goal-conclusion">abses_path_data_iso E F -&gt; abses_path_data E F</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk5e"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk5f"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E F -&gt; abses_path_data_iso E F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_path_data_to_iso.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E F -&gt; abses_path_data E F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk62">srapply (functor_sigma (grp_iso_homo _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : GroupIsomorphism E F,
(<span class="kr">fun</span> <span class="nv">phi</span> : GroupIsomorphism E F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E == projection F $o phi)) a -&gt;
(<span class="kr">fun</span> <span class="nv">phi</span> : E $-&gt; F =&gt;
 (phi $o inclusion E == inclusion F) *
 (projection E == projection F $o phi)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_to_iso E F
o functor_sigma (grp_iso_homo E F)
    (<span class="kr">fun</span> <span class="nv">a</span> : GroupIsomorphism E F =&gt; idmap) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk64"><span class="nb">intros</span> [phi [p q]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_to_iso E F
  (functor_sigma (grp_iso_homo E F)
     (<span class="kr">fun</span> <span class="nv">a</span> : GroupIsomorphism E F =&gt; idmap)
     (phi; (p, q))) = (phi; (p, q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk65"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_path_data_to_iso E F
   (functor_sigma (grp_iso_homo E F)
      (<span class="kr">fun</span> <span class="nv">a</span> : GroupIsomorphism E F =&gt; idmap)
      (phi; (p, q)))).<span class="mi">1</span> = (phi; (p, q)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma (grp_iso_homo E F)
  (<span class="kr">fun</span> <span class="nv">a</span> : GroupIsomorphism E F =&gt; idmap)
o abses_path_data_to_iso E F == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_abses</span> `{Univalence} {B A : AbGroup@{u}} {E F : AbSES B A}
  : abses_path_data E F &lt;~&gt; E = F
  := equiv_path_abses_iso oE equiv_path_abses_data E F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_abses</span> `{Univalence} {B A : AbGroup@{u}}
  {E F : AbSES B A} (phi : middle E $-&gt; F)
  (p : phi $o inclusion _ == inclusion _) (q : projection _ == projection _ $o phi)
  : E = F := equiv_path_abses (phi; (p,q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** The wildcat of short exact sequences *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_abses_path_data</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span> : AbSES B A)
  : IsGraph (abses_path_data_iso E F)
  := isgraph_induced (grp_iso_homo _ _ o pr1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_abses_path_data</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span> : AbSES B A)
  : Is01Cat (abses_path_data_iso E F)
  := is01cat_induced (grp_iso_homo _ _ o pr1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0gpd_abses_path_data</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} (<span class="nv">E</span> <span class="nv">F</span> : AbSES B A)
  : Is0Gpd (abses_path_data_iso E F)
  := is0gpd_induced (grp_iso_homo _ _ o pr1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} : IsGraph (AbSES B A)
  := Build_IsGraph _ abses_path_data_iso.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The path data corresponding to [idpath]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_path_data_1</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} (<span class="nv">E</span> : AbSES B A)
  : E $-&gt; E := (grp_iso_id; (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath, <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can compose path data in [AbSES B A]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_path_data_compose</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} {<span class="nv">E</span> <span class="nv">F</span> <span class="nv">G</span> : AbSES B A}
           (<span class="nv">p</span> : E $-&gt; F) (<span class="nv">q</span> : F $-&gt; G) : E $-&gt; G
  := (q.<span class="mi">1</span> $oE p.<span class="mi">1</span>; ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap q.<span class="mi">1</span> (fst p.<span class="mi">2</span> x) @ fst q.<span class="mi">2</span> x),
                     (<span class="kr">fun</span> <span class="nv">x</span> =&gt; snd p.<span class="mi">2</span> x @ snd q.<span class="mi">2</span> (p.<span class="mi">1</span> x)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}}
  : Is01Cat (AbSES B A)
  := Build_Is01Cat _ _ abses_path_data_1
       (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">q</span> <span class="nv">p</span> =&gt; abses_path_data_compose p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk67"><span class="kn">Definition</span> <span class="nf">abses_path_data_inverse</span>
  {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} {<span class="nv">E</span> <span class="nv">F</span> : AbSES B A}
  : (E $-&gt; F) -&gt; (F $-&gt; E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(E $-&gt; F) -&gt; F $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(E $-&gt; F) -&gt; F $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk69"><span class="nb">intros</span> [phi [p q]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk6a">srefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism F E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><label class="goal-separator" for="core-v-chk6b"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion F == inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><label class="goal-separator" for="core-v-chk6c"><hr></label><div class="goal-conclusion">projection F == projection E $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk6d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism F E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_iso_inverse phi).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk6e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_inverse phi $o inclusion F == inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk6f"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_iso_inverse phi $o inclusion F) a = inclusion E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (p a)^ @ eissect _ (inclusion E a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk70">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F == projection E $o grp_iso_inverse phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk71"><span class="nb">intro</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E F</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E == projection F $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F a = projection E (phi^-<span class="mi">1</span> a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (projection F) (eisretr _ _)^ @ (q _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0gpd_abses</span>
  {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} : Is0Gpd (AbSES B A)
  := {| gpd_rev := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; abses_path_data_inverse |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_abses</span>
  {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} : Is2Graph (AbSES B A)
  := <span class="kr">fun</span> <span class="nv">E</span> <span class="nv">F</span> =&gt; isgraph_abses_path_data E F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [AbSES B A] forms a 1Cat *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk72"><span class="kn">Instance</span> <span class="nf">is1cat_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}}
  : Is1Cat (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk74">snapply Build_Is1Cat&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbSES B A, Is01Cat (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk75"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbSES B A, Is0Gpd (a $-&gt; b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk76"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk77"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk78"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk79"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk7a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk7b"><span class="mi">1</span>: <span class="nb">intros</span> ? ?; <span class="nb">apply</span> is01cat_abses_path_data.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbSES B A, Is0Gpd (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk7c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk7d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk7e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk7f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk80"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk81"><span class="mi">1</span>: <span class="nb">intros</span> ? ?; <span class="nb">apply</span> is0gpd_abses_path_data.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk82"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk83"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk84"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk85"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk86"><span class="mi">3</span>-<span class="mi">5</span>: <span class="nb">cbn</span>; <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chk87"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk88"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">intros</span> E F G f;
  srapply Build_Is0Functor;
  <span class="nb">intros</span> p q h e; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $-&gt; q</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f.<span class="mi">1</span> (p.<span class="mi">1</span> e) = f.<span class="mi">1</span> (q.<span class="mi">1</span> e)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $-&gt; q</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="core-v-chk89"><hr></label><div class="goal-conclusion">p.<span class="mi">1</span> (f.<span class="mi">1</span> e) = q.<span class="mi">1</span> (f.<span class="mi">1</span> e)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $-&gt; q</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f.<span class="mi">1</span> (p.<span class="mi">1</span> e) = f.<span class="mi">1</span> (q.<span class="mi">1</span> e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f.<span class="mi">1</span> (h e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $-&gt; q</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (f.<span class="mi">1</span> e) = q.<span class="mi">1</span> (f.<span class="mi">1</span> e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (h (f.<span class="mi">1</span> e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8c"><span class="kn">Instance</span> <span class="nf">is1gpd_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}}
  : Is1Gpd (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Gpd (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Gpd (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk8e">rapply Build_Is1Gpd;
    <span class="nb">intros</span> E F p e; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p.<span class="mi">1</span>)^-<span class="mi">1</span> (p.<span class="mi">1</span> e) = e</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><label class="goal-separator" for="core-v-chk8f"><hr></label><div class="goal-conclusion">p.<span class="mi">1</span> ((p.<span class="mi">1</span>)^-<span class="mi">1</span> e) = e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p.<span class="mi">1</span>)^-<span class="mi">1</span> (p.<span class="mi">1</span> e) = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> ((p.<span class="mi">1</span>)^-<span class="mi">1</span> e) = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk92"><span class="kn">Instance</span> <span class="nf">hasmorext_abses</span> `{Funext} {A B : AbGroup@{u}}
  : HasMorExt (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk94"><span class="nb">intros</span> E F f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk95">srapply isequiv_homotopic&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; f.<span class="mi">1</span> == g.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="core-v-chk96"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> == GpdHom_path</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk97"><span class="mi">1</span>: <span class="bp">exact</span> (((equiv_path_groupisomorphism _ _)^-<span class="mi">1</span>%equiv)
              oE (equiv_path_sigma_hprop _ _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_groupisomorphism f.<span class="mi">1</span> g.<span class="mi">1</span>)^-<span class="mi">1</span>
oE (equiv_path_sigma_hprop f g)^-<span class="mi">1</span> == GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> p; <span class="bp">by</span> <span class="nb">induction</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Path data lemmas *)</span>

<span class="sd">(** We need to be able to work with path data as if they&#39;re paths. Our preference is to state things in terms of [abses_path_data_iso], since this lets us keep track of isomorphisms whose inverses compute. The &quot;abstract&quot; inverses produced by [short_five_lemma] do not compute well. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk98"><span class="kn">Definition</span> <span class="nf">equiv_path_abses_1</span> `{Univalence} {B A : AbGroup@{u}} {E : AbSES B A}
  : equiv_path_abses_iso (abses_path_data_1 E) = idpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (abses_path_data_1 E) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (abses_path_data_1 E) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9a"><span class="nb">apply</span> (equiv_ap_inv&#39; equiv_path_abses_iso).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span>
  (equiv_path_abses_iso (abses_path_data_1 E)) =
equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9b"><span class="nb">refine</span> (eissect _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_1 E = equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9c">srapply path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_id =
{|
  grp_iso_homo :=
    {|
      grp_homo_map := idmap;
      issemigrouppreserving_grp_homo :=
        abstract_algebra.id_sg_morphism
    |};
  isequiv_group_iso :=
    {|
      equiv_inv := idmap;
      eisretr := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>;
      eissect := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>;
      eisadj := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>
    |}
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9d">srapply equiv_path_groupisomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_id ==
{|
  grp_iso_homo :=
    {|
      grp_homo_map := idmap;
      issemigrouppreserving_grp_homo :=
        abstract_algebra.id_sg_morphism
    |};
  isequiv_group_iso :=
    {|
      equiv_inv := idmap;
      eisretr := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>;
      eissect := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>;
      eisadj := <span class="kr">fun</span> <span class="nv">x</span> : E =&gt; <span class="mi">1</span>
    |}
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9e"><span class="kn">Definition</span> <span class="nf">equiv_path_absesV_1</span> `{Univalence} {B A : AbGroup@{u}} {E : AbSES B A}
  : (@equiv_path_abses_iso _ B A E E)^-<span class="mi">1</span> idpath = Id E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span> = Id E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span> = Id E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka0"><span class="nb">apply</span> moveR_equiv_M; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_abses_iso^-<span class="mi">1</span>)^-<span class="mi">1</span> (Id E) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_abses_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka1"><span class="kn">Definition</span> <span class="nf">abses_path_data_V</span> `{Univalence} {B A : AbGroup@{u}} {E F : AbSES B A}
           (p : abses_path_data_iso E F)
  : (equiv_path_abses_iso p)^ = equiv_path_abses_iso (abses_path_data_inverse p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_abses_iso p)^ =
equiv_path_abses_iso (abses_path_data_inverse p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_abses_iso p)^ =
equiv_path_abses_iso (abses_path_data_inverse p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka3"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : abses_path_data_iso E F,
(equiv_path_abses_iso p)^ =
equiv_path_abses_iso (abses_path_data_inverse p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka4">equiv_intro (equiv_path_abses_iso (E:=E) (F:=F))^-<span class="mi">1</span> p; <span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_abses_iso (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))^ =
equiv_path_abses_iso
  (abses_path_data_inverse (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka5"><span class="nb">refine</span> (ap _ (eisretr _ _) @ _); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso
  (abses_path_data_inverse (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)) =
<span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka6">nrefine (ap (equiv_path_abses_iso o abses_path_data_inverse) equiv_path_absesV_1 @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (abses_path_data_inverse (Id E)) =
<span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka7"><span class="nb">refine</span> (ap equiv_path_abses_iso gpd_strong_rev_1 @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (Id E) = <span class="mi">1</span>^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Composition of path data corresponds to composition of paths. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8"><span class="kn">Definition</span> <span class="nf">abses_path_compose_beta</span> `{Univalence} {B A : AbGroup@{u}} {E F G : AbSES B A}
          (p : E = F) (q : F = G)
 : p @ q = equiv_path_abses_iso
             (abses_path_data_compose
                (equiv_path_abses_iso^-<span class="mi">1</span> p) (equiv_path_abses_iso^-<span class="mi">1</span> q)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>F = G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> p)
     (equiv_path_abses_iso^-<span class="mi">1</span> q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>F = G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> p)
     (equiv_path_abses_iso^-<span class="mi">1</span> q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa"><span class="nb">induction</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ <span class="mi">1</span> =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)
     (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab"><span class="nb">refine</span> (equiv_path_abses_1^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (abses_path_data_1 E) =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)
     (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac"><span class="nb">apply</span> (ap equiv_path_abses_iso).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_1 E =
abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)
  (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkad"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_path_data_1 E).<span class="mi">1</span> =
(abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)
   (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A second beta-principle where you start with path data instead of actual paths. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkae"><span class="kn">Definition</span> <span class="nf">abses_path_data_compose_beta</span> `{Univalence} {B A : AbGroup@{u}} {E F G : AbSES B A}
           (p : abses_path_data_iso E F) (q : abses_path_data_iso F G)
  : equiv_path_abses_iso p @ equiv_path_abses_iso q
    = equiv_path_abses_iso (abses_path_data_compose p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso p @ equiv_path_abses_iso q =
equiv_path_abses_iso (abses_path_data_compose p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso p @ equiv_path_abses_iso q =
equiv_path_abses_iso (abses_path_data_compose p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb0"><span class="nb">generalize</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : abses_path_data_iso E F)
(<span class="nv">q</span> : abses_path_data_iso F G),
equiv_path_abses_iso p @ equiv_path_abses_iso q =
equiv_path_abses_iso (abses_path_data_compose p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1">equiv_intro ((equiv_path_abses_iso (E:=E) (F:=F))^-<span class="mi">1</span>) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">q</span> : abses_path_data_iso F G,
equiv_path_abses_iso (equiv_path_abses_iso^-<span class="mi">1</span> x) @
equiv_path_abses_iso q =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> x)
     q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2">equiv_intro ((equiv_path_abses_iso (E:=F) (F:=G))^-<span class="mi">1</span>) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F = G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (equiv_path_abses_iso^-<span class="mi">1</span> x) @
equiv_path_abses_iso (equiv_path_abses_iso^-<span class="mi">1</span> y) =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> x)
     (equiv_path_abses_iso^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3"><span class="nb">refine</span> ((eisretr _ _ @@ eisretr _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso F G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F = G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x @ y =
equiv_path_abses_iso
  (abses_path_data_compose (equiv_path_abses_iso^-<span class="mi">1</span> x)
     (equiv_path_abses_iso^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply abses_path_compose_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Homotopies of path data *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4"><span class="kn">Definition</span> <span class="nf">equiv_path_data_homotopy</span> `{Univalence} {X : <span class="kt">Type</span>} {B A : AbGroup@{u}}
           (f g : X -&gt; AbSES B A) : (f $=&gt; g) &lt;~&gt; f == g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f $=&gt; g) &lt;~&gt; f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f $=&gt; g) &lt;~&gt; f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6">srapply equiv_functor_forall_id; <span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso (f x) (g x) &lt;~&gt; f x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_iso.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_abses_const</span> {<span class="nv">B&#39;</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}} : AbSES B A --&gt;* AbSES B&#39; A&#39;
  := Build_BasepointPreservingFunctor (const pt) (Id pt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_pointed</span> `{Univalence} {B&#39; A&#39; B A : AbGroup@{u}}
  : (AbSES B A --&gt;* AbSES B&#39; A&#39;) -&gt; (AbSES B A -&gt;* AbSES B&#39; A&#39;)
  := <span class="kr">fun</span> <span class="nv">f</span> =&gt; Build_pMap f (equiv_path_abses_iso (bp_pointed f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb7"><span class="kn">Lemma</span> <span class="nf">pmap_abses_const_to_pointed</span> `{Univalence} {B&#39; A&#39; B A : AbGroup@{u}}
  : pconst ==* to_pointed (@pmap_abses_const B&#39; A&#39; B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* to_pointed pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* to_pointed pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb9">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst == to_pointed pmap_abses_const</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chkba"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq pconst @
(dpoint_eq (to_pointed pmap_abses_const))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkbb"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : AbSES&#39; B A =&gt; <span class="mi">1</span>) pt =
dpoint_eq pconst @
(dpoint_eq (to_pointed pmap_abses_const))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkbc"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq (to_pointed pmap_abses_const) =
dpoint_eq pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkbd"><span class="nb">refine</span> (concat_1p _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint_eq (to_pointed pmap_abses_const) =
dpoint_eq pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkbe"><span class="kn">Lemma</span> <span class="nf">abses_ap_fmap</span> `{Univalence} {B0 B1 A0 A1 : AbGroup@{u}}
      (f : AbSES B0 A0 -&gt; AbSES B1 A1) `{!Is0Functor f, !Is1Functor f}
      {E F : AbSES B0 A0} (p : E $== F)
  : ap f (equiv_path_abses_iso p) = equiv_path_abses_iso (fmap f p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkbf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc0"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : E $== F,
ap f (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc1"><span class="nb">apply</span> (equiv_ind equiv_path_abses_iso^-<span class="mi">1</span>%equiv);
    <span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (equiv_path_abses_iso
     (equiv_path_abses_iso^-<span class="mi">1</span>%equiv p)) =
equiv_path_abses_iso
  (fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc2"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (equiv_path_abses_iso
     (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>)) =
equiv_path_abses_iso
  (fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc3"><span class="nb">refine</span> (ap (ap f) (eisretr _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> =
equiv_path_abses_iso
  (fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc4">nrefine (_ @ ap equiv_path_abses_iso _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = equiv_path_abses_iso <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><label class="goal-separator" for="core-v-chkc5"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> = fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc6"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> = fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc7">tapply path_hom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> $== fmap f (equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkc8">srefine (_ $@ fmap2 _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> $== fmap f <span class="nl">?f</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><label class="goal-separator" for="core-v-chkc9"><hr></label><div class="goal-conclusion">E $-&gt; E</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><label class="goal-separator" for="core-v-chkca"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> $== equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkcb"><span class="mi">2</span>: <span class="bp">exact</span> (Id E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> $== fmap f (Id E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><label class="goal-separator" for="core-v-chkcc"><hr></label><div class="goal-conclusion">Id E $== equiv_path_abses_iso^-<span class="mi">1</span>%equiv <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkcd"><span class="mi">2</span>: <span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> $== fmap f (Id E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap_id f _)^$.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkce">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, A0, A1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 -&gt; AbSES B1 A1</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor f</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = equiv_path_abses_iso (Id (f E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_1^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkcf"><span class="kn">Definition</span> <span class="nf">to_pointed_compose</span> `{Univalence} {B0 B1 B2 A0 A1 A2 : AbGroup@{u}}
           (f : AbSES B0 A0 --&gt;* AbSES B1 A1) (g : AbSES B1 A1 --&gt;* AbSES B2 A2)
           `{!Is1Functor f, !Is1Functor g}
  : to_pointed g o* to_pointed f ==* to_pointed (g $o* f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed g o* to_pointed f ==* to_pointed (g $o* f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed g o* to_pointed f ==* to_pointed (g $o* f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd1">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed g o* to_pointed f == to_pointed (g $o* f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkd2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><label class="goal-separator" for="core-v-chkd2"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (to_pointed g o* to_pointed f) @
(dpoint_eq (to_pointed (g $o* f)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd3"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : AbSES&#39; B0 A0 =&gt; <span class="mi">1</span>) pt =
dpoint_eq (to_pointed g o* to_pointed f) @
(dpoint_eq (to_pointed (g $o* f)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd4"><span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
dpoint_eq (to_pointed g o* to_pointed f) @
(dpoint_eq (to_pointed (g $o* f)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd5">napply moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq (to_pointed (g $o* f)) =
dpoint_eq (to_pointed g o* to_pointed f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd6">nrefine (concat_1p _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint_eq (to_pointed (g $o* f)) =
dpoint_eq (to_pointed g o* to_pointed f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd7"><span class="nb">unfold</span> pmap_compose, Build_pMap, pointed_fun, point_eq, dpoint_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint_eq (to_pointed (g $o* f)) =
ap (to_pointed g) (dpoint_eq (to_pointed f)) @
dpoint_eq (to_pointed g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkd8"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x @ _) _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (bp_pointed (g $o* f)) =
<span class="nl">?Goal0</span> @ equiv_path_abses_iso (bp_pointed g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><label class="goal-separator" for="core-v-chkd9"><hr></label><div class="goal-conclusion">ap (to_pointed g) (dpoint_eq (to_pointed f)) = <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkda"><span class="mi">2</span>: <span class="nb">apply</span> (abses_ap_fmap g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (bp_pointed (g $o* f)) =
equiv_path_abses_iso (fmap g (bp_pointed f)) @
equiv_path_abses_iso (bp_pointed g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkdb">nrefine (_ @ (abses_path_data_compose_beta _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso (bp_pointed (g $o* f)) =
equiv_path_abses_iso
  (abses_path_data_compose 
     (fmap g (bp_pointed f)) 
     (bp_pointed g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkdc">napply (ap equiv_path_abses_iso).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bp_pointed (g $o* f) =
abses_path_data_compose 
  (fmap g (bp_pointed f)) 
  (bp_pointed g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkdd">tapply path_hom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B0, B1, B2, A0, A1, A2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0 --&gt;* AbSES B1 A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1 --&gt;* AbSES B2 A2</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor f</span></span></span><br><span><var>Is1Functor1</var><span class="hyp-type"><b>: </b><span>Is1Functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bp_pointed (g $o* f) $==
abses_path_data_compose 
  (fmap g (bp_pointed f)) 
  (bp_pointed g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkde"><span class="kn">Definition</span> <span class="nf">equiv_ptransformation_phomotopy</span> `{Univalence} {B&#39; A&#39; B A : AbGroup@{u}}
           {f g : AbSES B A --&gt;* AbSES B&#39; A&#39;}
  : f $=&gt;* g &lt;~&gt; to_pointed f ==* to_pointed g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $=&gt;* g &lt;~&gt; to_pointed f ==* to_pointed g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkdf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $=&gt;* g &lt;~&gt; to_pointed f ==* to_pointed g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke0"><span class="nb">refine</span> (issig_pforall _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $=&gt;* g &lt;~&gt;
{f0
: <span class="kr">forall</span> <span class="nv">x</span> : AbSES B A,
  pfam_phomotopy (to_pointed f) (to_pointed g) x &amp;
f0 pt =
dpoint (pfam_phomotopy (to_pointed f) (to_pointed g))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke1"><span class="nb">apply</span> (equiv_functor_sigma&#39; (equiv_path_data_homotopy f g)); <span class="nb">intro</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt $== bp_pointed f $@ (bp_pointed g)^$ &lt;~&gt;
equiv_path_data_homotopy f g h pt =
dpoint (pfam_phomotopy (to_pointed f) (to_pointed g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke2"><span class="nb">refine</span> (equiv_concat_r _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
dpoint (pfam_phomotopy (to_pointed f) (to_pointed g))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chke3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><label class="goal-separator" for="core-v-chke3"><hr></label><div class="goal-conclusion">h pt $== bp_pointed f $@ (bp_pointed g)^$ &lt;~&gt;
equiv_path_data_homotopy f g h pt = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke4"><span class="mi">1</span>: <span class="bp">exact</span> ((abses_path_data_compose_beta _ _)^ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ @ x) (abses_path_data_V _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt $== bp_pointed f $@ (bp_pointed g)^$ &lt;~&gt;
equiv_path_data_homotopy f g h pt =
equiv_path_abses_iso
  (abses_path_data_compose (bp_pointed f)
     (abses_path_data_inverse (bp_pointed g)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke5"><span class="nb">refine</span> (equiv_ap&#39; equiv_path_abses_iso _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt $== bp_pointed f $@ (bp_pointed g)^$ &lt;~&gt;
h (<span class="mi">1</span>%equiv pt) =
abses_path_data_compose (bp_pointed f)
  (abses_path_data_inverse (bp_pointed g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke6"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B', A', B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>AbSES B A --&gt;* AbSES B&#39; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $=&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt $== bp_pointed f $@ (bp_pointed g)^$ &lt;~&gt;
(h (<span class="mi">1</span>%equiv pt)).<span class="mi">1</span> =
(abses_path_data_compose (bp_pointed f)
   (abses_path_data_inverse (bp_pointed g))).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Characterisation of loops of short exact sequences *)</span>

<span class="sd">(** Endomorphisms of the trivial short exact sequence in [AbSES B A] correspond to homomorphisms [B -&gt; A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke7"><span class="kn">Lemma</span> <span class="nf">abses_endomorphism_trivial</span> `{Funext} {B A : AbGroup@{u}}
  : {phi : GroupHomomorphism (point (AbSES B A)) (point (AbSES B A)) &amp;
             (phi o inclusion _ == inclusion _)
             * (projection _ == projection _ o phi)}
      &lt;~&gt; (B $-&gt; A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)} &lt;~&gt; (B $-&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)} &lt;~&gt; (B $-&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chke9">srapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)} -&gt; B $-&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chkea"><hr></label><div class="goal-conclusion">(B $-&gt; A) -&gt;
{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chkeb"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="core-v-chkec"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)} -&gt; B $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkee"><span class="nb">intros</span> [phi _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_biprod_pr1 $o phi $o ab_biprod_inr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B $-&gt; A) -&gt;
{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf0"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : GroupHomomorphism pt pt &amp;
(phi o inclusion pt == inclusion pt) *
(projection pt == projection pt o phi)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf1">snrefine (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism pt pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><label class="goal-separator" for="core-v-chkf2"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">phi</span> : GroupHomomorphism pt pt =&gt;
 (phi o inclusion pt == inclusion pt) *
 (projection pt == projection pt o phi)) <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism pt pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf4"><span class="nb">refine</span> (ab_biprod_rec ab_biprod_inl _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; ab_biprod A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_biprod_corec f grp_homo_id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">phi</span> : GroupHomomorphism pt pt =&gt;
 (phi o inclusion pt == inclusion pt) *
 (projection pt == projection pt o phi))
  (ab_biprod_rec ab_biprod_inl
     (ab_biprod_corec f grp_homo_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf6"><span class="nb">split</span>; <span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x + f group_unit, group_unit + group_unit) =
(x, group_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>pt</span></span></span><br></div><label class="goal-separator" for="core-v-chkf7"><hr></label><div class="goal-conclusion">snd x = group_unit + snd x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x + f group_unit, group_unit + group_unit) =
(x, group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkf9"><span class="nb">apply</span> path_prod; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + f group_unit = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chkfa"><hr></label><div class="goal-conclusion">group_unit + group_unit = group_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkfb">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + f group_unit = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (grp_homo_unit f) @ right_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkfc">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + group_unit = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkfd">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd x = group_unit + snd x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkfe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">X</span> : {phi : GroupHomomorphism pt pt &amp;
       (phi o inclusion pt == inclusion pt) *
       (projection pt == projection pt o phi)} =&gt;
 (<span class="kr">fun</span> (<span class="nv">phi</span> : GroupHomomorphism pt pt)
    (<span class="nv">_</span> : ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
          inclusion pt) *
         (projection pt ==
          (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x)))) =&gt;
  ab_biprod_pr1 $o phi $o ab_biprod_inr) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o (<span class="kr">fun</span> <span class="nv">f</span> : B $-&gt; A =&gt;
   (ab_biprod_rec ab_biprod_inl
      (ab_biprod_corec f grp_homo_id);
   ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
     path_prod
       (x + f group_unit, group_unit + group_unit)
       (x, group_unit)
       (ap (sg_op x) (grp_homo_unit f) @
        right_identity x
        :
        fst
          (x + f group_unit, group_unit + group_unit) =
        fst (x, group_unit))
       (right_identity group_unit
        :
        snd
          (x + f group_unit, group_unit + group_unit) =
        snd (x, group_unit))
     :
     ab_biprod_rec ab_biprod_inl
       (ab_biprod_corec f grp_homo_id)
       (inclusion pt x) = inclusion pt x)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
     ab_biprod_rec ab_biprod_inl
       (ab_biprod_corec f grp_homo_id)
       (inclusion pt x)) == inclusion pt,
   (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt;
    (left_identity (snd x))^
    :
    projection pt x =
    projection pt
      (ab_biprod_rec ab_biprod_inl
         (ab_biprod_corec f grp_homo_id) x))
   :
   projection pt ==
   (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt;
    projection pt
      (ab_biprod_rec ab_biprod_inl
         (ab_biprod_corec f grp_homo_id) x))))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkff"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_pr1 $o
ab_biprod_rec ab_biprod_inl
  (ab_biprod_corec f grp_homo_id) $o ab_biprod_inr = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk100">rapply equiv_path_grouphomomorphism; <span class="nb">intro</span> b; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + f b = f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk101">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : B $-&gt; A =&gt;
 (ab_biprod_rec ab_biprod_inl
    (ab_biprod_corec f grp_homo_id);
 ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   path_prod
     (x + f group_unit, group_unit + group_unit)
     (x, group_unit)
     (ap (sg_op x) (grp_homo_unit f) @
      right_identity x
      :
      fst (x + f group_unit, group_unit + group_unit) =
      fst (x, group_unit))
     (right_identity group_unit
      :
      snd (x + f group_unit, group_unit + group_unit) =
      snd (x, group_unit))
   :
   ab_biprod_rec ab_biprod_inl
     (ab_biprod_corec f grp_homo_id) (inclusion pt x) =
   inclusion pt x)
  :
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   ab_biprod_rec ab_biprod_inl
     (ab_biprod_corec f grp_homo_id) (inclusion pt x)) ==
  inclusion pt,
 (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt;
  (left_identity (snd x))^
  :
  projection pt x =
  projection pt
    (ab_biprod_rec ab_biprod_inl
       (ab_biprod_corec f grp_homo_id) x))
 :
 projection pt ==
 (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt;
  projection pt
    (ab_biprod_rec ab_biprod_inl
       (ab_biprod_corec f grp_homo_id) x)))))
o (<span class="kr">fun</span>
     <span class="nv">X</span> : {phi : GroupHomomorphism pt pt &amp;
         (phi o inclusion pt == inclusion pt) *
         (projection pt == projection pt o phi)} =&gt;
   (<span class="kr">fun</span> (<span class="nv">phi</span> : GroupHomomorphism pt pt)
      (<span class="nv">_</span> : ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
            inclusion pt) *
           (projection pt ==
            (<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x)))) =&gt;
    ab_biprod_pr1 $o phi $o ab_biprod_inr) X.<span class="mi">1</span> X.<span class="mi">2</span>) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk102"><span class="nb">intros</span> [phi [p q]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_biprod_rec ab_biprod_inl
   (ab_biprod_corec
      (ab_biprod_pr1 $o phi $o ab_biprod_inr)
      grp_homo_id);
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 path_prod
   (x +
    (ab_biprod_pr1 $o phi $o ab_biprod_inr) group_unit,
   group_unit + group_unit) (x, group_unit)
   (ap (sg_op x)
      (grp_homo_unit
         (ab_biprod_pr1 $o phi $o ab_biprod_inr)) @
    right_identity x) (right_identity group_unit),
<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; (left_identity (snd x))^)) =
(phi; (p, q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk103"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_rec ab_biprod_inl
  (ab_biprod_corec
     (grp_homo_compose
        (grp_homo_compose ab_biprod_pr1 phi)
        ab_biprod_inr) grp_homo_id) = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk104">rapply equiv_path_grouphomomorphism; <span class="nb">intros</span> [a b]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a + fst (phi (group_unit, b)), group_unit + b) =
phi (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk105"><span class="nb">apply</span> path_prod; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a + fst (phi (group_unit, b)) = fst (phi (a, b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk106" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="core-v-chk106"><hr></label><div class="goal-conclusion">group_unit + b = snd (phi (a, b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk107">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a + fst (phi (group_unit, b)) = fst (phi (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk108"><span class="nb">rewrite</span> (grp_prod_decompose a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a + fst (phi (group_unit, b)) =
fst (phi ((a, <span class="mi">0</span>) + (<span class="mi">0</span>, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk109"><span class="nb">refine</span> (_ @ (grp_homo_op (ab_biprod_pr1 $o phi) _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a + fst (phi (group_unit, b)) =
(ab_biprod_pr1 $o phi) (a, <span class="mi">0</span>) +
(ab_biprod_pr1 $o phi) (<span class="mi">0</span>, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10a"><span class="nb">apply</span> grp_cancelR; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_biprod_pr1 $o phi) (a, <span class="mi">0</span>) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap fst (p a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + b = snd (phi (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10c"><span class="nb">rewrite</span> (grp_prod_decompose a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + b = snd (phi ((a, <span class="mi">0</span>) + (<span class="mi">0</span>, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10d"><span class="nb">refine</span> (_ @ (grp_homo_op (ab_biprod_pr2 $o phi) _ _)^); <span class="nb">cbn</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism pt pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion pt x)) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection pt ==
(<span class="kr">fun</span> <span class="nv">x</span> : pt =&gt; projection pt (phi x))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (phi (a, <span class="mi">0</span>)) + snd (phi (<span class="mi">0</span>, b)) = group_unit + b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ (ap snd (p a)) (q (group_unit, b))^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Consequently, the loop space of [AbSES B A] is [GroupHomomorphism B A]. (In fact, [B $-&gt; A] are the loops of any short exact sequence, but the trivial case is easiest to show.) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">loops_abses</span> `{Univalence} {A B : AbGroup}
  : (B $-&gt; A) &lt;~&gt; loops (AbSES B A)
  := equiv_path_abses oE abses_endomorphism_trivial^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can transfer a loop of the trivial short exact sequence to any other. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10e"><span class="kn">Definition</span> <span class="nf">hom_loops_data_abses</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
  : (B $-&gt; A) -&gt; abses_path_data E E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B $-&gt; A) -&gt; abses_path_data E E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk10f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B $-&gt; A) -&gt; abses_path_data E E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk110"><span class="nb">intro</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk111">srefine (_; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk112" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><label class="goal-separator" for="core-v-chk112"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion E == inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk113" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><label class="goal-separator" for="core-v-chk113"><hr></label><div class="goal-conclusion">projection E == projection E $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk114">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_id + (inclusion E $o phi $o projection E)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk115">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_homo_id + inclusion E $o phi $o projection E) $o
inclusion E == inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk116"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E a +
inclusion E (phi (projection E (inclusion E a))) =
inclusion E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk117"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + inclusion E (phi x)) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chk118"><hr></label><div class="goal-conclusion">inclusion E a + inclusion E (phi <span class="nl">?Goal</span>) =
inclusion E a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk119"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E a + inclusion E (phi (pconst a)) =
inclusion E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk11a"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + x) (grp_homo_unit (inclusion E $o phi)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E a + <span class="mi">0</span> = inclusion E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E ==
projection E $o
(grp_homo_id + inclusion E $o phi $o projection E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk11c"><span class="nb">intro</span> e; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection E $o
 (grp_homo_id + inclusion E $o phi $o projection E)) e =
projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk11d"><span class="nb">refine</span> (grp_homo_op (projection E) _ _ @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E e +
projection E (inclusion E (phi (projection E e))) =
projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk11e"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + x) _ @  _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E (phi (projection E e))) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="core-v-chk11f"><hr></label><div class="goal-conclusion">projection E e + <span class="nl">?Goal</span> = projection E e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk120"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E e + pconst (phi (projection E e)) =
projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Morphisms of short exact sequences *)</span>

<span class="sd">(** A morphism between short exact sequences is a natural transformation between the underlying diagrams. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">AbSESMorphism</span> {<span class="nv">A</span> <span class="nv">X</span> <span class="nv">B</span> <span class="nv">Y</span> : AbGroup@{u}}
  {<span class="nv">E</span> : AbSES B A} {<span class="nv">F</span> : AbSES Y X} := {
    component1 : A $-&gt; X;
    component2 : middle E $-&gt; middle F;
    component3 : B $-&gt; Y;
    left_square : (inclusion _) $o component1 == component2 $o (inclusion _);
    right_square : (projection _) $o component2 == component3 $o (projection _);
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> AbSESMorphism {A X B Y} E F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_AbSESMorphism {_ _ _ _ _ _} _ _ _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_AbSESMorphism</span> {<span class="nv">A</span> <span class="nv">X</span> <span class="nv">B</span> <span class="nv">Y</span> : AbGroup@{u}}
           {<span class="nv">E</span> : AbSES B A} {<span class="nv">F</span> : AbSES Y X}
  : { f : (A $-&gt; X) * (middle E $-&gt; middle F) * (B $-&gt; Y)
          &amp; ((inclusion _) $o (fst (fst f)) == (snd (fst f)) $o (inclusion _))
            * ((projection F) $o (snd (fst f)) == (snd f) $o (projection _)) }
      &lt;~&gt; AbSESMorphism E F := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity morphism from [E] to [E]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk121"><span class="kn">Lemma</span> <span class="nf">abses_morphism_id</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup@{u}} (<span class="nv">E</span> : AbSES B A)
  : AbSESMorphism E E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk123">snapply (Build_AbSESMorphism grp_homo_id grp_homo_id grp_homo_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E $o grp_homo_id ==
grp_homo_id $o inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk124" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk124"><hr></label><div class="goal-conclusion">projection E $o grp_homo_id ==
grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk125"><span class="kn">Definition</span> <span class="nf">absesmorphism_compose</span> {<span class="nv">A0</span> <span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">B0</span> <span class="nv">B1</span> <span class="nv">B2</span> : AbGroup@{u}}
           {<span class="nv">E</span> : AbSES B0 A0} {<span class="nv">F</span> : AbSES B1 A1} {<span class="nv">G</span> : AbSES B2 A2}
           (<span class="nv">g</span> : AbSESMorphism F G) (<span class="nv">f</span> : AbSESMorphism E F)
  : AbSESMorphism E G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk127">rapply (Build_AbSESMorphism (component1 g $o component1 f)
                              (component2 g $o component2 f)
                              (component3 g $o component3 f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion G $o (component1 g $o component1 f) ==
component2 g $o component2 f $o inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk128" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="core-v-chk128"><hr></label><div class="goal-conclusion">projection G $o (component2 g $o component2 f) ==
component3 g $o component3 f $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk129">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion G $o (component1 g $o component1 f) ==
component2 g $o component2 f $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12a"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion G (component1 g (component1 f x)) =
component2 g (component2 f (inclusion E x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_square g _ @ ap _ (left_square f _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection G $o (component2 g $o component2 f) ==
component3 g $o component3 f $o projection E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12c"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1, A2, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B0 A0</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B1 A1</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbSES B2 A2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>AbSESMorphism F G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection G (component2 g (component2 f x)) =
component3 g (component3 f (projection E x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_square g _ @ ap _ (right_square f _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Characterization of split short exact sequences *)</span>

<span class="c">(* We characterize trivial short exact sequences in [AbSES] as those for which [projection] splits. *)</span>

<span class="sd">(** If [projection E] splits, we get an induced map [fun e =&gt; e - s (projection E e)] from [E] to [ab_kernel (projection E)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12d"><span class="kn">Definition</span> <span class="nf">projection_split_to_kernel</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
           {<span class="nv">s</span> : B $-&gt; E} (<span class="nv">h</span> : projection _ $o s == idmap)
  : (middle E) $-&gt; (@ab_kernel E B (projection _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; ab_kernel (projection E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; ab_kernel (projection E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk12f">snapply (grp_kernel_corec (G:=E) (A:=E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk130" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk130"><hr></label><div class="goal-conclusion">projection E $o <span class="nl">?g</span> == grp_homo_const</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk131">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (grp_homo_id - (s $o projection _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o (grp_homo_id - s $o projection E) ==
grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk133"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (x - s (projection E x)) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk134"><span class="nb">refine</span> (grp_homo_op (projection _) x _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E x + projection E (- s (projection E x)) =
group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk135"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (projection _) x + y) _ @ right_inverse ((projection _) x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (- s (projection E x)) = - projection E x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk136"><span class="nb">refine</span> (grp_homo_inv _ _ @ ap (-) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (s (projection E x)) = projection E x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The composite [A -&gt; E -&gt; ab_kernel (projection E)] is [grp_cxfib]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk137"><span class="kn">Lemma</span> <span class="nf">projection_split_to_kernel_beta</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
      {<span class="nv">s</span> : B $-&gt; E} (<span class="nv">h</span> : (projection _) $o s == idmap)
  : (projection_split_to_kernel E h) $o (inclusion _) == grp_cxfib cx_isexact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_to_kernel E h $o inclusion E ==
grp_cxfib cx_isexact</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_to_kernel E h $o inclusion E ==
grp_cxfib cx_isexact</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk139"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection_split_to_kernel E h $o inclusion E) a =
grp_cxfib cx_isexact a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13a"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E a - s (projection E (inclusion E a)) =
inclusion E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13b"><span class="nb">apply</span> grp_cancelL1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- s (projection E (inclusion E a)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13c"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; - s x) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chk13d"><hr></label><div class="goal-conclusion">- s <span class="nl">?Goal</span> = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13e"><span class="mi">1</span>: tapply cx_isexact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- s (pconst a) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (grp_homo_unit _) @ grp_inv_unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The induced map [E -&gt; ab_kernel (projection E) + B] is an isomorphism. We suffix it with 1 since it is the first composite in the desired isomorphism [E -&gt; A + B]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk13f"><span class="kn">Definition</span> <span class="nf">projection_split_iso1</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
           {<span class="nv">s</span> : GroupHomomorphism B E} (<span class="nv">h</span> : (projection _) $o s == idmap)
  : GroupIsomorphism E (ab_biprod (@ab_kernel E B (projection _)) B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E
  (ab_biprod (ab_kernel (projection E)) B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk140"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E
  (ab_biprod (ab_kernel (projection E)) B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk141">srapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism E
  (ab_biprod (ab_kernel (projection E)) B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk142" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk142"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk143">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism E
  (ab_biprod (ab_kernel (projection E)) B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk144"><span class="nb">refine</span> (ab_biprod_corec _ (projection _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; ab_kernel (projection E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (projection_split_to_kernel E h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk145">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (ab_biprod_corec (projection_split_to_kernel E h)
     (projection E))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk146">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod (ab_kernel (projection E)) B -&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk147"><hr></label><div class="goal-conclusion">ab_biprod_corec (projection_split_to_kernel E h)
  (projection E) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk148" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk148"><hr></label><div class="goal-conclusion"><span class="nl">?g</span>
o ab_biprod_corec (projection_split_to_kernel E h)
    (projection E) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk149">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod (ab_kernel (projection E)) B -&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14a"><span class="nb">refine</span> (ab_biprod_rec _ s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_kernel (projection E) $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply subgroup_incl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_corec (projection_split_to_kernel E h)
  (projection E)
o ab_biprod_rec
    (subgroup_incl (grp_kernel (projection E))) s ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14c"><span class="nb">intros</span> [a b]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a.<span class="mi">1</span> + s b - s (projection E (a.<span class="mi">1</span> + s b));
 grp_homo_op (projection E) (a.<span class="mi">1</span> + s b)
   (- s (projection E (a.<span class="mi">1</span> + s b))) @
 (ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; projection E (a.<span class="mi">1</span> + s b) + y)
    (grp_homo_inv (projection E)
       (s (projection E (a.<span class="mi">1</span> + s b))) @
     ap inv (h (projection E (a.<span class="mi">1</span> + s b)))) @
  right_inverse (projection E (a.<span class="mi">1</span> + s b)))),
projection E (a.<span class="mi">1</span> + s b)) = (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14d"><span class="nb">apply</span> path_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a.<span class="mi">1</span> + s b - s (projection E (a.<span class="mi">1</span> + s b));
grp_homo_op (projection E) (a.<span class="mi">1</span> + s b)
  (- s (projection E (a.<span class="mi">1</span> + s b))) @
(ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; projection E (a.<span class="mi">1</span> + s b) + y)
   (grp_homo_inv (projection E)
      (s (projection E (a.<span class="mi">1</span> + s b))) @
    ap inv (h (projection E (a.<span class="mi">1</span> + s b)))) @
 right_inverse (projection E (a.<span class="mi">1</span> + s b)))) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="core-v-chk14e"><hr></label><div class="goal-conclusion">projection E (a.<span class="mi">1</span> + s b) = b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk14f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a.<span class="mi">1</span> + s b - s (projection E (a.<span class="mi">1</span> + s b));
grp_homo_op (projection E) (a.<span class="mi">1</span> + s b)
  (- s (projection E (a.<span class="mi">1</span> + s b))) @
(ap (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; projection E (a.<span class="mi">1</span> + s b) + y)
   (grp_homo_inv (projection E)
      (s (projection E (a.<span class="mi">1</span> + s b))) @
    ap inv (h (projection E (a.<span class="mi">1</span> + s b)))) @
 right_inverse (projection E (a.<span class="mi">1</span> + s b)))) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk150">srapply path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> + s b - s (projection E (a.<span class="mi">1</span> + s b)) = a.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk151"><span class="nb">refine</span> ((associativity _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> + (s b - s (projection E (a.<span class="mi">1</span> + s b))) = a.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk152"><span class="nb">apply</span> grp_cancelL1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s b - s (projection E (a.<span class="mi">1</span> + s b)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk153"><span class="nb">refine</span> (ap _ _ @ right_inverse _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- s (projection E (a.<span class="mi">1</span> + s b)) = - s b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk154"><span class="nb">apply</span> (ap negate).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s (projection E (a.<span class="mi">1</span> + s b)) = s b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk155"><span class="nb">apply</span> (ap s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (a.<span class="mi">1</span> + s b) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk156"><span class="nb">refine</span> (grp_homo_op (projection _) a.<span class="mi">1</span> (s b) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E a.<span class="mi">1</span> + projection E (s b) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y + _) a.<span class="mi">2</span> @ left_identity _ @ h b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk157">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (a.<span class="mi">1</span> + s b) = b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk158"><span class="nb">refine</span> (grp_homo_op (projection _) a.<span class="mi">1</span> (s b) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ab_kernel (projection E)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E a.<span class="mi">1</span> + projection E (s b) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y + _) a.<span class="mi">2</span> @ left_identity _ @ h b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk159">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_rec
  (subgroup_incl (grp_kernel (projection E))) s
o ab_biprod_corec (projection_split_to_kernel E h)
    (projection E) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15a"><span class="nb">intro</span> e; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e - s (projection E e) + s (projection E e) = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_moveR_gM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The full isomorphism [E -&gt; A + B]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15b"><span class="kn">Definition</span> <span class="nf">projection_split_iso</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup@{u}}
  (<span class="nv">E</span> : AbSES B A) {<span class="nv">s</span> : GroupHomomorphism B E}
  (<span class="nv">h</span> : (projection _) $o s == idmap)
  : GroupIsomorphism E (ab_biprod A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E (ab_biprod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E (ab_biprod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15d"><span class="nb">etransitivity</span> (ab_biprod (ab_kernel _) B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E (ab_biprod (ab_kernel <span class="nl">?f</span>) B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk15e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk15e"><hr></label><div class="goal-conclusion">GroupIsomorphism (ab_biprod (ab_kernel <span class="nl">?f</span>) B)
  (ab_biprod A B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk15f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E (ab_biprod (ab_kernel <span class="nl">?f</span>) B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (projection_split_iso1 E h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk160">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism
  (ab_biprod (ab_kernel (projection E)) B)
  (ab_biprod A B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk161">srapply (equiv_functor_ab_biprod
               (grp_iso_inverse _) grp_iso_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A (ab_kernel (projection E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply grp_iso_cxfib.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk162"><span class="kn">Proposition</span> <span class="nf">projection_split_beta</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
            {<span class="nv">s</span> : B $-&gt; E} (<span class="nv">h</span> : (projection _) $o s == idmap)
  : projection_split_iso E h o (inclusion _) == ab_biprod_inl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_iso E h o inclusion E ==
ab_biprod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_iso E h o inclusion E ==
ab_biprod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk164"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_iso E h (inclusion E a) =
ab_biprod_inl a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The next two lines might help the reader, but both are definitional equalities:</span>
<span class="c">  lhs napply (ap _ (grp_prod_corec_natural _ _ _ _)).</span>
<span class="c">  lhs napply ab_biprod_functor_beta.</span>
<span class="c">  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk165">napply path_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_iso_inverse
   (grp_iso_cxfib (isexact_inclusion_projection E)) $o
 ab_biprod_pr1)
  (projection_split_iso1 E h (inclusion E a)) =
grp_homo_id a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk166" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chk166"><hr></label><div class="goal-conclusion">(grp_iso_id $o ab_biprod_pr2)
  (projection_split_iso1 E h (inclusion E a)) =
grp_homo_const a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk167"><span class="mi">2</span>: tapply cx_isexact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_iso_inverse
   (grp_iso_cxfib (isexact_inclusion_projection E)) $o
 ab_biprod_pr1)
  (projection_split_iso1 E h (inclusion E a)) =
grp_homo_id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The LHS of the remaining goal is definitionally equal to</span>
<span class="c">       (grp_iso_inverse (grp_iso_cxfib (isexact_inclusion_projection E)) $o</span>
<span class="c">         (projection_split_to_kernel E h $o inclusion E)) a</span>
<span class="c">     allowing us to do: *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk168">lhs napply (ap _ (projection_split_to_kernel_beta E h a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_inverse
  (grp_iso_cxfib (isexact_inclusion_projection E))
  (grp_cxfib cx_isexact a) = grp_homo_id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A short exact sequence [E] in [AbSES B A] is trivial if and only if [projection E] splits. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk169"><span class="kn">Proposition</span> <span class="nf">iff_abses_trivial_split</span> `{Univalence}
  {B A : AbGroup@{u}} (E : AbSES B A)
  : {s : B $-&gt; E &amp; (projection _) $o s == idmap}
    &lt;-&gt; (E = point (AbSES B A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : B $-&gt; E &amp; projection E $o s == idmap} &lt;-&gt; E = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : B $-&gt; E &amp; projection E $o s == idmap} &lt;-&gt; E = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16b"><span class="nb">refine</span> (iff_compose _ (iff_equiv equiv_path_abses_iso)); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : B $-&gt; E &amp; projection E $o s == idmap} -&gt;
abses_path_data_iso E pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk16c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="core-v-chk16c"><hr></label><div class="goal-conclusion">abses_path_data_iso E pt -&gt;
{s : B $-&gt; E &amp; projection E $o s == idmap}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : B $-&gt; E &amp; projection E $o s == idmap} -&gt;
abses_path_data_iso E pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16e"><span class="nb">intros</span> [s h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk16f"><span class="kr">exists</span> (<span class="nv">projection_split_iso</span> <span class="nv">E</span> <span class="nv">h</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection_split_iso E h $o inclusion E ==
 inclusion pt) *
(projection E ==
 projection pt $o projection_split_iso E h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk170"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_iso E h $o inclusion E ==
inclusion pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk171" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk171"><hr></label><div class="goal-conclusion">projection E ==
projection pt $o projection_split_iso E h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk172">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection_split_iso E h $o inclusion E ==
inclusion pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply projection_split_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk173">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>B $-&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E $o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E ==
projection pt $o projection_split_iso E h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk174">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso E pt -&gt;
{s : B $-&gt; E &amp; projection E $o s == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk175"><span class="nb">intros</span> [phi [g h]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E == projection pt $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : B $-&gt; E &amp; projection E $o s == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk176"><span class="kr">exists</span> (<span class="nv">grp_homo_compose</span> (grp_iso_inverse phi) ab_biprod_inr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E == projection pt $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o
grp_homo_compose (grp_iso_inverse phi) ab_biprod_inr ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk177"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism E pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>phi $o inclusion E == inclusion pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>projection E == projection pt $o phi</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (phi^-<span class="mi">1</span> (group_unit, x)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (h _ @ ap snd (eisretr _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Constructions of short exact sequences *)</span>

<span class="sd">(** Any inclusion [i : A $-&gt; E] determines a short exact sequence by quotienting. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk178"><span class="kn">Definition</span> <span class="nf">abses_from_inclusion</span> `{Univalence}
  {A E : AbGroup@{u}} (i : A $-&gt; E) `{IsEmbedding i}
  : AbSES (QuotientAbGroup E (grp_image_embedding i)) A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES (QuotientAbGroup E (grp_image_embedding i)) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk179"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES (QuotientAbGroup E (grp_image_embedding i)) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk17a">srapply (Build_AbSES E i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; QuotientAbGroup E (grp_image_embedding i)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk17b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk17b"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) <span class="nl">?projection</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk17c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk17c"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) i <span class="nl">?projection</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk17d"><span class="mi">1</span>: <span class="bp">exact</span> grp_quotient_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk17e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk17e"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) i grp_quotient_map</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk17f"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) i grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk180">srapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex i grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk181" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk181"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk182">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex i grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk183">srapply phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map o* i == pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk184"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_quotient_map o* i) x = pconst x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk185"><span class="nb">apply</span> qglue; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber i (- i x + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk186"><span class="kr">exists</span> (-x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i (- x) = - i x + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_inv _ _ @ (grp_unit_r _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk187">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
          qglue
            ((- x;
             grp_homo_inv i x @ (grp_unit_r (- i x))^)
             :
             in_cosetL
               {|
                 normalsubgroup_subgroup :=
                   grp_image_embedding i;
                 normalsubgroup_isnormal :=
                   isnormal_ab_subgroup E
                    (grp_image_embedding i)
               |} (i x) <span class="mi">0</span>))
         :
         grp_quotient_map o* i == pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk188">snapply (conn_map_homotopic (Tr (-<span class="mi">1</span>)) (B:=grp_kernel (@grp_quotient_map E _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; grp_kernel grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk189" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk189"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> ==
cxfib
  (phomotopy_homotopy_hset
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       qglue
         ((- x;
          grp_homo_inv i x @ (grp_unit_r (- i x))^)
          :
          in_cosetL
            {|
              normalsubgroup_subgroup :=
                grp_image_embedding i;
              normalsubgroup_isnormal :=
                isnormal_ab_subgroup E
                  (grp_image_embedding i)
            |} (i x) <span class="mi">0</span>))
      :
      grp_quotient_map o* i == pconst))</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk18a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><label class="goal-separator" for="core-v-chk18a"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; grp_kernel grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_kernel_quotient_iso _ o ab_image_in_embedding i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_kernel_quotient_iso (ab_image_embedding i)
o ab_image_in_embedding i ==
cxfib
  (phomotopy_homotopy_hset
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       qglue
         ((- x;
          grp_homo_inv i x @ (grp_unit_r (- i x))^)
          :
          in_cosetL
            {|
              normalsubgroup_subgroup :=
                grp_image_embedding i;
              normalsubgroup_isnormal :=
                isnormal_ab_subgroup E
                  (grp_image_embedding i)
            |} (i x) <span class="mi">0</span>))
      :
      grp_quotient_map o* i == pconst))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18d"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_kernel_quotient_iso 
  (ab_image_embedding i) 
  (ab_image_in_embedding i a) =
cxfib
  (phomotopy_homotopy_hset
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
      qglue
        (- x;
        grp_homo_inv i x @ (grp_unit_r (- i x))^))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply (isinj_embedding (subgroup_incl _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, E</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (grp_kernel_quotient_iso (ab_image_embedding i)
   o ab_image_in_embedding i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply conn_map_isequiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, given a short exact sequence [A -&gt; E -&gt; B], [A] is the kernel of [E -&gt; B]. (We don&#39;t need exactness at [B], so we drop this assumption.) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk18f"><span class="kn">Lemma</span> <span class="nf">abses_kernel_iso</span> `{Funext} {A E B : AbGroup} (i : A $-&gt; E) (p : E $-&gt; B)
  `{IsEmbedding i, IsExact (Tr (-<span class="mi">1</span>)) _ _ _ i p}
  : GroupIsomorphism A (ab_kernel p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A (ab_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk190"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A (ab_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk191">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_kernel p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><label class="goal-separator" for="core-v-chk192"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk193">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk194"><span class="nb">apply</span> (grp_kernel_corec i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p $o i == grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> cx_isexact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk195">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (grp_kernel_corec i cx_isexact)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk196"><span class="nb">apply</span> isequiv_surj_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (grp_kernel_corec i cx_isexact)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk197" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><label class="goal-separator" for="core-v-chk197"><hr></label><div class="goal-conclusion">IsEmbedding (grp_kernel_corec i cx_isexact)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk198"><span class="mi">2</span>: tapply (cancelL_mapinO _ (grp_kernel_corec _ _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (grp_kernel_corec i cx_isexact)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk199"><span class="nb">intros</span> [y q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber (grp_kernel_corec i cx_isexact) (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19a"><span class="nb">assert</span> (a : Tr (-<span class="mi">1</span>) (hfiber i y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber i y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk19b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber i y)</span></span></span><br></div><label class="goal-separator" for="core-v-chk19b"><hr></label><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber (grp_kernel_corec i cx_isexact) (y; q))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19c"><span class="mi">1</span>: <span class="bp">by</span> tapply isexact_preimage.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber i y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber (grp_kernel_corec i cx_isexact) (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19d">strip_truncations; <span class="nb">destruct</span> a <span class="kr">as</span> [a r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>i a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber (grp_kernel_corec i cx_isexact) (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19e">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>i a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber (grp_kernel_corec i cx_isexact) (y; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk19f"><span class="nb">refine</span> (tr (a; _)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>i a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i a; cx_isexact a) = (y; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a0"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>i a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i a = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A computation rule for the inverse of [abses_kernel_iso i p]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a1"><span class="kn">Lemma</span> <span class="nf">abses_kernel_iso_inv_beta</span> `{Funext} {A E B : AbGroup} (i : A $-&gt; E) (p : E $-&gt; B)
  `{IsEmbedding i, IsExact (Tr (-<span class="mi">1</span>)) _ _ _ i p}
  : i o (abses_kernel_iso i p)^-<span class="mi">1</span> == subgroup_incl _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i o (abses_kernel_iso i p)^-<span class="mi">1</span> ==
subgroup_incl (grp_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i o (abses_kernel_iso i p)^-<span class="mi">1</span> ==
subgroup_incl (grp_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a3">rapply (equiv_ind (abses_kernel_iso i p)); <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) i p</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i ((abses_kernel_iso i p)^-<span class="mi">1</span> (abses_kernel_iso i p a)) =
subgroup_incl (grp_kernel p) (abses_kernel_iso i p a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap i (eissect (abses_kernel_iso i p) _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Any surjection [p : E $-&gt; B] induces a short exact sequence by taking the kernel. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a4"><span class="kn">Lemma</span> <span class="nf">abses_from_surjection</span> {<span class="nv">E</span> <span class="nv">B</span> : AbGroup@{u}} (<span class="nv">p</span> : E $-&gt; B) `{IsSurjection p}
  : AbSES B (ab_kernel p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B (ab_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B (ab_kernel p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a6">srapply (Build_AbSES E _ p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_kernel p $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><label class="goal-separator" for="core-v-chk1a7"><hr></label><div class="goal-conclusion">IsEmbedding <span class="nl">?inclusion</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk1a8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><label class="goal-separator" for="core-v-chk1a8"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) <span class="nl">?inclusion</span> p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1a9"><span class="mi">1</span>: <span class="bp">exact</span> (subgroup_incl _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (subgroup_incl (grp_kernel p))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><label class="goal-separator" for="core-v-chk1aa"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (subgroup_incl (grp_kernel p)) p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ab"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (subgroup_incl (grp_kernel p)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ac">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (subgroup_incl (grp_kernel p)) p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><label class="goal-separator" for="core-v-chk1ad"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (subgroup_incl (grp_kernel p)) p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1af"><span class="nb">apply</span> phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p o* subgroup_incl (grp_kernel p) == pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b0"><span class="nb">intros</span> [e q]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_kernel p e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p e = ispointed_group B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">x</span> : ab_kernel p =&gt;
          (<span class="kr">fun</span> (<span class="nv">e</span> : E) (<span class="nv">q</span> : grp_kernel p e) =&gt;
           q
           :
           (p o* subgroup_incl (grp_kernel p)) (e; q) =
           pconst (e; q)) x.<span class="mi">1</span> x.<span class="mi">2</span>)
         :
         p o* subgroup_incl (grp_kernel p) == pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply conn_map_isequiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, given a short exact sequence [A -&gt; E -&gt; B], [B] is the cokernel of [A -&gt; E]. In fact, we don&#39;t need exactness at [A], so we drop this from the statement. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b2"><span class="kn">Lemma</span> <span class="nf">abses_cokernel_iso</span> `{Funext}
  {A E B : AbGroup@{u}} (f : A $-&gt; E) (g : GroupHomomorphism E B)
  `{IsSurjection g, IsExact (Tr (-<span class="mi">1</span>)) _ _ _ f g}
  : GroupIsomorphism (ab_cokernel f) B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (ab_cokernel f) B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (ab_cokernel f) B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b4">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (ab_cokernel f) B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><label class="goal-separator" for="core-v-chk1b5"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (ab_cokernel f) B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b7">snapply (quotient_abgroup_rec _ _ g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : E, grp_image f n -&gt; g n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b8"><span class="nb">intros</span> e; rapply Trunc_rec; <span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g e = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1b9"><span class="nb">refine</span> (ap _ p^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f a) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">tapply cx_isexact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (quotient_abgroup_rec 
     (grp_image f) B g
     (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
      Trunc_rec
        (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
         (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">p</span> : f a = e) =&gt;
          ap g p^ @ cx_isexact a) X.<span class="mi">1</span> X.<span class="mi">2</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1bb"><span class="nb">apply</span> isequiv_surj_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (quotient_abgroup_rec 
     (grp_image f) B g
     (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
      Trunc_rec
        (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
         ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><label class="goal-separator" for="core-v-chk1bc"><hr></label><div class="goal-conclusion">IsEmbedding
  (quotient_abgroup_rec 
     (grp_image f) B g
     (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
      Trunc_rec
        (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
         ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1bd"><span class="mi">1</span>: rapply cancelR_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (quotient_abgroup_rec 
     (grp_image f) B g
     (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
      Trunc_rec
        (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
         ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1be"><span class="nb">apply</span> isembedding_isinj_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjective
  (quotient_abgroup_rec 
     (grp_image f) B g
     (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
      Trunc_rec
        (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
         ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1bf">srapply Quotient_ind2_hprop; <span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span>
    <span class="nv">y</span> : E /
        in_cosetL
          {|
            normalsubgroup_subgroup := grp_image f;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup E (grp_image f)
          |} =&gt;
 quotient_abgroup_rec 
   (grp_image f) B g
   (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
    Trunc_rec
      (<span class="kr">fun</span> <span class="nv">X</span> : {x0 : A &amp; f x0 = e} =&gt;
       ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)) x =
 quotient_abgroup_rec 
   (grp_image f) B g
   (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
    Trunc_rec
      (<span class="kr">fun</span> <span class="nv">X</span> : {x0 : A &amp; f x0 = e} =&gt;
       ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>)) y -&gt; 
 x = y)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c0"><span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (in_cosetL
     {|
       normalsubgroup_subgroup := grp_image f;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup E (grp_image f)
     |}) x =
class_of
  (in_cosetL
     {|
       normalsubgroup_subgroup := grp_image f;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup E (grp_image f)
     |}) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c1"><span class="nb">apply</span> qglue; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trunc (-<span class="mi">1</span>) {x0 : A &amp; f x0 = - x + y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c2"><span class="nb">refine</span> (isexact_preimage (Tr (-<span class="mi">1</span>)) _ _ (-x + y) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (- x + y) = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c3"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (- x) + g y = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c4"><span class="nb">rewrite</span> grp_homo_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- g x + g y = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c5"><span class="nb">apply</span> grp_moveL_M1^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) x) =
quotient_abgroup_rec 
  (grp_image f) B g
  (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
   Trunc_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; f x = e} =&gt;
      ap g (X.<span class="mi">2</span>)^ @ cx_isexact X.<span class="mi">1</span>))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := grp_image f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup E (grp_image f)
        |}) y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g y = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c6"><span class="kn">Definition</span> <span class="nf">abses_cokernel_iso_inv_beta</span> `{Funext}
  {A E B : AbGroup} (f : A $-&gt; E) (g : GroupHomomorphism E B)
  `{IsSurjection g, IsExact (Tr (-<span class="mi">1</span>)) _ _ _ f g}
  : (abses_cokernel_iso f g)^-<span class="mi">1</span> o g == grp_quotient_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_cokernel_iso f g)^-<span class="mi">1</span> o g == grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, E, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; E</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism E B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsExact (Tr (-<span class="mi">1</span>)) f g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_cokernel_iso f g)^-<span class="mi">1</span> o g == grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="bp">by</span> <span class="nb">apply</span> moveR_equiv_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
