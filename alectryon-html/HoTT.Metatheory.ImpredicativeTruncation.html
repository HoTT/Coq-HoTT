<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>ImpredicativeTruncation.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Impredicative truncations *)</span>

<span class="sd">(** In this file, under the assumptions of propositional resizing [PropResizing] and function extensionality [Funext], we define the propositional truncation in any universe. In the main library, these are constructed using HITs. The definitions here are meant to be for illustration. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk0"><span class="kn">Require Import</span> HoTT.Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Universes.Smallness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using only function extensionality, we can define a &quot;propositional truncation&quot; [Trm A] of a type [A] in universe [i] which eliminates into propositions in universe [j].  It lands in [max(i,j+1)].  So if we want it to land in universe [i], then we can only eliminate into propositions in a strictly smaller universe [j].  Or, if we want it to eliminate into propositions in universe [i], then it must land in a strictly larger universe. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trm</span>@{i j | } (A : <span class="kt">Type</span>@{i})
  := <span class="kr">forall</span> <span class="nv">P</span>:<span class="kt">Type</span>@{j}, IsHProp P -&gt; (A -&gt; P) -&gt; P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trm</span>@{i j | } {A : <span class="kt">Type</span>@{i}} : A -&gt; Trm@{i j} A
  := <span class="kr">fun</span> <span class="nv">a</span> <span class="nv">P</span> <span class="nv">HP</span> <span class="nv">f</span> =&gt; f a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here [k] plays the role of [max(i,j+1)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk1"><span class="kn">Instance</span> <span class="nf">ishprop_Trm</span>@{i j k | i &lt;= k, j &lt; k} `{Funext} (A : <span class="kt">Type</span>@{i})
  : IsHProp (Trm@{i j} A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (Trm A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (Trm A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk3">napply istrunc_forall@{k k k}; <span class="nb">intro</span> B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsHProp B -&gt; (A -&gt; B) -&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk4">napply istrunc_forall@{j k k}; <span class="nb">intro</span> ishp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ishp</var><span class="hyp-type"><b>: </b><span>IsHProp B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp ((A -&gt; B) -&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istrunc_forall@{k j k}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As mentioned above, it eliminates into propositions in universe [j]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trm_rec</span>@{i j | } {A : <span class="kt">Type</span>@{i}}
  {P : <span class="kt">Type</span>@{j}} {p : IsHProp@{j} P} (f : A -&gt; P)
  : Trm@{i j} A -&gt; P
  := <span class="kr">fun</span> <span class="nv">ma</span> =&gt; ma P p f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This computes definitionally. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trm_rec_beta</span>@{i j | } {A : <span class="kt">Type</span>@{i}}
  {P : <span class="kt">Type</span>@{j}} `{IsHProp P} (f : A -&gt; P)
  : Trm_rec@{i j} f o trm == f
  := <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Because of the universe constraints, we can&#39;t make this into a functor on [Type@{i}].  We have a universe constraint [i&#39; &lt;= j] and [Trm@{i j} A] lands in [max(i,j+1)], which is strictly larger. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Trm</span>@{i j i&#39; j&#39; | i&#39; &lt;= j, j&#39; &lt; j} `{Funext}
  {A : <span class="kt">Type</span>@{i}} {A&#39; : <span class="kt">Type</span>@{i&#39;}} (f : A -&gt; A&#39;)
  : Trm@{i j} A -&gt; Trm@{i&#39; j&#39;} A&#39;
  := Trm_rec (trm o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We also record the dependent induction principle.  But it only computes propositionally. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk5"><span class="kn">Definition</span> <span class="nf">Trm_ind</span>@{i j k | i &lt;= k, j &lt; k} {A : <span class="kt">Type</span>@{i}} `{Funext}
  {P : Trm@{i j} A -&gt; <span class="kt">Type</span>@{j}} {p : <span class="kr">forall</span> <span class="nv">x</span>, IsHProp@{j} (P x)} (f : <span class="kr">forall</span> <span class="nv">a</span>, P (trm a))
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Trm A, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Trm A, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk7"><span class="nb">unfold</span> Trm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, IsHProp P -&gt; (A -&gt; P) -&gt; P, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk8"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, IsHProp P -&gt; (A -&gt; P) -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk9">rapply x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, IsHProp P -&gt; (A -&gt; P) -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chka"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, IsHProp P -&gt; (A -&gt; P) -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chkb"><span class="nb">refine</span> (transport P _ (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Trm A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Trm A, IsHProp (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (trm a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, IsHProp P -&gt; (A -&gt; P) -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trm a = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply path_ishprop@{k}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The universe constraints go away if we assume propositional resizing. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AssumePropResizing</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{PropResizing}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** If we assume propositions resizing, then we may as well quantify over propositions in the lowest universe [Set] when defining the truncation.  This reduces the number of universe variables.  We also assume that [Set &lt; i], so that the construction lands in universe [i]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">imp_Trm</span>@{i | <span class="kt">Set</span> &lt; i} (A : <span class="kt">Type</span>@{i}) : <span class="kt">Type</span>@{i}
    := Trm@{i <span class="kt">Set</span>} A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here we use propositional resizing to resize a arbitrary proposition [P] from an arbitrary universe [j] to universe [Set], so there is no constraint on the universe [j].  In particular, we can take [j = i], which shows that [imp_Trm] is a reflective subuniverse of [Type@{i}], since any two maps into a proposition agree. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">imp_Trm_rec</span>@{i j | <span class="kt">Set</span> &lt; i} {A : <span class="kt">Type</span>@{i}}
    {P : <span class="kt">Type</span>@{j}} `{IsHProp P} (f : A -&gt; P)
    : imp_Trm@{i} A -&gt; P
    := <span class="kr">fun</span> <span class="nv">ma</span> =&gt; (equiv_smalltype@{<span class="kt">Set</span> j} P)
                 (ma (smalltype@{<span class="kt">Set</span> j} P) _ ((equiv_smalltype@{<span class="kt">Set</span> j} P)^-<span class="mi">1</span> o f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Similarly, there are no constraints between [i] and [i&#39;] in the next definition, so they could be taken to be equal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_imp_Trm</span>@{i i&#39; | <span class="kt">Set</span> &lt; i, <span class="kt">Set</span> &lt; i&#39;} `{Funext}
    {A : <span class="kt">Type</span>@{i}} {A&#39; : <span class="kt">Type</span>@{i&#39;}} (f : A -&gt; A&#39;)
    : imp_Trm@{i} A -&gt; imp_Trm@{i&#39;} A&#39;
    := imp_Trm_rec (trm o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Note that [imp_Trm_rec] only computes propositionally. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chkc"><span class="kn">Definition</span> <span class="nf">imp_Trm_rec_beta</span>@{i j | <span class="kt">Set</span> &lt; i} {A : <span class="kt">Type</span>@{i}}
    {P : <span class="kt">Type</span>@{j}} `{IsHProp P} (f : A -&gt; P)
    : imp_Trm_rec@{i j} f o trm == f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">imp_Trm_rec f o trm == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">imp_Trm_rec f o trm == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chke"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">imp_Trm_rec f (trm a) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chkf"><span class="nb">unfold</span> imp_Trm_rec, trm; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_smalltype P ((equiv_smalltype P)^-<span class="mi">1</span> (f a)) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr@{<span class="kt">Set</span> j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AssumePropResizing</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Above, we needed the constraint [Set &lt; i].  But one can use propositional resizing again to make [imp_Trm] land in the lowest universe, if that is needed.  (We&#39;ll in fact let it land in any universe [u].)  To do this, we need to assume [Funext] in the definition of the truncation itself. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">TruncationWithFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{PropResizing} `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** [Funext] implies that [Trm A] is a proposition, so [PropResizing] can be used to put it in any universe. The construction passes through universe [k], which represents [max(i,Set+1)]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">resized_Trm</span>@{i k u | i &lt;= k, <span class="kt">Set</span> &lt; k} (A : <span class="kt">Type</span>@{i})
    : <span class="kt">Type</span>@{u}
    := smalltype@{u k} (Trm@{i <span class="kt">Set</span>} A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">resized_trm</span>@{i k u | i &lt;= k, <span class="kt">Set</span> &lt; k} {A : <span class="kt">Type</span>@{i}}
    : A -&gt; resized_Trm@{i k u} A
    := (equiv_smalltype _)^-<span class="mi">1</span> o trm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk10"><span class="kn">Definition</span> <span class="nf">resized_Trm_rec</span>@{i j k u | i &lt;= k, <span class="kt">Set</span> &lt; k} {A : <span class="kt">Type</span>@{i}}
    {P : <span class="kt">Type</span>@{j}} `{IsHProp P} (f : A -&gt; P)
    : resized_Trm@{i k u} A -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">resized_Trm A -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">resized_Trm A -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk12"><span class="nb">refine</span> (_ o (equiv_smalltype@{u k} _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trm A -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">ma</span> =&gt; (equiv_smalltype@{<span class="kt">Set</span> j} P)
                 (ma (smalltype@{<span class="kt">Set</span> j} P) _ ((equiv_smalltype@{<span class="kt">Set</span> j} P)^-<span class="mi">1</span> o f))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The beta rule is again propositional. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk13"><span class="kn">Definition</span> <span class="nf">resized_Trm_rec_beta</span>@{i j k u | i &lt;= k, <span class="kt">Set</span> &lt; k} {A : <span class="kt">Type</span>@{i}}
    {P : <span class="kt">Type</span>@{j}} `{IsHProp P} (f : A -&gt; P)
    : resized_Trm_rec@{i j k u} f o resized_trm == f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">resized_Trm_rec f o resized_trm == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">resized_Trm_rec f o resized_trm == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk15"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">resized_Trm_rec f (resized_trm a) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk16"><span class="nb">unfold</span> resized_Trm_rec, resized_trm, Trm, trm; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_smalltype P
  (equiv_smalltype
     (<span class="kr">forall</span> <span class="nv">P</span> : Type0, IsHProp P -&gt; (A -&gt; P) -&gt; P)
     ((equiv_smalltype
         (<span class="kr">forall</span> <span class="nv">P</span> : Type0, IsHProp P -&gt; (A -&gt; P) -&gt; P))^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">P</span> : Type0) (<span class="nv">_</span> : IsHProp P) (<span class="nv">f</span> : A -&gt; P)
         =&gt; f a)) (smalltype P)
     (istrunc_smalltype P (-<span class="mi">1</span>))
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (equiv_smalltype P)^-<span class="mi">1</span> (f x))) =
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="impredicativetruncation-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="impredicativetruncation-v-chk17"><span class="nb">rewrite</span> eisretr@{u k}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_smalltype P ((equiv_smalltype P)^-<span class="mi">1</span> (f a)) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr@{<span class="kt">Set</span> j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">TruncationWithFunext</span>.</span></span></pre>
</div>
</div></body>
</html>
