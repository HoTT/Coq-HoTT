<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Colimit.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Diagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Graph.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.ConstantDiagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.CommutativeSquares.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This file contains the definition of colimits, and functoriality results on colimits. *)</span>

<span class="sd">(** * Colimits *)</span>

<span class="sd">(** ** Abstract definition *)</span>

<span class="sd">(** A colimit is the extremity of a cocone. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsColimit</span> `(D: Diagram G) (Q: <span class="kt">Type</span>) := {
  iscolimit_cocone :: Cocone D Q;
  iscolimit_unicocone : UniversalCocone iscolimit_cocone;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">iscolimit_cocone</span> : IsColimit &gt;-&gt; Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_IsColimit {G D Q} C H : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> iscolimit_cocone {G D Q} C : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> iscolimit_unicocone {G D Q} H : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cocone_postcompose_inv] is defined for convenience: it is only the inverse of [cocone_postcompose]. It allows to recover the map [h] from a cocone [C&#39;]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cocone_postcompose_inv</span> `{D: Diagram G} {Q X}
  (H : IsColimit D Q) (C&#39; : Cocone D X) : Q -&gt; X
  := @equiv_inv _ _ _ (iscolimit_unicocone H X) C&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Existence of colimits *)</span>

<span class="sd">(** Every diagram has a colimit.  It could be described as the following HIT</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">  HIT Colimit {G : Graph} (D : Diagram G) : Type :=</span>
<span class="sd">  | colim : forall i, D i -&gt; Colimit D</span>
<span class="sd">  | colimp : forall i j (f : G i j) (x : D i) : colim j (D _f f x) = colim i x</span>
<span class="sd">  .</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">but we instead describe it as the coequalizer of the source and target maps of the diagram.  The source type in the coequalizer ought to be:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">{x : sig D &amp; {y : sig D &amp; {f : G x.1 y.1 &amp; D _f f x.2 = y.2}}}</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">However we notice that the path type forms a contractible component, so we can use the more efficient:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">{x : sig D &amp; {j : G &amp; G x.1 j}}</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Colimit</span> {<span class="nv">G</span> : Graph} (<span class="nv">D</span> : Diagram G) : <span class="kt">Type</span> :=
  @Coeq
    {x : sig D &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
    (sig D)
    (<span class="kr">fun</span> <span class="nv">t</span> =&gt; t.<span class="mi">1</span>)
    (<span class="kr">fun</span> <span class="nv">t</span> =&gt; (t.<span class="mi">2</span>.<span class="mi">1</span>; D _f t.<span class="mi">2</span>.<span class="mi">2</span> t.<span class="mi">1</span>.<span class="mi">2</span>))
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">colim</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) : Colimit D :=
  coeq (i ; x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">f</span> : G i j) (<span class="nv">x</span> : D i)
  : colim j (D _f f x) = colim i x
  := (cglue ((i; x); j; f))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** To obtain a path [colim j (D _f f x) = colim j (D _f f y)] from a path [x = y], one can either use [ap (D _f f)] followed by [ap (colim j)], or conjugate [ap (colim i)] by [colimp i j f]. These paths are equivalent. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1"><span class="kn">Definition</span> <span class="nf">ap_colim_homotopic</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} {<span class="nv">i</span> <span class="nv">j</span> : G} (<span class="nv">f</span> : G i j) {<span class="nv">x</span> <span class="nv">y</span> : D i} (<span class="nv">p</span> : x = y)
  : ap (colim j) (ap (D _f f) p)
    = colimp i j f x @ ap (colim i) p @ (colimp i j f y)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim j) (ap (D _f f) p) =
(colimp i j f x @ ap (colim i) p) @ (colimp i j f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim j) (ap (D _f f) p) =
(colimp i j f x @ ap (colim i) p) @ (colimp i j f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3">lhs_V napply ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; colim j ((D _f f) x)) p =
(colimp i j f x @ ap (colim i) p) @ (colimp i j f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap_homotopic (colimp _ _ _) p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4"><span class="kn">Definition</span> <span class="nf">Colimit_ind</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : Colimit D -&gt; <span class="kt">Type</span>)
(<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, P (colim i x))
(<span class="nv">pp_q</span> : <span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span> : D i),
  (@colimp G D i j g x) # (q j (D _f g x)) = q i x)
: <span class="kr">forall</span> <span class="nv">w</span>, P w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : Colimit D, P w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : Colimit D, P w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6">srapply Coeq_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {x : _ &amp; D x}, P (coeq a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}},
transport P (cglue b)
  (<span class="nl">?coeq&#39;</span>
     ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
       =&gt; t.<span class="mi">1</span>) b)) =
<span class="nl">?coeq&#39;</span>
  ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}} =&gt;
    ((t.<span class="mi">2</span>).<span class="mi">1</span>; (D _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {x : _ &amp; D x}, P (coeq a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9"><span class="nb">intros</span> [x i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>D x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (coeq (x; i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q x i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}},
transport P (cglue b)
  ((<span class="kr">fun</span> <span class="nv">a</span> : {x : _ &amp; D x} =&gt;
    (<span class="kr">fun</span> (<span class="nv">x</span> : G) (<span class="nv">i</span> : D x) =&gt; q x i) a.<span class="mi">1</span> a.<span class="mi">2</span>)
     ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
       =&gt; t.<span class="mi">1</span>) b)) =
(<span class="kr">fun</span> <span class="nv">a</span> : {x : _ &amp; D x} =&gt;
 (<span class="kr">fun</span> (<span class="nv">x</span> : G) (<span class="nv">i</span> : D x) =&gt; q x i) a.<span class="mi">1</span> a.<span class="mi">2</span>)
  ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}} =&gt;
    ((t.<span class="mi">2</span>).<span class="mi">1</span>; (D _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkb"><span class="nb">intros</span> [[i x] [j f]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (i; x).<span class="mi">1</span> j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f))
  (q (((i; x); j; f).<span class="mi">1</span>).<span class="mi">1</span> (((i; x); j; f).<span class="mi">1</span>).<span class="mi">2</span>) =
q (((i; x); j; f).<span class="mi">2</span>).<span class="mi">1</span>
  ((D _f (((i; x); j; f).<span class="mi">2</span>).<span class="mi">2</span>) (((i; x); j; f).<span class="mi">1</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkc"><span class="nb">cbn</span> <span class="kr">in</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f)) (q i x) =
q j ((D _f f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkd"><span class="nb">apply</span> moveR_transport_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q i x =
transport P (cglue ((i; x); j; f))^ (q j ((D _f f) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chke"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f))^ (q j ((D _f f) x)) =
q i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pp_q _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkf"><span class="kn">Definition</span> <span class="nf">Colimit_ind_beta_colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G}
  (<span class="nv">P</span> : Colimit D -&gt; <span class="kt">Type</span>) (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, P (colim i x))
  (<span class="nv">pp_q</span> : <span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span>: G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span>: D i),
    @colimp G D i j g x # q _ (D _f g x) = q _ x)
  (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i)
  : apD (Colimit_ind P q pp_q) (colimp i j g x) = pp_q i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (colimp i j g x) =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (colimp i j g x) =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk11"><span class="nb">refine</span> (apD_V _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveR_transport_V P (cglue ((i; x); j; g))
  (Colimit_ind P q pp_q (colim j ((D _f g) x)))
  (Colimit_ind P q pp_q (colim i x))
  (apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)))^ =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk12"><span class="nb">apply</span> moveR_equiv_M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)))^ =
(moveR_transport_V P (cglue ((i; x); j; g))
   (Colimit_ind P q pp_q (colim j ((D _f g) x)))
   (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
  (pp_q i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk13"><span class="nb">apply</span> moveR_equiv_M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)) =
inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk14"><span class="nb">refine</span> (Coeq_ind_beta_cglue _ _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveR_transport_p P (cglue ((i; x); j; g)) (q i x)
  (q j ((D _f g) x)) (pp_q i j g x)^ =
inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk15"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x)) =
moveR_transport_p P (cglue ((i; x); j; g)) (q i x)
  (q j ((D _f g) x)) (pp_q i j g x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveL_transport_p_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk16"><span class="kn">Definition</span> <span class="nf">Colimit_rec</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C</span> : Cocone D P)
  : Colimit D -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk18">srapply (Colimit_ind _ C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) (colimp i j g x)
  (C j ((D _f g) x)) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk19"><span class="nb">intros</span> i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) (colimp i j g x)
  (C j ((D _f g) x)) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1a"><span class="nb">refine</span> (transport_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C j ((D _f g) x) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> legs_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1b"><span class="kn">Definition</span> <span class="nf">Colimit_rec_beta_colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G}
  (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C</span> : Cocone D P) (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span>: D i)
  : ap (Colimit_rec P C) (colimp i j g x) = legs_comm C i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec P C) (colimp i j g x) =
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec P C) (colimp i j g x) =
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1d">rapply (cancelL (transport_const (colimp i j g x) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
ap (Colimit_rec P C) (colimp i j g x) =
transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1e">srapply ((apD_const (Colimit_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) C _) (colimp i j g x))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD
  (Colimit_ind (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) C
     (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
      transport_const (colimp i j g x)
        (C j ((D _f g) x)) @ legs_comm C i j g x))
  (colimp i j g x) =
transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Colimit_ind_beta_colimp (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) C _ i j g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> colim : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> colimp : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The natural cocone to the colimit. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cocone_colimit</span> {<span class="nv">G</span> : Graph} (<span class="nv">D</span> : Diagram G) : Cocone D (Colimit D)
  := Build_Cocone colim colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a cocone [C] and [f : Colimit D -&gt; P] inducing a &quot;homotopic&quot; cocone, [Colimit_rec P C] is homotopic to [f]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1f"><span class="kn">Definition</span> <span class="nf">Colimit_rec_homotopy</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C</span> : Cocone D P)
  (<span class="nv">f</span> : Colimit D -&gt; P)
  (<span class="nv">h_obj</span> : <span class="kr">forall</span> <span class="nv">i</span>, legs C i == f o colim i)
  (<span class="nv">h_comm</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> (<span class="nv">g</span> : G i j) <span class="nv">x</span>,
      legs_comm C i j g x @ h_obj i x = h_obj j ((D _f g) x) @ ap f (colimp i j g x))
  : Colimit_rec P C == f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P C == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P C == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk21">snapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
  (colim i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk22"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
  (colimp i j g x) (<span class="nl">?q</span> j ((D _f g) x)) = 
<span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
  (colim i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk24"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), C i x = f (colim i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h_obj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
  (colimp i j g x)
  ((h_obj
    :
    <span class="kr">forall</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0),
    (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
      (colim i0 x0)) j ((D _f g) x)) =
(h_obj
 :
 <span class="kr">forall</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0),
 (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
   (colim i0 x0)) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk26"><span class="nb">cbn</span> beta; <span class="nb">intros</span> i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; Colimit_rec P C w = f w)
  (colimp i j g x) (h_obj j ((D _f g) x)) = h_obj i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk27">transport_paths FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec P C) (colimp i j g x) @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk28">lhs napply (Colimit_rec_beta_colimp _ _ _ _ _ _ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C i == f o colim i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm C i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> h_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** &quot;Homotopic&quot; cocones induces homotopic maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk29"><span class="kn">Definition</span> <span class="nf">Colimit_rec_homotopy&#39;</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C1</span> <span class="nv">C2</span> : Cocone D P)
  (<span class="nv">h_obj</span> : <span class="kr">forall</span> <span class="nv">i</span>, legs C1 i == legs C2 i)
  (<span class="nv">h_comm</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> (<span class="nv">g</span> : G i j) <span class="nv">x</span>,
      legs_comm C1 i j g x @ h_obj i x = h_obj j (D _f g x) @ legs_comm C2 i j g x)
  : Colimit_rec P C1 == Colimit_rec P C2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P C1 == Colimit_rec P C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P C1 == Colimit_rec P C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2b">snapply Colimit_rec_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == Colimit_rec P C2 o colim i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk2c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ <span class="nl">?h_obj</span> i x =
<span class="nl">?h_obj</span> j ((D _f g) x) @
ap (Colimit_rec P C2) (colimp i j g x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == Colimit_rec P C2 o colim i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h_obj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @
ap (Colimit_rec P C2) (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2f"><span class="nb">intros</span> i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @
ap (Colimit_rec P C2) (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk30">rhs napply (<span class="mi">1</span> @@ Colimit_rec_beta_colimp _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1, C2</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, C1 i == C2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm C1 i j g x @ h_obj i x =
h_obj j ((D _f g) x) @ legs_comm C2 i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> h_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [Colimit_rec] is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk31"><span class="kn">Instance</span> <span class="nf">isequiv_colimit_rec</span> `{Funext} {G : Graph}
  {D : Diagram G} (P : <span class="kt">Type</span>)
  : IsEquiv (Colimit_rec (D:=D) P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Colimit_rec P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Colimit_rec P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk33">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; P) -&gt; Cocone D P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk34"><hr></label><div class="goal-conclusion">Colimit_rec P o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk35"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o Colimit_rec P == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; P) -&gt; Cocone D P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cocone_postcompose (cocone_colimit D)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P o cocone_postcompose (cocone_colimit D) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk38"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
  (cocone_postcompose (cocone_colimit D) f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk39"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
  (cocone_postcompose (cocone_colimit D) f) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3a">snapply Colimit_rec_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_postcompose (cocone_colimit D) f i ==
f o colim i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk3b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
legs_comm (cocone_postcompose (cocone_colimit D) f) i
  j g x @ <span class="nl">?h_obj</span> i x =
<span class="nl">?h_obj</span> j ((D _f g) x) @ ap f (colimp i j g x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3c"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
legs_comm (cocone_postcompose (cocone_colimit D) f) i
  j g x @ (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) i x =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x) @
ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3d"><span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (colimp i j g x) @ <span class="mi">1</span> = <span class="mi">1</span> @ ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_colimit D) o Colimit_rec P ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3f"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_colimit D)
  (Colimit_rec P
     {| legs := legs; legs_comm := legs_comm |}) =
{| legs := legs; legs_comm := legs_comm |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk40">srapply path_cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_postcompose (cocone_colimit D)
  (Colimit_rec P
     {| legs := legs; legs_comm := legs_comm |}) i ==
{| legs := legs; legs_comm := legs_comm |} i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk41"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
Cocone.legs_comm
  (cocone_postcompose (cocone_colimit D)
     (Colimit_rec P
        {| legs := legs; legs_comm := legs_comm |})) i
  j g x @ <span class="nl">?path_legs</span> i x =
<span class="nl">?path_legs</span> j ((D _f g) x) @
Cocone.legs_comm
  {| legs := legs; legs_comm := legs_comm |} i j g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk42"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
Cocone.legs_comm
  (cocone_postcompose (cocone_colimit D)
     (Colimit_rec P
        {| legs := legs; legs_comm := legs_comm |})) i
  j g x @ (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) i x =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x) @
Cocone.legs_comm
  {| legs := legs; legs_comm := legs_comm |} i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk43"><span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec P
     {| legs := legs; legs_comm := legs_comm |})
  (colimp i j g x) @ <span class="mi">1</span> = <span class="mi">1</span> @ legs_comm i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk44"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec P
     {| legs := legs; legs_comm := legs_comm |})
  (colimp i j g x) = legs_comm i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_colimit_rec</span> `{Funext} {G : Graph} {D : Diagram G} (P : <span class="kt">Type</span>)
  : Cocone D P &lt;~&gt; (Colimit D -&gt; P) := Build_Equiv _ _ _ (isequiv_colimit_rec P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that the HIT Colimit is an abstract colimit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk45"><span class="kn">Instance</span> <span class="nf">unicocone_colimit</span> `{Funext} {G : Graph} (D : Diagram G)
  : UniversalCocone (cocone_colimit D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_colimit D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_colimit D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk47">srapply Build_UniversalCocone; <span class="nb">intro</span> Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose (cocone_colimit D))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The goal is to show that [cocone_postcompose (cocone_colimit D)] is an equivalence, but that&#39;s the inverse to the equivalence we just defined. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_inverse (equiv_colimit_rec Y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">iscolimit_colimit</span> `{Funext} {G : Graph} (D : Diagram G)
  : IsColimit D (Colimit D)
  := Build_IsColimit _ (unicocone_colimit D).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of concrete colimits *)</span>

<span class="sd">(** We will capitalize [Colimit] in the identifiers to indicate that these definitions relate to the concrete colimit defined above.  Below, we will also get functoriality for abstract colimits, without the capital C.  However, to apply those results to the concrete colimit uses [iscolimit_colimit], which requires [Funext], so it is also useful to give direct proofs of some facts. *)</span>

<span class="sd">(** We first work in a more general situation.  Any diagram map [m : D1 =&gt; D2] induces a map between the canonical colimit of [D1] and any cocone over [D2].  We use &quot;half&quot; to indicate this situation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk48"><span class="kn">Definition</span> <span class="nf">functor_Colimit_half</span> {<span class="nv">G</span> : Graph} {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : DiagramMap D1 D2) {<span class="nv">Q</span>} (<span class="nv">HQ</span> : Cocone D2 Q)
  : Colimit D1 -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D1 -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D1 -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4a"><span class="nb">apply</span> Colimit_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cocone_precompose m HQ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Colimit_half_beta_colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : DiagramMap D1 D2) {<span class="nv">Q</span>} (<span class="nv">HQ</span> : Cocone D2 Q) (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D1 i)
  : ap (functor_Colimit_half m HQ) (colimp i j g x) = legs_comm (cocone_precompose m HQ) i j g x
  := Colimit_rec_beta_colimp _ _ _ _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Homotopic diagram maps induce homotopic maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4b"><span class="kn">Definition</span> <span class="nf">functor_Colimit_half_homotopy</span> {<span class="nv">G</span> : Graph} {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
  {<span class="nv">m1</span> <span class="nv">m2</span> : DiagramMap D1 D2} (<span class="nv">h</span> : DiagramMap_homotopy m1 m2)
  {<span class="nv">Q</span>} (<span class="nv">HQ</span> : Cocone D2 Q)
  : functor_Colimit_half m1 HQ == functor_Colimit_half m2 HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>DiagramMap_homotopy m1 m2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Colimit_half m1 HQ ==
functor_Colimit_half m2 HQ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>DiagramMap_homotopy m1 m2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Colimit_half m1 HQ ==
functor_Colimit_half m2 HQ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4d"><span class="nb">destruct</span> h <span class="kr">as</span> [h_obj h_comm].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Colimit_half m1 HQ ==
functor_Colimit_half m2 HQ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4e">snapply Colimit_rec_homotopy&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_precompose m1 HQ i == cocone_precompose m2 HQ i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk4f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
legs_comm (cocone_precompose m1 HQ) i j g x @
<span class="nl">?h_obj</span> i x =
<span class="nl">?h_obj</span> j ((D1 _f g) x) @
legs_comm (cocone_precompose m2 HQ) i j g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_precompose m1 HQ i == cocone_precompose m2 HQ i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk51"><span class="nb">intros</span> i x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HQ i (m1 i x) = HQ i (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, h_obj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D1 i),
legs_comm (cocone_precompose m1 HQ) i j g x @
(<span class="kr">fun</span> <span class="nv">i0</span> : G =&gt;
 (<span class="kr">fun</span> <span class="nv">x0</span> : D1 i0 =&gt;
  ap (HQ i0) (h_obj i0 x0)
  :
  cocone_precompose m1 HQ i0 x0 =
  cocone_precompose m2 HQ i0 x0)
 :
 cocone_precompose m1 HQ i0 ==
 cocone_precompose m2 HQ i0) i x =
(<span class="kr">fun</span> <span class="nv">i0</span> : G =&gt;
 (<span class="kr">fun</span> <span class="nv">x0</span> : D1 i0 =&gt;
  ap (HQ i0) (h_obj i0 x0)
  :
  cocone_precompose m1 HQ i0 x0 =
  cocone_precompose m2 HQ i0 x0)
 :
 cocone_precompose m1 HQ i0 ==
 cocone_precompose m2 HQ i0) j ((D1 _f g) x) @
legs_comm (cocone_precompose m2 HQ) i j g x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk53"><span class="nb">intros</span> i j g x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x @
h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x) @
DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j) (DiagramMap_comm m1 g x)^ @
 legs_comm HQ i j g (m1 i x)) @ ap (HQ i) (h_obj i x) =
ap (HQ j) (h_obj j ((D1 _f g) x)) @
(ap (HQ j) (DiagramMap_comm m2 g x)^ @
 legs_comm HQ i j g (m2 i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk54"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (HQ j) (DiagramMap_comm m1 g x)^
@&#39; legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j) (h_obj j ((D1 _f g) x))
@&#39; (ap (HQ j) (DiagramMap_comm m2 g x)^
    @&#39; legs_comm HQ i j g (m2 i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* TODO: Most of the work here comes from a mismatch between the direction of the path in [DiagramMap_comm] and [legs_comm] in the [Cocone] record, causing a reversal in [cocone_precompose].  There is no reversal in [cocone_postcompose], so I think [Cocone] should change. If that is done, then this result wouldn&#39;t be needed at all, and one could directly use [Colimit_rec_homotopy&#39;]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk55"><span class="nb">rewrite</span> ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j) (DiagramMap_comm m1 g x))^
@&#39; legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j) (h_obj j ((D1 _f g) x))
@&#39; (ap (HQ j) (DiagramMap_comm m2 g x)^
    @&#39; legs_comm HQ i j g (m2 i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk56">lhs napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j) (DiagramMap_comm m1 g x))^
@&#39; (legs_comm HQ i j g (m1 i x)
    @&#39; ap (HQ i) (h_obj i x)) =
ap (HQ j) (h_obj j ((D1 _f g) x))
@&#39; (ap (HQ j) (DiagramMap_comm m2 g x)^
    @&#39; legs_comm HQ i j g (m2 i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk57"><span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j) (DiagramMap_comm m1 g x)
@&#39; (ap (HQ j) (h_obj j ((D1 _f g) x))
    @&#39; (ap (HQ j) (DiagramMap_comm m2 g x)^
        @&#39; legs_comm HQ i j g (m2 i x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk58"><span class="nb">rewrite</span> ! concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j) (DiagramMap_comm m1 g x)
@&#39; ap (HQ j) (h_obj j ((D1 _f g) x))
@&#39; ap (HQ j) (DiagramMap_comm m2 g x)^
@&#39; legs_comm HQ i j g (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk59"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span> ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j)
  (DiagramMap_comm m1 g x
   @&#39; h_obj j ((D1 _f g) x)
   @&#39; (DiagramMap_comm m2 g x)^)
@&#39; legs_comm HQ i j g (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5a"><span class="nb">rewrite</span> h_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j)
  (ap (D2 _f g) (h_obj i x)
   @&#39; DiagramMap_comm m2 g x
   @&#39; (DiagramMap_comm m2 g x)^)
@&#39; legs_comm HQ i j g (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5b"><span class="nb">rewrite</span> concat_pp_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (HQ j) (ap (D2 _f g) (h_obj i x))
@&#39; legs_comm HQ i j g (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5c"><span class="nb">rewrite</span> &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>h_obj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, m1 i == m2 i</span></span></span><br><span><var>h_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D1 i),
DiagramMap_comm m1 g x
@&#39; h_obj j ((D1 _f g) x) =
ap (D2 _f g) (h_obj i x)
@&#39; DiagramMap_comm m2 g x</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone D2 Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D1 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm HQ i j g (m1 i x)
@&#39; ap (HQ i) (h_obj i x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : D2 i =&gt; HQ j ((D2 _f g) x)) (h_obj i x)
@&#39; legs_comm HQ i j g (m2 i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_Ap (legs_comm HQ i j g) (h_obj i x))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we specialize to the case where the second cone is a colimiting cone. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Colimit</span> {<span class="nv">G</span> : Graph} {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : DiagramMap D1 D2)
  : Colimit D1 -&gt; Colimit D2
  := functor_Colimit_half m (cocone_colimit D2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A homotopy between diagram maps [m1, m2 : D1 =&gt; D2] gives a homotopy between the induced maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Colimit_homotopy</span> {<span class="nv">G</span> : Graph} {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
  {<span class="nv">m1</span> <span class="nv">m2</span> : DiagramMap D1 D2} (<span class="nv">h</span> : DiagramMap_homotopy m1 m2)
  : functor_Colimit m1 == functor_Colimit m2
  := functor_Colimit_half_homotopy h _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Composition of diagram maps commutes with [functor_Colimit_half], provided the first map uses [functor_Colimit]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5d"><span class="kn">Definition</span> <span class="nf">functor_Colimit_half_compose</span> {<span class="nv">G</span> : Graph} {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : Diagram G} (<span class="nv">f</span> : DiagramMap A B) (<span class="nv">g</span> : DiagramMap B C) {<span class="nv">Q</span>} (<span class="nv">HQ</span> : Cocone C Q)
  : functor_Colimit_half (diagram_comp g f) HQ == functor_Colimit_half g HQ o functor_Colimit f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Colimit_half (diagram_comp g f) HQ ==
functor_Colimit_half g HQ o functor_Colimit f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Colimit_half (diagram_comp g f) HQ ==
functor_Colimit_half g HQ o functor_Colimit f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5f">snapply Colimit_rec_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_precompose (diagram_comp g f) HQ i ==
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 functor_Colimit_half g HQ (functor_Colimit f x))
o colim i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk60"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g0</span> : G i j) (<span class="nv">x</span> : A i),
legs_comm (cocone_precompose (diagram_comp g f) HQ) i
  j g0 x @ <span class="nl">?h_obj</span> i x =
<span class="nl">?h_obj</span> j ((A _f g0) x) @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x0))
  (colimp i j g0 x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_precompose (diagram_comp g f) HQ i ==
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 functor_Colimit_half g HQ (functor_Colimit f x))
o colim i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g0</span> : G i j) (<span class="nv">x</span> : A i),
legs_comm (cocone_precompose (diagram_comp g f) HQ) i
  j g0 x @ (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : A i0) =&gt; <span class="mi">1</span>) i x =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : A i0) =&gt; <span class="mi">1</span>) j ((A _f g0) x) @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x0))
  (colimp i j g0 x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk63"><span class="nb">intros</span> i j k x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j)
   (comm_square_comp (DiagramMap_comm f k)
      (DiagramMap_comm g k) x)^ @
 legs_comm HQ i j k (g i (f i x))) @ <span class="mi">1</span> =
<span class="mi">1</span> @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk64"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (HQ j)
  (comm_square_comp (DiagramMap_comm f k)
     (DiagramMap_comm g k) x)^ @
legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk65"><span class="nb">unfold</span> comm_square_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (HQ j)
  (DiagramMap_comm g k (f i x) @
   ap (g j) (DiagramMap_comm f k x))^ @
legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk66"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (HQ j)
  (DiagramMap_comm g k (f i x)
   @&#39; ap (g j) (DiagramMap_comm f k x))^
@&#39; legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk67">lhs napply (ap_V _ _ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j)
   (DiagramMap_comm g k (f i x)
    @&#39; ap (g j) (DiagramMap_comm f k x)))^
@&#39; legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk68">lhs napply (inverse2 (ap_pp (HQ j) _ _) @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j) (DiagramMap_comm g k (f i x))
 @&#39; ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk69">lhs napply (inv_pp _ _ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6a"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   functor_Colimit_half g HQ (functor_Colimit f x))
  (colimp i j k x) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6b">lhs napply (ap_compose (functor_Colimit f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (functor_Colimit f) (colimp i j k x)) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6c">lhs napply (ap _ (Colimit_rec_beta_colimp _ _ _ _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (legs_comm (cocone_precompose f (cocone_colimit B))
     i j k x) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* [legs_comm] unfolds to a composite of paths, but the next line works best without unfolding it. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6d">lhs napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (cocone_colimit B j) (DiagramMap_comm f k x)^)
@&#39; ap (functor_Colimit_half g HQ)
     (legs_comm (cocone_colimit B) i j k (f i x)) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6e">lhs nrefine (<span class="mi">1</span> @@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (legs_comm (cocone_colimit B) i j k (f i x)) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk6f"><hr></label><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (cocone_colimit B j) (DiagramMap_comm f k x)^)
@&#39; <span class="nl">?Goal</span> =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk70"><span class="mi">1</span>: napply functor_Colimit_half_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (cocone_colimit B j) (DiagramMap_comm f k x)^)
@&#39; legs_comm (cocone_precompose g HQ) i j k (f i x) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk71"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (colim j) (DiagramMap_comm f k x)^)
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x))^
    @&#39; legs_comm HQ i j k (g i (f i x))) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk72">lhs napply concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (colim j) (DiagramMap_comm f k x)^)
@&#39; ap (HQ j) (DiagramMap_comm g k (f i x))^
@&#39; legs_comm HQ i j k (g i (f i x)) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^
@&#39; legs_comm HQ i j k (g i (f i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk73">nrefine (_ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (colim j) (DiagramMap_comm f k x)^)
@&#39; ap (HQ j) (DiagramMap_comm g k (f i x))^ =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^
@&#39; (ap (HQ j) (DiagramMap_comm g k (f i x)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk74"><span class="nb">apply</span> ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (colim j) (DiagramMap_comm f k x)^) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk75"><hr></label><div class="goal-conclusion">ap (HQ j) (DiagramMap_comm g k (f i x))^ =
(ap (HQ j) (DiagramMap_comm g k (f i x)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk76"><span class="mi">2</span>: napply ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_Colimit_half g HQ)
  (ap (colim j) (DiagramMap_comm f k x)^) =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk77">lhs_V napply (ap_compose (colim j)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : B j =&gt; HQ j (g j x))
  (DiagramMap_comm f k x)^ =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk78">lhs napply (ap_V (HQ j o g j) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>DiagramMap A B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>DiagramMap B C</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Cocone C Q</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : B j =&gt; HQ j (g j x))
   (DiagramMap_comm f k x))^ =
(ap (HQ j) (ap (g j) (DiagramMap_comm f k x)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, ap_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of abstract colimits *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FunctorialityColimit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext} {G : Graph}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Colimits are preserved by composition with a (diagram) equivalence. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk79"><span class="kn">Definition</span> <span class="nf">iscolimit_precompose_equiv</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
    (<span class="nv">m</span> : D1 ~d~ D2) {<span class="nv">Q</span> : <span class="kt">Type</span>}
    : IsColimit D2 Q -&gt; IsColimit D1 Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D2 Q -&gt; IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D2 Q -&gt; IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7b"><span class="nb">intros</span> HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7c">srapply (Build_IsColimit (cocone_precompose m HQ) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_precompose m HQ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_equiv_universality, HQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7d"><span class="kn">Definition</span> <span class="nf">iscolimit_postcompose_equiv</span> {<span class="nv">D</span>: Diagram G} `(f: Q &lt;~&gt; Q&#39;)
    : IsColimit D Q -&gt; IsColimit D Q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q -&gt; IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q -&gt; IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7f"><span class="nb">intros</span> HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk80">srapply (Build_IsColimit (cocone_postcompose HQ f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_postcompose HQ f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_postcompose_equiv_universality, HQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A diagram map [m : D1 =&gt; D2] induces a map between any two colimits of [D1] and [D2]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_colimit</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : DiagramMap D1 D2)
    {<span class="nv">Q1</span> <span class="nv">Q2</span>} (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2)
    : Q1 -&gt; Q2 := cocone_postcompose_inv HQ1 (cocone_precompose m HQ2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And this map commutes with diagram map. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_colimit_commute</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
    (<span class="nv">m</span> : DiagramMap D1 D2) {<span class="nv">Q1</span> <span class="nv">Q2</span>}
    (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span>: IsColimit D2 Q2)
    : cocone_precompose m HQ2
      = cocone_postcompose HQ1 (functor_colimit m HQ1 HQ2)
    := (eisretr (cocone_postcompose HQ1) _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Additional coherence with postcompose and precompose. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk81"><span class="kn">Definition</span> <span class="nf">cocone_precompose_postcompose_comp</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
    (<span class="nv">m</span> : DiagramMap D1 D2) {<span class="nv">Q1</span> <span class="nv">Q2</span> : <span class="kt">Type</span>} (<span class="nv">HQ1</span> : IsColimit D1 Q1)
    (<span class="nv">HQ2</span> : IsColimit D2 Q2) {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">t</span> : Q2 -&gt; T)
    : cocone_postcompose HQ1 (t o functor_colimit m HQ1 HQ2)
      = cocone_precompose m (cocone_postcompose HQ2 t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Q2 -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1 (t o functor_colimit m HQ1 HQ2) =
cocone_precompose m (cocone_postcompose HQ2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Q2 -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1 (t o functor_colimit m HQ1 HQ2) =
cocone_precompose m (cocone_postcompose HQ2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk83">lhs napply cocone_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Q2 -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose
  (cocone_postcompose HQ1 (functor_colimit m HQ1 HQ2))
  t = cocone_precompose m (cocone_postcompose HQ2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk84">lhs_V <span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; cocone_postcompose x t)
        (functor_colimit_commute m HQ1 HQ2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Q2 -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_precompose m HQ2) t =
cocone_precompose m (cocone_postcompose HQ2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply cocone_precompose_postcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** In order to show that colimits are functorial, we show that this is true after precomposing with the cocone. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk85"><span class="kn">Definition</span> <span class="nf">postcompose_functor_colimit_compose</span> {<span class="nv">D1</span> <span class="nv">D2</span> <span class="nv">D3</span> : Diagram G}
    (<span class="nv">m</span> : DiagramMap D1 D2) (<span class="nv">n</span> : DiagramMap D2 D3)
    {<span class="nv">Q1</span> <span class="nv">Q2</span> <span class="nv">Q3</span>} (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2)
    (<span class="nv">HQ3</span> : IsColimit D3 Q3)
    : cocone_postcompose HQ1 (functor_colimit n HQ2 HQ3 o functor_colimit m HQ1 HQ2)
      = cocone_postcompose HQ1 (functor_colimit (diagram_comp n m) HQ1 HQ3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2, D3</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>DiagramMap D2 D3</span></span></span><br><span><var>Q1, Q2, Q3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>HQ3</var><span class="hyp-type"><b>: </b><span>IsColimit D3 Q3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (functor_colimit n HQ2 HQ3
   o functor_colimit m HQ1 HQ2) =
cocone_postcompose HQ1
  (functor_colimit (diagram_comp n m) HQ1 HQ3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2, D3</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>DiagramMap D2 D3</span></span></span><br><span><var>Q1, Q2, Q3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>HQ3</var><span class="hyp-type"><b>: </b><span>IsColimit D3 Q3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (functor_colimit n HQ2 HQ3
   o functor_colimit m HQ1 HQ2) =
cocone_postcompose HQ1
  (functor_colimit (diagram_comp n m) HQ1 HQ3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk87">lhs napply cocone_precompose_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2, D3</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>DiagramMap D2 D3</span></span></span><br><span><var>Q1, Q2, Q3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>HQ3</var><span class="hyp-type"><b>: </b><span>IsColimit D3 Q3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose m
  (cocone_postcompose HQ2 (functor_colimit n HQ2 HQ3)) =
cocone_postcompose HQ1
  (functor_colimit (diagram_comp n m) HQ1 HQ3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk88">lhs_V napply (ap _ (functor_colimit_commute n HQ2 HQ3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2, D3</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>DiagramMap D2 D3</span></span></span><br><span><var>Q1, Q2, Q3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>HQ3</var><span class="hyp-type"><b>: </b><span>IsColimit D3 Q3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose m (cocone_precompose n HQ3) =
cocone_postcompose HQ1
  (functor_colimit (diagram_comp n m) HQ1 HQ3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk89">lhs napply cocone_precompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2, D3</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DiagramMap D1 D2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>DiagramMap D2 D3</span></span></span><br><span><var>Q1, Q2, Q3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br><span><var>HQ3</var><span class="hyp-type"><b>: </b><span>IsColimit D3 Q3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_comp n m) HQ3 =
cocone_postcompose HQ1
  (functor_colimit (diagram_comp n m) HQ1 HQ3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply functor_colimit_commute.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_colimit_compose</span> {<span class="nv">D1</span> <span class="nv">D2</span> <span class="nv">D3</span> : Diagram G}
    (<span class="nv">m</span> : DiagramMap D1 D2) (<span class="nv">n</span> : DiagramMap D2 D3)
    {<span class="nv">Q1</span> <span class="nv">Q2</span> <span class="nv">Q3</span>} (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2)
    (<span class="nv">HQ3</span> : IsColimit D3 Q3)
    : functor_colimit n HQ2 HQ3 o functor_colimit m HQ1 HQ2
      = functor_colimit (diagram_comp n m) HQ1 HQ3
    := @equiv_inj _ _
      (cocone_postcompose HQ1) (iscolimit_unicocone HQ1 Q3) _ _
      (postcompose_functor_colimit_compose m n HQ1 HQ2 HQ3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Colimits of equivalent diagrams *)</span>

  <span class="sd">(** Now we have that two equivalent diagrams have equivalent colimits. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : D1 ~d~ D2) {<span class="nv">Q1</span> <span class="nv">Q2</span>}
    (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8a"><span class="kn">Definition</span> <span class="nf">functor_colimit_eissect</span>
    : functor_colimit m HQ1 HQ2
      o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit m HQ1 HQ2
o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit m HQ1 HQ2
o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8c"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
 functor_colimit m HQ1 HQ2
   (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8d">srapply (equiv_inj (cocone_postcompose HQ2) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose HQ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk8e"><hr></label><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
cocone_postcompose HQ2 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8f"><span class="mi">1</span>: <span class="nb">apply</span> HQ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
cocone_postcompose HQ2 idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk90"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk91"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = cocone_postcompose HQ2 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk92"><span class="mi">2</span>:<span class="nb">symmetry</span>; <span class="nb">apply</span> cocone_postcompose_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk93"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk94"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = HQ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk95"><span class="mi">1</span>: <span class="nb">apply</span> cocone_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose
  (cocone_postcompose HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1))
  (functor_colimit m HQ1 HQ2) = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk96"><span class="nb">rewrite</span> eisretr, cocone_precompose_postcompose, eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_equiv_inv m)
  (cocone_precompose m HQ2) = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk97"><span class="nb">rewrite</span> cocone_precompose_comp, diagram_inv_is_section.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_idmap D2) HQ2 = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk98"><span class="kn">Definition</span> <span class="nf">functor_colimit_eisretr</span>
    : functor_colimit (diagram_equiv_inv m) HQ2 HQ1
      o functor_colimit m HQ1 HQ2 == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit (diagram_equiv_inv m) HQ2 HQ1
o functor_colimit m HQ1 HQ2 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit (diagram_equiv_inv m) HQ2 HQ1
o functor_colimit m HQ1 HQ2 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9a"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
 functor_colimit (diagram_equiv_inv m) HQ2 HQ1
   (functor_colimit m HQ1 HQ2 x)) = idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9b">srapply (equiv_inj (cocone_postcompose HQ1) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose HQ1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk9c"><hr></label><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) =
cocone_postcompose HQ1 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9d"><span class="mi">1</span>: <span class="nb">apply</span> HQ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) =
cocone_postcompose HQ1 idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9e"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk9f"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = cocone_postcompose HQ1 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka0"><span class="mi">2</span>:<span class="nb">symmetry</span>; <span class="nb">apply</span> cocone_postcompose_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka1"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chka2"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = HQ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka3"><span class="mi">1</span>: <span class="nb">apply</span> cocone_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose
  (cocone_postcompose HQ1 (functor_colimit m HQ1 HQ2))
  (functor_colimit (diagram_equiv_inv m) HQ2 HQ1) =
HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka4"><span class="nb">rewrite</span> eisretr, cocone_precompose_postcompose, eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose m
  (cocone_precompose (diagram_equiv_inv m) HQ1) = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka5"><span class="nb">rewrite</span> cocone_precompose_comp, diagram_inv_is_retraction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_idmap D1) HQ1 = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_functor_colimit</span>
    : IsEquiv (functor_colimit m HQ1 HQ2)
    := isequiv_adjointify _ _
      functor_colimit_eissect functor_colimit_eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_colimit</span> : Q1 &lt;~&gt; Q2
    := Build_Equiv _ _ _ isequiv_functor_colimit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FunctorialityColimit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Unicity of colimits *)</span>

<span class="sd">(** A particular case of the functoriality result is that all colimits of a diagram are equivalent (and hence equal in presence of univalence). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka6"><span class="kn">Theorem</span> <span class="nf">colimit_unicity</span> `{Funext} {G : Graph} {D : Diagram G} {Q1 Q2 : <span class="kt">Type</span>}
  (HQ1 : IsColimit D Q1) (HQ2 : IsColimit D Q2)
  : Q1 &lt;~&gt; Q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q1 &lt;~&gt; Q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q1 &lt;~&gt; Q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka8">srapply equiv_functor_colimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D ~d~ D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_diagram_equiv (diagram_idmap D)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Colimits are left adjoint to constant diagram *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka9"><span class="kn">Theorem</span> <span class="nf">colimit_adjoint</span> `{Funext} {G : Graph} {D : Diagram G} {C : <span class="kt">Type</span>}
  : (Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkab"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap D (diagram_const C) &lt;~&gt; (Colimit D -&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkac"><span class="nb">refine</span> (equiv_colimit_rec C oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap D (diagram_const C) &lt;~&gt; Cocone D C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_diagram_const_cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
