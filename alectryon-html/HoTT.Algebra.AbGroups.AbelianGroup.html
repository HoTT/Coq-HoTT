<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>AbelianGroup.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.canonical_names (Zero, zero, Plus, plus, Negate, negate, Involutive, involutive).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.abstract_algebra (IsAbGroup(..), abgroup_group, abgroup_commutative).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Algebra.Groups.Group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Algebra.Groups.Subgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Abelian groups *)</span>

<span class="sd">(** Definition of an abelian group *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">AbGroup</span> := {
  abgroup_group : Group;
  abgroup_commutative :: @Commutative abgroup_group _ (+);
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">abgroup_group</span> : AbGroup &gt;-&gt; Group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">zero_abgroup</span> (<span class="nv">A</span> : AbGroup) : Zero A := mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">negate_abgroup</span> (<span class="nv">A</span> : AbGroup) : Negate A := inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_abgroup</span> (<span class="nv">A</span> : AbGroup) : Plus A := sg_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Sometimes we want an abelian group to act as if it has a [Plus], [Zero] and [Negate] operation. For example, when working with rings. We therefore make this module of hints available for import so that consumers can control the way the abelian group operation is treated.</span>

<span class="sd">Files about abelian groups (apart from this one) typically don&#39;t have these instances available, whereas files about rings do. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> AdditiveInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> zero_abgroup : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> negate_abgroup : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> plus_abgroup : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AdditiveInstances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1"><span class="kn">Instance</span> <span class="nf">isabgroup_abgroup</span> {<span class="nv">A</span> : AbGroup} : IsAbGroup A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Easier way to build abelian groups without redundant information. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3"><span class="kn">Definition</span> <span class="nf">Build_AbGroup&#39;</span> (<span class="nv">G</span> : <span class="kt">Type</span>)
  `{MonUnit G, Inverse G, SgOp G, IsHSet G}
  (comm : Commutative (A:=G) (+))
  (assoc : Associative (A:=G) (+))
  (unit_l : LeftIdentity (A:=G) (+) <span class="mi">0</span>)
  (inv_l : LeftInverse (A:=G) (+) (-) <span class="mi">0</span>)
  : AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5">snapply Build_AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk6"><hr></label><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply (Build_Group&#39; G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>Commutative sg_op</span></span></span><br><span><var>assoc</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>unit_l</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">0</span></span></span></span><br><span><var>inv_l</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_abgroup</span> : _ &lt;~&gt; AbGroup := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk9"><span class="kn">Definition</span> <span class="nf">ab_neg_op</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">x</span> <span class="nv">y</span> : A) : - (x + y) = -x - y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkb">lhs napply grp_inv_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- y - x = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths between abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkc"><span class="kn">Definition</span> <span class="nf">equiv_path_abgroup</span> `{Univalence} {A B : AbGroup@{u}}
  : GroupIsomorphism A B &lt;~&gt; (A = B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chke"><span class="nb">refine</span> (equiv_ap_inv issig_abgroup _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt;
issig_abgroup^-<span class="mi">1</span> A = issig_abgroup^-<span class="mi">1</span> B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkf"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt;
(issig_abgroup^-<span class="mi">1</span> A).<span class="mi">1</span> = (issig_abgroup^-<span class="mi">1</span> B).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_abgroup_group</span> `{Univalence} {A B : AbGroup}
  : (A = B :&gt; AbGroup) &lt;~&gt; (A = B :&gt; Group)
  := equiv_path_group oE equiv_path_abgroup^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Subgroups of abelian groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Hint Immediate</span> canonical_names.inverse_is_negate : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Subgroups of abelian groups are abelian *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk10"><span class="kn">Instance</span> <span class="nf">isabgroup_subgroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsAbGroup H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk12">napply Build_IsAbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk13"><hr></label><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk14"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk15"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_sgop x y = group_sgop y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk16"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(group_sgop x y).<span class="mi">1</span> = (group_sgop y x).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk17"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x.<span class="mi">1</span> + y.<span class="mi">1</span> = y.<span class="mi">1</span> + x.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given any subgroup of an abelian group, we can coerce it to an abelian group. Note that Coq complains this coercion doesn&#39;t satisfy the uniform-inheritance condition, but in practice it works and doesn&#39;t cause any issue, so we ignore it. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abgroup_subgroup</span> (<span class="nv">G</span> : AbGroup) : Subgroup G -&gt; AbGroup
  := <span class="kr">fun</span> <span class="nv">H</span> =&gt; Build_AbGroup H _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[warnings=<span class="s2">&quot;-uniform-inheritance&quot;</span>]
<span class="kn">Coercion</span> <span class="nf">abgroup_subgroup</span> : Subgroup &gt;-&gt; AbGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk18"><span class="kn">Instance</span> <span class="nf">isnormal_ab_subgroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsNormalSubgroup H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1a"><span class="nb">intros</span> x y h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (y + x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quotients of abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1b"><span class="kn">Instance</span> <span class="nf">isabgroup_quotient</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsAbGroup (QuotientGroup&#39; G H (isnormal_ab_subgroup G H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1d">napply Build_IsAbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk1e"><hr></label><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1f"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk20">srapply Quotient_ind2_hprop; <span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span>
    <span class="nv">y</span> : G /
        in_cosetL
          {|
            normalsubgroup_subgroup := H;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup G H
          |} =&gt; group_sgop x y = group_sgop y x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk21"><span class="nb">apply</span> (ap (class_of _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + y = y + x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">QuotientAbGroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G) : AbGroup
  := (Build_AbGroup (QuotientGroup&#39; G H (isnormal_ab_subgroup G H)) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> QuotientAbGroup G H : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_abgroup_rec</span> {<span class="nv">G</span> : AbGroup}
  (<span class="nv">N</span> : Subgroup G) (<span class="nv">H</span> : AbGroup)
  (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = mon_unit)
  : GroupHomomorphism (QuotientAbGroup G N) H
  := grp_quotient_rec G (Build_NormalSubgroup G N _) f h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk22"><span class="kn">Theorem</span> <span class="nf">equiv_quotient_abgroup_ump</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> : AbGroup}
  (<span class="nv">N</span> : Subgroup G) (<span class="nv">H</span> : Group)
  : {f : GroupHomomorphism G H &amp; <span class="kr">forall</span> (<span class="nv">n</span> : G), N n -&gt; f n = mon_unit}
    &lt;~&gt; (GroupHomomorphism (QuotientAbGroup G N) H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : GroupHomomorphism G H &amp;
<span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = <span class="mi">0</span>} &lt;~&gt;
GroupHomomorphism (QuotientAbGroup G N) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : GroupHomomorphism G H &amp;
<span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = <span class="mi">0</span>} &lt;~&gt;
GroupHomomorphism (QuotientAbGroup G N) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_grp_quotient_ump (Build_NormalSubgroup G N _) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The wild category of abelian groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_abgroup</span> : IsGraph AbGroup
  := isgraph_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_abgroup</span> : Is01Cat AbGroup
  := is01cat_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_abgroup</span> : Is2Graph AbGroup
  := is2graph_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_abgrouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : IsGraph (A $-&gt; B)
  := is2graph_induced abgroup_group A B.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_abgrouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : Is01Cat (A $-&gt; B)
  := is01cat_induced (@grp_homo_map A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0gpd_abgrouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : Is0Gpd (A $-&gt; B)
  := is0gpd_induced (@grp_homo_map A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [AbGroup] forms a 1Cat *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is1cat_abgroup</span> : Is1Cat AbGroup
  := is1cat_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">hasmorext_abgroup</span> `{Funext} : HasMorExt AbGroup
  := hasmorext_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">hasequivs_abgroup</span> : HasEquivs AbGroup
  := hasequivs_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Zero object of [AbGroup] *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk24"><span class="kn">Definition</span> <span class="nf">abgroup_trivial</span> : AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk26">rapply (Build_AbGroup grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [AbGroup] is a pointed category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk27"><span class="kn">Instance</span> <span class="nf">ispointedcat_abgroup</span> : IsPointedCat AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk29"><span class="nb">apply</span> Build_IsPointedCat <span class="kr">with</span> abgroup_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial abgroup_trivial</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal abgroup_trivial</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intro</span> A; <span class="nb">apply</span> ispointedcat_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [abgroup_group] is a functor *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0functor_abgroup_group</span> : Is0Functor abgroup_group
  := is0functor_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is1functor_abgroup_group</span> : Is1Functor abgroup_group
  := is1functor_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Image of group homomorphisms between abelian groups *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abgroup_image</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) : AbGroup
  := Build_AbGroup (grp_image f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** First isomorphism theorem of abelian groups *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2a"><span class="kn">Definition</span> <span class="nf">abgroup_first_iso</span> `{Funext} {A B : AbGroup} (f : A $-&gt; B)
  : GroupIsomorphism (QuotientAbGroup A (grp_kernel f)) (abgroup_image f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (abgroup_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (abgroup_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2c"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk2d"><hr></label><div class="goal-conclusion">GroupIsomorphism <span class="nl">?Goal</span> (abgroup_image f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2e"><span class="mi">2</span>: rapply grp_first_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (QuotientGroup A (grp_kernel f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_iso_quotient_normal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Kernels of abelian groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_kernel</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) : AbGroup
  := Build_AbGroup (grp_kernel f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transporting in families related to abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2f"><span class="kn">Lemma</span> <span class="nf">transport_abgrouphomomorphism_from_const</span> `{Univalence} {A B B&#39; : AbGroup}
      (p : B = B&#39;) (f : GroupHomomorphism A B)
  : transport (Hom A) p f
    = grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>B = B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) p f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>B = B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) p f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk31"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) <span class="mi">1</span> f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> <span class="mi">1</span>%path) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk32"><span class="kn">Lemma</span> <span class="nf">transport_iso_abgrouphomomorphism_from_const</span> `{Univalence} {A B B&#39; : AbGroup}
      (phi : GroupIsomorphism B B&#39;) (f : GroupHomomorphism A B)
  : transport (Hom A) (equiv_path_abgroup phi) f
    = grp_homo_compose phi f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup phi) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup phi) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk34"><span class="nb">refine</span> (transport_abgrouphomomorphism_from_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (equiv_path_abgroup^-<span class="mi">1</span> (equiv_path_abgroup phi)) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk35"><span class="kn">Lemma</span> <span class="nf">transport_abgrouphomomorphism_to_const</span> `{Univalence} {A A&#39; B : AbGroup}
      (p : A = A&#39;) (f : GroupHomomorphism A B)
  : transport (<span class="kr">fun</span> <span class="nv">G</span> =&gt; Hom G B) p f
    = grp_homo_compose f (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B) p f =
grp_homo_compose f
  (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B) p f =
grp_homo_compose f
  (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk37"><span class="nb">induction</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
grp_homo_compose f
  {|
    grp_homo_map := idmap;
    issemigrouppreserving_grp_homo :=
      abstract_algebra.invert_sg_morphism idmap
        abstract_algebra.id_sg_morphism
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk38"><span class="kn">Lemma</span> <span class="nf">transport_iso_abgrouphomomorphism_to_const</span> `{Univalence} {A A&#39; B : AbGroup}
      (phi : GroupIsomorphism A A&#39;) (f : GroupHomomorphism A B)
  : transport (<span class="kr">fun</span> <span class="nv">G</span> =&gt; Hom G B) (equiv_path_abgroup phi) f
    = grp_homo_compose f (grp_iso_inverse phi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B)
  (equiv_path_abgroup phi) f =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B)
  (equiv_path_abgroup phi) f =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3a"><span class="nb">refine</span> (transport_abgrouphomomorphism_to_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose f
  (grp_iso_inverse
     (equiv_path_abgroup^-<span class="mi">1</span> (equiv_path_abgroup phi))) =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Operations on abelian groups *)</span>

<span class="sd">(** The negation automorphism of an abelian group *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3b"><span class="kn">Definition</span> <span class="nf">ab_homo_negation</span> {<span class="nv">A</span> : AbGroup} : GroupIsomorphism A A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3d">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk3e"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk40">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk41"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; -a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk43">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk44"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk45"><span class="nb">refine</span> (grp_inv_op x y @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- y - x = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk47">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk48"><hr></label><div class="goal-conclusion">{|
  grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
     grp_inv_op x y @ commutativity (- y) (- x))
    :
    IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
|} o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk49"><hr></label><div class="goal-conclusion"><span class="nl">?g</span>
o {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |} == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4a"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; -a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
     grp_inv_op x y @ commutativity (- y) (- x))
    :
    IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
|} o (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk4b"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
o {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |} == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>-<span class="mi">2</span>: <span class="bp">exact</span> inverse_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Multiplication by [n : Int] defines an endomorphism of any abelian group [A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4c"><span class="kn">Definition</span> <span class="nf">ab_mul</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : Int) : GroupHomomorphism A A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4e">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk4f"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk50"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; grp_pow a n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; grp_pow a n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk51"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (a + b) n = grp_pow a n + grp_pow b n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pow_mul, commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ab_mul n] is natural. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_mul_natural</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup}
  (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">n</span> : Int)
  : f o ab_mul n == ab_mul n o f
  := grp_pow_natural f n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The image of an inclusion is a normal subgroup. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_image_embedding</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) `{IsEmbedding f} : NormalSubgroup B
  := {| normalsubgroup_subgroup := grp_image_embedding f; normalsubgroup_isnormal := _ |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_image_in_embedding</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) `{IsEmbedding f}
  : GroupIsomorphism A (ab_image_embedding f)
  := grp_image_in_embedding f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The cokernel of a homomorphism into an abelian group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_cokernel</span> {<span class="nv">G</span> : Group@{u}} {<span class="nv">A</span> : AbGroup@{u}} (<span class="nv">f</span> : GroupHomomorphism G A)
  : AbGroup := QuotientAbGroup _ (grp_image f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_cokernel_embedding</span> {<span class="nv">G</span> : Group} {<span class="nv">A</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A) `{IsEmbedding f}
  : AbGroup := QuotientAbGroup _ (grp_image_embedding f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk52"><span class="kn">Definition</span> <span class="nf">ab_cokernel_embedding_rec</span> {<span class="nv">G</span>: Group} {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A) `{IsEmbedding f}
  (h : A $-&gt; B) (p : grp_homo_compose h f $== grp_homo_const)
  : ab_cokernel_embedding f $-&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding f $-&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding f $-&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk54">snapply (grp_quotient_rec _ _ h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : A,
{|
  normalsubgroup_subgroup := grp_image_embedding f;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup A (grp_image_embedding f)
|} n -&gt; h n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk55"><span class="nb">intros</span> a [g q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f g = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h a = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk56"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (f g) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
