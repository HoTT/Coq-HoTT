<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Core.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3da" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3da"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.IdentitySystems.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core PointedCat TwoOneCat NatTrans
  <span class="kn">Universe</span> <span class="nf">Products</span> Equiv Yoneda.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Extensions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointed Types *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;pt&#39;&quot;</span> := (point _) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ X , x ]&quot;</span> := (Build_pType X x) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The unit type is pointed *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_unit</span> : IsPointed Unit := tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Unit [pType] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pUnit</span> : pType := [Unit, tt].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A sigma type of pointed components is pointed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_sigma</span> `{IsPointed A} `{IsPointed (B (point A))}
: IsPointed (sig B)
  := (point A; point (B (point A))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A product of pointed types is pointed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_prod</span> `{IsPointed A, IsPointed B} : IsPointed (A * B)
  := (point A, point B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We override the notation for products in pointed_scope *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;X * Y&quot;</span> := ([X * Y, ispointed_prod]) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A pointed type family consists of a type family over a pointed type and a section of that family at the basepoint. By making this a Record, it has one fewer universe variable, and is cumulative. We declare [pfam_pr1] to be a coercion [pFam &gt;-&gt; Funclass]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">pFam</span> (<span class="nv">A</span> : pType) := { pfam_pr1 :&gt; A -&gt; <span class="kt">Type</span>; dpoint : pfam_pr1 (point A)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_pFam {A} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> pfam_pr1 {A} P : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dpoint {A} P : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The constant pointed family *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfam_const</span> {<span class="nv">A</span> : pType} (<span class="nv">B</span> : pType) : pFam A
  := Build_pFam (<span class="kr">fun</span> <span class="nv">_</span> =&gt; pointed_type B) (point B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [IsTrunc] for a pointed type family *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsTrunc_pFam</span> <span class="nv">n</span> {<span class="nv">A</span>} (<span class="nv">P</span> : pFam A)
  := trunc_pfam_is_trunc : <span class="kr">forall</span> <span class="nv">x</span>, IsTrunc n (P x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pointed dependent functions *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">pForall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A) := {
  pointed_fun : <span class="kr">forall</span> <span class="nv">x</span>, P x ;
  dpoint_eq : pointed_fun (point A) = dpoint P ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dpoint_eq {A P} f : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> pointed_fun {A P} f : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pointed_fun</span> : pForall &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointed functions *)</span>

<span class="sd">(** A pointed map is a map with a proof that it preserves the point. We define it as as a notation for a non-dependent version of [pForall]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A -&gt;* B&quot;</span> := (pForall A (pfam_const B)) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_pMap</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">p</span> : f (point A) = point B)
  : A -&gt;* B
  := Build_pForall A (pfam_const B) f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [&amp;] is a bidirectionality hint that tells Coq to unify with the typing context after type checking the arguments to the left.  In practice, this allows Coq to infer [A] and [B] from the context. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_pMap {A B} &amp; f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pointed maps preserve the base point *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">point_eq</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
  : f (point A) = point B
  := dpoint_eq f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity pointed map *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_idmap</span> {<span class="nv">A</span> : pType} : A -&gt;* A
  := Build_pMap idmap <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Composition of pointed maps *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : pType} (<span class="nv">g</span> : B -&gt;* C) (<span class="nv">f</span> : A -&gt;* B)
  : A -&gt;* C
  := Build_pMap (g o f) (ap g (point_eq f) @ point_eq g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;o*&quot;</span> := pmap_compose : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointed homotopies *)</span>

<span class="sd">(** A pointed homotopy is a homotopy with a proof that the preservation paths agree. We define it instead as a special case of a [pForall]. This means that we can define pointed homotopies between pointed homotopies. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfam_phomotopy</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} (<span class="nv">f</span> <span class="nv">g</span> : pForall A P) : pFam A
  := Build_pFam (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x = g x) (dpoint_eq f @ (dpoint_eq g)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pHomotopy</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} (<span class="nv">f</span> <span class="nv">g</span> : pForall A P)
  := pForall A (pfam_phomotopy f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;==*&quot;</span> := pHomotopy : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_pHomotopy</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
  (<span class="nv">p</span> : f == g) (<span class="nv">q</span> : p (point A) = dpoint_eq f @ (dpoint_eq g)^)
  : f ==* g
  := Build_pForall A (pfam_phomotopy f g) p q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying homotopy of a pointed homotopy *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pointed_htpy</span> {A : pType} {P : pFam A} {f g : pForall A P} (h : f ==* g)
  : f == g
  := h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the form that the underlying proof of a pointed homotopy used to take before we changed it to be defined in terms of [pForall]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3db" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3db"><span class="kn">Definition</span> <span class="nf">point_htpy</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
  (<span class="nv">h</span> : f ==* g) : h (point A) @ dpoint_eq g = dpoint_eq f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt @ dpoint_eq g = dpoint_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3dc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3dc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt @ dpoint_eq g = dpoint_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3dd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3dd"><span class="nb">apply</span> moveR_pM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dpoint_eq h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointed equivalences *)</span>

<span class="sd">(** A pointed equivalence is a pointed map and a proof that it is an equivalence *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">pEquiv</span> (<span class="nv">A</span> <span class="nv">B</span> : pType) := {
  pointed_equiv_fun : pForall A (pfam_const B) ;
  pointed_isequiv :: IsEquiv pointed_equiv_fun ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_pEquiv {A B} &amp; _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: It might be better behaved to define [pEquiv] as an equivalence and a proof that this equivalence is pointed. In pEquiv.v we have another constructor [Build_pEquiv&#39;] which Coq can infer faster than [Build_pEquiv]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;&lt;~&gt;*&quot;</span> := pEquiv : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note: because we define [pMap] as a special case of [pForall], we must declare all coercions into [pForall], *not* into [pMap]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pointed_equiv_fun</span> : pEquiv &gt;-&gt; pForall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pointed_equiv_equiv</span> {A B} (f : A &lt;~&gt;* B)
  : A &lt;~&gt; B := Build_Equiv A B f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The pointed identity is a pointed equivalence *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_pmap_idmap</span> {<span class="nv">A</span>} : A &lt;~&gt;* A
  := Build_pEquiv pmap_idmap _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pointed sigma types *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">psigma</span> {<span class="nv">A</span> : pType} (<span class="nv">P</span> : pFam A) : pType
  := [sig P, (point A; dpoint P)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pointed products *)</span>

<span class="sd">(** Pointed pi types; note that the domain is not pointed *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pproduct</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : A -&gt; pType) : pType
  := [<span class="kr">forall</span> (<span class="nv">a</span> : A), pointed_type (F a), ispointed_type o F].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3de" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3de"><span class="kn">Definition</span> <span class="nf">pproduct_corec</span> `{Funext} {A : <span class="kt">Type</span>} (F : A -&gt; pType)
  (X : pType) (f : <span class="kr">forall</span> <span class="nv">a</span>, X -&gt;* F a)
  : X -&gt;* pproduct F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt;* pproduct F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3df" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt;* pproduct F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e0">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; pproduct F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3e1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><label class="goal-separator" for="core-v-chk3e1"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; pproduct F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e3"><span class="nb">intros</span> x a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f a x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; f a x) : pproduct F) pt =
pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; f a pt) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ispointed_type (F x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e6">funext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, X -&gt;* F a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a pt = ispointed_type (F a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> point_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e7"><span class="kn">Definition</span> <span class="nf">pproduct_proj</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">F</span> : A -&gt; pType} (<span class="nv">a</span> : A)
  : pproduct F -&gt;* F a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct F -&gt;* F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct F -&gt;* F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3e9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3e9">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct F -&gt; F a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chk3ea"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3eb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3eb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct F -&gt; F a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3ec" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3ec"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>pproduct F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (x a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3ed" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3ed">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : pproduct F =&gt; x a) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The projections from a pointed product are pointed maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfst</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} : A * B -&gt;* A
  := Build_pMap fst idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">psnd</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} : A * B -&gt;* B
  := Build_pMap snd idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pprod_corec</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">Z</span> : pType) (<span class="nv">f</span> : Z -&gt;* X) (<span class="nv">g</span> : Z -&gt;* Y)
  : Z -&gt;* (X * Y)
  := Build_pMap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; (f z, g z))
      (path_prod&#39; (point_eq _) (point_eq _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3ee" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3ee"><span class="kn">Definition</span> <span class="nf">pprod_corec_beta_fst</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">Z</span> : pType) (<span class="nv">f</span> : Z -&gt;* X) (<span class="nv">g</span> : Z -&gt;* Y)
  : pfst o* pprod_corec Z f g ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfst o* pprod_corec Z f g ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3ef" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3ef"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfst o* pprod_corec Z f g ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f0">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfst o* pprod_corec Z f g == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><label class="goal-separator" for="core-v-chk3f1"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (pfst o* pprod_corec Z f g) @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f2"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>) pt =
dpoint_eq (pfst o* pprod_corec Z f g) @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f3"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq f =
dpoint_eq (pfst o* pprod_corec Z f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f4"><span class="nb">refine</span> (concat_1p _ @ _^ @ (concat_p1 _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pfst (point_eq (pprod_corec Z f g)) = dpoint_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_fst_path_prod&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f5"><span class="kn">Definition</span> <span class="nf">pprod_corec_beta_snd</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">Z</span> : pType) (<span class="nv">f</span> : Z -&gt;* X) (<span class="nv">g</span> : Z -&gt;* Y)
  : psnd o* pprod_corec Z f g ==* g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">psnd o* pprod_corec Z f g ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">psnd o* pprod_corec Z f g ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f7">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">psnd o* pprod_corec Z f g == g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk3f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><label class="goal-separator" for="core-v-chk3f8"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (psnd o* pprod_corec Z f g) @ (dpoint_eq g)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3f9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3f9"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>) pt =
dpoint_eq (psnd o* pprod_corec Z f g) @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3fa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3fa"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq g =
dpoint_eq (psnd o* pprod_corec Z f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3fb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3fb"><span class="nb">refine</span> (concat_1p _ @ _^ @ (concat_p1 _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z -&gt;* X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap psnd (point_eq (pprod_corec Z f g)) = dpoint_eq g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_snd_path_prod&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The following tactics often allow us to &quot;pretend&quot; that pointed maps and homotopies preserve basepoints strictly. *)</span>

<span class="sd">(** First a version with no rewrites, which leaves some cleanup to be done but which can be used in transparent proofs. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">pointed_reduce</span> :=
  <span class="c">(*TODO: are these correct? *)</span>
  <span class="nb">unfold</span> pointed_fun, pointed_htpy;
  <span class="nb">cbn</span> <span class="kr">in</span> *;
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
           | [ X : pType |- _ ] =&gt; <span class="nb">destruct</span> X <span class="kr">as</span> [X <span class="nl">?point</span>]
           | [ P : pFam <span class="nl">?X</span> |- _ ] =&gt; <span class="nb">destruct</span> P <span class="kr">as</span> [P ?]
           | [ phi : pForall <span class="nl">?X</span> <span class="nl">?Y</span> |- _ ] =&gt; <span class="nb">destruct</span> phi <span class="kr">as</span> [phi ?]
           | [ alpha : pHomotopy <span class="nl">?f</span> <span class="nl">?g</span> |- _ ] =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">destruct</span> alpha <span class="kr">as</span> [alpha H]; <span class="kp">try</span> (<span class="nb">apply</span> moveR_pM <span class="kr">in</span> H)
           | [ equiv : pEquiv <span class="nl">?X</span> <span class="nl">?Y</span> |- _ ] =&gt; <span class="nb">destruct</span> equiv <span class="kr">as</span> [equiv <span class="nl">?iseq</span>]
         <span class="kr">end</span>;
  <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">unfold</span> point <span class="kr">in</span> *;
  path_induction; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Next a version that uses [rewrite], and should only be used in opaque proofs. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">pointed_reduce_rewrite</span> :=
  pointed_reduce;
  <span class="nb">rewrite</span> <span class="nl">?concat_p1</span>, <span class="nl">?concat_1p</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finally, a version that just strictifies a single map or equivalence.  This has the advantage that it leaves the context more readable. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">pointed_reduce_pmap</span> f
  := <span class="kp">try</span> <span class="kr">match</span> <span class="kp">type of</span> f <span class="kr">with</span>
    | pEquiv <span class="nl">?X</span> <span class="nl">?Y</span> =&gt; <span class="nb">destruct</span> f <span class="kr">as</span> [f <span class="nl">?iseq</span>]
    <span class="kr">end</span>;
    <span class="kr">match</span> <span class="kp">type of</span> f <span class="kr">with</span>
    | _ -&gt;* <span class="nl">?Y</span> =&gt; <span class="kr">let</span> <span class="nv">p</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">destruct</span> Y <span class="kr">as</span> [Y ?], f <span class="kr">as</span> [f p]; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p; <span class="nb">cbn</span>
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A general tactic to replace pointedness paths in a [pForall] with reflexivity.  Because it generalizes [f pt], it can usually only be applied once the function itself is not longer needed.  Compared to [pointed_reduce], an advantage is that the pointed types do not need to be destructed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">pelim</span> f :=
  <span class="kp">try</span> <span class="kr">match</span> <span class="kp">type of</span> f <span class="kr">with</span>
    | pEquiv <span class="nl">?X</span> <span class="nl">?Y</span> =&gt; <span class="nb">destruct</span> f <span class="kr">as</span> [f <span class="nl">?iseq</span>]; <span class="nb">unfold</span> pointed_fun <span class="kr">in</span> *
  <span class="kr">end</span>;
  <span class="nb">destruct</span> f <span class="kr">as</span> [f <span class="nl">?ptd</span>];
  <span class="nb">cbn</span> <span class="kr">in</span> f, ptd |- *;
  <span class="kr">match</span> <span class="kp">type of</span> ptd <span class="kr">with</span> <span class="nl">?fpt</span> = _ =&gt; <span class="nb">generalize dependent</span> fpt <span class="kr">end</span>;
  napply paths_ind_r;
  <span class="kp">try</span> <span class="nb">clear</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) := pelim x0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) := pelim x0; pelim x1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) <span class="kp">constr</span>(x2) := pelim x0; pelim x1 x2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) <span class="kp">constr</span>(x2) <span class="kp">constr</span>(x3) := pelim x0; pelim x1 x2 x3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) <span class="kp">constr</span>(x2) <span class="kp">constr</span>(x3) <span class="kp">constr</span>(x4) := pelim x0; pelim x1 x2 x3 x4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) <span class="kp">constr</span>(x2) <span class="kp">constr</span>(x3) <span class="kp">constr</span>(x4) <span class="kp">constr</span>(x5) := pelim x0; pelim x1 x2 x3 x4 x5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pelim&quot;</span> <span class="kp">constr</span>(x0) <span class="kp">constr</span>(x1) <span class="kp">constr</span>(x2) <span class="kp">constr</span>(x3) <span class="kp">constr</span>(x4) <span class="kp">constr</span>(x5) <span class="kp">constr</span>(x6) := pelim x0; pelim x1 x2 x3 x4 x5 x6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalences to sigma-types. *)</span>

<span class="sd">(** [pType] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_ptype</span> : { X : <span class="kt">Type</span> &amp; X } &lt;~&gt; pType := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A)
  : {f : <span class="kr">forall</span> <span class="nv">x</span>, P x &amp; f (point A) = dpoint P} &lt;~&gt; (pForall A P)
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pMap] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_pmap</span> (<span class="nv">A</span> <span class="nv">B</span> : pType)
  : {f : A -&gt; B &amp; f (point A) = point B} &lt;~&gt; (A -&gt;* B)
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pHomotopy] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_phomotopy</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} (<span class="nv">f</span> <span class="nv">g</span> : pForall A P)
  : {p : f == g &amp; p (point A) = dpoint_eq f @ (dpoint_eq g)^} &lt;~&gt; (f ==* g)
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pEquiv] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_pequiv</span> (<span class="nv">A</span> <span class="nv">B</span> : pType)
  : {f : A -&gt;* B &amp; IsEquiv f} &lt;~&gt; (A &lt;~&gt;* B)
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The record for pointed equivalences is equivalently a different sigma type *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_pequiv&#39;</span> (<span class="nv">A</span> <span class="nv">B</span> : pType)
  : {f : A &lt;~&gt; B &amp; f (point A) = point B} &lt;~&gt; (A &lt;~&gt;* B)
  := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] can also be described as a type of extensions. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3fc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3fc"><span class="kn">Definition</span> <span class="nf">equiv_extension_along_pforall</span> `{Funext} {A : pType} (P : pFam A)
  : ExtensionAlong@{<span class="kt">Set</span> _ _ _} (unit_name (point A)) P (unit_name (dpoint P)) &lt;~&gt; pForall A P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (unit_name pt) P (unit_name (dpoint P)) &lt;~&gt;
pForall A P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3fd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3fd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (unit_name pt) P (unit_name (dpoint P)) &lt;~&gt;
pForall A P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3fe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3fe"><span class="nb">unfold</span> ExtensionAlong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : <span class="kr">forall</span> <span class="nv">y</span> : A, P y &amp; Unit -&gt; s pt = dpoint P} &lt;~&gt;
pForall A P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk3ff" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk3ff"><span class="nb">refine</span> (issig_pforall A P oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : <span class="kr">forall</span> <span class="nv">y</span> : A, P y &amp; Unit -&gt; s pt = dpoint P} &lt;~&gt;
{f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk400" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk400"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Unit -&gt; s pt = dpoint P) &lt;~&gt; s pt = dpoint P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_unit_rec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is [equiv_prod_coind] for pointed families. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk401" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk401"><span class="kn">Definition</span> <span class="nf">equiv_pprod_coind</span> {<span class="nv">A</span> : pType} (<span class="nv">P</span> <span class="nv">Q</span> : pFam A)
  : (pForall A P * pForall A Q) &lt;~&gt;
      (pForall A (Build_pFam (<span class="kr">fun</span> <span class="nv">a</span> =&gt; prod (P a) (Q a)) (dpoint P, dpoint Q))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pForall A P * pForall A Q &lt;~&gt;
pForall A
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk402" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk402"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pForall A P * pForall A Q &lt;~&gt;
pForall A
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk403" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk403"><span class="nb">transitivity</span> {p : prod (<span class="kr">forall</span> <span class="nv">a</span>:A, P a) (<span class="kr">forall</span> <span class="nv">a</span>:A, Q a)
                    &amp; prod (fst p _ = dpoint P) (snd p _ = dpoint Q)}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pForall A P * pForall A Q &lt;~&gt;
{p : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a) &amp;
((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk404" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk404"><hr></label><div class="goal-conclusion">{p : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a) &amp;
((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type} &lt;~&gt;
pForall A
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk405" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk405"><span class="mi">1</span>: make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a) &amp;
((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type} &lt;~&gt;
pForall A
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk406" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk406"><span class="nb">refine</span> (issig_pforall _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a) &amp;
((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type} &lt;~&gt;
{f
: <span class="kr">forall</span> <span class="nv">x</span> : A,
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |} x &amp;
f pt =
dpoint
  {|
    pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
    dpoint := (dpoint P, dpoint Q)
  |}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk407" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk407">srapply equiv_functor_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A,
 {|
   pfam_pr1 := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (P a * Q a)%type;
   dpoint := (dpoint P, dpoint Q)
 |} x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk408" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk408"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a),
(<span class="kr">fun</span> <span class="nv">p</span> : (<span class="kr">forall</span> <span class="nv">a0</span> : A, P a0) * (<span class="kr">forall</span> <span class="nv">a0</span> : A, Q a0)
 =&gt;
 ((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type)
  a &lt;~&gt;
(<span class="kr">fun</span>
   <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A,
       {|
         pfam_pr1 := <span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; (P a0 * Q a0)%type;
         dpoint := (dpoint P, dpoint Q)
       |} x =&gt;
 f pt =
 dpoint
   {|
     pfam_pr1 := <span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; (P a0 * Q a0)%type;
     dpoint := (dpoint P, dpoint Q)
   |}) (<span class="nl">?f</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk409" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk409"><span class="mi">1</span>: <span class="nb">apply</span> equiv_prod_coind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : (<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a),
(<span class="kr">fun</span> <span class="nv">p</span> : (<span class="kr">forall</span> <span class="nv">a0</span> : A, P a0) * (<span class="kr">forall</span> <span class="nv">a0</span> : A, Q a0)
 =&gt;
 ((fst p pt = dpoint P) * (snd p pt = dpoint Q))%type)
  a &lt;~&gt;
(<span class="kr">fun</span>
   <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A,
       {|
         pfam_pr1 := <span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; (P a0 * Q a0)%type;
         dpoint := (dpoint P, dpoint Q)
       |} x =&gt;
 f pt =
 dpoint
   {|
     pfam_pr1 := <span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; (P a0 * Q a0)%type;
     dpoint := (dpoint P, dpoint Q)
   |}) (equiv_prod_coind P Q a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40a"><span class="nb">intro</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>((<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a))%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst f pt = dpoint P) * (snd f pt = dpoint Q) &lt;~&gt;
prod_coind_uncurried f pt = (dpoint P, dpoint Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40b"><span class="nb">unfold</span> prod_coind_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>((<span class="kr">forall</span> <span class="nv">a</span> : A, P a) * (<span class="kr">forall</span> <span class="nv">a</span> : A, Q a))%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst f pt = dpoint P) * (snd f pt = dpoint Q) &lt;~&gt;
(fst f pt, snd f pt) = (dpoint P, dpoint Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_prod (fst f _, snd f _) (dpoint P, dpoint Q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40c"><span class="kn">Definition</span> <span class="nf">functor_pprod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : pType} (<span class="nv">f</span> : A -&gt;* A&#39;) (<span class="nv">g</span> : B -&gt;* B&#39;)
  : A * B -&gt;* A&#39; * B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B -&gt;* A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B -&gt;* A&#39; * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk40e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk40e">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[A * B, ispointed_prod] -&gt; [A&#39; * B&#39;, ispointed_prod]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk40f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><label class="goal-separator" for="core-v-chk40f"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk410" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk410">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[A * B, ispointed_prod] -&gt; [A&#39; * B&#39;, ispointed_prod]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_prod f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk411" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk411">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod f g pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> point_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [isequiv_functor_prod] applies, and is an Instance. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_pprod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : pType} (<span class="nv">f</span> : A &lt;~&gt;* A&#39;) (<span class="nv">g</span> : B &lt;~&gt;* B&#39;)
  : A * B &lt;~&gt;* A&#39; * B&#39;
  := Build_pEquiv (functor_pprod f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Various operations with pointed homotopies *)</span>

<span class="sd">(** For the following three instances, the typeclass (e.g. [Reflexive]) requires a third universe variable, the maximum of the universe of [A] and the universe of the values of [P].  Because of this, in each case we first prove a version not mentioning the typeclass, which avoids a stray universe variable. *)</span>

<span class="sd">(** [pHomotopy] is a reflexive relation *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">phomotopy_reflexive</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} (<span class="nv">f</span> : pForall A P)
  : f ==* f
  := Build_pHomotopy (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>) (concat_pV _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">phomotopy_reflexive&#39;</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  : Reflexive (@pHomotopy A P)
  := @phomotopy_reflexive A P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pHomotopy] is a symmetric relation *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk412" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk412"><span class="kn">Definition</span> <span class="nf">phomotopy_symmetric</span> {<span class="nv">A</span> <span class="nv">P</span>} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P} (<span class="nv">p</span> : f ==* g)
  : g ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk413" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk413"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk414" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk414">snrefine (Build_pHomotopy _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk415" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk415"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> pt = dpoint_eq g @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk416" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk416"><span class="mi">1</span>: <span class="nb">intros</span> x; <span class="bp">exact</span> ((p x)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) : g == f) pt =
dpoint_eq g @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">phomotopy_symmetric&#39;</span> {<span class="nv">A</span> <span class="nv">P</span>}
  : Symmetric (@pHomotopy A P)
  := @phomotopy_symmetric A P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p ^*&quot;</span> := (phomotopy_symmetric p) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pHomotopy] is a transitive relation *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk417" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk417"><span class="kn">Definition</span> <span class="nf">phomotopy_transitive</span> {<span class="nv">A</span> <span class="nv">P</span>} {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : pForall A P} (<span class="nv">p</span> : f ==* g) (<span class="nv">q</span> : g ==* h)
  : f ==* h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk418" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk418"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk419" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk419">snrefine (Build_pHomotopy (<span class="kr">fun</span> <span class="nv">x</span> =&gt; p x @ q x) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; p x @ q x) pt =
dpoint_eq f @ (dpoint_eq h)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41a">nrefine (dpoint_eq p @@ dpoint_eq q @ concat_pp_p _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint_eq f @
((dpoint_eq g)^ @ dpoint (pfam_phomotopy g h)) =
dpoint_eq f @ (dpoint_eq h)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply whiskerL; napply concat_V_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">phomotopy_transitive&#39;</span> {<span class="nv">A</span> <span class="nv">P</span>} : Transitive (@pHomotopy A P)
  := @phomotopy_transitive A P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p @* q&quot;</span> := (phomotopy_transitive p q) : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Whiskering of pointed homotopies by pointed functions *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41b"><span class="kn">Definition</span> <span class="nf">pmap_postwhisker</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : pType} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt;* B}
  (<span class="nv">h</span> : B -&gt;* C) (<span class="nv">p</span> : f ==* g)
  : h o* f ==* h o* g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* f ==* h o* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* f ==* h o* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41d">snrefine (Build_pHomotopy _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x)) == (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk41e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk41e"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> pt =
(ap h (point_eq f) @ point_eq h) @
(ap h (point_eq g) @ point_eq h)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk41f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk41f"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap h (p x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ap h (p x)) pt =
(ap h (point_eq f) @ point_eq h) @
(ap h (point_eq g) @ point_eq h)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk420" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk420"><span class="kn">Definition</span> <span class="nf">pmap_prewhisker</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
  {<span class="nv">g</span> <span class="nv">h</span> : B -&gt;* C} (<span class="nv">p</span> : g ==* h)
  : g o* f ==* h o* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o* f ==* h o* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk421" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk421"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o* f ==* h o* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk422" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk422">snrefine (Build_pHomotopy _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk423" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><label class="goal-separator" for="core-v-chk423"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> pt =
(ap g (point_eq f) @ point_eq g) @
(ap h (point_eq f) @ point_eq h)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk424" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk424"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; p (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; p (f x)) pt =
(ap g (point_eq f) @ point_eq g) @
(ap h (point_eq f) @ point_eq h)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f p g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** 1-categorical properties of [pType]. *)</span>

<span class="sd">(** Composition of pointed maps is associative up to pointed homotopy *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk425" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk425"><span class="kn">Definition</span> <span class="nf">pmap_compose_assoc</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : pType} (<span class="nv">h</span> : C -&gt;* D)
  (<span class="nv">g</span> : B -&gt;* C) (<span class="nv">f</span> : A -&gt;* B)
  : (h o* g) o* f ==* h o* (g o* f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* g o* f ==* h o* (g o* f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk426" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk426"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* g o* f ==* h o* (g o* f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk427" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk427">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* g o* f == h o* (g o* f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk428" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk428"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (h o* g o* f) @ (dpoint_eq (h o* (g o* f)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk429" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk429"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (h o* g o* f) @ (dpoint_eq (h o* (g o* f)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** precomposition of identity pointed map *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42a"><span class="kn">Definition</span> <span class="nf">pmap_precompose_idmap</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
: f o* pmap_idmap ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pmap_idmap ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pmap_idmap ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42c">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pmap_idmap == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk42d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk42d"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq (f o* pmap_idmap) @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (f o* pmap_idmap) @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** postcomposition of identity pointed map *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk42f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk42f"><span class="kn">Definition</span> <span class="nf">pmap_postcompose_idmap</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
: pmap_idmap o* f ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_idmap o* f ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk430" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk430"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_idmap o* f ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk431" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk431">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_idmap o* f == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk432" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk432"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq (pmap_idmap o* f) @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk433" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk433"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (pmap_idmap o* f) @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** 1-categorical properties of [pForall]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk434" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk434"><span class="kn">Definition</span> <span class="nf">phomotopy_postwhisker</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : pForall A P} {<span class="nv">p</span> <span class="nv">p&#39;</span> : f ==* g} (<span class="nv">r</span> : p ==* p&#39;) (<span class="nv">q</span> : g ==* h)
  : p @* q ==* p&#39; @* q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p ==* p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q ==* p&#39; @* q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk435" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk435"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p ==* p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q ==* p&#39; @* q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk436" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk436">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p ==* p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q == p&#39; @* q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk437" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p ==* p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><label class="goal-separator" for="core-v-chk437"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq (p @* q) @ (dpoint_eq (p&#39; @* q))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk438" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk438"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; whiskerR (r x) (q x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p ==* p&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; whiskerR (r x) (q x)) pt =
dpoint_eq (p @* q) @ (dpoint_eq (p&#39; @* q))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim q r p p&#39; f g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk439" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk439"><span class="kn">Definition</span> <span class="nf">phomotopy_prewhisker</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : pForall A P} (<span class="nv">p</span> : f ==* g) {<span class="nv">q</span> <span class="nv">q&#39;</span> : g ==* h} (<span class="nv">s</span> : q ==* q&#39;)
  : p @* q ==* p @* q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q ==* q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q ==* p @* q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q ==* q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q ==* p @* q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43b">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q ==* q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* q == p @* q&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk43c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q ==* q&#39;</span></span></span><br></div><label class="goal-separator" for="core-v-chk43c"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq (p @* q) @ (dpoint_eq (p @* q&#39;))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43d"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; whiskerL (p x) (s x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q, q'</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q ==* q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; whiskerL (p x) (s x)) pt =
dpoint_eq (p @* q) @ (dpoint_eq (p @* q&#39;))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim s q q&#39; p f g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43e"><span class="kn">Definition</span> <span class="nf">phomotopy_compose_assoc</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">k</span> : pForall A P} (<span class="nv">p</span> : f ==* g) (<span class="nv">q</span> : g ==* h) (<span class="nv">r</span> : h ==* k)
  : p @* (q @* r) ==* (p @* q) @* r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h, k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h ==* k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* (q @* r) ==* (p @* q) @* r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk43f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk43f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h, k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h ==* k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* (q @* r) ==* (p @* q) @* r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk440" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk440">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h, k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h ==* k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* (q @* r) == (p @* q) @* r</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk441" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h, k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h ==* k</span></span></span><br></div><label class="goal-separator" for="core-v-chk441"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (p @* (q @* r)) @
(dpoint_eq ((p @* q) @* r))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk442" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk442"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; concat_p_pp (p x) (q x) (r x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h, k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g ==* h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h ==* k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; concat_p_pp (p x) (q x) (r x)) pt =
dpoint_eq (p @* (q @* r)) @
(dpoint_eq ((p @* q) @* r))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim r q p f g h k.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk443" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk443"><span class="kn">Definition</span> <span class="nf">phomotopy_compose_p1</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
 (<span class="nv">p</span> : f ==* g) : p @* <span class="bp">reflexivity</span> g ==* p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* <span class="bp">reflexivity</span> g ==* p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk444" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk444"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* <span class="bp">reflexivity</span> g ==* p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk445" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk445">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* <span class="bp">reflexivity</span> g == p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk446" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk446"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (p @* <span class="bp">reflexivity</span> g) @ (dpoint_eq p)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk447" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk447"><span class="mi">1</span>: <span class="nb">intro</span>; <span class="nb">apply</span> concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; concat_p1 (p x))
 :
 p @* <span class="bp">reflexivity</span> g == p) pt =
dpoint_eq (p @* <span class="bp">reflexivity</span> g) @ (dpoint_eq p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk448" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk448"><span class="kn">Definition</span> <span class="nf">phomotopy_compose_1p</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
 (<span class="nv">p</span> : f ==* g) : <span class="bp">reflexivity</span> f @* p ==* p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">reflexivity</span> f @* p ==* p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk449" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk449"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">reflexivity</span> f @* p ==* p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44a">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">reflexivity</span> f @* p == p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk44b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk44b"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (<span class="bp">reflexivity</span> f @* p) @ (dpoint_eq p)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44c"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="nb">apply</span> concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; concat_1p (p x))
 :
 <span class="bp">reflexivity</span> f @* p == p) pt =
dpoint_eq (<span class="bp">reflexivity</span> f @* p) @ (dpoint_eq p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44d"><span class="kn">Definition</span> <span class="nf">phomotopy_compose_pV</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
 (<span class="nv">p</span> : f ==* g) : p @* p ^* ==* phomotopy_reflexive f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* p^* ==* phomotopy_reflexive f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* p^* ==* phomotopy_reflexive f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk44f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk44f">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* p^* == phomotopy_reflexive f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk450" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk450"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (p @* p^*) @
(dpoint_eq (phomotopy_reflexive f))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk451" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk451"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="nb">apply</span> concat_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; concat_pV (p x))
 :
 p @* p^* == phomotopy_reflexive f) pt =
dpoint_eq (p @* p^*) @
(dpoint_eq (phomotopy_reflexive f))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk452" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk452"><span class="kn">Definition</span> <span class="nf">phomotopy_compose_Vp</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
 (<span class="nv">p</span> : f ==* g) : p ^* @* p ==* phomotopy_reflexive g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p^* @* p ==* phomotopy_reflexive g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk453" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk453"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p^* @* p ==* phomotopy_reflexive g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk454" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk454">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p^* @* p == phomotopy_reflexive g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk455" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><label class="goal-separator" for="core-v-chk455"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (p^* @* p) @
(dpoint_eq (phomotopy_reflexive g))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk456" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk456"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="nb">apply</span> concat_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f ==* g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; concat_Vp (p x))
 :
 p^* @* p == phomotopy_reflexive g) pt =
dpoint_eq (p^* @* p) @
(dpoint_eq (phomotopy_reflexive g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The pointed category structure of [pType] *)</span>

<span class="sd">(** Pointed types of pointed maps *)</span>

<span class="sd">(** A family of pointed types gives rise to a [pFam]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pointed_fam</span> {<span class="nv">A</span> : pType} (<span class="nv">B</span> : A -&gt; pType) : pFam A
  := Build_pFam (pointed_type o B) (point (B (point A))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The section of a family of pointed types *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">point_pforall</span> {<span class="nv">A</span> : pType} (<span class="nv">B</span> : A -&gt; pType) : pForall A (pointed_fam B)
  := Build_pForall A (pointed_fam B) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; point (B x)) <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The pointed type of dependent pointed maps. Note that we need a family of pointed types, not just a family of types with a point over the basepoint of [A]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ppForall</span> (<span class="nv">A</span> : pType) (<span class="nv">B</span> : A -&gt; pType) : pType
  := [pForall A (pointed_fam B), point_pforall B].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;ppforall&#39;  x .. y , P&quot;</span>
  := (ppForall _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; .. (ppForall _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; P)) ..))
     : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The constant (zero) map *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pconst</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} : A -&gt;* B
  := point_pforall (<span class="kr">fun</span> <span class="nv">_</span> =&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The pointed type of pointed maps.  This is a special case of [ppForall]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ppMap</span> (<span class="nv">A</span> <span class="nv">B</span> : pType) : pType
  := [A -&gt;* B, pconst].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;-&gt;**&quot;</span> := ppMap : pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk457" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk457"><span class="kn">Lemma</span> <span class="nf">pmap_punit_pconst</span> {<span class="nv">A</span> : pType} (<span class="nv">f</span> : A -&gt;* pUnit) : pconst ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* pUnit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk458" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk458"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* pUnit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk459" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk459">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* pUnit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk45a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* pUnit</span></span></span><br></div><label class="goal-separator" for="core-v-chk45a"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq pconst @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk45b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk45b"><span class="mi">1</span>: <span class="nb">intro</span>; <span class="nb">apply</span> path_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* pUnit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; path_unit (pconst x) (f x))
 :
 pconst == f) pt = dpoint_eq pconst @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk45c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk45c"><span class="kn">Lemma</span> <span class="nf">punit_pmap_pconst</span> {<span class="nv">A</span> : pType} (<span class="nv">f</span> : pUnit -&gt;* A) : pconst ==* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pUnit -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk45d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk45d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pUnit -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk45e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk45e">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pUnit -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk45f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pUnit -&gt;* A</span></span></span><br></div><label class="goal-separator" for="core-v-chk45f"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq pconst @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk460" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk460"><span class="mi">1</span>: <span class="nb">intros</span> []; <span class="bp">exact</span> (point_eq f)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pUnit -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : pUnit =&gt;
  <span class="kr">match</span> x <span class="kr">as</span> u <span class="kr">return</span> (pconst u = f u) <span class="kr">with</span>
  | tt =&gt; (point_eq f)^
  <span class="kr">end</span>)
 :
 pconst == f) pt = dpoint_eq pconst @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_1p _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk461" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk461"><span class="kn">Instance</span> <span class="nf">contr_pmap_from_contr</span> `{Funext} {A B : pType} `{C : Contr A}
  : Contr (A -&gt;* B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A -&gt;* B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk462" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk462"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A -&gt;* B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk463" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk463">rapply (contr_equiv&#39; { b : B &amp; b = pt }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : B &amp; b = pt} &lt;~&gt; (A -&gt;* B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk464" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk464"><span class="nb">refine</span> (issig_pmap A B oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : B &amp; b = pt} &lt;~&gt; {f : A -&gt; B &amp; f pt = pt}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_functor_sigma_pb (equiv_arrow_from_contr A B)^-<span class="mi">1</span>%equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * [pType] and [pForall] as wild categories *)</span>

<span class="sd">(** Note that the definitions for [pForall] are also used for the higher structure in [pType]. *)</span>

<span class="sd">(** [pType] is a graph *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_ptype</span> : IsGraph pType
  := Build_IsGraph pType (<span class="kr">fun</span> <span class="nv">X</span> <span class="nv">Y</span> =&gt; X -&gt;* Y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] is a graph *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A)
  : IsGraph (pForall A P)
  := Build_IsGraph _ pHomotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] is a 0-coherent 1-category *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_ptype</span> : Is01Cat pType
  := Build_Is01Cat pType _ (@pmap_idmap) (@pmap_compose).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] is a 0-coherent 1-category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk465" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk465"><span class="kn">Instance</span> <span class="nf">is01cat_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A) : Is01Cat (pForall A P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is01Cat (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk466" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk466"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is01Cat (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk467" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk467"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pForall A P, a $-&gt; a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk468" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk468"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P,
(b $-&gt; c) -&gt; (a $-&gt; b) -&gt; a $-&gt; c</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk469" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk469">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pForall A P, a $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> phomotopy_reflexive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P,
(b $-&gt; c) -&gt; (a $-&gt; b) -&gt; a $-&gt; c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46b"><span class="nb">intros</span> a b c f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a $-&gt; c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (g @* f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_ptype</span> : Is2Graph pType := <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A)
  : Is2Graph (pForall A P)
  := <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] is a 0-coherent 1-groupoid *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46c"><span class="kn">Instance</span> <span class="nf">is0gpd_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A) : Is0Gpd (pForall A P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Gpd (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Gpd (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46e">srapply Build_Is0Gpd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pForall A P, (a $-&gt; b) -&gt; b $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk46f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk46f"><span class="nb">intros</span> ? ? h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h^*.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] is a 1-coherent 1-category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk470" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk470"><span class="kn">Instance</span> <span class="nf">is1cat_ptype</span> : Is1Cat pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk471" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk471"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk472" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk472">snapply Build_Is1Cat&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType, Is01Cat (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType, Is0Gpd (a $-&gt; b)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o g $o f $== h $o (g $o f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), Id b $o f $== f</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk473" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk473"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o g $o f $== h $o (g $o f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), Id b $o f $== f</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk474" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk474">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk475" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk475"><span class="nb">intros</span> A B C h; rapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A $-&gt; B,
(a $-&gt; b) -&gt; cat_postcomp A h a $-&gt; cat_postcomp A h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk476" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk476"><span class="nb">intros</span> f g p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* f ==* h o* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pmap_postwhisker; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk477" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk477">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk478" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk478"><span class="nb">intros</span> A B C h; rapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B $-&gt; C,
(a $-&gt; b) -&gt; cat_precomp C h a $-&gt; cat_precomp C h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk479" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk479"><span class="nb">intros</span> f g p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* h ==* g o* h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pmap_prewhisker; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o g $o f $== h $o (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? ? ? f g h; <span class="bp">exact</span> (pmap_compose_assoc h g f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), Id b $o f $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? f; <span class="bp">exact</span> (pmap_postcompose_idmap f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> : a $-&gt; b), f $o Id a $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? f; <span class="bp">exact</span> (pmap_precompose_idmap f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] is a pointed category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47d"><span class="kn">Instance</span> <span class="nf">ispointedcat_ptype</span> : IsPointedCat pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk47f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk47f">snapply Build_IsPointedCat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial <span class="nl">?zero_object</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal <span class="nl">?zero_object</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk480" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk480">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pUnit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk481" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk481">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial pUnit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk482" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk482"><span class="nb">intro</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pUnit $-&gt; A &amp; <span class="kr">forall</span> <span class="nv">g</span> : pUnit $-&gt; A, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk483" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk483"><span class="kr">exists</span> <span class="nv">pconst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : pUnit $-&gt; A, pconst $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> punit_pmap_pconst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk484" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk484">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal pUnit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk485" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk485"><span class="nb">intro</span> B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : B $-&gt; pUnit &amp; <span class="kr">forall</span> <span class="nv">g</span> : B $-&gt; pUnit, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk486" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk486"><span class="kr">exists</span> <span class="nv">pconst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : B $-&gt; pUnit, pconst $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pmap_punit_pconst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The constant map is definitionally equal to the zero_morphism of a pointed category *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_zero_morphism_pconst</span> (<span class="nv">A</span> <span class="nv">B</span> : pType)
  : (@pconst A B) = zero_morphism := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] is a 1-category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk487" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk487"><span class="kn">Instance</span> <span class="nf">is1cat_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A) : Is1Cat (pForall A P) | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk488" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk488"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk489" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk489">snapply Build_Is1Cat&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pForall A P, Is01Cat (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk48a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pForall A P, Is0Gpd (a $-&gt; b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk48b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk48c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk48d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk48e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk48f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk48f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk490" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk490"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk491" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk491"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk492" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk492"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk493" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk493"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk494" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk494"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk495" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk495">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk496" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk496"><span class="nb">intros</span> f g h p; rapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : f $-&gt; g,
(a $-&gt; b) -&gt; cat_postcomp f p a $-&gt; cat_postcomp f p b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk497" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk497"><span class="nb">intros</span> q r s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q $-&gt; r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_postcomp f p q $-&gt; cat_postcomp f p r</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (phomotopy_postwhisker s p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk498" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk498">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk499" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk499"><span class="nb">intros</span> f g h p; rapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : g $-&gt; h,
(a $-&gt; b) -&gt; cat_precomp h p a $-&gt; cat_precomp h p b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49a"><span class="nb">intros</span> q r s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br><span><var>q, r</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>q $-&gt; r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_precomp h p q $-&gt; cat_precomp h p r</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (phomotopy_prewhisker p s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49c"><span class="nb">intros</span> ? ? ? ? p q r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>c $-&gt; d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r $o q $o p $== r $o (q $o p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>c $-&gt; d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @* (q @* r) ==* (p @* q) @* r</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (phomotopy_compose_assoc p q r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? p; <span class="bp">exact</span> (phomotopy_compose_p1 p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk49f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk49f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? p; <span class="bp">exact</span> (phomotopy_compose_1p p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pForall] is a 1-groupoid *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a0"><span class="kn">Instance</span> <span class="nf">is1gpd_pforall</span> (<span class="nv">A</span> : pType) (<span class="nv">P</span> : pFam A) : Is1Gpd (pForall A P) | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Gpd (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Gpd (pForall A P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a2"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f^$ $o f $== Id a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk4a3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f $o f^$ $== Id b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f^$ $o f $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a5"><span class="nb">intros</span> ? ? p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p^$ $o p $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (phomotopy_compose_pV p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pForall A P) (<span class="nv">f</span> : a $-&gt; b),
f $o f^$ $== Id b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a7"><span class="nb">intros</span> ? ? p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p $o p^$ $== Id b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (phomotopy_compose_Vp p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is3graph_ptype</span> : Is3Graph pType
  := <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; is2graph_pforall _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a8"><span class="kn">Instance</span> <span class="nf">is21cat_ptype</span> : Is21Cat pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is21Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4a9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4a9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is21Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4aa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4aa"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType, Is1Gpd (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">g</span> : b $-&gt; c),
Is1Functor (cat_postcomp a g)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b),
Is1Functor (cat_precomp c f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> <span class="nv">f&#39;</span> : a $-&gt; b)
(<span class="nv">g</span> <span class="nv">g&#39;</span> : b $-&gt; c) (<span class="nv">p</span> : f $== f&#39;) (<span class="nv">p&#39;</span> : g $== g&#39;),
(p&#39; $@R f) $@ (g&#39; $@L p) $== (g $@L p) $@ (p&#39; $@R f&#39;)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : c $-&gt; d =&gt;
   cat_precomp d f (cat_precomp d g x))
  (cat_precomp d (g $o f)) (cat_assoc f g)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">h</span> : c $-&gt; d),
Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : b $-&gt; c =&gt;
   cat_precomp d f (cat_postcomp b h x))
  (<span class="kr">fun</span> <span class="nv">x</span> : b $-&gt; c =&gt;
   cat_postcomp a h (cat_precomp c f x))
  (<span class="kr">fun</span> <span class="nv">g</span> : b $-&gt; c =&gt; cat_assoc f g h)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
Is1Natural (cat_postcomp a (h $o g))
  (<span class="kr">fun</span> <span class="nv">x</span> : a $-&gt; b =&gt;
   cat_postcomp a h (cat_postcomp a g x))
  (<span class="kr">fun</span> <span class="nv">f</span> : a $-&gt; b =&gt; cat_assoc f g h)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType,
Is1Natural (cat_postcomp a (Id b)) idmap cat_idl</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType,
Is1Natural (cat_precomp b (Id a)) idmap cat_idr</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d) (<span class="nv">k</span> : d $-&gt; e),
k $@L cat_assoc f g h $o cat_assoc f (h $o g) k $o
cat_assoc g h k $@R f $==
cat_assoc (g $o f) h k $o cat_assoc f g (k $o h)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
g $@L cat_idl f $o cat_assoc f (Id b) g $==
cat_idr g $@R f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ab" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType, Is1Gpd (a $-&gt; b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ac" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ac">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">g</span> : b $-&gt; c),
Is1Functor (cat_postcomp a g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ad" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ad"><span class="nb">intros</span> A B C f; napply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A $-&gt; B) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (cat_postcomp A f) f0 $==
fmap (cat_postcomp A f) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="core-v-chk4ae"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A $-&gt; B,
fmap (cat_postcomp A f) (Id a) $==
Id (cat_postcomp A f a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk4af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="core-v-chk4af"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A $-&gt; B) (<span class="nv">f0</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (cat_postcomp A f) (g $o f0) $==
fmap (cat_postcomp A f) g $o
fmap (cat_postcomp A f) f0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A $-&gt; B) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (cat_postcomp A f) f0 $==
fmap (cat_postcomp A f) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b1"><span class="nb">intros</span> g h p q r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) p $==
fmap (cat_postcomp A f) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b2">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) p == fmap (cat_postcomp A f) q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><label class="goal-separator" for="core-v-chk4b3"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_postcomp A f) p) @
(dpoint_eq (fmap (cat_postcomp A f) q))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b4"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; ap _ (r _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ap (ap f) (r x)) pt =
dpoint_eq (fmap (cat_postcomp A f) p) @
(dpoint_eq (fmap (cat_postcomp A f) q))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim r p q g h f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A $-&gt; B,
fmap (cat_postcomp A f) (Id a) $==
Id (cat_postcomp A f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b6"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) (Id g) $==
Id (cat_postcomp A f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b7">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) (Id g) ==
Id (cat_postcomp A f g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="core-v-chk4b8"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_postcomp A f) (Id g)) @
(dpoint_eq (Id (cat_postcomp A f g)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4b9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4b9"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (fmap (cat_postcomp A f) (Id g)) @
(dpoint_eq (Id (cat_postcomp A f g)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim g f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ba" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ba">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A $-&gt; B) (<span class="nv">f0</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (cat_postcomp A f) (g $o f0) $==
fmap (cat_postcomp A f) g $o
fmap (cat_postcomp A f) f0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4bb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4bb"><span class="nb">intros</span> g h i p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) (q $o p) $==
fmap (cat_postcomp A f) q $o fmap (cat_postcomp A f) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4bc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4bc">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_postcomp A f) (q $o p) ==
fmap (cat_postcomp A f) q $o fmap (cat_postcomp A f) p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><label class="goal-separator" for="core-v-chk4bd"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_postcomp A f) (q $o p)) @
(dpoint_eq
   (fmap (cat_postcomp A f) q $o
    fmap (cat_postcomp A f) p))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4be" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4be"><span class="mi">1</span>: <span class="nb">cbn</span>; <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; ap_pp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ap_pp f (p x) (q x))
 :
 fmap (cat_postcomp A f) (q $o p) ==
 fmap (cat_postcomp A f) q $o
 fmap (cat_postcomp A f) p) pt =
dpoint_eq (fmap (cat_postcomp A f) (q $o p)) @
(dpoint_eq
   (fmap (cat_postcomp A f) q $o
    fmap (cat_postcomp A f) p))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p q g h i f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4bf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b),
Is1Functor (cat_precomp c f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c0"><span class="nb">intros</span> A B C f; napply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : B $-&gt; C) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (cat_precomp C f) f0 $== fmap (cat_precomp C f) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="core-v-chk4c1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : B $-&gt; C,
fmap (cat_precomp C f) (Id a) $==
Id (cat_precomp C f a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk4c2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="core-v-chk4c2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : B $-&gt; C) (<span class="nv">f0</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (cat_precomp C f) (g $o f0) $==
fmap (cat_precomp C f) g $o fmap (cat_precomp C f) f0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : B $-&gt; C) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (cat_precomp C f) f0 $== fmap (cat_precomp C f) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c4"><span class="nb">intros</span> g h p q r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) p $== fmap (cat_precomp C f) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c5">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) p == fmap (cat_precomp C f) q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><label class="goal-separator" for="core-v-chk4c6"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_precomp C f) p) @
(dpoint_eq (fmap (cat_precomp C f) q))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c7"><span class="mi">1</span>: <span class="nb">intro</span>; <span class="bp">exact</span> (r _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (f x))
 :
 fmap (cat_precomp C f) p == fmap (cat_precomp C f) q)
  pt =
dpoint_eq (fmap (cat_precomp C f) p) @
(dpoint_eq (fmap (cat_precomp C f) q))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f r p q g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : B $-&gt; C,
fmap (cat_precomp C f) (Id a) $==
Id (cat_precomp C f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4c9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4c9"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) (Id g) $==
Id (cat_precomp C f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ca" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ca">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) (Id g) ==
Id (cat_precomp C f g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="core-v-chk4cb"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_precomp C f) (Id g)) @
(dpoint_eq (Id (cat_precomp C f g)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4cc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4cc"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (fmap (cat_precomp C f) (Id g)) @
(dpoint_eq (Id (cat_precomp C f g)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4cd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4cd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : B $-&gt; C) (<span class="nv">f0</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (cat_precomp C f) (g $o f0) $==
fmap (cat_precomp C f) g $o fmap (cat_precomp C f) f0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ce" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ce"><span class="nb">intros</span> g h i p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) (q $o p) $==
fmap (cat_precomp C f) q $o fmap (cat_precomp C f) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4cf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4cf">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (cat_precomp C f) (q $o p) ==
fmap (cat_precomp C f) q $o fmap (cat_precomp C f) p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><label class="goal-separator" for="core-v-chk4d0"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap (cat_precomp C f) (q $o p)) @
(dpoint_eq
   (fmap (cat_precomp C f) q $o
    fmap (cat_precomp C f) p))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d1"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g, h, i</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $-&gt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (fmap (cat_precomp C f) (q $o p)) @
(dpoint_eq
   (fmap (cat_precomp C f) q $o
    fmap (cat_precomp C f) p))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f p q i g h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> <span class="nv">f&#39;</span> : a $-&gt; b)
(<span class="nv">g</span> <span class="nv">g&#39;</span> : b $-&gt; c) (<span class="nv">p</span> : f $== f&#39;) (<span class="nv">p&#39;</span> : g $== g&#39;),
(p&#39; $@R f) $@ (g&#39; $@L p) $== (g $@L p) $@ (p&#39; $@R f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d3"><span class="nb">intros</span> A B C f g h k p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $@R f) $@ (k $@L p) $== (h $@L p) $@ (q $@R g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d4">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $@R f) $@ (k $@L p) == (h $@L p) $@ (q $@R g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br></div><label class="goal-separator" for="core-v-chk4d5"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq ((q $@R f) $@ (k $@L p)) @
(dpoint_eq ((h $@L p) $@ (q $@R g)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q $@R f) $@ (k $@L p) == (h $@L p) $@ (q $@R g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d7"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((q $@R f) $@ (k $@L p)) x =
((h $@L p) $@ (q $@R g)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_Ap q _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (concat_Ap q (p x))^)
 :
 (q $@R f) $@ (k $@L p) == (h $@L p) $@ (q $@R g)) pt =
dpoint_eq ((q $@R f) $@ (k $@L p)) @
(dpoint_eq ((h $@L p) $@ (q $@R g)))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p f g q h k.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4d9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : c $-&gt; d =&gt;
   cat_precomp d f (cat_precomp d g x))
  (cat_precomp d (g $o f)) (cat_assoc f g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4da" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4da"><span class="nb">intros</span> A B C D f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : C $-&gt; D =&gt;
   cat_precomp D f (cat_precomp D g x))
  (cat_precomp D (g $o f)) (cat_assoc f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4db" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4db">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : C $-&gt; D) (<span class="nv">f0</span> : a $-&gt; a&#39;),
cat_assoc f g a&#39; $o
fmap (cat_precomp D f o cat_precomp D g) f0 $==
fmap (cat_precomp D (g $o f)) f0 $o cat_assoc f g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4dc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4dc"><span class="nb">intros</span> r1 r2 s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_assoc f g r2 $o
fmap (cat_precomp D f o cat_precomp D g) s1 $==
fmap (cat_precomp D (g $o f)) s1 $o cat_assoc f g r1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4dd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4dd">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_assoc f g r2 $o
fmap (cat_precomp D f o cat_precomp D g) s1 ==
fmap (cat_precomp D (g $o f)) s1 $o cat_assoc f g r1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4de" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><label class="goal-separator" for="core-v-chk4de"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (cat_assoc f g r2 $o
   fmap (cat_precomp D f o cat_precomp D g) s1) @
(dpoint_eq
   (fmap (cat_precomp D (g $o f)) s1 $o
    cat_assoc f g r1))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4df" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4df"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; concat_p1 _ @ (concat_1p _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 concat_p1
   (fmap (cat_precomp D f o cat_precomp D g) s1 x) @
 (concat_1p
    (fmap (cat_precomp D f o cat_precomp D g) s1 x))^)
  pt =
dpoint_eq
  (cat_assoc f g r2 $o
   fmap (cat_precomp D f o cat_precomp D g) s1) @
(dpoint_eq
   (fmap (cat_precomp D (g $o f)) s1 $o
    cat_assoc f g r1))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f g s1 r1 r2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">h</span> : c $-&gt; d),
Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : b $-&gt; c =&gt;
   cat_precomp d f (cat_postcomp b h x))
  (<span class="kr">fun</span> <span class="nv">x</span> : b $-&gt; c =&gt;
   cat_postcomp a h (cat_precomp c f x))
  (<span class="kr">fun</span> <span class="nv">g</span> : b $-&gt; c =&gt; cat_assoc f g h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e1"><span class="nb">intros</span> A B C D f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural
  (<span class="kr">fun</span> <span class="nv">x</span> : B $-&gt; C =&gt;
   cat_precomp D f (cat_postcomp B g x))
  (<span class="kr">fun</span> <span class="nv">x</span> : B $-&gt; C =&gt;
   cat_postcomp A g (cat_precomp C f x))
  (<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e2">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : B $-&gt; C) (<span class="nv">f0</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) a&#39; $o
fmap (cat_precomp D f o cat_postcomp B g) f0 $==
fmap (cat_postcomp A g o cat_precomp C f) f0 $o
(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e3"><span class="nb">intros</span> r1 r2 s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r2 $o
fmap (cat_precomp D f o cat_postcomp B g) s1 $==
fmap (cat_postcomp A g o cat_precomp C f) s1 $o
(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e4">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r2 $o
fmap (cat_precomp D f o cat_postcomp B g) s1 ==
fmap (cat_postcomp A g o cat_precomp C f) s1 $o
(<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><label class="goal-separator" for="core-v-chk4e5"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  ((<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r2 $o
   fmap (cat_precomp D f o cat_postcomp B g) s1) @
(dpoint_eq
   (fmap (cat_postcomp A g o cat_precomp C f) s1 $o
    (<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r1))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e6"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; concat_p1 _ @ (concat_1p _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 concat_p1
   (fmap (cat_precomp D f o cat_postcomp B g) s1 x) @
 (concat_1p
    (fmap (cat_precomp D f o cat_postcomp B g) s1 x))^)
  pt =
dpoint_eq
  ((<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r2 $o
   fmap (cat_precomp D f o cat_postcomp B g) s1) @
(dpoint_eq
   (fmap (cat_postcomp A g o cat_precomp C f) s1 $o
    (<span class="kr">fun</span> <span class="nv">g0</span> : B $-&gt; C =&gt; cat_assoc f g0 g) r1))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f s1 r1 r2 g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : pType) (<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
Is1Natural (cat_postcomp a (h $o g))
  (<span class="kr">fun</span> <span class="nv">x</span> : a $-&gt; b =&gt;
   cat_postcomp a h (cat_postcomp a g x))
  (<span class="kr">fun</span> <span class="nv">f</span> : a $-&gt; b =&gt; cat_assoc f g h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e8"><span class="nb">intros</span> A B C D f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (cat_postcomp A (g $o f))
  (<span class="kr">fun</span> <span class="nv">x</span> : A $-&gt; B =&gt;
   cat_postcomp A g (cat_postcomp A f x))
  (<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4e9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4e9">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A $-&gt; B) (<span class="nv">f0</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">f1</span> : A $-&gt; B =&gt; cat_assoc f1 f g) a&#39; $o
fmap (cat_postcomp A (g $o f)) f0 $==
fmap (cat_postcomp A g o cat_postcomp A f) f0 $o
(<span class="kr">fun</span> <span class="nv">f1</span> : A $-&gt; B =&gt; cat_assoc f1 f g) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ea" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ea"><span class="nb">intros</span> r1 r2 s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r2 $o
fmap (cat_postcomp A (g $o f)) s1 $==
fmap (cat_postcomp A g o cat_postcomp A f) s1 $o
(<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4eb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4eb">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r2 $o
fmap (cat_postcomp A (g $o f)) s1 ==
fmap (cat_postcomp A g o cat_postcomp A f) s1 $o
(<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><label class="goal-separator" for="core-v-chk4ec"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  ((<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r2 $o
   fmap (cat_postcomp A (g $o f)) s1) @
(dpoint_eq
   (fmap (cat_postcomp A g o cat_postcomp A f) s1 $o
    (<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r1))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ed" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ed"><span class="mi">1</span>: <span class="nb">cbn</span>; <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; concat_p1 _ @ ap_compose _ _ _ @ (concat_1p _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
  (concat_p1 (ap (g o f) (s1 x)) @
   ap_compose f g (s1 x)) @
  (concat_1p (ap g (ap f (s1 x))))^)
 :
 (<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r2 $o
 fmap (cat_postcomp A (g $o f)) s1 ==
 fmap (cat_postcomp A g o cat_postcomp A f) s1 $o
 (<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r1) pt =
dpoint_eq
  ((<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r2 $o
   fmap (cat_postcomp A (g $o f)) s1) @
(dpoint_eq
   (fmap (cat_postcomp A g o cat_postcomp A f) s1 $o
    (<span class="kr">fun</span> <span class="nv">f0</span> : A $-&gt; B =&gt; cat_assoc f0 f g) r1))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim s1 r1 r2 f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ee" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType,
Is1Natural (cat_postcomp a (Id b)) idmap cat_idl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4ef" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4ef"><span class="nb">intros</span> A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (cat_postcomp A (Id B)) idmap cat_idl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f0">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A $-&gt; B) (<span class="nv">f</span> : a $-&gt; a&#39;),
cat_idl a&#39; $o fmap (cat_postcomp A (Id B)) f $==
fmap idmap f $o cat_idl a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f1"><span class="nb">intros</span> r1 r2 s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_idl r2 $o fmap (cat_postcomp A (Id B)) s1 $==
fmap idmap s1 $o cat_idl r1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f2">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_idl r2 $o fmap (cat_postcomp A (Id B)) s1 ==
fmap idmap s1 $o cat_idl r1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4f3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><label class="goal-separator" for="core-v-chk4f3"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (cat_idl r2 $o fmap (cat_postcomp A (Id B)) s1) @
(dpoint_eq (fmap idmap s1 $o cat_idl r1))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f4"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; concat_p1 _ @ ap_idmap _ @ (concat_1p _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 (concat_p1 (ap idmap (s1 x)) @ ap_idmap (s1 x)) @
 (concat_1p (s1 x))^) pt =
dpoint_eq
  (cat_idl r2 $o fmap (cat_postcomp A (Id B)) s1) @
(dpoint_eq (fmap idmap s1 $o cat_idl r1))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim s1 r1 r2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType,
Is1Natural (cat_precomp b (Id a)) idmap cat_idr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f6"><span class="nb">intros</span> A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (cat_precomp B (Id A)) idmap cat_idr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f7">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A $-&gt; B) (<span class="nv">f</span> : a $-&gt; a&#39;),
cat_idr a&#39; $o fmap (cat_precomp B (Id A)) f $==
fmap idmap f $o cat_idr a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f8"><span class="nb">intros</span> r1 r2 s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_idr r2 $o fmap (cat_precomp B (Id A)) s1 $==
fmap idmap s1 $o cat_idr r1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4f9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4f9">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_idr r2 $o fmap (cat_precomp B (Id A)) s1 ==
fmap idmap s1 $o cat_idr r1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><label class="goal-separator" for="core-v-chk4fa"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (cat_idr r2 $o fmap (cat_precomp B (Id A)) s1) @
(dpoint_eq (fmap idmap s1 $o cat_idr r1))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4fb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4fb"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; concat_p1 _ @ (concat_1p _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>r1 $-&gt; r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 concat_p1 (fmap (cat_precomp B (Id A)) s1 x) @
 (concat_1p (fmap (cat_precomp B (Id A)) s1 x))^) pt =
dpoint_eq
  (cat_idr r2 $o fmap (cat_precomp B (Id A)) s1) @
(dpoint_eq (fmap idmap s1 $o cat_idr r1))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">by</span> pelim s1 r1 r2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4fc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4fc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d) (<span class="nv">k</span> : d $-&gt; e),
k $@L cat_assoc f g h $o cat_assoc f (h $o g) k $o
cat_assoc g h k $@R f $==
cat_assoc (g $o f) h k $o cat_assoc f g (k $o h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4fd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4fd"><span class="nb">intros</span> A B C D E f g h j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D $-&gt; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j $@L cat_assoc f g h $o cat_assoc f (h $o g) j $o
cat_assoc g h j $@R f $==
cat_assoc (g $o f) h j $o cat_assoc f g (j $o h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk4fe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk4fe">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D $-&gt; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j $@L cat_assoc f g h $o cat_assoc f (h $o g) j $o
cat_assoc g h j $@R f ==
cat_assoc (g $o f) h j $o cat_assoc f g (j $o h)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk4ff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D $-&gt; E</span></span></span><br></div><label class="goal-separator" for="core-v-chk4ff"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (j $@L cat_assoc f g h $o cat_assoc f (h $o g) j $o
   cat_assoc g h j $@R f) @
(dpoint_eq
   (cat_assoc (g $o f) h j $o cat_assoc f g (j $o h)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk500" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk500"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, E</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; D</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D $-&gt; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq
  (j $@L cat_assoc f g h $o cat_assoc f (h $o g) j $o
   cat_assoc g h j $@R f) @
(dpoint_eq
   (cat_assoc (g $o f) h j $o cat_assoc f g (j $o h)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f g h j.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk501" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk501">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
g $@L cat_idl f $o cat_assoc f (Id b) g $==
cat_idr g $@R f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk502" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk502"><span class="nb">intros</span> A B C f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $@L cat_idl f $o cat_assoc f (Id B) g $==
cat_idr g $@R f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk503" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk503">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $@L cat_idl f $o cat_assoc f (Id B) g ==
cat_idr g $@R f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk504" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="core-v-chk504"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (g $@L cat_idl f $o cat_assoc f (Id B) g) @
(dpoint_eq (cat_idr g $@R f))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk505" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk505"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) pt =
dpoint_eq (g $@L cat_idl f $o cat_assoc f (Id B) g) @
(dpoint_eq (cat_idr g $@R f))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The forgetful map from [pType] to [Type] is a 0-functor *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk506" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk506"><span class="kn">Instance</span> <span class="nf">is0functor_pointed_type</span> : Is0Functor pointed_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor pointed_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk507" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk507"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor pointed_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk508" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk508"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType, (a $-&gt; b) -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk509" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk509"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The forgetful map from [pType] to [Type] is a 1-functor *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50a"><span class="kn">Instance</span> <span class="nf">is1functor_pointed_type</span> : Is1Functor pointed_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor pointed_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor pointed_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50c"><span class="nb">apply</span> Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap pointed_type f $== fmap pointed_type g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pType, fmap pointed_type (Id a) $== Id a</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap pointed_type (g $o f) $==
fmap pointed_type g $o fmap pointed_type f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap pointed_type f $== fmap pointed_type g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50e"><span class="nb">intros</span> ? ? ? ? h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap pointed_type f $== fmap pointed_type g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk50f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk50f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pType, fmap pointed_type (Id a) $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk510" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk510"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap pointed_type (Id a) $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk511" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk511">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap pointed_type (g $o f) $==
fmap pointed_type g $o fmap pointed_type f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk512" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk512"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap pointed_type (g $o f) $==
fmap pointed_type g $o fmap pointed_type f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] has binary products *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk513" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk513"><span class="kn">Instance</span> <span class="nf">hasbinaryproducts_ptype</span> : HasBinaryProducts pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk514" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk514"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk515" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk515"><span class="nb">intros</span> X Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BinaryProduct X Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk516" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk516">snapply Build_BinaryProduct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk517" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk517"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; X</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk518" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk518"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; Y</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk519" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk519"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : pType,
(z $-&gt; X) -&gt; (z $-&gt; Y) -&gt; z $-&gt; <span class="nl">?cat_binprod&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk51a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk51a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : z $-&gt; X) (<span class="nv">g</span> : z $-&gt; Y),
<span class="nl">?cat_pr1</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk51b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk51b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : z $-&gt; X) (<span class="nv">g</span> : z $-&gt; Y),
<span class="nl">?cat_pr2</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== g</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk51c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk51c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; <span class="nl">?cat_binprod&#39;</span>),
<span class="nl">?cat_pr1</span> $o f $== <span class="nl">?cat_pr1</span> $o g -&gt;
<span class="nl">?cat_pr2</span> $o f $== <span class="nl">?cat_pr2</span> $o g -&gt; f $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk51d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk51d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (X * Y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk51e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk51e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Y $-&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pfst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk51f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk51f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Y $-&gt; Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> psnd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk520" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk520">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : pType,
(z $-&gt; X) -&gt; (z $-&gt; Y) -&gt; z $-&gt; X * Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pprod_corec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk521" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk521">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : z $-&gt; X) (<span class="nv">g</span> : z $-&gt; Y),
pfst $o pprod_corec z f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pprod_corec_beta_fst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk522" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk522">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : z $-&gt; X) (<span class="nv">g</span> : z $-&gt; Y),
psnd $o pprod_corec z f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pprod_corec_beta_snd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk523" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk523">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; X * Y),
pfst $o f $== pfst $o g -&gt;
psnd $o f $== psnd $o g -&gt; f $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk524" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk524"><span class="nb">intros</span> Z f g p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk525" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk525"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk526" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk526">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk527" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><label class="goal-separator" for="core-v-chk527"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk528" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk528">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk529" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk529"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52a"><span class="nb">apply</span> path_prod&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (f a) = fst (g a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk52b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><label class="goal-separator" for="core-v-chk52b"><hr></label><div class="goal-conclusion">snd (f a) = snd (g a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (f a) = fst (g a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (f a) = snd (g a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q a).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">a</span> : Z =&gt;
  path_prod&#39; (p a : fst (f a) = fst (g a))
    (q a : snd (f a) = snd (g a)))
 :
 f == g) pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk52f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk52f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; X * Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pfst $o f $== pfst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>psnd $o f $== psnd $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod&#39; (p pt) (q pt) =
dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pelim p q f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] has I-indexed product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk530" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk530"><span class="kn">Instance</span> <span class="nf">hasallproducts_ptype</span> `{Funext} : HasAllProducts pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasAllProducts pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk531" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk531"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasAllProducts pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk532" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk532"><span class="nb">intros</span> I x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Product I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk533" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk533">snapply Build_Product.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk534" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk534"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : I, <span class="nl">?cat_prod</span> $-&gt; x i</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk535" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk535"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : pType,
(<span class="kr">forall</span> <span class="nv">i</span> : I, z $-&gt; x i) -&gt; z $-&gt; <span class="nl">?cat_prod</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk536" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk536"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">i</span> : I, z $-&gt; x i)
(<span class="nv">i</span> : I), <span class="nl">?cat_pr</span> i $o <span class="nl">?cat_prod_corec</span> z f $== f i</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk537" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk537"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; <span class="nl">?cat_prod</span>),
(<span class="kr">forall</span> <span class="nv">i</span> : I, <span class="nl">?cat_pr</span> i $o f $== <span class="nl">?cat_pr</span> i $o g) -&gt;
f $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk538" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk538">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pType</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pproduct x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk539" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk539">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : I, pproduct x $-&gt; x i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pproduct_proj.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : pType,
(<span class="kr">forall</span> <span class="nv">i</span> : I, z $-&gt; x i) -&gt; z $-&gt; pproduct x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pproduct_corec x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">i</span> : I, z $-&gt; x i)
(<span class="nv">i</span> : I),
pproduct_proj i $o pproduct_corec x z f $== f i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53c"><span class="nb">intros</span> Z f i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct_proj i $o pproduct_corec x Z f $== f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53d">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pproduct_proj i $o pproduct_corec x Z f == f i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk53e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><label class="goal-separator" for="core-v-chk53e"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (pproduct_proj i $o pproduct_corec x Z f) @
(dpoint_eq (f i))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk53f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk53f"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Z =&gt; <span class="mi">1</span>) pt =
dpoint_eq (pproduct_proj i $o pproduct_corec x Z f) @
(dpoint_eq (f i))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk540" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk540"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq (f i) =
dpoint_eq (pproduct_proj i $o pproduct_corec x Z f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk541" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk541"><span class="nb">apply</span> equiv_1p_q1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I, Z $-&gt; x i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint_eq (f i) =
ap (pproduct_proj i) (point_eq (pproduct_corec x Z f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD10_path_forall _ _ (<span class="kr">fun</span> <span class="nv">a</span> =&gt; point_eq (f a)) i)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk542" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk542">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; pproduct x),
(<span class="kr">forall</span> <span class="nv">i</span> : I,
 pproduct_proj i $o f $== pproduct_proj i $o g) -&gt;
f $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk543" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk543"><span class="nb">intros</span> Z f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk544" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk544">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk545" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br></div><label class="goal-separator" for="core-v-chk545"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk546" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk546"><span class="mi">1</span>: <span class="nb">intros</span> z; funext i; <span class="nb">apply</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">z</span> : Z =&gt;
  path_forall (f z) (g z)
    ((<span class="kr">fun</span> <span class="nv">i</span> : I =&gt;
      <span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">i0</span> : I =&gt; pointed_fun (p i0) <span class="kr">in</span>
      X i z)
     :
     f z == g z))
 :
 f == g) pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk547" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk547"><span class="nb">cbn</span>; <span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">i</span> : I =&gt; p i pt) =
apD10 (dpoint_eq f @ (dpoint_eq g)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk548" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk548">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p i pt = apD10 (dpoint_eq f @ (dpoint_eq g)^) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk549" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk549">rhs napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p i pt =
ap (pproduct_proj i) (dpoint_eq f) @
ap (pproduct_proj i) (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54a">lhs <span class="bp">exact</span> (dpoint_eq (p i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dpoint
  (pfam_phomotopy (pproduct_proj i $o f)
     (pproduct_proj i $o g)) =
ap (pproduct_proj i) (dpoint_eq f) @
ap (pproduct_proj i) (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54b"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq f) @ <span class="mi">1</span> =
ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk54c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><label class="goal-separator" for="core-v-chk54c"><hr></label><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq g) @
 <span class="mi">1</span>)^ =
ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq g)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq f) @ <span class="mi">1</span> =
ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq g) @
 <span class="mi">1</span>)^ =
ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk54f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk54f">rhs napply (ap_V _ (dpoint_eq g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq g) @
 <span class="mi">1</span>)^ =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk550" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk550"><span class="nb">apply</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>I -&gt; pType</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Z $-&gt; pproduct x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : I,
pproduct_proj i $o f $== pproduct_proj i $o g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (point_eq g) @ <span class="mi">1</span> =
ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">a</span> : I, x a =&gt; x i) (dpoint_eq g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Some higher homotopies *)</span>

<span class="sd">(** Horizontal composition of homotopies. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p @@* q&quot;</span> := (p $@@ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Funext for pointed types and direct consequences. *)</span>

<span class="sd">(** By funext pointed homotopies are equivalent to paths *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk551" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk551"><span class="kn">Definition</span> <span class="nf">equiv_path_pforall</span> `{Funext} {A : pType}
  {P : pFam A} (f g : pForall A P)
  : (f ==* g) &lt;~&gt; (f = g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk552" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk552"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk553" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk553"><span class="nb">refine</span> (_ oE (issig_phomotopy f g)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == g &amp; p pt = dpoint_eq f @ (dpoint_eq g)^} &lt;~&gt;
f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk554" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk554"><span class="nb">revert</span> f g; <span class="nb">apply</span> (equiv_path_issig_contr (issig_pforall A P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P},
{p : issig_pforall A P b == issig_pforall A P b &amp;
p pt =
dpoint_eq (issig_pforall A P b) @
(dpoint_eq (issig_pforall A P b))^}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk555" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><label class="goal-separator" for="core-v-chk555"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b1</span> : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P},
Contr
  {b2 : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P} &amp;
  {p : issig_pforall A P b1 == issig_pforall A P b2 &amp;
  p pt =
  dpoint_eq (issig_pforall A P b1) @
  (dpoint_eq (issig_pforall A P b2))^}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk556" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk556">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P},
{p : issig_pforall A P b == issig_pforall A P b &amp;
p pt =
dpoint_eq (issig_pforall A P b) @
(dpoint_eq (issig_pforall A P b))^}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk557" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk557"><span class="nb">intros</span> [f feq]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == f &amp; p pt = feq @ feq^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk558" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk558"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>%path).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = feq @ feq^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_pV _)^.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk559" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk559">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b1</span> : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P},
Contr
  {b2 : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P} &amp;
  {p : issig_pforall A P b1 == issig_pforall A P b2 &amp;
  p pt =
  dpoint_eq (issig_pforall A P b1) @
  (dpoint_eq (issig_pforall A P b2))^}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55a"><span class="nb">intros</span> [f feq]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {b2 : {f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp; f pt = dpoint P} &amp;
  {p : f == b2.<span class="mi">1</span> &amp; p pt = feq @ (b2.<span class="mi">2</span>)^}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55b">contr_sigsig f (<span class="kr">fun</span> <span class="nv">a</span>:A =&gt; idpath (f a)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {y : f pt = dpoint P &amp; <span class="mi">1</span> = feq @ y^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55c"><span class="nb">refine</span> (contr_equiv&#39; {feq&#39; : f (point A) = dpoint P &amp; feq = feq&#39;} _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{feq&#39; : f pt = dpoint P &amp; feq = feq&#39;} &lt;~&gt;
{y : f pt = dpoint P &amp; <span class="mi">1</span> = feq @ y^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55d"><span class="nb">refine</span> (equiv_functor_sigma&#39; (equiv_idmap _) _); <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq, p</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">feq = p &lt;~&gt; <span class="mi">1</span> = feq @ (<span class="mi">1</span>%equiv p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55e"><span class="nb">refine</span> (_^-<span class="mi">1</span> oE equiv_path_inverse _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>feq, p</var><span class="hyp-type"><b>: </b><span>f pt = dpoint P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = feq @ (<span class="mi">1</span>%equiv p)^ &lt;~&gt; p = feq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_moveR_1M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_pforall</span> `{Funext} {A : pType} {P : pFam A} {f g : pForall A P}
  : (f ==* g) -&gt; (f = g) := equiv_path_pforall f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We note that the inverse of [path_pforall] computes definitionally on reflexivity, and hence [path_pforall] itself computes typally so. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_inverse_path_pforall_1</span> `{Funext} {A : pType} {P : pFam A} (f : pForall A P)
  : (equiv_path_pforall f f)^-<span class="mi">1</span>%equiv <span class="mi">1</span>%path = <span class="bp">reflexivity</span> f
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_pforall_1</span> `{Funext} {A : pType} {P : pFam A} {f : pForall A P}
  : equiv_path_pforall _ _ (<span class="bp">reflexivity</span> f) = <span class="mi">1</span>%path
  := moveR_equiv_M _ _ (equiv_inverse_path_pforall_1 f)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here is the inverse map without assuming funext *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">phomotopy_path</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A} {<span class="nv">f</span> <span class="nv">g</span> : pForall A P}
  : (f = g) -&gt; (f ==* g) := <span class="kp">ltac</span>:(<span class="bp">by</span> <span class="nb">intros</span> []).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And we prove that it agrees with the inverse of [equiv_path_pforall] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_equiv_path_pforall_phomotopy_path</span> `{Funext} {A : pType}
  {P : pFam A} {f g : pForall A P}
  : phomotopy_path (f:=f) (g:=g) = (equiv_path_pforall f g)^-<span class="mi">1</span>%equiv
  := <span class="kp">ltac</span>:(<span class="bp">by</span> funext []).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: The next few results could be proven for [GpdHom_path] in any WildCat. *)</span>

<span class="sd">(** [phomotopy_path] sends concatenation to composition of pointed homotopies.*)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk55f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk55f"><span class="kn">Definition</span> <span class="nf">phomotopy_path_pp</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : pForall A P} (<span class="nv">p</span> : f = g) (<span class="nv">q</span> : g = h)
  : phomotopy_path (p @ q) ==* phomotopy_path p @* phomotopy_path q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path (p @ q) ==*
phomotopy_path p @* phomotopy_path q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk560" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk560"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path (p @ q) ==*
phomotopy_path p @* phomotopy_path q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk561" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk561"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path (<span class="mi">1</span> @ q) ==*
phomotopy_path <span class="mi">1</span> @* phomotopy_path q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk562" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk562"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path (<span class="mi">1</span> @ <span class="mi">1</span>) ==*
phomotopy_path <span class="mi">1</span> @* phomotopy_path <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk563" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk563"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path <span class="mi">1</span> @* phomotopy_path <span class="mi">1</span> ==*
phomotopy_path (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> phomotopy_compose_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** [phomotopy_path] respects 2-cells. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk564" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk564"><span class="kn">Definition</span> <span class="nf">phomotopy_path2</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> : pForall A P} {<span class="nv">p</span> <span class="nv">p&#39;</span> : f = g} (<span class="nv">q</span> : p = p&#39;)
  : phomotopy_path p ==* phomotopy_path p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path p ==* phomotopy_path p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk565" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk565"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>p = p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path p ==* phomotopy_path p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk566" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk566"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path p ==* phomotopy_path p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [phomotopy_path] sends inverses to inverses.*)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk567" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk567"><span class="kn">Definition</span> <span class="nf">phomotopy_path_V</span> {<span class="nv">A</span> : pType} {<span class="nv">P</span> : pFam A}
  {<span class="nv">f</span> <span class="nv">g</span> : pForall A P} (<span class="nv">p</span> : f = g)
  : phomotopy_path (p^) ==* (phomotopy_path p)^*.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path p^ ==* (phomotopy_path p)^*</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk568" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk568"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path p^ ==* (phomotopy_path p)^*</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk569" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk569"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_path <span class="mi">1</span>^ ==* (phomotopy_path <span class="mi">1</span>)^*</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_reflexive&#39; f ==* (phomotopy_reflexive&#39; f)^*</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56b"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phomotopy_reflexive&#39; f)^* ==* phomotopy_reflexive&#39; f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> gpd_rev_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since pointed homotopies are equivalent to equalities, we can act as if they are paths and define a path induction for them. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56c"><span class="kn">Definition</span> <span class="nf">phomotopy_ind</span> `{H0 : Funext} {A : pType} {P : pFam A}
  {k : pForall A P} (Q : <span class="kr">forall</span> (<span class="nv">k&#39;</span> : pForall A P), (k ==* k&#39;) -&gt; <span class="kt">Type</span>)
  (q : Q k (<span class="bp">reflexivity</span> k)) (k&#39; : pForall A P)
  : <span class="kr">forall</span> (<span class="nv">H</span> : k ==* k&#39;), Q k&#39; H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">H</span> : k ==* k&#39;, Q k&#39; H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">H</span> : k ==* k&#39;, Q k&#39; H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56e">equiv_intro (equiv_path_pforall k k&#39;)^-<span class="mi">1</span>%equiv p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k = k&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k&#39; ((equiv_path_pforall k k&#39;)^-<span class="mi">1</span>%equiv p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk56f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk56f"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k ((equiv_path_pforall k k)^-<span class="mi">1</span>%equiv <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Sometimes you have a goal with both a pointed homotopy [H] and [path_pforall H].  This is an induction principle that allows us to replace both of them by reflexivity at the same time. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk570" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk570"><span class="kn">Definition</span> <span class="nf">phomotopy_ind&#39;</span> `{H0 : Funext} {A : pType} {P : pFam A}
  {k : pForall A P} (Q : <span class="kr">forall</span> (<span class="nv">k&#39;</span> : pForall A P), (k ==* k&#39;) -&gt; (k = k&#39;) -&gt; <span class="kt">Type</span>)
  (q : Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span> % path) (k&#39; : pForall A P) (H : k ==* k&#39;)
  (p : k = k&#39;) (r : path_pforall H = p)
  : Q k&#39; H p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k ==* k&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k = k&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>path_pforall H = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k&#39; H p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk571" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk571"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k ==* k&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k = k&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>path_pforall H = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k&#39; H p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk572" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk572"><span class="nb">induction</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k ==* k&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k&#39; H (path_pforall H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk573" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk573"><span class="nb">revert</span> k&#39; H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k&#39;</span> : pForall A P) (<span class="nv">H</span> : k ==* k&#39;),
Q k&#39; H (path_pforall H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk574" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk574">rapply phomotopy_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q k (<span class="bp">reflexivity</span> k) (path_pforall (<span class="bp">reflexivity</span> k))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport (Q _ (<span class="bp">reflexivity</span> _)) path_pforall_1^ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk575" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk575"><span class="kn">Definition</span> <span class="nf">phomotopy_ind_1</span> `{H0 : Funext} {A : pType} {P : pFam A}
  {k : pForall A P} (Q : <span class="kr">forall</span> (<span class="nv">k&#39;</span> : pForall A P), (k ==* k&#39;) -&gt; <span class="kt">Type</span>)
  (q : Q k (<span class="bp">reflexivity</span> k)) :
  phomotopy_ind Q q k (<span class="bp">reflexivity</span> k) = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_ind Q q k (<span class="bp">reflexivity</span> k) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk576" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk576"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_ind Q q k (<span class="bp">reflexivity</span> k) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk577" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk577"><span class="nb">change</span> (<span class="bp">reflexivity</span> k) <span class="kr">with</span> ((equiv_path_pforall k k)^-<span class="mi">1</span>%equiv (idpath k)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P, k ==* k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_ind Q q k
  ((equiv_path_pforall k k)^-<span class="mi">1</span>%equiv <span class="mi">1</span>) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_ind_comp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk578" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk578"><span class="kn">Definition</span> <span class="nf">phomotopy_ind_1&#39;</span> `{H0 : Funext} {A : pType} {P : pFam A}
  {k : pForall A P} (Q : <span class="kr">forall</span> (<span class="nv">k&#39;</span> : pForall A P), (k ==* k&#39;) -&gt; (k = k&#39;) -&gt; <span class="kt">Type</span>)
  (q : Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span> % path)
  : phomotopy_ind&#39; Q q k (<span class="bp">reflexivity</span> k) (path_pforall (<span class="bp">reflexivity</span> k)) (<span class="mi">1</span> % path)
  = transport (Q k (<span class="bp">reflexivity</span> k)) path_pforall_1^ q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_ind&#39; Q q k (<span class="bp">reflexivity</span> k)
  (path_pforall (<span class="bp">reflexivity</span> k)) <span class="mi">1</span> =
transport (Q k (<span class="bp">reflexivity</span> k)) path_pforall_1^ q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk579" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk579"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pFam A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>pForall A P</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k&#39;</span> : pForall A P,
k ==* k&#39; -&gt; k = k&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q k (<span class="bp">reflexivity</span> k) <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phomotopy_ind&#39; Q q k (<span class="bp">reflexivity</span> k)
  (path_pforall (<span class="bp">reflexivity</span> k)) <span class="mi">1</span> =
transport (Q k (<span class="bp">reflexivity</span> k)) path_pforall_1^ q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply phomotopy_ind_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every homotopy between pointed maps of sets is a pointed homotopy. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57a"><span class="kn">Definition</span> <span class="nf">phomotopy_homotopy_hset</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} `{IsHSet Y} {f g : X -&gt;* Y} (h : f == g)
  : f ==* g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57c"><span class="nb">apply</span> (Build_pHomotopy h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h pt = dpoint_eq f @ (dpoint_eq g)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pointed homotopies in a set form an HProp. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ishprop_phomotopy_hset</span> `{Funext} {X Y : pType} `{IsHSet Y} (f g : X -&gt;* Y)
  : IsHProp (f ==* g)
  := inO_equiv_inO&#39; (O:=Tr (-<span class="mi">1</span>)) _ (issig_phomotopy f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Operations on equivalences needed to make [pType] a wild category with equivalences *)</span>

<span class="sd">(** The inverse equivalence of a pointed equivalence is again a pointed equivalence *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57d"><span class="kn">Definition</span> <span class="nf">pequiv_inverse</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A &lt;~&gt;* B) : B &lt;~&gt;* A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B &lt;~&gt;* A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B &lt;~&gt;* A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk57f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk57f">snapply Build_pEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt;* A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk580" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk580"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?pointed_equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk581" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk581"><span class="mi">1</span>: <span class="nb">apply</span> (Build_pMap f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> pt = pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk582" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk582"><hr></label><div class="goal-conclusion">IsEquiv (Build_pMap f^-<span class="mi">1</span> <span class="nl">?Goal</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk583" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk583"><span class="mi">1</span>: <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> point_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (Build_pMap f^-<span class="mi">1</span> (moveR_equiv_V pt pt (point_eq f)^))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* A pointed equivalence is a section of its inverse *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk584" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk584"><span class="kn">Definition</span> <span class="nf">peissect</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A &lt;~&gt;* B)
  : (pequiv_inverse f) o* f ==* pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_inverse f o* f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk585" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk585"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_inverse f o* f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk586" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk586">srefine (Build_pHomotopy _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_inverse f o* f == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk587" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk587"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (pequiv_inverse f o* f) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk588" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk588"><span class="mi">1</span>: <span class="bp">exact</span> (eissect f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f pt =
dpoint_eq (pequiv_inverse f o* f) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk589" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk589"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f pt =
(ap f^-<span class="mi">1</span> (point_eq f) @
 moveR_equiv_V pt pt (point_eq f)^) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58a"><span class="nb">unfold</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f pt =
(ap f^-<span class="mi">1</span> (point_eq f) @
 (ap f^-<span class="mi">1</span> (point_eq f)^ @ eissect f pt)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58b">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f point0 = (<span class="mi">1</span> @ (<span class="mi">1</span> @ eissect f point0)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58c"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @ (<span class="mi">1</span> @ eissect f point0)) @ <span class="mi">1</span> = eissect f point0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _ @ concat_1p _ @ concat_1p _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* A pointed equivalence is a retraction of its inverse *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58d"><span class="kn">Definition</span> <span class="nf">peisretr</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A &lt;~&gt;* B)
  : f o* (pequiv_inverse f) ==* pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pequiv_inverse f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pequiv_inverse f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk58f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk58f">srefine (Build_pHomotopy _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pequiv_inverse f == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk590" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk590"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (f o* pequiv_inverse f) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk591" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk591"><span class="mi">1</span>: <span class="bp">exact</span> (eisretr f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f pt =
dpoint_eq (f o* pequiv_inverse f) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk592" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk592">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f (f point0) =
(ap f (moveR_equiv_V (f point0) point0 <span class="mi">1</span>) @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk593" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk593"><span class="nb">unfold</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f (f point0) =
(ap f (ap f^-<span class="mi">1</span> <span class="mi">1</span> @ eissect f point0) @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk594" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk594"><span class="nb">refine</span> (eisadj f _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (eissect f point0) =
(ap f (ap f^-<span class="mi">1</span> <span class="mi">1</span> @ eissect f point0) @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk595" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk595"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>iseq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (ap f^-<span class="mi">1</span> <span class="mi">1</span> @ eissect f point0) @ <span class="mi">1</span>) @ <span class="mi">1</span> =
ap f (eissect f point0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _ @ concat_p1 _ @ ap _ (concat_1p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Univalence for pointed types *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk596" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk596"><span class="kn">Definition</span> <span class="nf">equiv_path_ptype</span> `{Univalence} (A B : pType@{u}) : A &lt;~&gt;* B &lt;~&gt; A = B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A &lt;~&gt;* B) &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk597" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk597"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A &lt;~&gt;* B) &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk598" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk598"><span class="nb">refine</span> (equiv_path_from_contr A (<span class="kr">fun</span> <span class="nv">C</span> =&gt; A &lt;~&gt;* C) pequiv_pmap_idmap _ B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {y : pType &amp; A &lt;~&gt;* y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk599" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk599">napply (contr_equiv&#39; { X : <span class="kt">Type</span>@{u} &amp; { f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x} }}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{X : <span class="kt">Type</span> &amp; {f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x}}} &lt;~&gt;
{y : pType &amp; A &lt;~&gt;* y}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk59a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk59a"><hr></label><div class="goal-conclusion">Contr {X : <span class="kt">Type</span> &amp; {f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x}}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59b"><span class="mi">1</span>: make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {X : <span class="kt">Type</span> &amp; {f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59c">rapply (contr_equiv&#39; { X : <span class="kt">Type</span>@{u} &amp;  A &lt;~&gt; X }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{X : <span class="kt">Type</span> &amp; A &lt;~&gt; X} &lt;~&gt;
{X : <span class="kt">Type</span> &amp; {f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59d">napply equiv_functor_sigma_id; <span class="nb">intro</span> X; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A &lt;~&gt; X &amp; {x : X &amp; f pt = x}} &lt;~&gt; (A &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_sigma_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** If you replace the type in the second line with { Xf : {X : Type &amp; A &lt;~&gt; X} &amp; {x : Xf.1 &amp; Xf.2 pt = x} }, then the third line completes the proof, but that results in an extra universe variable. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_ptype</span> `{Univalence} {A B : pType} : (A &lt;~&gt;* B) -&gt; A = B
  := equiv_path_ptype A B.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The inverse map can be defined without Univalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_path</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">p</span> : A = B) : (A &lt;~&gt;* B)
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; pequiv_pmap_idmap <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This just confirms that it is definitionally the inverse map. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_path_equiv_path_ptype_inverse</span> `{Univalence} {A B : pType}
  : @pequiv_path A B = (equiv_path_ptype A B)^-<span class="mi">1</span>
  := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_pequiv_path</span> `{Univalence} {A B : pType}
  : IsEquiv (@pequiv_path A B)
  := isequiv_inverse (equiv_path_ptype A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Two pointed equivalences are equal if their underlying pointed functions are equal. This requires [Funext] for knowing that [IsEquiv] is an [HProp]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59e"><span class="kn">Definition</span> <span class="nf">equiv_path_pequiv&#39;</span> `{Funext} {A B : pType} (f g : A &lt;~&gt;* B)
  : (f = g :&gt; (A -&gt;* B)) &lt;~&gt; (f = g :&gt; (A &lt;~&gt;* B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk59f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk59f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a0"><span class="nb">refine</span> ((equiv_ap&#39; (issig_pequiv A B)^-<span class="mi">1</span>%equiv f g)^-<span class="mi">1</span>%equiv oE _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt;
(f; pointed_isequiv A B f) =
(g; pointed_isequiv A B g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">match goal with</span> |- _ &lt;~&gt; <span class="nl">?F</span> = <span class="nl">?G</span> =&gt; <span class="bp">exact</span> (equiv_path_sigma_hprop F G) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Two pointed equivalences are equal if their underlying pointed functions are pointed homotopic. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_pequiv</span> `{Funext} {A B : pType} (f g : A &lt;~&gt;* B)
  : (f ==* g) &lt;~&gt; (f = g)
  := equiv_path_pequiv&#39; f g oE equiv_path_pforall f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_pequiv</span> `{Funext} {A B : pType} (f g : A &lt;~&gt;* B)
  : (f ==* g) -&gt; (f = g)
  := equiv_path_pequiv f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a1"><span class="kn">Definition</span> <span class="nf">equiv_phomotopy_concat_l</span> `{Funext} {A B : pType}
  (f g h : A -&gt;* B) (K : g ==* f)
  : f ==* h &lt;~&gt; g ==* h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>g ==* f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* h &lt;~&gt; g ==* h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>g ==* f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* h &lt;~&gt; g ==* h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a3"><span class="nb">refine</span> ((equiv_path_pforall _ _)^-<span class="mi">1</span>%equiv oE _ oE equiv_path_pforall _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>g ==* f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = h &lt;~&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a4">rapply equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>g ==* f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a5"><span class="nb">apply</span> equiv_path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>g ==* f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> K.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under funext, [pType] has morphism extensionality *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a6"><span class="kn">Instance</span> <span class="nf">hasmorext_ptype</span> `{Funext} : HasMorExt pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a8"><span class="nb">intros</span> A B f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5a9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5a9"><span class="nb">refine</span> (isequiv_homotopic (equiv_path_pforall f g)^-<span class="mi">1</span>%equiv _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_pforall f g)^-<span class="mi">1</span>%equiv == GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] has equivalences *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5aa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5aa"><span class="kn">Instance</span> <span class="nf">hasequivs_ptype</span> : HasEquivs pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ab" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ac" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ac">stapply (
    Build_HasEquivs _ _ _ _ _ pEquiv (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> =&gt; IsEquiv f));
  <span class="nb">intros</span> A B f; <span class="nb">cbn</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;* B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5ad"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="core-v-chk5ae"><hr></label><div class="goal-conclusion">A &lt;~&gt;* B</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>fe</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="core-v-chk5af"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span>@{f:=(<span class="kr">fun</span> <span class="nv">H</span> : IsEquiv f =&gt; <span class="nl">?Goal4</span>@{X:=H}) fe} ==*
f</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5b0"><hr></label><div class="goal-conclusion">B -&gt;* A</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5b1"><hr></label><div class="goal-conclusion"><span class="nl">?Goal1</span> o* <span class="nl">?Goal</span> ==* pmap_idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5b2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5b2"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> o* <span class="nl">?Goal1</span> ==* pmap_idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk5b3"><hr></label><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;* B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;~&gt;* B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_pEquiv f _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>fe</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">H</span> : IsEquiv f =&gt;
 {| pointed_equiv_fun := f; pointed_isequiv := H |})
  fe ==* f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt;* A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pequiv_inverse f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5b9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5b9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_inverse f o* f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> peissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ba" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pequiv_inverse f ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5bb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5bb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
o* Build_pMap f^-<span class="mi">1</span> (moveR_equiv_V pt pt (point_eq f)^) ==*
pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (peisretr f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5bc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5bc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5bd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5bd">rapply (isequiv_adjointify f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><label class="goal-separator" for="core-v-chk5be"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5bf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5bf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (r x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>f o* g ==* pmap_idmap</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>g o* f ==* pmap_idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (s x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c1"><span class="kn">Instance</span> <span class="nf">hasmorext_core_ptype</span> `{Funext} : HasMorExt (core pType).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt (core pType)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt (core pType)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c3">rapply hasmorext_core.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : core pType)
(<span class="nv">f</span> <span class="nv">g</span> : uncore x $&lt;~&gt; uncore y), IsEquiv (ap cate_fun)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c4"><span class="nb">intros</span> A B f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>core pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>uncore A $&lt;~&gt; uncore B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap cate_fun)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c5">snapply isequiv_homotopic&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>core pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>uncore A $&lt;~&gt; uncore B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; f = g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>core pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>uncore A $&lt;~&gt; uncore B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5c6"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == ap cate_fun</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c7"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_path_pequiv&#39; f g)^-<span class="mi">1</span>%equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>core pType</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>uncore A $&lt;~&gt; uncore B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_pequiv&#39; f g)^-<span class="mi">1</span>%equiv == ap cate_fun</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pType] is a univalent 1-coherent 1-category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c8"><span class="kn">Instance</span> <span class="nf">isunivalent_ptype</span> `{Univalence} : IsUnivalent1Cat pType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnivalent1Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5c9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5c9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnivalent1Cat pType</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ca" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ca"><span class="nb">intros</span> A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cat_equiv_path A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* [cate_equiv_path] is almost definitionally equal to [pequiv_path].  Both are defined by path induction, sending [idpath A] to [id_cate A] and [pequiv_pmap_idmap A], respectively.  [id_cate A] is almost definitionally equal to [pequiv_pmap_idmap A], except that the former uses [catie_adjointify], so the adjoint law is different. However, the underlying pointed maps are definitionally equal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5cb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5cb"><span class="nb">refine</span> (isequiv_homotopic pequiv_path _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_path == cat_equiv_path A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5cc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5cc"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_path <span class="mi">1</span> = cat_equiv_path A A <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5cd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5cd"><span class="nb">apply</span> equiv_path_pequiv&#39;.  <span class="c">(* Change to equality as pointed functions. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pequiv_path <span class="mi">1</span> = cat_equiv_path A A <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The free base point added to a type. This is in fact a functor and left adjoint to the forgetful functor [pType] to [Type]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pointify</span> (<span class="nv">S</span> : <span class="kt">Type</span>) : pType := [S + Unit, inr tt].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ce" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ce"><span class="kn">Instance</span> <span class="nf">is0functor_pointify</span> : Is0Functor pointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor pointify</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5cf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5cf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor pointify</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d0"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>,
(a $-&gt; b) -&gt; pointify a $-&gt; pointify b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d1"><span class="nb">intros</span> A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pointify A $-&gt; pointify B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d2">srapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pointify A -&gt; pointify B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5d3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="core-v-chk5d3"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d4"><span class="mi">1</span>: <span class="bp">exact</span> (functor_sum f idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sum f idmap pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pointify] is left adjoint to forgetting the basepoint in the following sense *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d5"><span class="kn">Theorem</span> <span class="nf">equiv_pointify_map</span> `{Funext} (A : <span class="kt">Type</span>) (X : pType)
  : (pointify A -&gt;* X) &lt;~&gt; (A -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pointify A -&gt;* X) &lt;~&gt; (A -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pointify A -&gt;* X) &lt;~&gt; (A -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5d7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5d7">snapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pointify A -&gt;* X) -&gt; A -&gt; X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5d8"><hr></label><div class="goal-conclusion">(A -&gt; X) -&gt; pointify A -&gt;* X</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5d9"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5da"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5db" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5db"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f o inl).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt; X) -&gt; pointify A -&gt;* X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5dc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5dc"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk5dd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5dd"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5de" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5de">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt; X) -&gt; pointify A -&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5df" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5df"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pointify A -&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e0">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pointify A -&gt; X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5e1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br></div><label class="goal-separator" for="core-v-chk5e1"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pointify A -&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e3"><span class="nb">intros</span> [a|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="core-v-chk5e4"><hr></label><div class="goal-conclusion">X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e5"><span class="mi">1</span>: <span class="bp">exact</span> (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pt.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
 <span class="kr">match</span> X0 <span class="kr">with</span>
 | inl a =&gt; (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; f a0) a
 | inr u =&gt; unit_name pt u
 <span class="kr">end</span>) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl)
o (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
   Build_pMap
     (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; f a0) a
      | inr u =&gt; unit_name pt u
      <span class="kr">end</span>) <span class="mi">1</span>) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5e8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk5e8"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
 Build_pMap
   (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; f a0) a
    | inr u =&gt; unit_name pt u
    <span class="kr">end</span>) <span class="mi">1</span>) o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5e9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5e9"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
 Build_pMap
   (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; f a0) a
    | inr u =&gt; unit_name pt u
    <span class="kr">end</span>) <span class="mi">1</span>) o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ea" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ea"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pointify A -&gt;* X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
   <span class="kr">match</span> X0 <span class="kr">with</span>
   | inl a =&gt; f (inl a)
   | inr _ =&gt; pt
   <span class="kr">end</span>) <span class="mi">1</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5eb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5eb"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>pointify A -&gt;* X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; ispointed_type X
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ec" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ec">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A + Unit -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} = {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ed" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ed">rapply equiv_path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A + Unit -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} ==* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5ee" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5ee">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A + Unit -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} == {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A + Unit -&gt; X</span></span></span><br></div><label class="goal-separator" for="core-v-chk5ef"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  {|
    pointed_fun :=
      <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; f (inl a)
      | inr _ =&gt; f (inr tt)
      <span class="kr">end</span>;
    dpoint_eq := <span class="mi">1</span>
  |} @
(dpoint_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f0"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">intros</span> [a|[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A + Unit -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : [A + Unit, inr tt] =&gt;
  <span class="kr">match</span>
    x <span class="kr">as</span> s
    <span class="kr">return</span>
      ({|
         pointed_fun :=
           <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
           <span class="kr">match</span> X0 <span class="kr">with</span>
           | inl a =&gt; f (inl a)
           | inr _ =&gt; f (inr tt)
           <span class="kr">end</span>;
         dpoint_eq := <span class="mi">1</span>
       |} s = {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} s)
  <span class="kr">with</span>
  | inl a =&gt; (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; <span class="mi">1</span>) a
  | inr u =&gt;
      (<span class="kr">fun</span> <span class="nv">u0</span> : Unit =&gt;
       <span class="kr">match</span>
         u0 <span class="kr">as</span> u1
         <span class="kr">return</span>
           ({|
              pointed_fun :=
                <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
                <span class="kr">match</span> X0 <span class="kr">with</span>
                | inl a =&gt; f (inl a)
                | inr _ =&gt; f (inr tt)
                <span class="kr">end</span>;
              dpoint_eq := <span class="mi">1</span>
            |} (inr u1) =
            {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
              (inr u1))
       <span class="kr">with</span>
       | tt =&gt; <span class="mi">1</span>
       <span class="kr">end</span>) u
  <span class="kr">end</span>)
 :
 {|
   pointed_fun :=
     <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
     <span class="kr">match</span> X0 <span class="kr">with</span>
     | inl a =&gt; f (inl a)
     | inr _ =&gt; f (inr tt)
     <span class="kr">end</span>;
   dpoint_eq := <span class="mi">1</span>
 |} == {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) pt =
dpoint_eq
  {|
    pointed_fun :=
      <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; f (inl a)
      | inr _ =&gt; f (inr tt)
      <span class="kr">end</span>;
    dpoint_eq := <span class="mi">1</span>
  |} @
(dpoint_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f1"><span class="kn">Lemma</span> <span class="nf">natequiv_pointify_r</span> `{Funext} (A : <span class="kt">Type</span>)
  : NatEquiv (opyon (pointify A)) (opyon A o pointed_type).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (pointify A)) (opyon A o pointed_type)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (pointify A)) (opyon A o pointed_type)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f3">snapply Build_NatEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pType,
opyon (pointify A) a $&lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : pType =&gt; opyon A x) a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5f4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="core-v-chk5f4"><hr></label><div class="goal-conclusion">Is1Natural (opyon (pointify A))
  (<span class="kr">fun</span> <span class="nv">x</span> : pType =&gt; opyon A x) (<span class="kr">fun</span> <span class="nv">a</span> : pType =&gt; <span class="nl">?e</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f5"><span class="mi">1</span>: rapply equiv_pointify_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon (pointify A))
  (<span class="kr">fun</span> <span class="nv">x</span> : pType =&gt; opyon A x)
  (<span class="kr">fun</span> <span class="nv">a</span> : pType =&gt; equiv_pointify_map A a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f6">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : pType) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">a0</span> : pType =&gt; cate_fun (equiv_pointify_map A a0))
  a&#39; $o fmap (opyon (pointify A)) f $==
fmap (opyon A o pointed_type) f $o
(<span class="kr">fun</span> <span class="nv">a0</span> : pType =&gt; cate_fun (equiv_pointify_map A a0))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbv</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Pointed categories give rise to pointed structures *)</span>

<span class="sd">(** Pointed categories have pointed hom sets *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pHom</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsPointedCat A} (a1 a2 : A)
  := [Hom a1 a2, zero_morphism].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pointed functors give pointed maps on morphisms *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f7"><span class="kn">Definition</span> <span class="nf">pfmap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">F</span> : A -&gt; B)
  `{IsPointedCat A, IsPointedCat B, !HasEquivs B, !HasMorExt B}
  `{!Is0Functor F, !Is1Functor F, !IsPointedFunctor F}
  {a1 a2 : A}
  : pHom a1 a2 -&gt;* pHom (F a1) (F a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pHom a1 a2 -&gt;* pHom (F a1) (F a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pHom a1 a2 -&gt;* pHom (F a1) (F a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5f9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5f9">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pHom a1 a2 -&gt; pHom (F a1) (F a2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk5fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="core-v-chk5fa"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5fb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pHom a1 a2 -&gt; pHom (F a1) (F a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap F).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5fc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5fc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk5fd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk5fd"><span class="nb">apply</span> path_hom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsGraph0</var><span class="hyp-type"><b>: </b><span>IsGraph A</span></span></span><br><span><var>Is2Graph0</var><span class="hyp-type"><b>: </b><span>Is2Graph A</span></span></span><br><span><var>Is01Cat0</var><span class="hyp-type"><b>: </b><span>Is01Cat A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Is1Cat A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPointedCat A</span></span></span><br><span><var>IsGraph1</var><span class="hyp-type"><b>: </b><span>IsGraph B</span></span></span><br><span><var>Is2Graph1</var><span class="hyp-type"><b>: </b><span>Is2Graph B</span></span></span><br><span><var>Is01Cat1</var><span class="hyp-type"><b>: </b><span>Is01Cat B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Is1Cat B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsPointedCat B</span></span></span><br><span><var>HasEquivs0</var><span class="hyp-type"><b>: </b><span>HasEquivs B</span></span></span><br><span><var>HasMorExt0</var><span class="hyp-type"><b>: </b><span>HasMorExt B</span></span></span><br><span><var>Is0Functor0</var><span class="hyp-type"><b>: </b><span>Is0Functor F</span></span></span><br><span><var>Is1Functor0</var><span class="hyp-type"><b>: </b><span>Is1Functor F</span></span></span><br><span><var>IsPointedFunctor0</var><span class="hyp-type"><b>: </b><span>IsPointedFunctor F</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap F pt $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">snapply fmap_zero_morphism; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
