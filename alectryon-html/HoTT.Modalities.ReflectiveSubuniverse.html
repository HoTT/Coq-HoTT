<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>ReflectiveSubuniverse.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Equiv.BiInv Extensions HProp HFiber NullHomotopy Limits.Pullback.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.IdentitySystems.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Pushout.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Reflective Subuniverses *)</span>

<span class="sd">(** ** References  *)</span>

<span class="sd">(** Reflective subuniverses (and modalities) are studied in the following papers, which we will refer to below by their abbreviations:</span>

<span class="sd">- The Book: The Homotopy Type Theory Book, chapter 7.  Bare references to &quot;Theorem 7.x.x&quot; are always to the Book.</span>
<span class="sd">- RSS: Rijke, Spitters, and Shulman, &quot;Modalities in homotopy type theory&quot;, https://arxiv.org/abs/1706.07526.</span>
<span class="sd">- CORS: Christensen, Opie, Rijke, and Scoccola, &quot;Localization in Homotopy Type Theory&quot;, https://arxiv.org/abs/1807.04155.</span>
<span class="sd">*)</span>

<span class="sd">(** ** Definitions *)</span>

<span class="sd">(** *** Subuniverses *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Subuniverse</span>@{i} :=
{
  In_internal : <span class="kt">Type</span>@{i} -&gt; <span class="kt">Type</span>@{i} ;
  hprop_inO_internal : Funext -&gt; <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>@{i}),
      IsHProp (In_internal T) ;
  inO_equiv_inO_internal : <span class="kr">forall</span> (<span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>@{i}) (<span class="nv">T_inO</span> : In_internal T)
                                  (<span class="nv">f</span> : T -&gt; U) {<span class="nv">feq</span> : IsEquiv f},
      In_internal U ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Work around Coq bug that fields of records can&#39;t be typeclasses. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">In</span> (<span class="nv">O</span> : Subuniverse) (<span class="nv">T</span> : <span class="kt">Type</span>) := in_internal : In_internal O T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Being in the subuniverse is a mere predicate (by hypothesis).  We include funext in the hypotheses of [hprop_inO] so that it doesn&#39;t have to be assumed in all definitions of (reflective) subuniverses, since in most examples it is required for this and this only.  Here we redefine it using the replaced [In]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">hprop_inO</span> `{Funext} (O : Subuniverse) (T : <span class="kt">Type</span>)
  : IsHProp (In O T)
  := @hprop_inO_internal _ _ T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We assumed repleteness of the subuniverse in the definition.  Of course, with univalence this would be automatic, but we include it as a hypothesis since most of the theory of reflective subuniverses and modalities doesn&#39;t need univalence, and most or all examples can be shown to be replete without using univalence.  Here we redefine it using the replaced [In]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inO_equiv_inO</span> {<span class="nv">O</span> : Subuniverse} (<span class="nv">T</span> : <span class="kt">Type</span>) {<span class="nv">U</span> : <span class="kt">Type</span>}
           `{T_inO : In O T} (f : T -&gt; U) `{IsEquiv T U f}
  : In O U
  := @inO_equiv_inO_internal O T U T_inO f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inO_equiv_inO&#39;</span> {<span class="nv">O</span> : Subuniverse}
           (<span class="nv">T</span> : <span class="kt">Type</span>) {<span class="nv">U</span> : <span class="kt">Type</span>} `{In O T} (f : T &lt;~&gt; U)
  : In O U
  := inO_equiv_inO T f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iff_inO_equiv</span> (<span class="nv">O</span> : Subuniverse)
           {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : T &lt;~&gt; U)
  : In O T &lt;-&gt; In O U
  := (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inO_equiv_inO&#39; _ f, <span class="kr">fun</span> <span class="nv">H</span> =&gt; inO_equiv_inO&#39; _ f^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_inO_equiv</span> `{Funext} (O : Subuniverse)
           {T : <span class="kt">Type</span>} {U : <span class="kt">Type</span>} (f : T &lt;~&gt; U)
  : In O T &lt;~&gt; In O U
  := equiv_iff_hprop_uncurried (iff_inO_equiv _ f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The universe of types in the subuniverse *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Type_</span>@{i j} (O : Subuniverse@{i}) : <span class="kt">Type</span>@{j}
  := @sig@{j i} <span class="kt">Type</span>@{i} (<span class="kr">fun</span> (<span class="nv">T</span> : <span class="kt">Type</span>@{i}) =&gt; In O T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">TypeO_pr1</span> O (T : Type_ O) := @pr1 <span class="kt">Type</span> (In O) T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The second component of [TypeO] is unique.  *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_TypeO</span>@{i j} {fs : Funext} O (T T&#39; : Type_@{i j} O) (p : T.<span class="mi">1</span> = T&#39;.<span class="mi">1</span>)
  : T = T&#39;
  := path_sigma_hprop@{j i j} T T&#39; p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_TypeO</span>@{i j} {fs : Funext} O (T T&#39; : Type_@{i j} O)
  : (paths@{j} T.<span class="mi">1</span> T&#39;.<span class="mi">1</span>) &lt;~&gt; (T = T&#39;)
  := equiv_path_sigma_hprop@{j i j} T T&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Types in [TypeO] are always in [O]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">inO_TypeO</span> {<span class="nv">O</span> : Subuniverse} (<span class="nv">A</span> : Type_ O) : In O A
  := A.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of Subuniverses *)</span>

<span class="sd">(** A map is O-local if all its fibers are. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">MapIn</span> (<span class="nv">O</span> : Subuniverse) {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  := inO_hfiber_ino_map :: <span class="kr">forall</span> (<span class="nv">b</span>:B), In O (hfiber f b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Subuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : Subuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Being a local map is an hprop *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_mapinO</span> `{Funext} {A B : <span class="kt">Type</span>} (f : A -&gt; B)
  : IsHProp (MapIn O f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (MapIn O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (MapIn O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> istrunc_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Anything homotopic to a local map is local. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3"><span class="kn">Definition</span> <span class="nf">mapinO_homotopic</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> : A -&gt; B}
             (<span class="nv">p</span> : f == g) `{MapIn O _ _ f}
  : MapIn O g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber g b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO (hfiber f b)
                          (equiv_hfiber_homotopic f g p b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The projection from a family of local types is local. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>}
         `{<span class="kr">forall</span> <span class="nv">a</span>, In O (B a)}
  : MapIn O (@pr1 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber pr1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO (B a) (hfiber_fibration a B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A family of types is local if and only if the associated projection map is local. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9"><span class="kn">Lemma</span> <span class="nf">iff_forall_inO_mapinO_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>)
    : (<span class="kr">forall</span> <span class="nv">a</span>, In O (B a)) &lt;-&gt; MapIn O (@pr1 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) &lt;-&gt; MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) &lt;-&gt; MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) -&gt; MapIn O pr1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkc"><hr></label><div class="goal-conclusion">MapIn O pr1 -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) -&gt; MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _. <span class="c">(* Uses the instance mapinO_pr1 above. *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O pr1 -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf">rapply functor_forall; <span class="nb">intros</span> a x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>In O (hfiber pr1 (<span class="nl">?Goal</span> a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (B a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO (hfiber pr1 a)
                           (hfiber_fibration a B)^-<span class="mi">1</span>%equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10"><span class="kn">Lemma</span> <span class="nf">equiv_forall_inO_mapinO_pr1</span> `{Funext} {A : <span class="kt">Type</span>} (B : A -&gt; <span class="kt">Type</span>)
    : (<span class="kr">forall</span> <span class="nv">a</span>, In O (B a)) &lt;~&gt; MapIn O (@pr1 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) &lt;~&gt; MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, In O (B a)) &lt;~&gt; MapIn O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_iff_hprop_uncurried (iff_forall_inO_mapinO_pr1 B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Subuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Reflections *)</span>

<span class="sd">(** A pre-reflection is a map to a type in the subuniverse. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">PreReflects</span>@{i} (O : Subuniverse@{i}) (T : <span class="kt">Type</span>@{i}) :=
{
  O_reflector : <span class="kt">Type</span>@{i} ;
  O_inO :: In O O_reflector ;
  to : T -&gt; O_reflector ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_reflector O T {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> to O T {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_inO {O} T {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It is a reflection if it has the requisite universal property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Reflects</span>@{i} (O : Subuniverse@{i}) (T : <span class="kt">Type</span>@{i})
      `{PreReflects@{i} O T} :=
{
  extendable_to_O : <span class="kr">forall</span> {<span class="nv">Q</span> : <span class="kt">Type</span>@{i}} {<span class="nv">Q_inO</span> : In O Q},
      ooExtendableAlong (to O T) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Q)
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> extendable_to_O O {T _ _ Q Q_inO}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here&#39;s a modified version that applies to types in possibly-smaller universes without collapsing those universes to [i]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12"><span class="kn">Definition</span> <span class="nf">extendable_to_O&#39;</span>@{i j k | j &lt;= i, k &lt;= i} (O : Subuniverse@{i}) (T : <span class="kt">Type</span>@{j})
           `{Reflects O T} {Q : <span class="kt">Type</span>@{k}} {Q_inO : In O Q}
  : ooExtendableAlong (to O T) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>PreReflects O T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Reflects O T</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O T)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O T =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>PreReflects O T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Reflects O T</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O T)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O T =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk14"><span class="nb">apply</span> lift_ooextendablealong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>PreReflects O T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Reflects O T</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O T)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O T =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply extendable_to_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In particular, every type in the subuniverse automatically reflects into it. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk15"><span class="kn">Definition</span> <span class="nf">prereflects_in</span> (<span class="nv">O</span> : Subuniverse) (<span class="nv">T</span> : <span class="kt">Type</span>) `{In O T} : PreReflects O T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk18"><hr></label><div class="goal-conclusion">In O <span class="nl">?O_reflector</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk19"><hr></label><div class="goal-conclusion">T -&gt; <span class="nl">?O_reflector</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">T -&gt; T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d"><span class="kn">Definition</span> <span class="nf">reflects_in</span> (<span class="nv">O</span> : Subuniverse) (<span class="nv">T</span> : <span class="kt">Type</span>) `{In O T} : @Reflects O T (prereflects_in O T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">intros</span>; rapply ooextendable_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A reflective subuniverse is one for which every type reflects into it. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">ReflectiveSubuniverse</span>@{i} :=
{
  rsu_subuniv : Subuniverse@{i} ;
  rsu_prereflects :: <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>@{i}), PreReflects rsu_subuniv T ;
  rsu_reflects :: <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>@{i}), Reflects rsu_subuniv T ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">rsu_subuniv</span> : ReflectiveSubuniverse &gt;-&gt; Subuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We allow the name of a subuniverse or modality to be used as the name of its reflector.  This means that when defining a particular example, you should generally put the parametrizing family in a wrapper, so that you can notate the subuniverse as parameterized by, rather than identical to, its parameter.  See Modality.v, Truncations.v, and Localization.v for examples. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rsu_reflector</span> (<span class="nv">O</span> : ReflectiveSubuniverse) (<span class="nv">T</span> : <span class="kt">Type</span>) : <span class="kt">Type</span>
  := O_reflector O T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">rsu_reflector</span> : ReflectiveSubuniverse &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Recursion principles *)</span>

<span class="sd">(** We now extract the recursion principle and the restricted induction principles for paths. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ORecursion</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">O</span> : Subuniverse} {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} {<span class="nv">Q_inO</span> : In O Q} `{Reflects O P}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_rec</span> (<span class="nv">f</span> : P -&gt; Q)
    : O_reflector O P -&gt; Q
    := (fst (extendable_to_O O <span class="mi">1</span>%nat) f).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_rec_beta</span> (<span class="nv">f</span> : P -&gt; Q) (<span class="nv">x</span> : P)
    : O_rec f (to O P x) = f x
    := (fst (extendable_to_O O <span class="mi">1</span>%nat) f).<span class="mi">2</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_indpaths</span> (<span class="nv">g</span> <span class="nv">h</span> : O_reflector O P -&gt; Q)
             (<span class="nv">p</span> : g o to O P == h o to O P)
    : g == h
    := (fst (snd (extendable_to_O O <span class="mi">2</span>) g h) p).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_indpaths_beta</span> (<span class="nv">g</span> <span class="nv">h</span> : O_reflector O P -&gt; Q)
             (<span class="nv">p</span> : g o (to O P) == h o (to O P)) (<span class="nv">x</span> : P)
    : O_indpaths g h p (to O P x) = p x
    := (fst (snd (extendable_to_O O <span class="mi">2</span>) g h) p).<span class="mi">2</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_ind2paths</span> {<span class="nv">g</span> <span class="nv">h</span> : O_reflector O P -&gt; Q} (<span class="nv">p</span> <span class="nv">q</span> : g == h)
             (<span class="nv">r</span> : p oD (to O P) == q oD (to O P))
    : p == q
    := (fst (snd (snd (extendable_to_O O <span class="mi">3</span>) g h) p q) r).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_ind2paths_beta</span> {<span class="nv">g</span> <span class="nv">h</span> : O_reflector O P -&gt; Q} (<span class="nv">p</span> <span class="nv">q</span> : g == h)
             (<span class="nv">r</span> : p oD (to O P) == q oD (to O P)) (<span class="nv">x</span> : P)
    : O_ind2paths p q r (to O P x) = r x
    := (fst (snd (snd (extendable_to_O O <span class="mi">3</span>) g h) p q) r).<span class="mi">2</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Clearly we can continue indefinitely as needed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ORecursion</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* We never want to see [extendable_to_O].  The [!x] allows [cbn] to unfold these when passed a constructor, such as [tr x].  This, for example, means that [O_rec (O:=Tr n) f (tr x)] will compute to [f x] and [Trunc_functor n f (tr x)] will compute to [tr (f x)]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_rec {O} {P Q}%_type_scope {Q_inO H H0} f%_function_scope !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_rec_beta {O} {P Q}%_type_scope {Q_inO H H0} f%_function_scope !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_indpaths {O} {P Q}%_type_scope {Q_inO H H0} (g h)%_function_scope p !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_indpaths_beta {O} {P Q}%_type_scope {Q_inO H H0} (g h)%_function_scope p !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_ind2paths {O} {P Q}%_type_scope {Q_inO H H0} {g h}%_function_scope p q r !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> O_ind2paths_beta {O} {P Q}%_type_scope {Q_inO H H0} {g h}%_function_scope p q r !x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A tactic that generalizes [strip_truncations] to reflective subuniverses. [strip_truncations] introduces fewer universe variables, so tends to work better when removing truncations. [strip_modalities] in Modality.v also applies dependent elimination when [O] is a modality. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">strip_reflections</span> :=
  <span class="sd">(** Search for hypotheses of type [O X] for some [O] such that the goal is [O]-local. *)</span>
  <span class="kp">progress</span> <span class="kp">repeat</span>
    <span class="kr">match goal with</span>
    | [ T : _ |- _ ]
      =&gt; revert_opaque T;
        <span class="nb">refine</span> (@O_rec _ _ _ _ _ _ _) || <span class="nb">refine</span> (@O_indpaths _ _ _ _ _ _ _ _ _);
        <span class="sd">(** Ensure that we didn&#39;t generate more than one subgoal, i.e. that the goal was appropriately local. *)</span>
        [];
        <span class="nb">intro</span> T
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given [Funext], we prove the definition of reflective subuniverse in the book. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_o_to_O</span> `{Funext}
       (O : ReflectiveSubuniverse) (P Q : <span class="kt">Type</span>) `{In O Q}
: IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : O P -&gt; Q =&gt; g o to O P)
:= isequiv_ooextendable _ _ (extendable_to_O O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_o_to_O</span> `{Funext}
           (O : ReflectiveSubuniverse) (P Q : <span class="kt">Type</span>) `{In O Q}
: (O P -&gt; Q) &lt;~&gt; (P -&gt; Q)
:= Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">g</span> : O P -&gt; Q =&gt; g o to O P) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [isequiv_ooextendable] is defined in a way that makes [O_rec] definitionally equal to the inverse of [equiv_o_to_O]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_O_rec_to_O</span> `{Funext}
       (O : ReflectiveSubuniverse) (P Q : <span class="kt">Type</span>) `{In O Q}
  : IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : P -&gt; Q =&gt; O_rec g)
  := (equiv_isequiv (equiv_o_to_O O P Q)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of Reflective Subuniverses *)</span>

<span class="sd">(** We now prove a bunch of things about an arbitrary reflective subuniverse. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Reflective_Subuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : ReflectiveSubuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Functoriality of [O_rec] homotopies *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f"><span class="kn">Definition</span> <span class="nf">O_rec_homotopy</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} `{In O Q} (f g : P -&gt; Q) (pi : f == g)
  : O_rec (O := O) f == O_rec g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f == O_rec g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f == O_rec g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21"><span class="nb">apply</span> O_indpaths; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f (to O P x) = O_rec g (to O P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f (to O P x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk23"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = O_rec g (to O P x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f (to O P x) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = O_rec g (to O P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = O_rec g (to O P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk28"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = O_rec g (to O P x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pi _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g x = O_rec g (to O P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Q</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g x = O_rec g (to O P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** If [T] is in the subuniverse, then [to O T] is an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_to_O_inO</span> (<span class="nv">T</span> : <span class="kt">Type</span>) `{In O T} : IsEquiv (to O T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e"><span class="nb">pose</span> (g := O_rec idmap : O T -&gt; T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f"><span class="nb">refine</span> (isequiv_adjointify (to O T) g _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O T =&gt; to O T (g x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk30"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; g (to O T x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O T =&gt; to O T (g x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32"><span class="nb">refine</span> (O_indpaths (to O T o g) idmap _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; to O T (g (to O T x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; to O T x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O T (g (to O T x)) = to O T x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (to O T x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; g (to O T x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk36"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O T</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>O_rec idmap : O T -&gt; T</span></span><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (to O T x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_to_O</span> (<span class="nv">T</span> : <span class="kt">Type</span>) `{In O T} : T &lt;~&gt; O T
    := Build_Equiv T (O T) (to O T) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** In this section, we see that [O] is a functor. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) : O A -&gt; O B
      := O_rec (to O B o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Naturality of [to O] *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_O_natural</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
    : (O_functor f) o (to O A) == (to O B) o f
    := (O_rec_beta _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Functoriality on composition *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk37"><span class="kn">Definition</span> <span class="nf">O_functor_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
    : (O_functor (g o f)) == (O_functor g) o (O_functor f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (g o f) == O_functor g o O_functor f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (g o f) == O_functor g o O_functor f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk39">srapply O_indpaths; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (to O A x) =
O_functor g (O_functor f (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3a"><span class="nb">refine</span> (to_O_natural (g o f) x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O C (g (f x)) =
O_functor g (O_functor f (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3b"><span class="nb">transitivity</span> (O_functor g (to O B (f x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O C (g (f x)) = O_functor g (to O B (f x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk3c"><hr></label><div class="goal-conclusion">O_functor g (to O B (f x)) =
O_functor g (O_functor f (to O A x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O C (g (f x)) = O_functor g (to O B (f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor g (to O B (f x)) = to O C (g (f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to_O_natural g (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor g (to O B (f x)) =
O_functor g (O_functor f (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk40"><span class="nb">apply</span> ap; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O A x) = to O B (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to_O_natural f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Functoriality on homotopies (2-functoriality) *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk41"><span class="kn">Definition</span> <span class="nf">O_functor_homotopy</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">pi</span> : f == g)
    : O_functor f == O_functor g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f == O_functor g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f == O_functor g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk43"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O A x) = O_functor g (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk44"><span class="nb">refine</span> (to_O_natural f x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O B (f x) = O_functor g (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk45"><span class="nb">refine</span> (_ @ (to_O_natural g x)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O B (f x) = to O B (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, pi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Functoriality for inverses of homotopies *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk46"><span class="kn">Definition</span> <span class="nf">O_functor_homotopy_V</span>
               {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">pi</span> : f == g)
    : O_functor_homotopy g f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (pi x)^)
      == <span class="kr">fun</span> <span class="nv">x</span> =&gt; (O_functor_homotopy f g pi x)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (pi x)^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; (O_functor_homotopy f g pi x)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (pi x)^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; (O_functor_homotopy f g pi x)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk48"><span class="nb">refine</span> (O_ind2paths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_homotopy g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (pi x)^)
 oD to O A) x =
((<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; (O_functor_homotopy f g pi x)^)
 oD to O A) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk49"><span class="nb">unfold</span> composeD, O_functor_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (O_functor g) (O_functor f)
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural g x @
   (ap (to O B) (pi x)^ @ (to_O_natural f x)^))
  (to O A x) =
(O_indpaths (O_functor f) (O_functor g)
   (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
    to_O_natural f x @
    (ap (to O B) (pi x) @ (to_O_natural g x)^))
   (to O A x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4a"><span class="nb">rewrite</span> !O_indpaths_beta, !ap_V, !inv_pp, inv_V, !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_O_natural g x @ (ap (to O B) (pi x))^) @
(to_O_natural f x)^ =
(to_O_natural g x @ (ap (to O B) (pi x))^) @
(to_O_natural f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Hence functoriality on commutative squares *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4b"><span class="kn">Definition</span> <span class="nf">O_functor_square</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">pi1</span> : X -&gt; A) (<span class="nv">pi2</span> : X -&gt; B)
               (<span class="nv">f</span> : A -&gt; C) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">comm</span> : (f o pi1) == (g o pi2))
    : ( (O_functor f) o (O_functor pi1) )
      == ( (O_functor g) o (O_functor pi2) ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f o O_functor pi1 ==
O_functor g o O_functor pi2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f o O_functor pi1 ==
O_functor g o O_functor pi2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4d"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_functor pi1 x) =
O_functor g (O_functor pi2 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk4e"><span class="nb">transitivity</span> (O_functor (f o pi1) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_functor pi1 x) = O_functor (f o pi1) x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk4f"><hr></label><div class="goal-conclusion">O_functor (f o pi1) x = O_functor g (O_functor pi2 x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_functor pi1 x) = O_functor (f o pi1) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; rapply O_functor_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (f o pi1) x = O_functor g (O_functor pi2 x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk52"><span class="nb">transitivity</span> (O_functor (g o pi2) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (f o pi1) x = O_functor (g o pi2) x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk53"><hr></label><div class="goal-conclusion">O_functor (g o pi2) x = O_functor g (O_functor pi2 x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk54">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (f o pi1) x = O_functor (g o pi2) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_functor_homotopy, comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk55">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pi1</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>pi2</var><span class="hyp-type"><b>: </b><span>X -&gt; B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>f o pi1 == g o pi2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (g o pi2) x = O_functor g (O_functor pi2 x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_functor_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Functoriality on identities *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk56"><span class="kn">Definition</span> <span class="nf">O_functor_idmap</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : @O_functor A A idmap == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor idmap == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor idmap == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk58"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor idmap (to O A x) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** 3-functoriality, as an example use of [O_ind2paths] *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk59"><span class="kn">Definition</span> <span class="nf">O_functor_2homotopy</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B}
               (<span class="nv">p</span> <span class="nv">q</span> : f == g) (<span class="nv">r</span> : p == q)
    : O_functor_homotopy f g p == O_functor_homotopy f g q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p == q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy f g p == O_functor_homotopy f g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p == q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy f g p == O_functor_homotopy f g q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5b"><span class="nb">refine</span> (O_ind2paths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p == q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor_homotopy f g p oD to O A) x =
(O_functor_homotopy f g q oD to O A) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5c"><span class="nb">unfold</span> O_functor_homotopy, composeD.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p == q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (O_functor f) (O_functor g)
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural f x @
   (ap (to O B) (p x) @ (to_O_natural g x)^))
  (to O A x) =
O_indpaths (O_functor f) (O_functor g)
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural f x @
   (ap (to O B) (q x) @ (to_O_natural g x)^))
  (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5d"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> O_indpaths_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>p == q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural f x @
(ap (to O B) (p x) @ (to_O_natural g x)^) =
to_O_natural f x @
(ap (to O B) (q x) @ (to_O_natural g x)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerL, whiskerR, ap, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Of course, if we wanted to prove 4-functoriality, we&#39;d need to make this transparent. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** 2-naturality: Functoriality on homotopies is also natural *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5e"><span class="kn">Definition</span> <span class="nf">O_functor_homotopy_beta</span>
               {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">pi</span> : f == g) (<span class="nv">x</span> : A)
    : O_functor_homotopy f g pi (to O A x)
      = to_O_natural f x
      @ ap (to O B) (pi x)
      @ (to_O_natural g x)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy f g pi (to O A x) =
(to_O_natural f x @ ap (to O B) (pi x)) @
(to_O_natural g x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk5f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_homotopy f g pi (to O A x) =
(to_O_natural f x @ ap (to O B) (pi x)) @
(to_O_natural g x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk60"><span class="nb">unfold</span> O_functor_homotopy, to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (O_functor f) (O_functor g)
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O B (f x0)) x @
   (ap (to O B) (pi x) @
    (O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O B (g x0)) x)^))
  (to O A x) =
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) x @
 ap (to O B) (pi x)) @
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (g x)) x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk61"><span class="nb">refine</span> (O_indpaths_beta _ _ _ x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>pi</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) x @
(ap (to O B) (pi x) @
 (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (g x)) x)^) =
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) x @
 ap (to O B) (pi x)) @
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (g x)) x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p_pp _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The pointed endofunctor ([O],[to O]) is well-pointed *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk62"><span class="kn">Definition</span> <span class="nf">O_functor_wellpointed</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_functor (to O A) == to O (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (to O A) == to O (O_reflector O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (to O A) == to O (O_reflector O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk64"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (to O A) (to O A x) =
to O (O_reflector O A) (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** &quot;Functoriality of naturality&quot;: the pseudonaturality axiom for composition *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk65"><span class="kn">Definition</span> <span class="nf">to_O_natural_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
               (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : A)
    : ap (O_functor g) (to_O_natural f a)
      @ to_O_natural g (f a)
      = (O_functor_compose f g (to O A a))^
      @ to_O_natural (g o f) a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor g) (to_O_natural f a) @
to_O_natural g (f a) =
(O_functor_compose f g (to O A a))^ @
to_O_natural (g o f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor g) (to_O_natural f a) @
to_O_natural g (f a) =
(O_functor_compose f g (to O A a))^ @
to_O_natural (g o f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk67"><span class="nb">unfold</span> O_functor_compose, to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor g)
  (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) a) @
O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O C (g x)) (f a) =
(O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)))
   (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; O_functor g (O_functor f x))
   (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
    O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O C (g (f x0))) x @
    ((O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; to O C (g x0)) (f x))^ @
     ap (O_functor g)
       (O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O B (f x0)) x)^))
   (to O A a))^ @
O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O C (g (f x))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk68"><span class="nb">rewrite</span> O_indpaths_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor g)
  (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) a) @
O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O C (g x)) (f a) =
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O C (g (f x))) a @
 ((O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O C (g x)) (f a))^ @
  ap (O_functor g)
    (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) a)^))^ @
O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O C (g (f x))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk69"><span class="nb">rewrite</span> !inv_pp, ap_V, !inv_V, !concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (O_functor g)
  (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) a) @
O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O C (g x)) (f a) =
ap (O_functor g)
  (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)) a) @
(O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O C (g x)) (f a) @
 ((O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O C (g (f x))) a)^ @
  O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O C (g (f x))) a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> concat_Vp, concat_p1; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The pseudofunctoriality axiom *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6a"><span class="kn">Definition</span> <span class="nf">O_functor_compose_compose</span>
               {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">h</span> : C -&gt; D)
               (<span class="nv">a</span> : O A)
    : O_functor_compose f (h o g) a
      @ O_functor_compose g h (O_functor f a)
      = O_functor_compose (g o f) h a
        @ ap (O_functor h) (O_functor_compose f g a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_compose f (h o g) a @
O_functor_compose g h (O_functor f a) =
O_functor_compose (g o f) h a @
ap (O_functor h) (O_functor_compose f g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_compose f (h o g) a @
O_functor_compose g h (O_functor f a) =
O_functor_compose (g o f) h a @
ap (O_functor h) (O_functor_compose f g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6c"><span class="nb">revert</span> a; <span class="nb">refine</span> (O_ind2paths _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O A =&gt;
 O_functor_compose f (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x @
 O_functor_compose g h (O_functor f x)) oD to O A ==
(<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O A =&gt;
 O_functor_compose (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) h x @
 ap (O_functor h) (O_functor_compose f g x)) oD to O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6d"><span class="nb">intros</span> a; <span class="nb">unfold</span> composeD, O_functor_compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))))
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) (O_functor f x))
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; h (g (f x0))) x @
   ((to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) (f x))^ @
    ap (O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)))
      (to_O_natural f x)^)) (to O A a) @
O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
  (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
   to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x @
   ((to_O_natural h (g x))^ @
    ap (O_functor h) (to_O_natural g x)^))
  (O_functor f (to O A a)) =
O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))))
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   O_functor h (O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x))
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; h (g (f x0))) x @
   ((to_O_natural h (g (f x)))^ @
    ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x)^))
  (to O A a) @
ap (O_functor h)
  (O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)))
     (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; O_functor g (O_functor f x))
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
      to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x @
      ((to_O_natural g (f x))^ @
       ap (O_functor g) (to_O_natural f x)^))
     (to O A a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6e"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))))
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) (O_functor f x))
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; h (g (f x0))) x
   @&#39; ((to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) (f x))^
       @&#39; ap (O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)))
            (to_O_natural f x)^)) (to O A a)
@&#39; O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
     (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
      to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x
      @&#39; ((to_O_natural h (g x))^
          @&#39; ap (O_functor h) (to_O_natural g x)^))
     (O_functor f (to O A a)) =
O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))))
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   O_functor h (O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x))
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; h (g (f x0))) x
   @&#39; ((to_O_natural h (g (f x)))^
       @&#39; ap (O_functor h)
            (to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x)^))
  (to O A a)
@&#39; ap (O_functor h)
     (O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)))
        (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; O_functor g (O_functor f x))
        (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
         to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; g (f x0)) x
         @&#39; ((to_O_natural g (f x))^
             @&#39; ap (O_functor g) (to_O_natural f x)^))
        (to O A a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk6f"><span class="nb">rewrite</span> !O_indpaths_beta, !ap_pp, !ap_V, !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a))^
@&#39; O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
     (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
      to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x
      @&#39; ((to_O_natural h (g x))^
          @&#39; ap (O_functor h) (to_O_natural g x)^))
     (O_functor f (to O A a)) =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a))^
@&#39; ap (O_functor h)
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a)
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk70"><span class="nb">refine</span> (whiskerL _ (apD _ (to_O_natural f a)^)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a))^
@&#39; transport
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O B =&gt;
      O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x =
      O_functor h (O_functor g x)) (to_O_natural f a)^
     (O_indpaths (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
        (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
        (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
         to_O_natural (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x
         @&#39; ((to_O_natural h (g x))^
             @&#39; ap (O_functor h) (to_O_natural g x)^))
        (to O B (f a))) =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a))^
@&#39; ap (O_functor h)
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a)
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk71"><span class="nb">rewrite</span> O_indpaths_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a))^
@&#39; transport
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O B =&gt;
      O_functor (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; h (g x0)) x =
      O_functor h (O_functor g x)) (to_O_natural f a)^
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a)
      @&#39; ((to_O_natural h (g (f a)))^
          @&#39; ap (O_functor h) (to_O_natural g (f a))^)) =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a))^
@&#39; ap (O_functor h)
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a)
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk72"><span class="nb">rewrite</span> transport_paths_FlFr, !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a)^)^
@&#39; to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a)
@&#39; (to_O_natural h (g (f a)))^
@&#39; ap (O_functor h) (to_O_natural g (f a))^
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
     (to_O_natural f a)^ =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a))^
@&#39; ap (O_functor h)
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a)
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk73"><span class="nb">rewrite</span> !ap_V, inv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a))^
@&#39; (ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
      (to_O_natural f a))^
@&#39; ap (O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)))
     (to_O_natural f a)
@&#39; to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; h (g x)) (f a)
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
      (to_O_natural f a))^ =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h)
      (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a))^
@&#39; ap (O_functor h)
     (to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) a)
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk74"><span class="nb">rewrite</span> !concat_pV_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
      (to_O_natural f a))^ =
to_O_natural (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (g (f x))) a
@&#39; (to_O_natural h (g (f a)))^
@&#39; (ap (O_functor h) (to_O_natural g (f a)))^
@&#39; (ap (O_functor h)
      (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk75"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
   (to_O_natural f a))^ =
(ap (O_functor h)
   (ap (O_functor g) (to_O_natural f a)))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk76"><span class="nb">apply</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor h (O_functor g x))
  (to_O_natural f a) =
ap (O_functor h) (ap (O_functor g) (to_O_natural f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Preservation of equivalences *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk77">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_O_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
    : IsEquiv (O_functor f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk78"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk79"><span class="nb">refine</span> (isequiv_adjointify (O_functor f) (O_functor f^-<span class="mi">1</span>) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor f (O_functor f^-<span class="mi">1</span> x)) ==
idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk7a"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; O_functor f^-<span class="mi">1</span> (O_functor f x)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk7b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt; O_functor f (O_functor f^-<span class="mi">1</span> x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk7c"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_functor f^-<span class="mi">1</span> x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk7d"><span class="nb">refine</span> ((O_functor_compose _ _ x)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (f^-<span class="mi">1</span> x)) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk7e"><span class="nb">refine</span> (O_functor_homotopy _ idmap _ x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (f^-<span class="mi">1</span> x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk7f"><hr></label><div class="goal-conclusion">O_functor idmap x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk80">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (f^-<span class="mi">1</span> x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> y; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk81">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor idmap x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_functor_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk82">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; O_functor f^-<span class="mi">1</span> (O_functor f x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk83"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f^-<span class="mi">1</span> (O_functor f x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk84"><span class="nb">refine</span> ((O_functor_compose _ _ x)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk85"><span class="nb">refine</span> (O_functor_homotopy _ idmap _ x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk86"><hr></label><div class="goal-conclusion">O_functor idmap x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk87">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> y; <span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk88">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor idmap x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_functor_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
    : O A &lt;~&gt; O B
    := Build_Equiv _ _ (O_functor f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This is sometimes useful to have a separate name for, to facilitate rewriting along it. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_O_equiv_natural</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
    : (equiv_O_functor f) o (to O A) == (to O B) o f
    := to_O_natural f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This corresponds to [ap O] on the universe. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk89"><span class="kn">Definition</span> <span class="nf">ap_O_path_universe&#39;</span> `{Univalence}
               {A B : <span class="kt">Type</span>} (f : A &lt;~&gt; B)
    : ap O (path_universe_uncurried f)
      = path_universe_uncurried (equiv_O_functor f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap O (path_universe_uncurried f) =
path_universe_uncurried (equiv_O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap O (path_universe_uncurried f) =
path_universe_uncurried (equiv_O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8b"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A &lt;~&gt; B,
ap O (path_universe_uncurried f) =
path_universe_uncurried (equiv_O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8c">equiv_intro (equiv_path A B) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap O (path_universe_uncurried (equiv_path A B p)) =
path_universe_uncurried
  (equiv_O_functor (equiv_path A B p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8d"><span class="nb">refine</span> (ap (ap O) (eta_path_universe p) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap O p =
path_universe_uncurried
  (equiv_O_functor (equiv_path A B p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8e"><span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
path_universe_uncurried
  (equiv_O_functor (equiv_path A A <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk8f"><span class="nb">apply</span> moveL_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (O A) (O A) <span class="mi">1</span> =
equiv_O_functor (equiv_path A A <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk90"><span class="nb">apply</span> path_equiv, path_arrow, O_indpaths; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (O A) (O A) <span class="mi">1</span> (to O A x) =
equiv_O_functor (equiv_path A A <span class="mi">1</span>) (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_O_path_universe</span> `{Univalence}
               {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsEquiv _ _ f}
    : ap O (path_universe f) = path_universe (O_functor f)
    := ap_O_path_universe&#39; (Build_Equiv _ _ f _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Postcomposition respects [O_rec] *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk91"><span class="kn">Definition</span> <span class="nf">O_rec_postcompose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>@{i}} `{In O B} {C_inO : In O C}
               (f : A -&gt; B) (g : B -&gt; C)
    : g o O_rec (O := O) f == O_rec (O := O) (g o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o O_rec f == O_rec (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o O_rec f == O_rec (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk93"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (O_rec f (to O A x)) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk94"><span class="nb">transitivity</span> (g (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (O_rec f (to O A x)) = g (f x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk95"><hr></label><div class="goal-conclusion">g (f x) = O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (to O A x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (O_rec f (to O A x)) = g (f x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk97"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f (to O A x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f x) = O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk99"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>C_inO</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (to O A x) = g (f x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta (g o f) x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** In particular, we have: *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_rec_postcompose_to_O</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{In O B}
    : to O B o O_rec f == O_functor f
    := O_rec_postcompose f (to O B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Replete</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** An equivalent formulation of repleteness is that a type lies in the subuniverse as soon as its unit map is an equivalence. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inO_isequiv_to_O</span> (<span class="nv">T</span>:<span class="kt">Type</span>)
    : IsEquiv (to O T) -&gt; In O T
    := <span class="kr">fun</span> <span class="nv">_</span> =&gt; inO_equiv_inO (O T) (to O T)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** We don&#39;t make this an ordinary instance, but we allow it to solve [In O] constraints if we already have [IsEquiv] as a hypothesis. [Hint Immediate] doesn&#39;t support #[export] in Sections, so we repeat this at the end of the file. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[local]
    <span class="kn">Hint Immediate</span> inO_isequiv_to_O : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9a"><span class="kn">Definition</span> <span class="nf">inO_iff_isequiv_to_O</span> (<span class="nv">T</span>:<span class="kt">Type</span>)
    : In O T &lt;-&gt; IsEquiv (to O T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O T &lt;-&gt; IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O T &lt;-&gt; IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Thus, [T] is in a subuniverse as soon as [to O T] admits a retraction. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9c"><span class="kn">Definition</span> <span class="nf">inO_to_O_retract</span> (<span class="nv">T</span>:<span class="kt">Type</span>) (<span class="nv">mu</span> : O T -&gt; T)
    : mu o (to O T) == idmap -&gt; In O T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mu o to O T == idmap -&gt; In O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mu o to O T == idmap -&gt; In O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9e"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk9f"><span class="nb">apply</span> inO_isequiv_to_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to O T)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka0"><span class="nb">apply</span> isequiv_adjointify <span class="kr">with</span> (g:=mu).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O T =&gt; to O T (mu x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chka1"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; mu (to O T x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O T =&gt; to O T (mu x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka3"><span class="nb">refine</span> (O_indpaths (to O T o mu) idmap _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; to O T (mu (to O T x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; to O T x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (ap (to O T) (H x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>O T -&gt; T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mu o to O T == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; mu (to O T x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** It follows that reflective subuniverses are closed under retracts. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka5"><span class="kn">Definition</span> <span class="nf">inO_retract_inO</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) `{In O B} (s : A -&gt; B) (r : B -&gt; A)
      (K : r o s == idmap)
      : In O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka7">napply (inO_to_O_retract A (r o (to O B)^-<span class="mi">1</span> o (O_functor s))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r ((to O B)^-<span class="mi">1</span> (O_functor s (to O A x)))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka8"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r ((to O B)^-<span class="mi">1</span> (O_functor s (to O A a))) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chka9">lhs <span class="bp">exact</span> (ap (r o (to O B)^-<span class="mi">1</span>) (to_O_natural s a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r ((to O B)^-<span class="mi">1</span> (to O B (s a))) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkaa">lhs nrefine (ap r (eissect _ (s a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (s a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> K.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Replete</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The maps that are inverted by the reflector.  Note that this notation is not (yet) global (because notations in a section cannot be made global); it only exists in this section.  After the section is over, we will redefine it globally. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">O_inverts</span> f := (IsEquiv (O_functor f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">OInverts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkab">#[export] <span class="kn">Instance</span> <span class="nf">O_inverts_O_unit</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_inverts (to O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkad"><span class="nb">refine</span> (isequiv_homotopic (to O (O A)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (O_reflector O A) == O_functor (to O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">symmetry</span>; <span class="nb">apply</span> O_functor_wellpointed.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** A map between modal types that is inverted by [O] is already an equivalence.  This can&#39;t be an [Instance], probably because it causes an infinite regress applying more and more [O_functor]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkae"><span class="kn">Definition</span> <span class="nf">isequiv_O_inverts</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} `{In O B}
      (f : A -&gt; B) `{O_inverts f}
    : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb0"><span class="nb">refine</span> (isequiv_commsq&#39; f (O_functor f) (to O A) (to O B) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_functor f (to O A x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Strangely, even this seems to cause infinite loops *)</span>
    <span class="sd">(** [Hint Immediate isequiv_O_inverts : typeclass_instances.] *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_inverts</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} `{In O B}
      (f : A -&gt; B) `{O_inverts f}
    : A &lt;~&gt; B
    := Build_Equiv _ _ f (isequiv_O_inverts f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb1"><span class="kn">Definition</span> <span class="nf">isequiv_O_rec_O_inverts</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O B} (f : A -&gt; B) `{O_inverts f}
    : IsEquiv (O_rec (O := O) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_rec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_rec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* Not sure why we need [C:=O B] on the next line to get Coq to use two typeclass instances. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb3">rapply (cancelL_isequiv (C:=O B) (to O B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O A =&gt; to O B (O_rec f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_homotopic (O_functor f) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (O_rec_postcompose_to_O f x)^)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_rec_O_inverts</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O B} (f : A -&gt; B) `{O_inverts f}
      : O A &lt;~&gt; B
      := Build_Equiv _ _ _ (isequiv_O_rec_O_inverts f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_to_O_O_inverts</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} (f : A -&gt; B) `{O_inverts f}
      : IsEquiv (to O B o f)
      := isequiv_homotopic (O_functor f o to O A) (to_O_natural f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_to_O_O_inverts</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} (f : A -&gt; B) `{O_inverts f}
      : A &lt;~&gt; O B
      := Build_Equiv _ _ _ (isequiv_to_O_O_inverts f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** If [f] is inverted by [O], then mapping out of it into any modal type is an equivalence.  First we prove a version not requiring funext.  For use in [O_inverts_O_leq] below, we allow the types [A], [B], and [Z] to perhaps live in smaller universes than the one [i] on which our subuniverse lives.  This the first half of Lemma 1.23 of RSS. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb4"><span class="kn">Definition</span> <span class="nf">ooextendable_O_inverts</span>@{a b z i}
               {A : <span class="kt">Type</span>@{a}} {B : <span class="kt">Type</span>@{b}} (f : A -&gt; B) `{O_inverts f}
               (Z : <span class="kt">Type</span>@{z}) `{In@{i} O Z}
      : ooExtendableAlong@{a b z i} f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb6"><span class="nb">refine</span> (cancelL_ooextendable@{a b i z i i i i i} _ _ (to O B) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O B)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkb7"><hr></label><div class="goal-conclusion">ooExtendableAlong (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb8"><span class="mi">1</span>:<span class="bp">exact</span> (extendable_to_O&#39;@{i b z} O B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkb9"><span class="nb">refine</span> (ooextendable_homotopic _ (O_functor f o to O A) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_functor f (to O A x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkba"><hr></label><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_functor f (to O A x))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkbb"><span class="mi">1</span>:<span class="nb">apply</span> to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_functor f (to O A x))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkbc"><span class="nb">refine</span> (ooextendable_compose _ (to O A) (O_functor f) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_functor f)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkbd"><hr></label><div class="goal-conclusion">ooExtendableAlong (to O A)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O A =&gt; Z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_functor f)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply ooextendable_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O A)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O A =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (extendable_to_O&#39;@{i a z} O A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** And now the funext version *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc0"><span class="kn">Definition</span> <span class="nf">isequiv_precompose_O_inverts</span> `{Funext}
               {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{O_inverts f}
               (Z : <span class="kt">Type</span>) `{In O Z}
      : IsEquiv (<span class="kr">fun</span> <span class="nv">g</span>:B-&gt;Z =&gt; g o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc2">srapply (equiv_extendable_isequiv <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ooextendable_O_inverts f Z <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Conversely, if a map is inverted by the representable functor [? -&gt; Z] for all [O]-modal types [Z], then it is inverted by [O].  As before, first we prove a version that doesn&#39;t require funext. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc3"><span class="kn">Definition</span> <span class="nf">O_inverts_from_extendable</span>
               {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} {<span class="nv">B</span> : <span class="kt">Type</span>@{j}} (<span class="nv">f</span> : A -&gt; B)
               (** Without the universe annotations, the result ends up insufficiently polymorphic. *)
               (<span class="nv">e</span> : <span class="kr">forall</span> (<span class="nv">Z</span>:<span class="kt">Type</span>@{k}), In O Z -&gt; ExtendableAlong@{i j k l} <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Z))
      : O_inverts f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc5">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O B -&gt; O A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkc6"><hr></label><div class="goal-conclusion">O_functor f o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkc7"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o O_functor f == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O B -&gt; O A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec (fst (e (O A) _) (to O A)).<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkc9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
o O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkca">srapply O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt;
 O_functor f
   (O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> x))
o to O B == idmap o to O B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkcb"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
  (O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span>
     (to O B b)) = to O B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkcc"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> b) =
to O B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkcd"><span class="nb">assert</span> (e1 := <span class="kr">fun</span> <span class="nv">h</span> <span class="nv">k</span> =&gt; fst (snd (e (O B) _) h k)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O B) b)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) (f a)),
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> b) =
to O B b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkce"><span class="nb">cbn</span> <span class="kr">in</span> e1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">h</span> <span class="nv">k</span> : B -&gt; O B)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, h (f a) = k (f a)),
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> b) =
to O B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkcf"><span class="nb">refine</span> ((e1 (<span class="kr">fun</span> <span class="nv">y</span> =&gt; O_functor f ((fst (e (O A) _) (to O A)).<span class="mi">1</span> y)) (to O B) _).<span class="mi">1</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">h</span> <span class="nv">k</span> : B -&gt; O B)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, h (f a) = k (f a)),
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
O_functor f
  ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> (f a)) =
to O B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd0"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">h</span> <span class="nv">k</span> : B -&gt; O B)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, h (f a) = k (f a)),
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
  ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> (f a)) =
to O B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd1"><span class="nb">rewrite</span> ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">2</span> a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">h</span> <span class="nv">k</span> : B -&gt; O B)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, h (f a) = k (f a)),
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b) g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O A a) = to O B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span>
o O_functor f == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd3">srapply O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
 O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span>
   (O_functor f x)) o to O A == idmap o to O A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd4"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span>
  (O_functor f (to O A a)) = to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd5"><span class="nb">rewrite</span> to_O_natural, O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst (e (O A) (O_inO A)) (to O A)).<span class="mi">1</span> (f a) = to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fst (e (O A) (O_inO A)) (to O A)).<span class="mi">2</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Hint Extern</span> <span class="mi">4</span> =&gt; <span class="kp">progress</span> (<span class="nb">cbv</span> beta iota) : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** And the version with funext.  Use it with universe parameters [i j k l lplus l l l l]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd6"><span class="kn">Definition</span> <span class="nf">O_inverts_from_isequiv_precompose</span> `{Funext}
               {A B : <span class="kt">Type</span>} (f : A -&gt; B)
               (e : <span class="kr">forall</span> (<span class="nv">Z</span>:<span class="kt">Type</span>), In O Z -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span>:B-&gt;Z =&gt; g o f))
      : O_inverts f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd8"><span class="nb">apply</span> O_inverts_from_extendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkd9"><span class="nb">intros</span> Z ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply ((equiv_extendable_isequiv <span class="mi">0</span> _ _)^-<span class="mi">1</span>%equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This property also characterizes the types in the subuniverse, which is the other half of Lemma 1.23. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkda"><span class="kn">Definition</span> <span class="nf">inO_ooextendable_O_inverts</span> (<span class="nv">Z</span>:<span class="kt">Type</span>@{k})
               (<span class="nv">E</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) (<span class="nv">B</span> : <span class="kt">Type</span>@{j}) (<span class="nv">f</span> : A -&gt; B)
                      (<span class="nv">Oif</span> : O_inverts f),
                   ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Z))
      : In O Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt;
ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkdb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt;
ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkdc"><span class="nb">pose</span> (EZ := fst (E Z (O Z) (to O Z) _ <span class="mi">1</span>%nat) idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt;
ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</span></span></span><br><span><var>EZ</var><span><span class="hyp-body"><b>:= </b><span>fst (E Z (O Z) (to O Z) (O_inverts_O_unit Z) <span class="mi">1</span>)
  idmap</span></span><span class="hyp-type"><b>: </b><span>ExtensionAlong (to O Z) (<span class="kr">fun</span> <span class="nv">_</span> : O Z =&gt; Z) idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_to_O_retract _ EZ.<span class="mi">1</span> EZ.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** A version with the equivalence form of the extension condition. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkdd"><span class="kn">Definition</span> <span class="nf">inO_isequiv_precompose_O_inverts</span> (<span class="nv">Z</span>:<span class="kt">Type</span>)
               (<span class="nv">Yo</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
                       (<span class="nv">Oif</span> : O_inverts f),
                   IsEquiv (<span class="kr">fun</span> <span class="nv">g</span>:B-&gt;Z =&gt; g o f))
      : In O Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Yo</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkde"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Yo</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkdf"><span class="nb">pose</span> (EZ := extension_isequiv_precompose (to O Z) _ (Yo Z (O Z) (to O Z) _) idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Yo</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
O_inverts f -&gt; IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : B -&gt; Z =&gt; g o f)</span></span></span><br><span><var>EZ</var><span><span class="hyp-body"><b>:= </b><span>extension_isequiv_precompose (to O Z)
  (<span class="kr">fun</span> <span class="nv">_</span> : O Z =&gt; Z)
  (Yo Z (O Z) (to O Z) (O_inverts_O_unit Z)) idmap</span></span><span class="hyp-type"><b>: </b><span>ExtensionAlong (to O Z) (<span class="kr">fun</span> <span class="nv">_</span> : O Z =&gt; Z) idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_to_O_retract _ EZ.<span class="mi">1</span> EZ.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke0"><span class="kn">Definition</span> <span class="nf">to_O_inv_natural</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} `{In O B}
               (f : A -&gt; B)
    : (to O B)^-<span class="mi">1</span> o (O_functor f) == f o (to O A)^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> o O_functor f == f o (to O A)^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> o O_functor f == f o (to O A)^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke2"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor f (to O A x)) =
f ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke3"><span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O A x) =
to O B (f ((to O A)^-<span class="mi">1</span> (to O A x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke4"><span class="nb">refine</span> (to_O_natural f x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O B (f x) = to O B (f ((to O A)^-<span class="mi">1</span> (to O A x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke5"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = (to O A)^-<span class="mi">1</span> (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Two maps between modal types that become equal after applying [O_functor] are already equal. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke6"><span class="kn">Definition</span> <span class="nf">O_functor_faithful_inO</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} `{In O B}
      (f g : A -&gt; B) (e : O_functor f == O_functor g)
      : f == g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke8"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chke9"><span class="nb">refine</span> (ap f (eissect (to O A) x)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((to O A)^-<span class="mi">1</span> (to O A x)) = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkea"><span class="nb">refine</span> (_ @ ap g (eissect (to O A) x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((to O A)^-<span class="mi">1</span> (to O A x)) =
g ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkeb"><span class="nb">transitivity</span> ((to O B)^-<span class="mi">1</span> (O_functor f (to O A x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((to O A)^-<span class="mi">1</span> (to O A x)) =
(to O B)^-<span class="mi">1</span> (O_functor f (to O A x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkec"><hr></label><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor f (to O A x)) =
g ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chked">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((to O A)^-<span class="mi">1</span> (to O A x)) =
(to O B)^-<span class="mi">1</span> (O_functor f (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> to_O_inv_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkee">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor f (to O A x)) =
g ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkef"><span class="nb">transitivity</span> ((to O B)^-<span class="mi">1</span> (O_functor g (to O A x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor f (to O A x)) =
(to O B)^-<span class="mi">1</span> (O_functor g (to O A x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkf0"><hr></label><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor g (to O A x)) =
g ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor f (to O A x)) =
(to O B)^-<span class="mi">1</span> (O_functor g (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O_functor f == O_functor g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O B)^-<span class="mi">1</span> (O_functor g (to O A x)) =
g ((to O A)^-<span class="mi">1</span> (to O A x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_inv_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Any map to a type in the subuniverse that is inverted by [O] must be equivalent to [to O].  More precisely, the type of such maps is contractible. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">typeof_to_O</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
      := { OA : <span class="kt">Type</span> &amp; { Ou : A -&gt; OA &amp; ((In O OA) * (O_inverts Ou)) }}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf3">#[export] <span class="kn">Instance</span> <span class="nf">contr_typeof_O_unit</span> `{Univalence} (A : <span class="kt">Type</span>)
    : Contr (typeof_to_O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (typeof_to_O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (typeof_to_O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf5"><span class="nb">apply</span> (Build_Contr _ (O A ; (to O A ; (_ , _)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {OA : <span class="kt">Type</span> &amp;
    {Ou : A -&gt; OA &amp; In O OA * O_inverts Ou}},
(O A; to O A; (O_inO A, O_inverts_O_unit A)) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf6"><span class="nb">intros</span> [OA [Ou [? ?]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O A; to O A; (O_inO A, O_inverts_O_unit A)) =
(OA; Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf7"><span class="nb">pose</span> (f := O_rec Ou : O A -&gt; OA).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O A; to O A; (O_inO A, O_inverts_O_unit A)) =
(OA; Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf8"><span class="nb">pose</span> (g := (O_functor Ou)^-<span class="mi">1</span> o to O OA : (OA -&gt; O A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O A; to O A; (O_inO A, O_inverts_O_unit A)) =
(OA; Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkf9"><span class="nb">assert</span> (IsEquiv f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkfa"><hr></label><div class="goal-conclusion">(O A; to O A; (O_inO A, O_inverts_O_unit A)) =
(OA; Ou; (fst, snd))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkfb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkfc"><span class="nb">refine</span> (isequiv_adjointify f g _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : OA =&gt; f (g x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chkfd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chkfd"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; g (f x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkfe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : OA =&gt; f (g x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chkff"><span class="nb">apply</span> O_functor_faithful_inO; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (<span class="kr">fun</span> <span class="nv">x</span> : OA =&gt; f (g x)) x =
O_functor idmap x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk100"><span class="nb">rewrite</span> O_functor_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (<span class="kr">fun</span> <span class="nv">x</span> : OA =&gt; f (g x)) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk101"><span class="nb">rewrite</span> O_functor_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_functor g x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk102"><span class="nb">unfold</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
  (O_functor
     (<span class="kr">fun</span> <span class="nv">x</span> : OA =&gt; (O_functor Ou)^-<span class="mi">1</span> (to O OA x)) x) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk103"><span class="nb">rewrite</span> (O_functor_compose (to O OA) (O_functor Ou)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
  (O_functor (O_functor Ou)^-<span class="mi">1</span> (O_functor (to O OA) x)) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk104"><span class="nb">rewrite</span> O_functor_wellpointed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f
  (O_functor (O_functor Ou)^-<span class="mi">1</span>
     (to O (O_reflector O OA) x)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk105"><span class="nb">rewrite</span> (to_O_natural (O_functor Ou)^-<span class="mi">1</span> x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O (O A) ((O_functor Ou)^-<span class="mi">1</span> x)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk106"><span class="nb">refine</span> (to_O_natural f _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O OA (f ((O_functor Ou)^-<span class="mi">1</span> x)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk107"><span class="nb">set</span> (y := (O_functor Ou)^-<span class="mi">1</span> x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> x</span></span><span class="hyp-type"><b>: </b><span>O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O OA (f y) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk108"><span class="nb">transitivity</span> (O_functor Ou y); [ | <span class="nb">apply</span> eisretr].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> x</span></span><span class="hyp-type"><b>: </b><span>O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O OA (f y) = O_functor Ou y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk109"><span class="nb">unfold</span> f, O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O OA</span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> x</span></span><span class="hyp-type"><b>: </b><span>O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O OA (O_rec Ou y) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O OA (Ou x)) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_postcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt; g (f x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10b"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f (to O A x)) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10c"><span class="nb">unfold</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (O_rec Ou (to O A x)) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10d"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (Ou x) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10e"><span class="nb">unfold</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor Ou)^-<span class="mi">1</span> (to O OA (Ou x)) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk10f"><span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O OA (Ou x) = O_functor Ou (to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk110">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O A; to O A; (O_inO A, O_inverts_O_unit A)) =
(OA; Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk111"><span class="nb">simple refine</span> (path_sigma _ _ _ _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O A = OA</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk112" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk112"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">OA</span> : <span class="kt">Type</span> =&gt;
   {Ou : A -&gt; OA &amp; In O OA * O_inverts Ou}) <span class="nl">?Goal</span>
  (to O A; (O_inO A, O_inverts_O_unit A)) =
(Ou; (fst, snd))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk113">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O A = OA</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_universe f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk114">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">OA</span> : <span class="kt">Type</span> =&gt;
   {Ou : A -&gt; OA &amp; In O OA * O_inverts Ou})
  (path_universe f)
  (to O A; (O_inO A, O_inverts_O_unit A)) =
(Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk115"><span class="nb">rewrite</span> transport_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; A -&gt; x) (path_universe f)
   (to O A; (O_inO A, O_inverts_O_unit A)).<span class="mi">1</span>;
transportD (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; A -&gt; x)
  (<span class="kr">fun</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : A -&gt; x) =&gt; In O x * O_inverts y)
  (path_universe f)
  (to O A; (O_inO A, O_inverts_O_unit A)).<span class="mi">1</span>
  (to O A; (O_inO A, O_inverts_O_unit A)).<span class="mi">2</span>) =
(Ou; (fst, snd))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk116"><span class="nb">simple refine</span> (path_sigma _ _ _ _ _); <span class="nb">cbn</span>; [ | <span class="nb">apply</span> path_ishprop].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; A -&gt; x) (path_universe f)
  (to O A) = Ou</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk117"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; A -&gt; x) (path_universe f)
  (to O A) x = Ou x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk118"><span class="nb">rewrite</span> transport_arrow_fromconst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe f) (to O A x) = Ou x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk119"><span class="nb">rewrite</span> transport_path_universe.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, OA</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ou</var><span class="hyp-type"><b>: </b><span>A -&gt; OA</span></span></span><br><span><var>fst</var><span class="hyp-type"><b>: </b><span>In O OA</span></span></span><br><span><var>snd</var><span class="hyp-type"><b>: </b><span>O_inverts Ou</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>O_rec Ou : O A -&gt; OA</span></span><span class="hyp-type"><b>: </b><span>O A -&gt; OA</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>(O_functor Ou)^-<span class="mi">1</span> o to O OA : OA -&gt; O A</span></span><span class="hyp-type"><b>: </b><span>OA -&gt; O A</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (to O A x) = Ou x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> f; <span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">OInverts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Types</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** The [Unit] type *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11a">#[export] <span class="kn">Instance</span> <span class="nf">inO_unit</span> : In O Unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11c"><span class="nb">apply</span> inO_to_O_retract@{<span class="kt">Set</span>} <span class="kr">with</span> (mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unit_name tt == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@contr@{<span class="kt">Set</span>} Unit _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** It follows that any contractible type is in [O]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11d">#[export] <span class="kn">Instance</span> <span class="nf">inO_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{Contr A} : In O A | <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO@{<span class="kt">Set</span> _ _} Unit equiv_contr_unit^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** And that the reflection of a contractible type is still contractible. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk11f">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">contr_O_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{Contr A} : Contr (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk120"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv A (to O A)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Dependent product and arrows *)</span>
    <span class="sd">(** Theorem 7.7.2 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk121">#[export] <span class="kn">Instance</span> <span class="nf">inO_forall</span> {<span class="nv">fs</span> : Funext} (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">B</span>:A -&gt; <span class="kt">Type</span>)
    : (<span class="kr">forall</span> <span class="nv">x</span>, (In O (B x)))
      -&gt; (In O (<span class="kr">forall</span> <span class="nv">x</span>:A, (B x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)) -&gt; In O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)) -&gt; In O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk123"><span class="nb">intro</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk124"><span class="nb">pose</span> (ev := <span class="kr">fun</span> <span class="nv">x</span> =&gt; (<span class="kr">fun</span> (<span class="nv">f</span>:(<span class="kr">forall</span> <span class="nv">x</span>, (B x))) =&gt; f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>ev</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) =&gt; f x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk125"><span class="nb">pose</span> (zz := <span class="kr">fun</span> <span class="nv">x</span>:A =&gt; O_rec (O := O) (ev x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>ev</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) =&gt; f x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br><span><var>zz</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_rec (ev x)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A,
O_reflector O (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk126"><span class="nb">apply</span> inO_to_O_retract <span class="kr">with</span> (mu := <span class="kr">fun</span> <span class="nv">z</span> =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; zz x z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>ev</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) =&gt; f x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br><span><var>zz</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_rec (ev x)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A,
O_reflector O (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">x0</span> : A) =&gt;
 zz x0 (to O (<span class="kr">forall</span> <span class="nv">x1</span> : A, B x1) x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk127"><span class="nb">intro</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>ev</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) =&gt; f x</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br><span><var>zz</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; O_rec (ev x)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A,
O_reflector O (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) -&gt; B x</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; zz x (to O (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) phi)) =
phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk128"><span class="nb">unfold</span> zz, ev; <span class="nb">clear</span> zz; <span class="nb">clear</span> ev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_rec (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0 =&gt; f x)
   (to O (<span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) phi)) = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk129"><span class="nb">apply</span> path_forall; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In O (B x)</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x =&gt; f x)
  (to O (<span class="kr">forall</span> <span class="nv">x</span> : A, B x) phi) = phi x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x0</span>, (B x0) =&gt; f x) phi).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12a">#[export] <span class="kn">Instance</span> <span class="nf">inO_arrow</span> {<span class="nv">fs</span> : Funext} (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) `{In O B}
    : In O (A -&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A -&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A -&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12c"><span class="nb">apply</span> inO_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; In O B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12d"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Product *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12e">#[export] <span class="kn">Instance</span> <span class="nf">inO_prod</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) `{In O A} `{In O B}
    : In O (A*B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk12f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk130"><span class="nb">apply</span> inO_to_O_retract <span class="kr">with</span>
        (mu := <span class="kr">fun</span> <span class="nv">X</span> =&gt; (@O_rec _ (A * B) A _ _ _ fst X , O_rec snd X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt;
 (O_rec fst (to O (A * B) x),
 O_rec snd (to O (A * B) x))) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk131"><span class="nb">intros</span> [a b]; <span class="nb">apply</span> path_prod; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec fst (to O (A * B) (a, b)) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk132"><hr></label><div class="goal-conclusion">O_rec snd (to O (A * B) (a, b)) = b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk133">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec fst (to O (A * B) (a, b)) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta fst (a,b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk134">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec snd (to O (A * B) (a, b)) = b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta snd (a,b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Two ways to define a map [O(A * B) -&gt; X * Y] agree. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk135"><span class="kn">Definition</span> <span class="nf">O_rec_functor_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} `{In O X} `{In O Y}
      (f : A -&gt; X) (g : B -&gt; Y)
      : O_rec (functor_prod f g) == prod_coind (O_rec (f o fst : A * B -&gt; X))
                                               (O_rec (g o snd : A * B -&gt; Y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (functor_prod f g) ==
prod_coind (O_rec (f o fst : A * B -&gt; X))
  (O_rec (g o snd : A * B -&gt; Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk136"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (functor_prod f g) ==
prod_coind (O_rec (f o fst : A * B -&gt; X))
  (O_rec (g o snd : A * B -&gt; Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk137"><span class="nb">apply</span> O_indpaths; <span class="nb">intro</span> ab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>ab</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (functor_prod f g) (to O (A * B) ab) =
prod_coind (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; f (fst x)))
  (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; g (snd x)))
  (to O (A * B) ab)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk138"><span class="nb">unfold</span> functor_prod, prod_coind, prod_coind_uncurried; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>ab</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">z</span> : A * B =&gt; (f (fst z), g (snd z)))
  (to O (A * B) ab) =
(O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; f (fst x)) (to O (A * B) ab),
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; g (snd x)) (to O (A * B) ab))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk139">lhs (napply O_rec_beta).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>ab</var><span class="hyp-type"><b>: </b><span>A * B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (fst ab), g (snd ab)) =
(O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; f (fst x)) (to O (A * B) ab),
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt; g (snd x)) (to O (A * B) ab))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">cbn</span>; <span class="nb">symmetry</span>; napply O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** We show that [OA*OB] has the same universal property as [O(A*B)] *)</span>

    <span class="sd">(** Here is the map witnessing the universal property.  *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_prod_unit</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : A * B -&gt; O A * O B
      := functor_prod (to O A) (to O B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** We express the universal property without funext, using extensions. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13a"><span class="kn">Definition</span> <span class="nf">ooextendable_O_prod_unit</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) `{In O C}
      : ooExtendableAlong (O_prod_unit A B) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_prod_unit A B)
  (<span class="kr">fun</span> <span class="nv">_</span> : O A * O B =&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_prod_unit A B)
  (<span class="kr">fun</span> <span class="nv">_</span> : O A * O B =&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13c"><span class="nb">apply</span> ooextendable_functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O B -&gt; ooExtendableAlong (to O A) (<span class="kr">fun</span> <span class="nv">_</span> : O A =&gt; C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk13d"><hr></label><div class="goal-conclusion">O A -&gt; ooExtendableAlong (to O B) (<span class="kr">fun</span> <span class="nv">_</span> : O B =&gt; C)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="nb">intros</span>; rapply extendable_to_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here&#39;s the version with funext. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13e"><span class="kn">Definition</span> <span class="nf">isequiv_O_prod_unit_precompose</span>
               {<span class="nv">fs</span> : Funext} (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) `{In O C}
      : IsEquiv (<span class="kr">fun</span> (<span class="nv">f</span> : (O A) * (O B) -&gt; C) =&gt; f o O_prod_unit A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">f</span> : O A * O B -&gt; C =&gt; f o O_prod_unit A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk13f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">f</span> : O A * O B -&gt; C =&gt; f o O_prod_unit A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk140">rapply isequiv_ooextendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_prod_unit A B)
  (<span class="kr">fun</span> <span class="nv">_</span> : O A * O B =&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply ooextendable_O_prod_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_prod_unit_precompose</span>
               {<span class="nv">fs</span> : Funext} (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) `{In O C}
      : ((O A) * (O B) -&gt; C) &lt;~&gt; (A * B -&gt; C)
      := Build_Equiv _ _ _ (isequiv_O_prod_unit_precompose A B C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The (funext-free) universal property implies that [O_prod_unit] is an [O]-equivalence, hence induces an equivalence between [O (A*B)] and [O A * O B]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk141">#[export] <span class="kn">Instance</span> <span class="nf">O_inverts_O_prod_unit</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
      : O_inverts (O_prod_unit A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (O_prod_unit A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk142"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (O_prod_unit A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk143">rapply O_inverts_from_extendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt;
ExtendableAlong <span class="mi">2</span> (O_prod_unit A B)
  (<span class="kr">fun</span> <span class="nv">_</span> : O A * O B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; rapply ooextendable_O_prod_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_prod_cmp</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : O (A * B) -&gt; O A * O B
      := O_rec (O_prod_unit A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk144">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_O_prod_cmp</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
      : IsEquiv (O_prod_cmp A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_prod_cmp A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk145"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_prod_cmp A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isequiv_O_rec_O_inverts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_prod_cmp</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
      : O (A * B) &lt;~&gt; (O A * O B)
      := Build_Equiv _ _ (O_prod_cmp A B) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk146"><span class="kn">Definition</span> <span class="nf">equiv_path_O_prod</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} {<span class="nv">x0</span> <span class="nv">x1</span> : X} {<span class="nv">y0</span> <span class="nv">y1</span> : Y}
      : (to O _ (x0, y0) = to O _ (x1, y1))
          &lt;~&gt; (to O _ x0 = to O _ x1) * (to O _ y0 = to O _ y1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (X * Y) (x0, y0) = to O (X * Y) (x1, y1) &lt;~&gt;
(to O X x0 = to O X x1) * (to O Y y0 = to O Y y1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk147"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (X * Y) (x0, y0) = to O (X * Y) (x1, y1) &lt;~&gt;
(to O X x0 = to O X x1) * (to O Y y0 = to O Y y1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk148"><span class="nb">refine</span> (_ oE equiv_ap&#39; (equiv_O_prod_cmp _ _) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_prod_cmp X Y (to O (X * Y) (x0, y0)) =
equiv_O_prod_cmp X Y (to O (X * Y) (x1, y1)) &lt;~&gt;
(to O X x0 = to O X x1) * (to O Y y0 = to O Y y1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk149"><span class="nb">refine</span> (_ oE equiv_concat_lr _ _); <span class="kp">only</span> <span class="mi">2</span>: <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> = <span class="nl">?Goal1</span> &lt;~&gt;
(to O X x0 = to O X x1) * (to O Y y0 = to O Y y1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk14a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk14a"><hr></label><div class="goal-conclusion">equiv_O_prod_cmp X Y (to O (X * Y) (x0, y0)) = <span class="nl">?Goal0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk14b"><hr></label><div class="goal-conclusion">equiv_O_prod_cmp X Y (to O (X * Y) (x1, y1)) = <span class="nl">?Goal1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk14c"><span class="mi">2</span>,<span class="mi">3</span>: <span class="nb">apply</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y0, y1</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_prod_unit X Y (x0, y0) = O_prod_unit X Y (x1, y1) &lt;~&gt;
(to O X x0 = to O X x1) * (to O Y y0 = to O Y y1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_prod _ _)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_prod_cmp_coind</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
      : O_prod_cmp A B == prod_coind (O_rec (to O _ o fst : A * B -&gt; O A))
                                     (O_rec (to O _ o snd : A * B -&gt; O B))
      := O_rec_functor_prod _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Pullbacks *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk14d">#[export] <span class="kn">Instance</span> <span class="nf">inO_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
           `{In O A} `{In O B} `{In O C}
      : In O (Pullback f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (Pullback f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk14e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (Pullback f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk14f">srapply inO_to_O_retract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pullback f g) -&gt; Pullback f g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk150" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk150"><hr></label><div class="goal-conclusion"><span class="nl">?mu</span> o to O (Pullback f g) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk151">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pullback f g) -&gt; Pullback f g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk152"><span class="nb">intros</span> op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>O (Pullback f g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pullback f g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk153"><span class="kr">exists</span> (<span class="nv">O_rec</span> <span class="nv">pr1</span> <span class="nv">op</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>O (Pullback f g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{c : C &amp; f (O_rec pr1 op) = g c}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk154"><span class="kr">exists</span> (<span class="nv">O_rec</span> (<span class="kr">fun</span> <span class="nv">p</span> =&gt; p.<span class="mi">2</span>.<span class="mi">1</span>) op).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>O (Pullback f g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (O_rec pr1 op) =
g
  (O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     op)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk155"><span class="nb">revert</span> op; <span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> [b [c a]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (O_rec pr1 (to O (Pullback f g) (b; c; a))) =
g
  (O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     (to O (Pullback f g) (b; c; a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk156"><span class="nb">refine</span> (ap f (O_rec_beta _ _) @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f b =
g
  (O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     (to O (Pullback f g) (b; c; a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a @ ap g (O_rec_beta _ _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk157">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">op</span> : O (Pullback f g) =&gt;
 (O_rec pr1 op;
 O_rec
   (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
   op;
 O_indpaths
   (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
    f (O_rec pr1 x))
   (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
    g
      (O_rec
         (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
          (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
   ((<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
     (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">proj2</span> : {c : C &amp; f b = g c}) =&gt;
      (<span class="kr">fun</span> (<span class="nv">c</span> : C) (<span class="nv">a</span> : f b = g c) =&gt;
       ap f (O_rec_beta pr1 (b; c; a)) @
       (a @
        ap g
          (O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : ... =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
             (b; c; a))^
        :
        f (b; c; a).<span class="mi">1</span> =
        g
          (O_rec (<span class="kr">fun</span> <span class="nv">p</span> : ... =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
             (to O (Pullback f g) (b; c; a)))))
        proj2.<span class="mi">1</span> proj2.<span class="mi">2</span>) x.<span class="mi">1</span> x.<span class="mi">2</span>)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
     f (O_rec pr1 (to O (Pullback f g) x))) ==
    (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
     g
       (O_rec
          (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
           (p.<span class="mi">2</span>).<span class="mi">1</span>) (to O (Pullback f g) x)))) op))
o to O (Pullback f g) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk158"><span class="nb">intros</span> [b [c a]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_rec pr1 (to O (Pullback f g) (b; c; a));
O_rec
  (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
  (to O (Pullback f g) (b; c; a));
O_indpaths
  (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
   f (O_rec pr1 x))
  (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
   g
     (O_rec
        (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
         (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
   ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
   ((x.<span class="mi">2</span>).<span class="mi">2</span> @
    ap g
      (O_rec_beta (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
         (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
  (to O (Pullback f g) (b; c; a))) = (b; c; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk159">srapply path_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec pr1 (to O (Pullback f g) (b; c; a)) = b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk15a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk15a"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; {c : C &amp; f b = g c}) <span class="nl">?p</span>
  (O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     (to O (Pullback f g) (b; c; a));
  O_indpaths
    (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
     f (O_rec pr1 x))
    (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
     g
       (O_rec
          (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
           (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
    (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
     ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
     ((x.<span class="mi">2</span>).<span class="mi">2</span> @
      ap g
        (O_rec_beta
           (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
           (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
    (to O (Pullback f g) (b; c; a))) = (c; a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk15b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec pr1 (to O (Pullback f g) (b; c; a)) = b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk15c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; {c : C &amp; f b = g c})
  (O_rec_beta pr1 (b; c; a))
  (O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     (to O (Pullback f g) (b; c; a));
  O_indpaths
    (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
     f (O_rec pr1 x))
    (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
     g
       (O_rec
          (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
           (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
    (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
     ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
     ((x.<span class="mi">2</span>).<span class="mi">2</span> @
      ap g
        (O_rec_beta
           (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
           (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
    (to O (Pullback f g) (b; c; a))) = (c; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk15d"><span class="nb">refine</span> (transport_sigma&#39; _ _ @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_rec
   (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
   (to O (Pullback f g) (b; c; a));
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
   f x =
   g
     (O_rec
        (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
         (p.<span class="mi">2</span>).<span class="mi">1</span>) (to O (Pullback f g) (b; c; a))))
  (O_rec_beta pr1 (b; c; a))
  (O_indpaths
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
      f (O_rec pr1 x))
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
      g
        (O_rec
           (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
            (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
      ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
      ((x.<span class="mi">2</span>).<span class="mi">2</span> @
       ap g
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
            (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
     (to O (Pullback f g) (b; c; a)))) = (c; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk15e">srapply path_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
  (to O (Pullback f g) (b; c; a)) = c</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk15f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk15f"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : C =&gt; f b = g y) <span class="nl">?p</span>
  (transport
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
      f x =
      g
        (O_rec
           (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
            (p.<span class="mi">2</span>).<span class="mi">1</span>) (to O (Pullback f g) (b; c; a))))
     (O_rec_beta pr1 (b; c; a))
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
         f (O_rec pr1 x))
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
         g
           (O_rec
              (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}}
               =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
        (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
         ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
         ((x.<span class="mi">2</span>).<span class="mi">2</span> @
          ap g
            (O_rec_beta
               (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
               (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
        (to O (Pullback f g) (b; c; a)))) = a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk160">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
  (to O (Pullback f g) (b; c; a)) = c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk161">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>f b = g c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : C =&gt; f b = g y)
  (O_rec_beta
     (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>)
     (b; c; a))
  (transport
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
      f x =
      g
        (O_rec
           (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}} =&gt;
            (p.<span class="mi">2</span>).<span class="mi">1</span>) (to O (Pullback f g) (b; c; a))))
     (O_rec_beta pr1 (b; c; a))
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
         f (O_rec pr1 x))
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (Pullback f g) =&gt;
         g
           (O_rec
              (<span class="kr">fun</span> <span class="nv">p</span> : {b : B &amp; {c : C &amp; f b = g c}}
               =&gt; (p.<span class="mi">2</span>).<span class="mi">1</span>) x))
        (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
         ap f (O_rec_beta pr1 (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>)) @
         ((x.<span class="mi">2</span>).<span class="mi">2</span> @
          ap g
            (O_rec_beta
               (<span class="kr">fun</span> <span class="nv">x0</span> : Pullback f g =&gt; (x0.<span class="mi">2</span>).<span class="mi">1</span>)
               (x.<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">1</span>; (x.<span class="mi">2</span>).<span class="mi">2</span>))^))
        (to O (Pullback f g) (b; c; a)))) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
          <span class="nb">rewrite</span> transport_paths_Fr;
          <span class="nb">rewrite</span> transport_paths_Fl;
          <span class="nb">rewrite</span> O_indpaths_beta;
          <span class="nb">rewrite</span> concat_V_pp;
          <span class="nb">rewrite</span> ap_V;
          <span class="nb">apply</span> concat_pV_p ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Fibers *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk162">#[export] <span class="kn">Instance</span> <span class="nf">inO_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O A} `{In O B}
           (f : A -&gt; B) (b : B)
    : In O (hfiber f b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk164"><span class="nb">simple refine</span> (inO_to_O_retract _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber f b) -&gt; hfiber f b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk165" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk165"><hr></label><div class="goal-conclusion"><span class="nl">?mu</span> o to O (hfiber f b) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk166">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber f b) -&gt; hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk167"><span class="nb">intros</span> x; <span class="nb">simple refine</span> (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (hfiber f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (hfiber f b)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk168"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk169">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (hfiber f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec pr1 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (hfiber f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) (O_rec pr1 x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16b"><span class="nb">revert</span> x; <span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>hfiber f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (O_rec pr1 (to O (hfiber f b) x)) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16c"><span class="nb">refine</span> (ap f (O_rec_beta pr1 x) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>hfiber f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x.<span class="mi">1</span> = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (x.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O (hfiber f b) =&gt;
 (O_rec pr1 x;
 O_indpaths
   (<span class="kr">fun</span> <span class="nv">x0</span> : O_reflector O (hfiber f b) =&gt;
    f (O_rec pr1 x0))
   (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O (hfiber f b) =&gt; b)
   ((<span class="kr">fun</span> <span class="nv">x0</span> : hfiber f b =&gt;
     ap f (O_rec_beta pr1 x0) @ x0.<span class="mi">2</span>
     :
     f (O_rec pr1 (to O (hfiber f b) x0)) = b)
    :
    (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber f b =&gt;
     f (O_rec pr1 (to O (hfiber f b) x0))) ==
    (<span class="kr">fun</span> <span class="nv">_</span> : hfiber f b =&gt; b)) x)) o to O (hfiber f b) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk16e"><span class="nb">intros</span> [a p]; <span class="nb">simple refine</span> (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec pr1 (to O (hfiber f b) (a; p)) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk16f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk16f"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) <span class="nl">?p</span>
  (O_indpaths
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (hfiber f b) =&gt;
      f (O_rec pr1 x))
     (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O (hfiber f b) =&gt; b)
     (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f b =&gt;
      ap f (O_rec_beta pr1 x) @ x.<span class="mi">2</span>)
     (to O (hfiber f b) (a; p))) = p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk170">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec pr1 (to O (hfiber f b) (a; p)) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta pr1 (a;p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk171">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b)
  (O_rec_beta pr1 (a; p))
  (O_indpaths
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O (hfiber f b) =&gt;
      f (O_rec pr1 x))
     (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O (hfiber f b) =&gt; b)
     (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f b =&gt;
      ap f (O_rec_beta pr1 x) @ x.<span class="mi">2</span>)
     (to O (hfiber f b) (a; p))) = p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk172"><span class="nb">refine</span> (ap (transport _ _) (O_indpaths_beta _ _ _ _) @ _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b)
  (O_rec_beta pr1 (a; p))
  (ap f (O_rec_beta pr1 (a; p)) @ p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk173"><span class="nb">refine</span> (transport_paths_Fl _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (O_rec_beta pr1 (a; p)))^ @
(ap f (O_rec_beta pr1 (a; p)) @ p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_V_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inO_unsigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>)
               `{In O A} {B_inO : In O {x:A &amp; B x}} (x : A)
    : In O (B x)
    := inO_equiv_inO _ (hfiber_fibration x B)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[local]
    <span class="kn">Hint Immediate</span> inO_unsigma : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The reflector preserving hfibers is a characterization of lex modalities.  Here is the comparison map. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk174"><span class="kn">Definition</span> <span class="nf">O_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
    : O (hfiber f b) -&gt; hfiber (O_functor f) (to O B b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber f b) -&gt; hfiber (O_functor f) (to O B b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk175"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber f b) -&gt; hfiber (O_functor f) (to O B b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk176"><span class="nb">apply</span> O_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber (O_functor f) (to O B b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk177"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (O_functor f) (to O B b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk178"><span class="kr">exists</span> (<span class="nv">to</span> <span class="nv">O</span> <span class="nv">A</span> <span class="nv">a</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (to O A a) = to O B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk179"><span class="nb">refine</span> (to_O_natural f a @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O B (f a) = to O B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17a"><span class="kn">Definition</span> <span class="nf">O_functor_hfiber_natural</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
      : (O_functor_hfiber f b) o to O (hfiber f b) == functor_hfiber (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (to_O_natural f u)^) b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_hfiber f b o to O (hfiber f b) ==
functor_hfiber (<span class="kr">fun</span> <span class="nv">u</span> : A =&gt; (to_O_natural f u)^) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_hfiber f b o to O (hfiber f b) ==
functor_hfiber (<span class="kr">fun</span> <span class="nv">u</span> : A =&gt; (to_O_natural f u)^) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17c"><span class="nb">intros</span> [a p]; <span class="nb">unfold</span> O_functor_hfiber, functor_hfiber, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
   (to O A X.<span class="mi">1</span>; to_O_natural f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))
  (to O (hfiber f b) (a; p)) =
(to O A a; ((to_O_natural f a)^)^ @ ap (to O B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17d"><span class="nb">refine</span> (O_rec_beta _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to O A a; to_O_natural f a @ ap (to O B) p) =
(to O A a; ((to_O_natural f a)^)^ @ ap (to O B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (inv_V _ @@ <span class="mi">1</span>))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** [functor_sigma] over [idmap] preserves [O]-equivalences. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17e"><span class="kn">Definition</span> <span class="nf">O_inverts_functor_sigma_id</span> {<span class="nv">A</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>}
           (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) `{<span class="kr">forall</span> <span class="nv">a</span>, O_inverts (g a)}
      : O_inverts (functor_sigma idmap g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, O_inverts (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_sigma idmap g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk17f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, O_inverts (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_sigma idmap g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk180"><span class="nb">apply</span> O_inverts_from_extendable; <span class="nb">intros</span> Z Z_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, O_inverts (g a)</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> (functor_sigma idmap g)
  (<span class="kr">fun</span> <span class="nv">_</span> : {x : _ &amp; Q x} =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk181"><span class="nb">apply</span> ooextendable_functor_sigma_id; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, O_inverts (g a)</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (g a) (<span class="kr">fun</span> <span class="nv">_</span> : Q a =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ooextendable_O_inverts; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Theorem 7.3.9: The reflector [O] can be discarded inside a reflected sum.  This can be obtained from [O_inverts_functor_sigma_id] applied to the family of units [to O (P x)], but unfortunately the definitional behavior of the inverse obtained thereby (which here we take as the &quot;forwards&quot; direction) is poor.  So instead we give an explicit proof, but note that the &quot;backwards&quot; direction here is precisely [functor_sigma]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk182"><span class="kn">Definition</span> <span class="nf">equiv_O_sigma_O</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      : O {x:A &amp; O (P x)} &lt;~&gt; O {x:A &amp; P x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; O (P x)} &lt;~&gt; O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** := (Build_Equiv _ _ _ (O_inverts_functor_sigma_id (fun x =&gt; to O (P x))))^-1. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk183"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; O (P x)} &lt;~&gt; O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk184">srapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; O (P x)} -&gt; O {x : A &amp; P x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk185" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk185"><hr></label><div class="goal-conclusion">O {x : A &amp; P x} -&gt; O {x : A &amp; O (P x)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk186"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk187" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk187"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk188">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; O (P x)} -&gt; O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk189"><span class="nb">apply</span> O_rec; <span class="nb">intros</span> [a op]; <span class="nb">revert</span> op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (P a) -&gt; O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18a"><span class="nb">apply</span> O_rec; <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to O _ (a;p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O {x : A &amp; P x} -&gt; O {x : A &amp; O (P x)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18c"><span class="nb">apply</span> O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; P x} -&gt; {x : A &amp; O (P x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; to O (P x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; O (P x)} =&gt;
   (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">op</span> : O (P a)) =&gt;
    O_rec (<span class="kr">fun</span> <span class="nv">p</span> : P a =&gt; to O {x : A &amp; P x} (a; p))
      op) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o O_functor
    (functor_sigma idmap
       (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O (P (idmap x)))) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18e"><span class="nb">unfold</span> O_functor; rapply O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt;
 O_rec
   (<span class="kr">fun</span> <span class="nv">X</span> : {x0 : A &amp; O (P x0)} =&gt;
    O_rec
      (<span class="kr">fun</span> <span class="nv">p</span> : P X.<span class="mi">1</span> =&gt; to O {x0 : A &amp; P x0} (X.<span class="mi">1</span>; p))
      X.<span class="mi">2</span>)
   (O_rec
      (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : A &amp; P x0} =&gt;
       to O {x1 : A &amp; O (P x1)}
         (functor_sigma idmap
            (<span class="kr">fun</span> <span class="nv">x1</span> : A =&gt; to O (P x1)) x0))
      (to O {x0 : A &amp; P x0} x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt; to O {x0 : A &amp; P x0} x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk18f"><span class="nb">intros</span> [a p]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; O (P x)} =&gt;
   O_rec
     (<span class="kr">fun</span> <span class="nv">p</span> : P X.<span class="mi">1</span> =&gt; to O {x : A &amp; P x} (X.<span class="mi">1</span>; p))
     X.<span class="mi">2</span>)
  (O_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt;
      to O {x0 : A &amp; O (P x0)}
        (functor_sigma idmap
           (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O (P x0)) x))
     (to O {x : A &amp; P x} (a; p))) =
to O {x : A &amp; P x} (a; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="kp">repeat</span> (<span class="nb">rewrite</span> O_rec_beta); <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk190">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O (P (idmap x))))
o O_rec
    (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; O (P x)} =&gt;
     (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">op</span> : O (P a)) =&gt;
      O_rec (<span class="kr">fun</span> <span class="nv">p</span> : P a =&gt; to O {x : A &amp; P x} (a; p))
        op) X.<span class="mi">1</span> X.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk191"><span class="nb">unfold</span> O_functor; rapply O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; O (P x)} =&gt;
 O_rec
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : A &amp; P x0} =&gt;
    to O {x1 : A &amp; O (P x1)}
      (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x1</span> : A =&gt; to O (P x1))
         x0))
   (O_rec
      (<span class="kr">fun</span> <span class="nv">X</span> : {x0 : A &amp; O (P x0)} =&gt;
       O_rec
         (<span class="kr">fun</span> <span class="nv">p</span> : P X.<span class="mi">1</span> =&gt;
          to O {x0 : A &amp; P x0} (X.<span class="mi">1</span>; p)) X.<span class="mi">2</span>)
      (to O {x0 : A &amp; O (P x0)} x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; O (P x)} =&gt;
 to O {x0 : A &amp; O (P x0)} x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk192"><span class="nb">intros</span> [a op]; <span class="nb">revert</span> op; rapply O_indpaths; <span class="nb">intros</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt;
   to O {x0 : A &amp; O (P x0)}
     (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; to O (P x0))
        x))
  (O_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : {x : A &amp; O (P x)} =&gt;
      O_rec
        (<span class="kr">fun</span> <span class="nv">p</span> : P X.<span class="mi">1</span> =&gt; to O {x : A &amp; P x} (X.<span class="mi">1</span>; p))
        X.<span class="mi">2</span>)
     (to O {x : A &amp; O (P x)} (a; to O (P a) p))) =
to O {x : A &amp; O (P x)} (a; to O (P a) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="kp">repeat</span> (<span class="nb">rewrite</span> O_rec_beta); <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Equivalences *)</span>

    <span class="sd">(** Naively it might seem that we need closure under Sigmas (hence a modality) to deduce closure under [Equiv], but in fact the above closure under fibers is sufficient.  This appears as part of the proof of Proposition 2.18 of CORS.  For later use, we try to reduce the number of universe parameters (but we don&#39;t completely control them all). *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk193">#[export] <span class="kn">Instance</span> <span class="nf">inO_equiv</span> `{Funext} (A : <span class="kt">Type</span>@{i}) (B : <span class="kt">Type</span>@{j})
           `{In O A} `{In O B}
      : In O (A &lt;~&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk194"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk195"><span class="nb">refine</span> (inO_equiv_inO _ (issig_equiv@{i j k} A B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {f : A -&gt; B &amp; IsEquiv f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk196"><span class="nb">refine</span> (inO_equiv_inO _ (equiv_functor_sigma equiv_idmap@{k}
                                 (<span class="kr">fun</span> <span class="nv">f</span> =&gt; equiv_biinv_isequiv@{i j k} f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {x : _ &amp; BiInv x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk197">transparent <span class="nb">assert</span> (c : (prod@{k k} (A-&gt;B) (prod@{k k} (B-&gt;A) (B-&gt;A)) -&gt; prod@{k k} (A -&gt; A) (B -&gt; B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk198" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk198"><hr></label><div class="goal-conclusion">In O {x : _ &amp; BiInv x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk199">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [f [g h]]; <span class="bp">exact</span> (h o f, f o g).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk19a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">snd</span> : (B -&gt; A) * (B -&gt; A)) =&gt;
 (<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">h</span> : B -&gt; A =&gt; (h o f, f o g)) (fst snd)
   (Overture.snd snd)) (fst X) (snd X)</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {x : _ &amp; BiInv x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk19b"><span class="nb">pose</span> (U := hfiber@{k k} c (idmap, idmap)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">snd</span> : (B -&gt; A) * (B -&gt; A)) =&gt;
 (<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">h</span> : B -&gt; A =&gt; (h o f, f o g)) (fst snd)
   (Overture.snd snd)) (fst X) (snd X)</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O {x : _ &amp; BiInv x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk19c"><span class="nb">refine</span> (inO_equiv_inO&#39;@{k k k} U _). <span class="sd">(** Introduces some extra copies of [k] by typeclass inference. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">snd</span> : (B -&gt; A) * (B -&gt; A)) =&gt;
 (<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">h</span> : B -&gt; A =&gt; (h o f, f o g)) (fst snd)
   (Overture.snd snd)) (fst X) (snd X)</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">U &lt;~&gt; {x : _ &amp; BiInv x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk19d"><span class="nb">unfold</span> hfiber, BiInv; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">U &lt;~&gt;
{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk19e">srefine (equiv_adjointify _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">U -&gt;
{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk19f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk19f"><hr></label><div class="goal-conclusion">{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}} -&gt; U</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1a0"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1a1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1a1"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">U -&gt;
{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a3"><span class="nb">intros</span> [[f [g h]] p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>c (f, (g, h)) = (idmap, idmap)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a4"><span class="nb">apply</span> (equiv_inverse (equiv_path_prod _ _)) <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(fst (c (f, (g, h))) = fst (idmap, idmap)) *
(snd (c (f, (g, h))) = snd (idmap, idmap))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a5"><span class="nb">destruct</span> p <span class="kr">as</span> [p q]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x)) = idmap</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) = idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a6"><span class="kr">exists</span> <span class="nv">f</span>; <span class="nb">split</span>; [ <span class="kr">exists</span> <span class="nv">h</span> | <span class="kr">exists</span> <span class="nv">g</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x)) = idmap</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) = idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; h (f x)) = idmap</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) = idmap</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1a7"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="nb">apply</span> ap10; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
{h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}} -&gt; U</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1a9"><span class="nb">intros</span> [f [[g p] [h q]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">U</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1aa"><span class="kr">exists</span> (<span class="nv">f</span>,(h,g)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c (f, (h, g)) = (idmap, idmap)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> path_arrow; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X</span> : U =&gt;
 (<span class="kr">fun</span> <span class="nv">proj1</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
  (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">snd</span> : (B -&gt; A) * (B -&gt; A)) =&gt;
   (<span class="kr">fun</span> (<span class="nv">g</span> <span class="nv">h</span> : B -&gt; A)
      (<span class="nv">p</span> : c (f, (g, h)) = (idmap, idmap)) =&gt;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      equiv_fun
        (equiv_path_prod (c (f, (g, h)))
           (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">p0</span> := X0 p <span class="kr">in</span>
    (<span class="kr">fun</span>
       (<span class="nv">p1</span> : fst (c (f, (g, h))) = fst (idmap, idmap))
       (<span class="nv">q</span> : Overture.snd (c (f, (g, h))) =
            Overture.snd (idmap, idmap)) =&gt;
     (f; ((h; ap10 p1), (g; ap10 q)))
     :
     {f0 : A -&gt; B &amp;
     {g0 : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g0 (...)) == idmap} *
     {h0 : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f0 (...)) == idmap}})
      (fst p0) (Overture.snd p0)) (fst snd)
     (Overture.snd snd)) (fst proj1) (snd proj1)) X.<span class="mi">1</span>
   X.<span class="mi">2</span>)
o (<span class="kr">fun</span>
     <span class="nv">X</span> : {f : A -&gt; B &amp;
         {g : B -&gt; A &amp;
         (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
         {h : B -&gt; A &amp;
         (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}} =&gt;
   (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B)
      (<span class="nv">proj2</span> : {g : B -&gt; A &amp;
               (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
               {h : B -&gt; A &amp;
               (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}) =&gt;
    (<span class="kr">fun</span>
       <span class="nv">fst</span> : {g : B -&gt; A &amp;
             (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} =&gt;
     (<span class="kr">fun</span> (<span class="nv">g</span> : B -&gt; A)
        (<span class="nv">p</span> : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap)
        (<span class="nv">snd</span> : {h : B -&gt; A &amp;
               (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}) =&gt;
      (<span class="kr">fun</span> (<span class="nv">h</span> : B -&gt; A)
         (<span class="nv">q</span> : (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap) =&gt;
       ((f, (h, g));
       path_prod (c (f, (h, g))) (idmap, idmap)
         (path_arrow (Overture.fst (c (f, (h, g))))
            (Overture.fst (idmap, idmap)) p)
         (path_arrow (Overture.snd (c (f, (h, g))))
            (Overture.snd (idmap, idmap)) q)
       :
       c (f, (h, g)) = (idmap, idmap))) snd.<span class="mi">1</span> snd.<span class="mi">2</span>)
       fst.<span class="mi">1</span> fst.<span class="mi">2</span>) (fst proj2) (snd proj2)) X.<span class="mi">1</span> X.<span class="mi">2</span>) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ac"><span class="nb">intros</span> [f [[g p] [h q]]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f;
((g;
 ap10
   (ap fst
      (path_prod (c (f, (h, g))) (idmap, idmap)
         (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p)
         (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q)))),
(h;
ap10
  (ap snd
     (path_prod (c (f, (h, g))) (idmap, idmap)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q)))))) =
(f; ((g; p), (h; q)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ad"><span class="nb">apply</span> (path_sigma&#39; _ <span class="mi">1</span>); <span class="nb">apply</span> path_prod; <span class="nb">apply</span> (path_sigma&#39; _ <span class="mi">1</span>);
          <span class="nb">cbn</span>; <span class="nb">rewrite</span> transport_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10
  (ap fst
     (path_prod (c (f, (h, g))) (idmap, idmap)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q))) =
p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1ae"><hr></label><div class="goal-conclusion">ap10
  (ap snd
     (path_prod (c (f, (h, g))) (idmap, idmap)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q))) =
q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1af"><span class="mi">1</span>:<span class="nb">rewrite</span> ap_fst_path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p) = p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1b0"><hr></label><div class="goal-conclusion">ap10
  (ap snd
     (path_prod (c (f, (h, g))) (idmap, idmap)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p)
        (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q))) =
q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b1"><span class="mi">2</span>:<span class="nb">rewrite</span> ap_snd_path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) idmap p) = p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1b2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1b2"><hr></label><div class="goal-conclusion">ap10 (path_arrow (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) idmap q) = q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="nb">apply</span> path_forall; <span class="nb">intros</span> x; <span class="nb">rewrite</span> ap10_path_arrow; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">X</span> : {f : A -&gt; B &amp;
       {g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
       {h : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}}
 =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B)
    (<span class="nv">proj2</span> : {g : B -&gt; A &amp;
             (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} *
             {h : B -&gt; A &amp;
             (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}) =&gt;
  (<span class="kr">fun</span>
     <span class="nv">fst</span> : {g : B -&gt; A &amp;
           (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap} =&gt;
   (<span class="kr">fun</span> (<span class="nv">g</span> : B -&gt; A)
      (<span class="nv">p</span> : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap)
      (<span class="nv">snd</span> : {h : B -&gt; A &amp;
             (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap}) =&gt;
    (<span class="kr">fun</span> (<span class="nv">h</span> : B -&gt; A)
       (<span class="nv">q</span> : (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (h x)) == idmap) =&gt;
     ((f, (h, g));
     path_prod (c (f, (h, g))) (idmap, idmap)
       (path_arrow (Overture.fst (c (f, (h, g))))
          (Overture.fst (idmap, idmap)) p)
       (path_arrow (Overture.snd (c (f, (h, g))))
          (Overture.snd (idmap, idmap)) q)
     :
     c (f, (h, g)) = (idmap, idmap))) snd.<span class="mi">1</span> snd.<span class="mi">2</span>)
     fst.<span class="mi">1</span> fst.<span class="mi">2</span>) (fst proj2) (snd proj2)) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o (<span class="kr">fun</span> <span class="nv">X</span> : U =&gt;
   (<span class="kr">fun</span> <span class="nv">proj1</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
    (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">snd</span> : (B -&gt; A) * (B -&gt; A)) =&gt;
     (<span class="kr">fun</span> (<span class="nv">g</span> <span class="nv">h</span> : B -&gt; A)
        (<span class="nv">p</span> : c (f, (g, h)) = (idmap, idmap)) =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> :=
        equiv_fun
          (equiv_path_prod (c (f, (g, h)))
             (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">p0</span> := X0 p <span class="kr">in</span>
      (<span class="kr">fun</span>
         (<span class="nv">p1</span> : fst (c (f, (g, h))) =
               fst (idmap, idmap))
         (<span class="nv">q</span> : Overture.snd (c (f, (g, h))) =
              Overture.snd (idmap, idmap)) =&gt;
       (f; ((h; ap10 p1), (g; ap10 q)))
       :
       {f0 : A -&gt; B &amp;
       {g0 : B -&gt; A &amp;
       (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g0 (...)) == idmap} *
       {h0 : B -&gt; A &amp;
       (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f0 (...)) == idmap}}) (fst p0)
        (Overture.snd p0)) (fst snd)
       (Overture.snd snd)) (fst proj1) (snd proj1))
     X.<span class="mi">1</span> X.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b4"><span class="nb">intros</span> fghp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>fghp</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((<span class="kr">let</span> <span class="nv">X</span> :=
     equiv_fun
       (equiv_path_prod
          (c
             (fst fghp.<span class="mi">1</span>,
             (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
          (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
   (fst fghp.<span class="mi">1</span>;
   ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
   (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">1</span>,
 ((snd
     (<span class="kr">let</span> <span class="nv">X</span> :=
        equiv_fun
          (equiv_path_prod
             (c
                (fst fghp.<span class="mi">1</span>,
                (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
             (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
      (fst fghp.<span class="mi">1</span>;
      ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
      (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>,
 (fst
    (<span class="kr">let</span> <span class="nv">X</span> :=
       equiv_fun
         (equiv_path_prod
            (c
               (fst fghp.<span class="mi">1</span>,
               (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
            (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
     (fst fghp.<span class="mi">1</span>;
     ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
     (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>));
path_prod
  (c
     ((<span class="kr">let</span> <span class="nv">X</span> :=
         equiv_fun
           (equiv_path_prod
              (c
                 (fst fghp.<span class="mi">1</span>,
                 (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
              (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
       <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
       (fst fghp.<span class="mi">1</span>;
       ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
       (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">1</span>,
     ((snd
         (<span class="kr">let</span> <span class="nv">X</span> :=
            equiv_fun
              (equiv_path_prod
                 (c
                    (fst fghp.<span class="mi">1</span>,
                    (fst (snd fghp.<span class="mi">1</span>),
                    snd (snd fghp.<span class="mi">1</span>)))) (idmap, idmap))^-<span class="mi">1</span>
            <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
          (fst fghp.<span class="mi">1</span>;
          ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
          (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>,
     (fst
        (<span class="kr">let</span> <span class="nv">X</span> :=
           equiv_fun
             (equiv_path_prod
                (c
                   (fst fghp.<span class="mi">1</span>,
                   (fst (snd fghp.<span class="mi">1</span>),
                   snd (snd fghp.<span class="mi">1</span>)))) (idmap, idmap))^-<span class="mi">1</span>
           <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
         (fst fghp.<span class="mi">1</span>;
         ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
         (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>)))
  (idmap, idmap)
  (path_arrow
     (fst
        (c
           ((<span class="kr">let</span> <span class="nv">X</span> :=
               equiv_fun
                 (equiv_path_prod
                    (c
                       (fst fghp.<span class="mi">1</span>,
                       (fst (snd fghp.<span class="mi">1</span>),
                       snd (snd fghp.<span class="mi">1</span>))))
                    (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
             (fst fghp.<span class="mi">1</span>;
             ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
             (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">1</span>,
           ((snd
               (<span class="kr">let</span> <span class="nv">X</span> :=
                  equiv_fun
                    (equiv_path_prod
                       (c
                          (fst fghp.<span class="mi">1</span>,
                          (fst (snd fghp.<span class="mi">1</span>),
                          snd (snd fghp.<span class="mi">1</span>))))
                       (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
                <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
                (fst fghp.<span class="mi">1</span>;
                ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
                (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>,
           (fst
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 equiv_fun
                   (equiv_path_prod
                      (c
                         (fst fghp.<span class="mi">1</span>,
                         (fst (snd fghp.<span class="mi">1</span>),
                         snd (snd fghp.<span class="mi">1</span>))))
                      (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
               <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
               (fst fghp.<span class="mi">1</span>;
               ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
               (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>))))
     (fst (idmap, idmap))
     (fst
        (<span class="kr">let</span> <span class="nv">X</span> :=
           equiv_fun
             (equiv_path_prod
                (c
                   (fst fghp.<span class="mi">1</span>,
                   (fst (snd fghp.<span class="mi">1</span>),
                   snd (snd fghp.<span class="mi">1</span>)))) (idmap, idmap))^-<span class="mi">1</span>
           <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
         (fst fghp.<span class="mi">1</span>;
         ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
         (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">2</span>)
  (path_arrow
     (snd
        (c
           ((<span class="kr">let</span> <span class="nv">X</span> :=
               equiv_fun
                 (equiv_path_prod
                    (c
                       (fst fghp.<span class="mi">1</span>,
                       (fst (snd fghp.<span class="mi">1</span>),
                       snd (snd fghp.<span class="mi">1</span>))))
                    (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
             (fst fghp.<span class="mi">1</span>;
             ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
             (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">1</span>,
           ((snd
               (<span class="kr">let</span> <span class="nv">X</span> :=
                  equiv_fun
                    (equiv_path_prod
                       (c
                          (fst fghp.<span class="mi">1</span>,
                          (fst (snd fghp.<span class="mi">1</span>),
                          snd (snd fghp.<span class="mi">1</span>))))
                       (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
                <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
                (fst fghp.<span class="mi">1</span>;
                ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
                (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>,
           (fst
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 equiv_fun
                   (equiv_path_prod
                      (c
                         (fst fghp.<span class="mi">1</span>,
                         (fst (snd fghp.<span class="mi">1</span>),
                         snd (snd fghp.<span class="mi">1</span>))))
                      (idmap, idmap))^-<span class="mi">1</span> <span class="kr">in</span>
               <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
               (fst fghp.<span class="mi">1</span>;
               ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
               (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">1</span>))))
     (snd (idmap, idmap))
     (snd
        (<span class="kr">let</span> <span class="nv">X</span> :=
           equiv_fun
             (equiv_path_prod
                (c
                   (fst fghp.<span class="mi">1</span>,
                   (fst (snd fghp.<span class="mi">1</span>),
                   snd (snd fghp.<span class="mi">1</span>)))) (idmap, idmap))^-<span class="mi">1</span>
           <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">p</span> := X fghp.<span class="mi">2</span> <span class="kr">in</span>
         (fst fghp.<span class="mi">1</span>;
         ((snd (snd fghp.<span class="mi">1</span>); ap10 (fst p)),
         (fst (snd fghp.<span class="mi">1</span>); ap10 (snd p))))).<span class="mi">2</span>).<span class="mi">2</span>)) =
fghp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>fghp</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fst fghp.<span class="mi">1</span>, (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>)));
path_prod
  (c
     (fst fghp.<span class="mi">1</span>,
     (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
  (idmap, idmap)
  (path_arrow
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd fghp.<span class="mi">1</span>) (fst fghp.<span class="mi">1</span> x))
     idmap (ap10 (ap fst fghp.<span class="mi">2</span>)))
  (path_arrow
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst fghp.<span class="mi">1</span> (fst (snd fghp.<span class="mi">1</span>) x))
     idmap (ap10 (ap snd fghp.<span class="mi">2</span>)))) = fghp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b6"><span class="nb">apply</span> (path_sigma&#39; _ <span class="mi">1</span>); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>c</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : (A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd X) (fst X x),
<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst X (fst (snd X) x))</span></span><span class="hyp-type"><b>: </b><span>(A -&gt; B) * ((B -&gt; A) * (B -&gt; A)) -&gt;
(A -&gt; A) * (B -&gt; B)</span></span></span></span><br><span><var>U</var><span><span class="hyp-body"><b>:= </b><span>hfiber c (idmap, idmap)</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>fghp</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_prod
  (c
     (fst fghp.<span class="mi">1</span>,
     (fst (snd fghp.<span class="mi">1</span>), snd (snd fghp.<span class="mi">1</span>))))
  (idmap, idmap)
  (path_arrow
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; snd (snd fghp.<span class="mi">1</span>) (fst fghp.<span class="mi">1</span> x))
     idmap (ap10 (ap fst fghp.<span class="mi">2</span>)))
  (path_arrow
     (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; fst fghp.<span class="mi">1</span> (fst (snd fghp.<span class="mi">1</span>) x))
     idmap (ap10 (ap snd fghp.<span class="mi">2</span>))) = fghp.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (_ @ eta_path_prod (pr2 fghp)); <span class="nb">apply</span> ap011; <span class="nb">apply</span> eta_path_arrow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Paths *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b7"><span class="kn">Definition</span> <span class="nf">inO_paths</span>@{i} (S : <span class="kt">Type</span>@{i}) {S_inO : In O S} (x y : S)
    : In O (x=y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1b9"><span class="nb">simple refine</span> (inO_to_O_retract@{i} _ _ _); <span class="nb">intro</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1ba"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span>@{u:=to O (x = y) u} = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1bb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1bc"><span class="nb">assert</span> (p : (<span class="kr">fun</span> <span class="nv">_</span> : O (x=y) =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span>=&gt; y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x) ==
(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1bd"><hr></label><div class="goal-conclusion">x = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1be">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1bf"><span class="nb">refine</span> (O_indpaths _ _ _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> v; <span class="bp">exact</span> v.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>O (x = y)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x) ==
(<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">p</span> :=
   O_indpaths (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x)
     (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y)
     ((idmap
       :
       (<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; y))
      :
      (<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; x) == (<span class="kr">fun</span> <span class="nv">_</span> : x = y =&gt; y)) <span class="kr">in</span>
 p (to O (x = y) u)) = u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S_inO</var><span class="hyp-type"><b>: </b><span>In O S</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>S</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_indpaths (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; x)
  (<span class="kr">fun</span> <span class="nv">_</span> : O (x = y) =&gt; y) idmap (to O (x = y) u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> O_indpaths_beta; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">inO_paths</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c3"><span class="kn">Lemma</span> <span class="nf">O_concat</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">a0</span> <span class="nv">a1</span> <span class="nv">a2</span> : A}
      : O (a0 = a1) -&gt; O (a1 = a2) -&gt; O (a0 = a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0, a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (a0 = a1) -&gt; O (a1 = a2) -&gt; O (a0 = a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0, a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (a0 = a1) -&gt; O (a1 = a2) -&gt; O (a0 = a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c5"><span class="nb">intros</span> p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0, a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>O (a0 = a1)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>O (a1 = a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (a0 = a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c6">strip_reflections.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0, a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a0 = a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (a0 = a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to O _ (p @ q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Truncations  *)</span>

    <span class="sd">(** The reflector preserves hprops (and, as we have already seen, contractible types), although it doesn&#39;t generally preserve [n]-types for other [n]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c7">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_O_ishprop</span> {<span class="nv">A</span>} `{IsHProp A} : IsHProp (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1c9"><span class="nb">refine</span> ishprop_isequiv_diag.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : O A =&gt; (a, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ca"><span class="nb">refine</span> (isequiv_homotopic (O_prod_cmp A A
                               o O_functor (<span class="kr">fun</span> (<span class="nv">a</span>:A) =&gt; (a,a))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
 O_prod_cmp A A (O_functor (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)) x)) ==
(<span class="kr">fun</span> <span class="nv">a</span> : O A =&gt; (a, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1cb"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_prod_cmp A A
  (O_functor (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)) (to O A x)) =
(to O A x, to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1cc"><span class="nb">refine</span> (ap (O_prod_cmp A A) (to_O_natural (<span class="kr">fun</span> (<span class="nv">a</span>:A) =&gt; (a,a)) x) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_prod_cmp A A (to O (A * A) (x, x)) =
(to O A x, to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> O_prod_cmp; <span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** If [A] is [In O], then so is [IsTrunc n A]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1cd">#[export] <span class="kn">Instance</span> <span class="nf">inO_istrunc</span> `{Funext} {n} {A} `{In O A}
    : In O (IsTrunc n A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (IsTrunc n A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (IsTrunc n A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1cf"><span class="nb">generalize dependent</span> A; simple_induction n n IH; <span class="nb">intros</span> A ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (Contr A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, In O A -&gt; In O (IsTrunc n A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1d0"><hr></label><div class="goal-conclusion">In O (IsTrunc n.+<span class="mi">1</span> A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d1">- <span class="sd">(** We have to be slightly clever here: the actual definition of [Contr] involves a sigma, which [O] is not generally closed under, but fortunately we have [equiv_contr_inhabited_allpath]. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (Contr A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ equiv_contr_inhabited_allpath^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, In O A -&gt; In O (IsTrunc n A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (IsTrunc n.+<span class="mi">1</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (equiv_istrunc_unfold n.+<span class="mi">1</span> A)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Coproducts *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d3"><span class="kn">Definition</span> <span class="nf">O_inverts_functor_sum</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span>} (<span class="nv">f</span> : A -&gt; A&#39;) (<span class="nv">g</span> : B -&gt; B&#39;)
               `{O_inverts f} `{O_inverts g}
      : O_inverts (functor_sum f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d5"><span class="nb">apply</span> O_inverts_from_extendable; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts f</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts g</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> (functor_sum f g)
  (<span class="kr">fun</span> <span class="nv">_</span> : A&#39; + B&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> extendable_functor_sum; <span class="nb">apply</span> ooextendable_O_inverts; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_functor_sum</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span>} (<span class="nv">f</span> : A -&gt; A&#39;) (<span class="nv">g</span> : B -&gt; B&#39;)
               `{O_inverts f} `{O_inverts g}
      : O (A + B) &lt;~&gt; O (A&#39; + B&#39;)
      := Build_Equiv _ _ _ (O_inverts_functor_sum f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_sum</span> {<span class="nv">A</span> <span class="nv">B</span>} :
      O (A + B) &lt;~&gt; O (O A + O B)
      := equiv_O_functor_sum (to O A) (to O B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Coequalizers *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">OCoeq</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : B -&gt; A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d6"><span class="kn">Definition</span> <span class="nf">O_inverts_functor_coeq</span>
                 {<span class="nv">B&#39;</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>} {<span class="nv">f&#39;</span> <span class="nv">g&#39;</span> : B&#39; -&gt; A&#39;}
                 (<span class="nv">h</span> : B -&gt; B&#39;) (<span class="nv">k</span> : A -&gt; A&#39;)
                 (<span class="nv">p</span> : k o f == f&#39; o h) (<span class="nv">q</span> : k o g == g&#39; o h)
                 `{O_inverts k} `{O_inverts h}
        : O_inverts (functor_coeq h k p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d8"><span class="nb">apply</span> O_inverts_from_extendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt;
ExtendableAlong <span class="mi">2</span> (functor_coeq h k p q)
  (<span class="kr">fun</span> <span class="nv">_</span> : Coeq f&#39; g&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1d9"><span class="nb">intros</span> Z Z_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> (functor_coeq h k p q)
  (<span class="kr">fun</span> <span class="nv">_</span> : Coeq f&#39; g&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1da"><span class="nb">apply</span> extendable_functor_coeq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> k (<span class="kr">fun</span> <span class="nv">_</span> : A&#39; =&gt; Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O Z</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1db"><hr></label><div class="goal-conclusion">ExtendableAlong <span class="mi">3</span> h (<span class="kr">fun</span> <span class="nv">_</span> : B&#39; =&gt; Z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:napply ooextendable_O_inverts; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_functor_coeq</span>
                 {<span class="nv">B&#39;</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f&#39;</span> <span class="nv">g&#39;</span> : B&#39; -&gt; A&#39;)
                 (<span class="nv">h</span> : B -&gt; B&#39;) (<span class="nv">k</span> : A -&gt; A&#39;)
                 (<span class="nv">p</span> : k o f == f&#39; o h) (<span class="nv">q</span> : k o g == g&#39; o h)
                 `{O_inverts k} `{O_inverts h}
        : O (Coeq f g) &lt;~&gt; O (Coeq f&#39; g&#39;)
        := Build_Equiv _ _ _ (O_inverts_functor_coeq h k p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">coeq_cmp</span> : Coeq f g -&gt; Coeq (O_functor f) (O_functor g)
        := functor_coeq (to O B) (to O A)
                       (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (to_O_natural f y)^)
                       (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (to_O_natural g y)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1dc">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_O_coeq_cmp</span> : O_inverts coeq_cmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts coeq_cmp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1dd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts coeq_cmp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_inverts_functor_coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_coeq</span>
      : O (Coeq f g) &lt;~&gt; O (Coeq (O_functor f) (O_functor g))
        := Build_Equiv _ _ (O_functor coeq_cmp) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1de"><span class="kn">Definition</span> <span class="nf">equiv_O_coeq_to_O</span> (<span class="nv">a</span> : A)
        : equiv_O_coeq (to O (Coeq f g) (coeq a))
          = to O (Coeq (O_functor f) (O_functor g)) (coeq (to O A a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_coeq (to O (Coeq f g) (coeq a)) =
to O (Coeq (O_functor f) (O_functor g))
  (coeq (to O A a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_coeq (to O (Coeq f g) (coeq a)) =
to O (Coeq (O_functor f) (O_functor g))
  (coeq (to O A a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to_O_natural _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e0"><span class="kn">Definition</span> <span class="nf">inverse_equiv_O_coeq_to_O</span> (<span class="nv">a</span> : A)
        : equiv_O_coeq^-<span class="mi">1</span> (to O (Coeq (O_functor f) (O_functor g)) (coeq (to O A a)))
          = to O (Coeq f g) (coeq a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor coeq_cmp)^-<span class="mi">1</span>
  (to O (Coeq (O_functor f) (O_functor g))
     (coeq (to O A a))) = to O (Coeq f g) (coeq a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor coeq_cmp)^-<span class="mi">1</span>
  (to O (Coeq (O_functor f) (O_functor g))
     (coeq (to O A a))) = to O (Coeq f g) (coeq a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_O_coeq_to_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">OCoeq</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Pushouts *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">OPushout</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : A -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e2"><span class="kn">Definition</span> <span class="nf">O_inverts_functor_pushout</span>
             {<span class="nv">A&#39;</span> <span class="nv">B&#39;</span> <span class="nv">C&#39;</span>} {<span class="nv">f&#39;</span> : A&#39; -&gt; B&#39;} {<span class="nv">g&#39;</span> : A&#39; -&gt; C&#39;}
             (<span class="nv">h</span> : A -&gt; A&#39;) (<span class="nv">k</span> : B -&gt; B&#39;) (<span class="nv">l</span> : C -&gt; C&#39;)
             (<span class="nv">p</span> : k o f == f&#39; o h) (<span class="nv">q</span> : l o g == g&#39; o h)
             `{O_inverts h} `{O_inverts k} `{O_inverts l}
        : O_inverts (functor_pushout h k l p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts2</var><span class="hyp-type"><b>: </b><span>O_inverts l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts h</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts k</span></span></span><br><span><var>O_inverts2</var><span class="hyp-type"><b>: </b><span>O_inverts l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_inverts_functor_coeq; rapply O_inverts_functor_sum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_O_pushout</span>
        : O (Pushout f g) &lt;~&gt; O (Pushout (O_functor f) (O_functor g))
        := Build_Equiv _ _ _ (O_inverts_functor_pushout (to O A) (to O B) (to O C)
                                                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (to_O_natural f x)^)
                                                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (to_O_natural g x)^)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e4"><span class="kn">Definition</span> <span class="nf">equiv_O_pushout_to_O_pushl</span> (<span class="nv">b</span> : B)
        : equiv_O_pushout (to O (Pushout f g) (pushl b))
          = to O (Pushout (O_functor f) (O_functor g)) (pushl (to O B b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout (to O (Pushout f g) (pushl b)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushl (to O B b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout (to O (Pushout f g) (pushl b)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushl (to O B b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor
  (functor_pushout (to O A) (to O B) (to O C)
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural f x)^)
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural g x)^))
  (to O (Pushout f g) (pushl b)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushl (to O B b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">rapply to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e7"><span class="kn">Definition</span> <span class="nf">equiv_O_pushout_to_O_pushr</span> (<span class="nv">c</span> : C)
        : equiv_O_pushout (to O (Pushout f g) (pushr c))
          = to O (Pushout (O_functor f) (O_functor g)) (pushr (to O C c)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout (to O (Pushout f g) (pushr c)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushr (to O C c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout (to O (Pushout f g) (pushr c)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushr (to O C c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1e9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor
  (functor_pushout (to O A) (to O B) (to O C)
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural f x)^)
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural g x)^))
  (to O (Pushout f g) (pushr c)) =
to O (Pushout (O_functor f) (O_functor g))
  (pushr (to O C c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">rapply to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ea"><span class="kn">Definition</span> <span class="nf">inverse_equiv_O_pushout_to_O_pushl</span> (<span class="nv">b</span> : B)
        : equiv_O_pushout^-<span class="mi">1</span> (to O (Pushout (O_functor f) (O_functor g)) (pushl (to O B b)))
          = to O (Pushout f g) (pushl b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout^-<span class="mi">1</span>
  (to O (Pushout (O_functor f) (O_functor g))
     (pushl (to O B b))) =
to O (Pushout f g) (pushl b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1eb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout^-<span class="mi">1</span>
  (to O (Pushout (O_functor f) (O_functor g))
     (pushl (to O B b))) =
to O (Pushout f g) (pushl b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_O_pushout_to_O_pushl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ec"><span class="kn">Definition</span> <span class="nf">inverse_equiv_O_pushout_to_O_pushr</span> (<span class="nv">c</span> : C)
        : equiv_O_pushout^-<span class="mi">1</span> (to O (Pushout (O_functor f) (O_functor g)) (pushr (to O C c)))
          = to O (Pushout f g) (pushr c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout^-<span class="mi">1</span>
  (to O (Pushout (O_functor f) (O_functor g))
     (pushr (to O C c))) =
to O (Pushout f g) (pushr c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ed"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pushout^-<span class="mi">1</span>
  (to O (Pushout (O_functor f) (O_functor g))
     (pushr (to O C c))) =
to O (Pushout f g) (pushr c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_O_pushout_to_O_pushr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">OPushout</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Types</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Decidable</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** If [Empty] belongs to [O], then [O] preserves decidability. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ee">#[export] <span class="kn">Instance</span> <span class="nf">decidable_O</span> `{In O Empty} (A : <span class="kt">Type</span>) `{Decidable A}
    : Decidable (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ef"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f0"><span class="nb">destruct</span> (dec A) <span class="kr">as</span> [y|n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (O A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1f1"><hr></label><div class="goal-conclusion">Decidable (O A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl (to O A y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (O A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inr (O_rec n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Dually, if [O A] is decidable, then [O (Decidable A)]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f4"><span class="kn">Definition</span> <span class="nf">O_decidable</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{Decidable (O A)}
    : O (Decidable A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Decidable A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Decidable A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f6"><span class="nb">destruct</span> (dec (O A)) <span class="kr">as</span> [y|n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Decidable A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk1f7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ O A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk1f7"><hr></label><div class="goal-conclusion">O (Decidable A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Decidable A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_functor inl y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1f9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Decidable A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1fa"><span class="nb">refine</span> (O_functor inr _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (~ A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1fb"><span class="nb">apply</span> to; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable (O A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ O A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (n (to O A a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Decidable</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Monad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_monad_mult</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : O (O A) -&gt; O A
      := O_rec idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1fc"><span class="kn">Definition</span> <span class="nf">O_monad_mult_natural</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
    : O_functor f o O_monad_mult A == O_monad_mult B o O_functor (O_functor f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f o O_monad_mult A ==
O_monad_mult B o O_functor (O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1fd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f o O_monad_mult A ==
O_monad_mult B o O_functor (O_functor f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1fe"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">unfold</span> O_monad_mult.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_rec idmap (to O (O A) x)) =
O_rec idmap (O_functor (O_functor f) (to O (O A) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk1ff"><span class="nb">rewrite</span> (to_O_natural (O_functor f) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f (O_rec idmap (to O (O A) x)) =
O_rec idmap (to O (O B) (O_functor f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk200"><span class="nb">rewrite</span> (O_rec_beta idmap x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f x =
O_rec idmap (to O (O B) (O_functor f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk201"><span class="nb">rewrite</span> (O_rec_beta idmap (O_functor f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor f x = O_functor f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk202"><span class="kn">Definition</span> <span class="nf">O_monad_unitlaw1</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_monad_mult A o (to O (O A)) == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o to O (O A) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk203"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o to O (O A) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk204"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">unfold</span> O_monad_mult.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap (to O (O A) (to O A x)) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_rec_beta idmap (to O A x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk205"><span class="kn">Definition</span> <span class="nf">O_monad_unitlaw2</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_monad_mult A o (O_functor (to O A)) == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o O_functor (to O A) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk206"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o O_functor (to O A) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk207"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">unfold</span> O_monad_mult, O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap
  (O_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O (O_reflector O A) (to O A x))
     (to O A x)) = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk208"><span class="kp">repeat</span> <span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O A x = to O A x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk209"><span class="kn">Definition</span> <span class="nf">O_monad_mult_assoc</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_monad_mult A o O_monad_mult (O A) == O_monad_mult A o O_functor (O_monad_mult A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o O_monad_mult (O A) ==
O_monad_mult A o O_functor (O_monad_mult A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult A o O_monad_mult (O A) ==
O_monad_mult A o O_functor (O_monad_mult A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20b"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">unfold</span> O_monad_mult, O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap (O_rec idmap (to O (O (O A)) x)) =
O_rec idmap
  (O_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : O (O A) =&gt; to O (O A) (O_rec idmap x))
     (to O (O (O A)) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20c"><span class="kp">repeat</span> <span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap x = O_rec idmap x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Monad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">StrongMonad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">fs</span> : Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">O_monad_strength</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : A * O B -&gt; O (A * B)
      := <span class="kr">fun</span> <span class="nv">aob</span> =&gt; O_rec (<span class="kr">fun</span> <span class="nv">b</span> <span class="nv">a</span> =&gt; to O (A*B) (a,b)) (snd aob) (fst aob).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20d"><span class="kn">Definition</span> <span class="nf">O_monad_strength_natural</span> (<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; A&#39;) (<span class="nv">g</span> : B -&gt; B&#39;)
    : O_functor (functor_prod f g) o O_monad_strength A B ==
      O_monad_strength A&#39; B&#39; o functor_prod f (O_functor g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (functor_prod f g) o O_monad_strength A B ==
O_monad_strength A&#39; B&#39; o functor_prod f (O_functor g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (functor_prod f g) o O_monad_strength A B ==
O_monad_strength A&#39; B&#39; o functor_prod f (O_functor g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk20f"><span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (functor_prod f g)
  (O_monad_strength A B (a, b)) =
O_monad_strength A&#39; B&#39;
  (functor_prod f (O_functor g) (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk210"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
O_functor (functor_prod f g)
  (O_monad_strength A B (a, b)) =
O_monad_strength A&#39; B&#39;
  (functor_prod f (O_functor g) (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk211"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_functor (functor_prod f g)
   (O_monad_strength A B (x, b))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A&#39; B&#39;
   (functor_prod f (O_functor g) (x, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk212">strip_reflections.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_functor (functor_prod f g)
   (O_monad_strength A B (x, to O B b))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A&#39; B&#39;
   (functor_prod f (O_functor g) (x, to O B b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk213"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (functor_prod f g)
  (O_monad_strength A B (a, to O B b)) =
O_monad_strength A&#39; B&#39;
  (functor_prod f (O_functor g) (a, to O B b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk214"><span class="nb">unfold</span> O_monad_strength, O_functor; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : A * B =&gt;
   to O (A&#39; * B&#39;) (functor_prod f g x))
  (O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
     (to O B b) a) =
O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B&#39;) (<span class="nv">a</span> : A&#39;) =&gt; to O (A&#39; * B&#39;) (a, b))
  (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; to O B&#39; (g x)) (to O B b))
  (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk215"><span class="kp">repeat</span> <span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (A&#39; * B&#39;) (functor_prod f g (a, b)) =
to O (A&#39; * B&#39;) (f a, g b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The diagrams for strength, see http://en.wikipedia.org/wiki/Strong_monad *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk216"><span class="kn">Definition</span> <span class="nf">O_monad_strength_unitlaw1</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : O_functor (@snd Unit A) o O_monad_strength Unit A == @snd Unit (O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor snd o O_monad_strength Unit A == snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk217"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor snd o O_monad_strength Unit A == snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk218"><span class="nb">intros</span> [[] a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor snd (O_monad_strength Unit A (tt, a)) =
snd (tt, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk219">strip_reflections.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor snd (O_monad_strength Unit A (tt, to O A a)) =
snd (tt, to O A a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21a"><span class="nb">unfold</span> O_monad_strength, O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">x</span> : Unit * A =&gt; to O A (snd x))
  (O_rec
     (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : Unit) =&gt; to O (Unit * A) (a, b))
     (snd (tt, to O A a)) (fst (tt, to O A a))) =
snd (tt, to O A a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">x</span> : Unit * A =&gt; to O A (snd x))
  (O_rec
     (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : Unit) =&gt; to O (Unit * A) (a, b))
     (to O A a) tt) = to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21c"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> <span class="nv">x</span> : Unit * A =&gt; to O A (snd x))
  (to O (Unit * A) (tt, a)) = to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21d"><span class="kn">Definition</span> <span class="nf">O_monad_strength_unitlaw2</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    : O_monad_strength A B o functor_prod idmap (to O B) == to O (A*B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_strength A B o functor_prod idmap (to O B) ==
to O (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_strength A B o functor_prod idmap (to O B) ==
to O (A * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk21f"><span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_strength A B
  (functor_prod idmap (to O B) (a, b)) =
to O (A * B) (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk220"><span class="nb">unfold</span> O_monad_strength, functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
  (snd (fst (a, b), to O B (snd (a, b))))
  (fst (fst (a, b), to O B (snd (a, b)))) =
to O (A * B) (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk221"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
  (to O B b) a = to O (A * B) (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk222"><span class="nb">revert</span> a; <span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
  (to O B b) = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O (A * B) (x, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk223"><span class="kn">Definition</span> <span class="nf">O_monad_strength_assoc1</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
    : O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span> o O_monad_strength (A*B) C ==
      O_monad_strength A (B*C) o functor_prod idmap (O_monad_strength B C) o (equiv_prod_assoc A B (O C))^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
o O_monad_strength (A * B) C ==
O_monad_strength A (B * C)
o functor_prod idmap (O_monad_strength B C)
o (equiv_prod_assoc A B (O C))^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk224"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
o O_monad_strength (A * B) C ==
O_monad_strength A (B * C)
o functor_prod idmap (O_monad_strength B C)
o (equiv_prod_assoc A B (O C))^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk225"><span class="nb">intros</span> [[a b] c].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
  (O_monad_strength (A * B) C (a, b, c)) =
O_monad_strength A (B * C)
  (functor_prod idmap (O_monad_strength B C)
     ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span> (a, b, c)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk226"><span class="nb">revert</span> a; <span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
   (O_monad_strength (A * B) C (x, b, c))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A (B * C)
   (functor_prod idmap (O_monad_strength B C)
      ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span> (x, b, c))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk227"><span class="nb">revert</span> b; <span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : B) (<span class="nv">x0</span> : A) =&gt;
 O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
   (O_monad_strength (A * B) C (x0, x, c))) =
(<span class="kr">fun</span> (<span class="nv">x</span> : B) (<span class="nv">x0</span> : A) =&gt;
 O_monad_strength A (B * C)
   (functor_prod idmap (O_monad_strength B C)
      ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span> (x0, x, c))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk228">strip_reflections.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : B) (<span class="nv">x0</span> : A) =&gt;
 O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
   (O_monad_strength (A * B) C (x0, x, to O C c))) =
(<span class="kr">fun</span> (<span class="nv">x</span> : B) (<span class="nv">x0</span> : A) =&gt;
 O_monad_strength A (B * C)
   (functor_prod idmap (O_monad_strength B C)
      ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
         (x0, x, to O C c))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk229"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
   (O_monad_strength (A * B) C (x, b, to O C c))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A (B * C)
   (functor_prod idmap (O_monad_strength B C)
      ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
         (x, b, to O C c))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22a"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (equiv_prod_assoc A B C)^-<span class="mi">1</span>
  (O_monad_strength (A * B) C (a, b, to O C c)) =
O_monad_strength A (B * C)
  (functor_prod idmap (O_monad_strength B C)
     ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span> (a, b, to O C c)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22b"><span class="nb">unfold</span> O_monad_strength, O_functor, functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : A * B * C =&gt;
   to O (A * (B * C)) ((equiv_prod_assoc A B C)^-<span class="mi">1</span> x))
  (O_rec
     (<span class="kr">fun</span> (<span class="nv">b</span> : C) (<span class="nv">a</span> : A * B) =&gt;
      to O (A * B * C) (a, b)) (snd (a, b, to O C c))
     (fst (a, b, to O C c))) =
O_rec
  (<span class="kr">fun</span> (<span class="nv">b</span> : B * C) (<span class="nv">a</span> : A) =&gt;
   to O (A * (B * C)) (a, b))
  (snd
     (fst
        ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
           (a, b, to O C c)),
     O_rec
       (<span class="kr">fun</span> (<span class="nv">b</span> : C) (<span class="nv">a</span> : B) =&gt; to O (B * C) (a, b))
       (snd
          (snd
             ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
                (a, b, to O C c))))
       (fst
          (snd
             ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
                (a, b, to O C c))))))
  (fst
     (fst
        ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
           (a, b, to O C c)),
     O_rec
       (<span class="kr">fun</span> (<span class="nv">b</span> : C) (<span class="nv">a</span> : B) =&gt; to O (B * C) (a, b))
       (snd
          (snd
             ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
                (a, b, to O C c))))
       (fst
          (snd
             ((equiv_prod_assoc A B (O C))^-<span class="mi">1</span>
                (a, b, to O C c))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : A * B * C =&gt;
   to O (A * (B * C))
     (fst (fst x), (snd (fst x), snd x)))
  (O_rec
     (<span class="kr">fun</span> (<span class="nv">b</span> : C) (<span class="nv">a</span> : A * B) =&gt;
      to O (A * B * C) (a, b)) (to O C c) (a, b)) =
O_rec
  (<span class="kr">fun</span> (<span class="nv">b</span> : B * C) (<span class="nv">a</span> : A) =&gt;
   to O (A * (B * C)) (a, b))
  (O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : C) (<span class="nv">a</span> : B) =&gt; to O (B * C) (a, b))
     (to O C c) b) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22d"><span class="kp">repeat</span> <span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (A * (B * C)) (a, (b, c)) =
to O (A * (B * C)) (a, (b, c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22e"><span class="kn">Definition</span> <span class="nf">O_monad_strength_assoc2</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    : O_monad_mult (A*B) o O_functor (O_monad_strength A B) o O_monad_strength A (O B) ==
      O_monad_strength A B o functor_prod idmap (O_monad_mult B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult (A * B)
o O_functor (O_monad_strength A B)
o O_monad_strength A (O B) ==
O_monad_strength A B
o functor_prod idmap (O_monad_mult B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk22f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult (A * B)
o O_functor (O_monad_strength A B)
o O_monad_strength A (O B) ==
O_monad_strength A B
o functor_prod idmap (O_monad_mult B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk230"><span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>O (O B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult (A * B)
  (O_functor (O_monad_strength A B)
     (O_monad_strength A (O B) (a, b))) =
O_monad_strength A B
  (functor_prod idmap (O_monad_mult B) (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk231"><span class="nb">revert</span> a; <span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>O (O B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_mult (A * B)
   (O_functor (O_monad_strength A B)
      (O_monad_strength A (O B) (x, b)))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A B
   (functor_prod idmap (O_monad_mult B) (x, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk232">strip_reflections.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_mult (A * B)
   (O_functor (O_monad_strength A B)
      (O_monad_strength A (O B)
         (x, to O (O B) (to O B b))))) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 O_monad_strength A B
   (functor_prod idmap (O_monad_mult B)
      (x, to O (O B) (to O B b))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk233"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_monad_mult (A * B)
  (O_functor (O_monad_strength A B)
     (O_monad_strength A (O B)
        (a, to O (O B) (to O B b)))) =
O_monad_strength A B
  (functor_prod idmap (O_monad_mult B)
     (a, to O (O B) (to O B b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk234"><span class="nb">unfold</span> O_monad_strength, O_functor, O_monad_mult, functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap
  (O_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : A * O B =&gt;
      to O (O (A * B))
        (O_rec
           (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
           (snd x) (fst x)))
     (O_rec
        (<span class="kr">fun</span> (<span class="nv">b</span> : O B) (<span class="nv">a</span> : A) =&gt;
         to O (A * O B) (a, b))
        (snd (a, to O (O B) (to O B b)))
        (fst (a, to O (O B) (to O B b))))) =
O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
  (snd
     (fst (a, to O (O B) (to O B b)),
     O_rec idmap (snd (a, to O (O B) (to O B b)))))
  (fst
     (fst (a, to O (O B) (to O B b)),
     O_rec idmap (snd (a, to O (O B) (to O B b)))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk235"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec idmap
  (O_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : A * O B =&gt;
      to O (O (A * B))
        (O_rec
           (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
           (snd x) (fst x)))
     (O_rec
        (<span class="kr">fun</span> (<span class="nv">b</span> : O B) (<span class="nv">a</span> : A) =&gt;
         to O (A * O B) (a, b))
        (to O (O B) (to O B b)) a)) =
O_rec (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A) =&gt; to O (A * B) (a, b))
  (O_rec idmap (to O (O B) (to O B b))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk236"><span class="kp">repeat</span> (<span class="nb">rewrite</span> O_rec_beta; <span class="nb">simpl</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (A * B) (a, b) = to O (A * B) (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">StrongMonad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Reflective_Subuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we make the [O_inverts] notation global. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">O_inverts</span> O f := (IsEquiv (O_functor O f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Modally connected types *)</span>

<span class="sd">(** Connectedness of a type, relative to a modality or reflective subuniverse, can be defined in two equivalent ways: quantifying over all maps into modal types, or by considering just the universal case, the modal reflection of the type itself.  The former requires only core Coq, but blows up the size (universe level) of [IsConnected], since it quantifies over types; moreover, it is not even quite correct since (at least with a polymorphic modality) it should really be quantified over all universes.  Thus, we use the latter, although in most examples it requires HITs to define the modal reflection.</span>

<span class="sd">Question: is there a definition of connectedness (say, for n-types) that neither blows up the universe level, nor requires HIT&#39;s? *)</span>

<span class="sd">(** We give annotations to reduce the number of universe parameters. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsConnected</span> (<span class="nv">O</span> : ReflectiveSubuniverse@{i}) (<span class="nv">A</span> : <span class="kt">Type</span>@{i})
  := isconnected_contr_O :: Contr@{i} (O A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ConnectedTypes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : ReflectiveSubuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Being connected is an hprop *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk237">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_isconnected</span> `{Funext} A
  : IsHProp (IsConnected O A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsConnected O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk238"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsConnected O A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> IsConnected; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Anything equivalent to a connected type is connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk239"><span class="kn">Definition</span> <span class="nf">isconnected_equiv</span> (<span class="nv">A</span> : <span class="kt">Type</span>) {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
  : IsConnected O A -&gt; IsConnected O B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A -&gt; IsConnected O B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A -&gt; IsConnected O B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?; <span class="bp">exact</span> (contr_equiv (O A) (O_functor O f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isconnected_equiv&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>) {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : IsConnected O A -&gt; IsConnected O B
    := isconnected_equiv A f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The O-connected types form a subuniverse. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23b"><span class="kn">Definition</span> <span class="nf">Conn</span> : Subuniverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23d">rapply (Build_Subuniverse (IsConnected O)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
IsConnected O T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; IsConnected O U</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23e"><span class="nb">simpl</span>; <span class="nb">intros</span> T U isconnT f isequivf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isconnT</var><span class="hyp-type"><b>: </b><span>IsConnected O T</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; U</span></span></span><br><span><var>isequivf</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O U</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv T f isconnT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connectedness of a type [A] can equivalently be characterized by the fact that any map to an [O]-type [C] is nullhomotopic.  Here is one direction of that equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk23f"><span class="kn">Definition</span> <span class="nf">isconnected_elim</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsConnected O A} (C : <span class="kt">Type</span>) `{In O C} (f : A -&gt; C)
  : NullHomotopy f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk240"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk241"><span class="nb">set</span> (ff := @O_rec O _ _ _ _ _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>ff</var><span><span class="hyp-body"><b>:= </b><span>O_rec f</span></span><span class="hyp-type"><b>: </b><span>O_reflector O A -&gt; C</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk242"><span class="kr">exists</span> (<span class="nv">ff</span> (center _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>ff</var><span><span class="hyp-body"><b>:= </b><span>O_rec f</span></span><span class="hyp-type"><b>: </b><span>O_reflector O A -&gt; C</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, f x = ff (center (O_reflector O A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk243"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>ff</var><span><span class="hyp-body"><b>:= </b><span>O_rec f</span></span><span class="hyp-type"><b>: </b><span>O_reflector O A -&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = ff (center (O_reflector O A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk244"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>ff</var><span><span class="hyp-body"><b>:= </b><span>O_rec f</span></span><span class="hyp-type"><b>: </b><span>O_reflector O A -&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ff (center (O_reflector O A)) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk245"><span class="nb">refine</span> (ap ff (contr (to O _ a)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>ff</var><span><span class="hyp-body"><b>:= </b><span>O_rec f</span></span><span class="hyp-type"><b>: </b><span>O_reflector O A -&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ff (to O A a) = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** For the other direction of the equivalence, it&#39;s sufficient to consider the case when [C] is [O A]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk246"><span class="kn">Definition</span> <span class="nf">isconnected_from_elim_to_O</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  : NullHomotopy (to O A) -&gt; IsConnected O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O A) -&gt; IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk247"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O A) -&gt; IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk248"><span class="nb">intros</span> nh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk249"><span class="nb">apply</span> (Build_Contr _ (nh .<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : O_reflector O A, nh.<span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24a">rapply O_indpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; nh.<span class="mi">1</span>) == (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">symmetry</span>; <span class="nb">apply</span> (nh .<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now the general case follows. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24b"><span class="kn">Definition</span> <span class="nf">isconnected_from_elim</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  : (<span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) `{In O C} (f : A -&gt; C), NullHomotopy f)
    -&gt; IsConnected O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
 In O C -&gt; <span class="kr">forall</span> <span class="nv">f</span> : A -&gt; C, NullHomotopy f) -&gt;
IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
 In O C -&gt; <span class="kr">forall</span> <span class="nv">f</span> : A -&gt; C, NullHomotopy f) -&gt;
IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24d"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
In O C -&gt; <span class="kr">forall</span> <span class="nv">f</span> : A -&gt; C, NullHomotopy f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_from_elim_to_O (H (O A) (O_inO A) (to O A))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connected types are closed under sigmas. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24e">#[export] <span class="kn">Instance</span> <span class="nf">isconnected_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>}
             `{IsConnected O A} `{<span class="kr">forall</span> <span class="nv">a</span>, IsConnected O (B a)}
  : IsConnected O {a:A &amp; B a}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk24f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk250"><span class="nb">apply</span> isconnected_from_elim; <span class="nb">intros</span> C ? f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a} -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk251"><span class="nb">pose</span> (nB := <span class="kr">fun</span> <span class="nv">a</span> =&gt; @isconnected_elim (B a) _ C _ (<span class="kr">fun</span> <span class="nv">b</span> =&gt; f (a;b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a} -&gt; C</span></span></span><br><span><var>nB</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
isconnected_elim C (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
NullHomotopy (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk252"><span class="nb">pose</span> (nA := isconnected_elim C (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (nB a).<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a} -&gt; C</span></span></span><br><span><var>nB</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
isconnected_elim C (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
NullHomotopy (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span></span></span><br><span><var>nA</var><span><span class="hyp-body"><b>:= </b><span>isconnected_elim C (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (nB a).<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (nB a).<span class="mi">1</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk253"><span class="kr">exists</span> (<span class="nv">nA</span>.<span class="mi">1</span>); <span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a} -&gt; C</span></span></span><br><span><var>nB</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
isconnected_elim C (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
NullHomotopy (<span class="kr">fun</span> <span class="nv">b</span> : B a =&gt; f (a; b))</span></span></span></span><br><span><var>nA</var><span><span class="hyp-body"><b>:= </b><span>isconnected_elim C (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (nB a).<span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (nB a).<span class="mi">1</span>)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a; b) = nA.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((nB a).<span class="mi">2</span> b @ nA.<span class="mi">2</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Contractible types are connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk254">#[export] <span class="kn">Instance</span> <span class="nf">isconnected_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{Contr A}
    : IsConnected O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk255"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply contr_O_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A type which is both connected and modal is contractible. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk256"><span class="kn">Definition</span> <span class="nf">contr_trunc_conn</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{In O A} `{IsConnected O A}
  : Contr A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk257"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv _ (to O A)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Any map between connected types is inverted by O. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk258">#[export] <span class="kn">Instance</span> <span class="nf">O_inverts_isconnected</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
             `{IsConnected O A} `{IsConnected O B}
    : O_inverts O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk259"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here&#39;s another way of stating the universal property for mapping out of connected types into modal ones. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25a"><span class="kn">Definition</span> <span class="nf">extendable_const_isconnected_inO</span> (<span class="nv">n</span> : nat)
             (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsConnected O A}
             (C : <span class="kt">Type</span>) `{In O C}
  : ExtendableAlong n (const_tt A) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (const_tt A) (unit_name C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (const_tt A) (unit_name C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25c"><span class="nb">generalize dependent</span> C;
      simple_induction n n IHn; <span class="nb">intros</span> C ?;
      [ <span class="bp">exact</span> tt | <span class="nb">split</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : A -&gt; C,
ExtensionAlong (const_tt A) (unit_name C) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk25d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk25d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : Unit -&gt; C,
ExtendableAlong n (const_tt A)
  (<span class="kr">fun</span> <span class="nv">b</span> : Unit =&gt; h b = k b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : A -&gt; C,
ExtensionAlong (const_tt A) (unit_name C) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk25f"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (const_tt A) (unit_name C) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk260"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> : Unit =&gt; (isconnected_elim C f).<span class="mi">1</span>); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isconnected_elim C f).<span class="mi">1</span> = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> ((isconnected_elim C f).<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk261">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : Unit -&gt; C,
ExtendableAlong n (const_tt A)
  (<span class="kr">fun</span> <span class="nv">b</span> : Unit =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk262"><span class="nb">intros</span> h k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>Unit -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (const_tt A)
  (<span class="kr">fun</span> <span class="nv">b</span> : Unit =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk263"><span class="nb">refine</span> (extendable_postcompose&#39; n _ _ _ _ (IHn (h tt = k tt) (inO_paths _ _ _ _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, In O C -&gt; ExtendableAlong n (const_tt A) (unit_name C)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span>Unit -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit, h tt = k tt &lt;~&gt; h b = k b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">exact</span> equiv_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ooextendable_const_isconnected_inO</span>
             (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) `{IsConnected@{i} O A}
             (C : <span class="kt">Type</span>@{j}) `{In O C}
  : ooExtendableAlong (const_tt A) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C)
    := <span class="kr">fun</span> <span class="nv">n</span> =&gt; extendable_const_isconnected_inO n A C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk264"><span class="kn">Definition</span> <span class="nf">isequiv_const_isconnected_inO</span> `{Funext}
             {A : <span class="kt">Type</span>} `{IsConnected O A} (C : <span class="kt">Type</span>) `{In O C}
  : IsEquiv (@const A C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk265"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In O C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@isequiv_compose _ _ _ (<span class="kr">fun</span> <span class="nv">c</span> <span class="nv">u</span> =&gt; c) _ _
              (isequiv_ooextendable (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C) (const_tt A)
                                    (ooextendable_const_isconnected_inO A C))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_const_isconnected_inO</span> `{Funext}
             {A : <span class="kt">Type</span>} `{IsConnected O A} (C : <span class="kt">Type</span>) `{In O C}
  : C &lt;~&gt; (A -&gt; C) := Build_Equiv _ _ const (isequiv_const_isconnected_inO C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ConnectedTypes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Modally truncated maps *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ModalMaps</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : ReflectiveSubuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Any equivalence is modal *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk266">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
  : MapIn O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk267"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A slightly specialized result: if [Empty] is modal, then a map with decidable hprop fibers (such as [inl] or [inr]) is modal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk268">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_hfiber_decidable_hprop</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
         `{In O Empty}
         `{<span class="kr">forall</span> <span class="nv">b</span>, IsHProp (hfiber f b)}
         `{<span class="kr">forall</span> <span class="nv">b</span>, Decidable (hfiber f b)}
  : MapIn O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk269"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26a"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26b"><span class="nb">destruct</span> (equiv_decidable_hprop (hfiber f b)) <span class="kr">as</span> [e|e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hfiber f b &lt;~&gt; Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk26c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hfiber f b &lt;~&gt; Empty</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk26c"><hr></label><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hfiber f b &lt;~&gt; Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO Unit e^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O Empty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsHProp (hfiber f b)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Decidable (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hfiber f b &lt;~&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO Empty e^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Any map between modal types is modal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk26f">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_between_inO</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
             `{In O A} `{In O B}
  : MapIn O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk270"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Modal maps cancel on the left. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk271"><span class="kn">Definition</span> <span class="nf">cancelL_mapinO</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
  : MapIn O g -&gt; MapIn O (g o f) -&gt; MapIn O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g -&gt; MapIn O (g o f) -&gt; MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk272"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g -&gt; MapIn O (g o f) -&gt; MapIn O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk273"><span class="nb">intros</span> ? ? b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn O (g o f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_hfiber_compose_map f g b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Modal maps also cancel with equivalences on the other side. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk274"><span class="kn">Definition</span> <span class="nf">cancelR_isequiv_mapinO</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
    `{IsEquiv _ _ f} `{MapIn O _ _ (g o f)}
  : MapIn O g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk275"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk276"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O (g o f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber g b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk277">srefine (inO_equiv_inO&#39; (hfiber (g o f) b) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O (g o f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (g o f) b &lt;~&gt; hfiber g b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_functor_sigma f (<span class="kr">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>%equiv)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cancelR_equiv_mapinO</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">g</span> : B -&gt; C)
    `{MapIn O _ _ (g o f)}
  : MapIn O g
  := cancelR_isequiv_mapinO f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The pullback of a modal map is modal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk278">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
         (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A) `{MapIn O _ _ g}
  : MapIn O (f^* g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (f^* g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk279"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (f^* g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27a"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (f^* g) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_pullback_along f g b)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27b">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_pullback&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
         (<span class="nv">g</span> : C -&gt; A) (<span class="nv">f</span> : B -&gt; A) `{MapIn O _ _ f}
  : MapIn O (g^*&#39; f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (g ^*&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (g ^*&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27d"><span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (g ^*&#39; f) c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_pullback_along&#39; g f c)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** [functor_sum] preserves modal maps. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27e">#[export] <span class="kn">Instance</span> <span class="nf">mapinO_functor_sum</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span>}
         (<span class="nv">f</span> : A -&gt; A&#39;) (<span class="nv">g</span> : B -&gt; B&#39;) `{MapIn O _ _ f} `{MapIn O _ _ g}
  : MapIn O (functor_sum f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk27f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk280"><span class="nb">intros</span> [a|b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (functor_sum f g) (inl a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk281" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk281"><hr></label><div class="goal-conclusion">In O (hfiber (functor_sum f g) (inr b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk282">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (functor_sum f g) (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_functor_sum_l f g a)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk283">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (functor_sum f g) (inr b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_functor_sum_r f g b)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** So does [unfunctor_sum], if both summands are preserved.  These can&#39;t be [Instance]s since they require [Ha] and [Hb] to be supplied. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk284"><span class="kn">Definition</span> <span class="nf">mapinO_unfunctor_sum_l</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span>}
         (<span class="nv">h</span> : A + B -&gt; A&#39; + B&#39;)
         (<span class="nv">Ha</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, is_inl (h (inl a)))
         (<span class="nv">Hb</span> : <span class="kr">forall</span> <span class="nv">b</span>:B, is_inr (h (inr b)))
         `{MapIn O _ _ h}
  : MapIn O (unfunctor_sum_l h Ha).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (unfunctor_sum_l h Ha)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk285"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (unfunctor_sum_l h Ha)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk286"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (unfunctor_sum_l h Ha) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_unfunctor_sum_l h Ha Hb a)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk287"><span class="kn">Definition</span> <span class="nf">mapinO_unfunctor_sum_r</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span>}
         (<span class="nv">h</span> : A + B -&gt; A&#39; + B&#39;)
         (<span class="nv">Ha</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, is_inl (h (inl a)))
         (<span class="nv">Hb</span> : <span class="kr">forall</span> <span class="nv">b</span>:B, is_inr (h (inr b)))
         `{MapIn O _ _ h}
  : MapIn O (unfunctor_sum_r h Hb).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (unfunctor_sum_r h Hb)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk288"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (unfunctor_sum_r h Hb)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk289"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A + B -&gt; A&#39; + B&#39;</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, is_inr (h (inr b))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn O h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (unfunctor_sum_r h Hb) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_unfunctor_sum_r h Ha Hb b)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Given a family of maps [f : forall a, P a -&gt; Q a] which are in [O], the induced map on Pi types is also in [O]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28a"><span class="kn">Definition</span> <span class="nf">mapinO_functor_forall_id</span> `{Funext}
    {A : <span class="kt">Type</span>} {P Q : A -&gt; <span class="kt">Type</span>} (f : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) `{<span class="kr">forall</span> <span class="nv">a</span>, MapIn O (f a)}
    : MapIn O (functor_forall_id f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, MapIn O (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (functor_forall_id f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, MapIn O (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O (functor_forall_id f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28c"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, MapIn O (f a)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (hfiber (functor_forall_id f) g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO _ (hfiber_functor_forall_id f g)^-<span class="mi">1</span>%equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ModalMaps</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Modally connected maps *)</span>

<span class="sd">(** Connectedness of a map can again be defined in two equivalent ways: by connectedness of its fibers (as types), or by the lifting property/elimination principle against modal types.  We use the former; the equivalence with the latter is given below in [conn_map_elim], [conn_map_comp], and [conn_map_from_extension_elim]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsConnMap</span> (<span class="nv">O</span> : ReflectiveSubuniverse@{i})
      {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} {<span class="nv">B</span> : <span class="kt">Type</span>@{i}} (<span class="nv">f</span> : A -&gt; B)
  := isconnected_hfiber_conn_map
     <span class="sd">(** The extra universe [k] is &gt;= max(i,j). *)</span>
     :: <span class="kr">forall</span> <span class="nv">b</span>:B, IsConnected@{i} O (hfiber@{i i} f b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ConnectedMaps</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Universe</span> <span class="nf">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : ReflectiveSubuniverse@{i}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Any equivalence is connected *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28d">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
  : IsConnMap O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Anything homotopic to a connected map is connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk28f"><span class="kn">Definition</span> <span class="nf">conn_map_homotopic</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">h</span> : f == g)
  : IsConnMap O f -&gt; IsConnMap O g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f -&gt; IsConnMap O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk290"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f -&gt; IsConnMap O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk291"><span class="nb">intros</span> ? b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber g b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv O (hfiber@{i i} f b)
                             (equiv_hfiber_homotopic@{i i i} f g h b) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The pullback of a connected map is connected *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk292">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
         (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A) `{IsConnMap O _ _ g}
  : IsConnMap O (f^* g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (f^* g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk293"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (f^* g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk294"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber (f^* g) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv _ _ (hfiber_pullback_along f g b)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk295">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_pullback&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
         (<span class="nv">g</span> : C -&gt; A) (<span class="nv">f</span> : B -&gt; A) `{IsConnMap O _ _ f}
  : IsConnMap O (g^*&#39; f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (g ^*&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk296"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (g ^*&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk297"><span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber (g ^*&#39; f) c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv _ _ (hfiber_pullback_along&#39; g f c)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The projection from a family of connected types is connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk298">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>}
         `{<span class="kr">forall</span> <span class="nv">a</span>, IsConnected O (B a)}
  : IsConnMap O (@pr1 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk299"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29a"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnected O (B a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber pr1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv O (B a) (hfiber_fibration a B) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Being connected is an hprop *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29b">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_isconnmap</span> `{Funext} {A B : <span class="kt">Type</span>} (f : A -&gt; B)
  : IsHProp (IsConnMap O f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsConnMap O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsConnMap O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> istrunc_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A map which is both connected and modal is an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29d"><span class="kn">Definition</span> <span class="nf">isequiv_conn_ino_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
             `{IsConnMap O _ _ f} `{MapIn O _ _ f}
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk29f"><span class="nb">apply</span> isequiv_contr_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a0"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_trunc_conn O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connected maps are orthogonal to modal maps (i.e. families of modal types). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a1"><span class="kn">Definition</span> <span class="nf">conn_map_elim</span>
             {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
             (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
             (d : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a))
  : <span class="kr">forall</span> <span class="nv">b</span>:B, P b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a3"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a4"><span class="nb">refine</span> (pr1 (isconnected_elim O (A:=hfiber f b) _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a5"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport P p (d a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a6"><span class="kn">Definition</span> <span class="nf">conn_map_comp</span>
             {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
             (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
             (d : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a))
  : <span class="kr">forall</span> <span class="nv">a</span>:A, conn_map_elim f P d (f a) = d a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, conn_map_elim f P d (f a) = d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, conn_map_elim f P d (f a) = d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a8"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim f P d (f a) = d a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2a9"><span class="nb">unfold</span> conn_map_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isconnected_elim O (P (f a))
   (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f (f a) =&gt; transport P X.<span class="mi">2</span> (d X.<span class="mi">1</span>))).<span class="mi">1</span> =
d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2aa"><span class="nb">set</span> (fibermap := (<span class="kr">fun</span> <span class="nv">a0p</span> : hfiber f (f a)
                      =&gt; <span class="kr">let</span> (<span class="nv">a0</span>, p) := a0p <span class="kr">in</span> transport P p (d a0))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>fibermap</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a0p</span> : hfiber f (f a) =&gt;
<span class="kr">let</span> <span class="nv">a0</span> := a0p.<span class="mi">1</span> <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">p</span> := a0p.<span class="mi">2</span> <span class="kr">in</span> transport P p (d a0)</span></span><span class="hyp-type"><b>: </b><span>hfiber f (f a) -&gt; P (f a)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isconnected_elim O (P (f a)) fibermap).<span class="mi">1</span> = d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ab"><span class="nb">destruct</span> (isconnected_elim O (P (f a)) fibermap) <span class="kr">as</span> [x e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>fibermap</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a0p</span> : hfiber f (f a) =&gt;
<span class="kr">let</span> <span class="nv">a0</span> := a0p.<span class="mi">1</span> <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">p</span> := a0p.<span class="mi">2</span> <span class="kr">in</span> transport P p (d a0)</span></span><span class="hyp-type"><b>: </b><span>hfiber f (f a) -&gt; P (f a)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P (f a)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : hfiber f (f a), fibermap x0 = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; e).<span class="mi">1</span> = d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ac"><span class="nb">change</span> (d a) <span class="kr">with</span> (fibermap (a;<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>fibermap</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">a0p</span> : hfiber f (f a) =&gt;
<span class="kr">let</span> <span class="nv">a0</span> := a0p.<span class="mi">1</span> <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">p</span> := a0p.<span class="mi">2</span> <span class="kr">in</span> transport P p (d a0)</span></span><span class="hyp-type"><b>: </b><span>hfiber f (f a) -&gt; P (f a)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P (f a)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : hfiber f (f a), fibermap x0 = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; e).<span class="mi">1</span> = fibermap (a; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inverse, e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We can re-express this in terms of extensions. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ad"><span class="kn">Lemma</span> <span class="nf">extension_conn_map_elim</span>
        {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
        (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
        (d : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a))
  : ExtensionAlong f P d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong f P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong f P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2af"><span class="kr">exists</span> (<span class="nv">conn_map_elim</span> <span class="nv">f</span> <span class="nv">P</span> <span class="nv">d</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, conn_map_elim f P d (f x) = d x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> conn_map_comp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b0"><span class="kn">Definition</span> <span class="nf">extendable_conn_map_inO</span> (<span class="nv">n</span> : nat)
             {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
             (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
  : ExtendableAlong n f P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b2"><span class="nb">generalize dependent</span> P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt; ExtendableAlong n f P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b3">simple_induction n n IHn; <span class="nb">intros</span> P ?; [ <span class="bp">exact</span> tt | <span class="nb">split</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>, (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt; ExtendableAlong n f P</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a), ExtensionAlong f P g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>, (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt; ExtendableAlong n f P</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2b4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>, (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt; ExtendableAlong n f P</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a), ExtensionAlong f P g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> d; <span class="nb">apply</span> extension_conn_map_elim; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>, (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt; ExtendableAlong n f P</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> h k; <span class="nb">apply</span> IHn; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ooextendable_conn_map_inO</span>
             {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
             (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
  : ooExtendableAlong f P
    := <span class="kr">fun</span> <span class="nv">n</span> =&gt; extendable_conn_map_inO n f P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b7"><span class="kn">Lemma</span> <span class="nf">allpath_extension_conn_map</span> `{Funext}
        {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsConnMap O _ _ f}
        (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
        (d : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a))
        (e e&#39; : ExtensionAlong f P d)
  : e = e&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>e, e'</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f P d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e = e&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>e, e'</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f P d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e = e&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2b9"><span class="nb">apply</span> path_extension.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>e, e'</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f P d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong f (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; e.<span class="mi">1</span> y = e&#39;.<span class="mi">1</span> y)
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; e.<span class="mi">2</span> x @ (e&#39;.<span class="mi">2</span> x)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (extension_conn_map_elim _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It follows that [conn_map_elim] is actually an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ba"><span class="kn">Theorem</span> <span class="nf">isequiv_o_conn_map</span> `{Funext}
          {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsConnMap O _ _ f}
          (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
  : IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span>:B, P b) =&gt; g oD f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2bb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2bc"><span class="nb">apply</span> isequiv_contr_map; <span class="nb">intros</span> d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2bd"><span class="nb">apply</span> contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  (hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2be"><hr></label><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  (hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c0">nrefine (@istrunc_equiv_istrunc {g : <span class="kr">forall</span> <span class="nv">b</span>, P b &amp; g oD f == d} _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d} &lt;~&gt;
hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2c1"><hr></label><div class="goal-conclusion">IsHProp {g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d} &lt;~&gt;
hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c3"><span class="nb">refine</span> (equiv_functor_sigma_id _); <span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g oD f == d &lt;~&gt; g oD f = d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_forall.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp {g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c5"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : {g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d},
x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c6"><span class="nb">intros</span> g h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>{g : <span class="kr">forall</span> <span class="nv">b</span> : B, P b &amp; g oD f == d}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (allpath_extension_conn_map f P d g h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, P b =&gt; g oD f) d</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c8"><span class="kr">exists</span> (<span class="nv">conn_map_elim</span> <span class="nv">f</span> <span class="nv">P</span> <span class="nv">d</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim f P d oD f = d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> x; <span class="nb">apply</span> conn_map_comp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_o_conn_map</span> `{Funext}
          {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsConnMap O _ _ f}
          (P : B -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
  : (<span class="kr">forall</span> <span class="nv">b</span>, P b) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">a</span>, P (f a))
  := Build_Equiv _ _ _ (isequiv_o_conn_map f P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** When considering lexness properties, we often want to consider the property of the universe of modal types being modal.  We can&#39;t say this directly (except in the accessible, hence liftable, case) because it lives in a higher universe, but we can make a direct extendability statement.  Here we prove a lemma that oo-extendability into the universe follows from plain extendability, essentially because the type of equivalences between two [O]-modal types is [O]-modal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2c9"><span class="kn">Definition</span> <span class="nf">ooextendable_TypeO_from_extension</span> `{Univalence}
             {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsConnMap O _ _ f}
             (extP : <span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O, ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P)
    : ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Type_ O).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** By definition, in addition to our assumption [extP] that maps into [Type_ O] extend along [f], we must show that sections of families of equivalences are [ooExtendableAlong] it.  *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2cb"><span class="nb">intros</span> [|[|n]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">0</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2cc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2cc"><hr></label><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2cd"><hr></label><div class="goal-conclusion">ExtendableAlong n.+<span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">0</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> tt.                                 <span class="c">(* n = 0 *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Note that due to the implementation of [ooExtendableAlong], we actually have to use [extP] twice (there should probably be a general cofixpoint lemma for this). *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2cf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; [ <span class="nb">apply</span> extP | <span class="nb">intros</span>; <span class="bp">exact</span> tt ]. <span class="c">(* n = 1 *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n.+<span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d1"><span class="nb">split</span>; [ <span class="nb">apply</span> extP | ].                  <span class="c">(* n &gt; 1 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : B -&gt; Type_ O,
ExtendableAlong n.+<span class="mi">1</span> f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** What remains is to extend families of paths. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d2"><span class="nb">intros</span> P Q; rapply (ooextendable_postcompose&#39; (<span class="kr">fun</span> <span class="nv">b</span> =&gt; P b &lt;~&gt; Q b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>B -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, (P b &lt;~&gt; Q b) &lt;~&gt; P b = Q b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2d3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>B -&gt; Type_ O</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2d3"><hr></label><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; P b &lt;~&gt; Q b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>B -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, (P b &lt;~&gt; Q b) &lt;~&gt; P b = Q b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (equiv_path_TypeO _ _ _ oE equiv_path_universe _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>extP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; Type_ O,
ExtensionAlong f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Type_ O) P</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>B -&gt; Type_ O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; P b &lt;~&gt; Q b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Conversely, if a map satisfies this elimination principle (expressed via extensions), then it is connected.  This completes the proof of Lemma 7.5.7 from the book. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d6"><span class="kn">Lemma</span> <span class="nf">conn_map_from_extension_elim</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  : (<span class="kr">forall</span> (<span class="nv">P</span> : B -&gt; <span class="kt">Type</span>) {<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">b</span>:B, In O (P b)}
            (<span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a)),
       ExtensionAlong f P d)
    -&gt; IsConnMap O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
 (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
 <span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
 ExtensionAlong f P d) -&gt; IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
 (<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
 <span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
 ExtensionAlong f P d) -&gt; IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d8"><span class="nb">intros</span> Hf b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2d9"><span class="nb">apply</span> isconnected_from_elim_to_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O (hfiber f b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2da" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2da"><span class="nb">assert</span> (e := Hf (<span class="kr">fun</span> <span class="nv">b</span> =&gt; O (hfiber f b)) _ (<span class="kr">fun</span> <span class="nv">a</span> =&gt; to O _ (a;<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; O (hfiber f b))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; to O (hfiber f (f a)) (a; <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O (hfiber f b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2db"><span class="kr">exists</span> (<span class="nv">e</span>.<span class="mi">1</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; O (hfiber f b))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; to O (hfiber f (f a)) (a; <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : hfiber f b, to O (hfiber f b) x = e.<span class="mi">1</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2dc"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; O (hfiber f b))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; to O (hfiber f (f a)) (a; <span class="mi">1</span>))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (hfiber f b) (a; p) = e.<span class="mi">1</span> b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2dd"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
ExtensionAlong f P d</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; O (hfiber f b))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; to O (hfiber f (f a)) (a; <span class="mi">1</span>))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (hfiber f (f a)) (a; <span class="mi">1</span>) = e.<span class="mi">1</span> (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> (e.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Lemma 7.5.6: Connected maps compose and cancel on the right. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2de">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
         `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
  : IsConnMap O (g o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e0"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span> P ? d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : C, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (g (f a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e1"><span class="kr">exists</span> (<span class="nv">conn_map_elim</span> <span class="nv">g</span> <span class="nv">P</span> (conn_map_elim f (<span class="kr">fun</span> <span class="nv">b</span> =&gt; P (g b)) d)); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : C, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (g (f a))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim g P
  (conn_map_elim f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; P (g b)) d) (g (f a)) =
d a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_map_comp g P _ _ @ conn_map_comp f (<span class="kr">fun</span> <span class="nv">b</span> =&gt; P (g b)) d a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">      
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e2"><span class="kn">Definition</span> <span class="nf">cancelR_conn_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
         `{IsConnMap O _ _ f} `{IsConnMap O _ _ (g o f)}
  :  IsConnMap O g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e4"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span> P ? d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : C, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : B, P (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong g P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e5"><span class="kr">exists</span> (<span class="nv">conn_map_elim</span> (g o f) P (d oD f)); <span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : C, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : B, P (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) P (d oD f) (g b) =
d b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e6"><span class="nb">pattern</span> b; <span class="nb">refine</span> (conn_map_elim f _ _ b); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : C, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : B, P (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) P (d oD f)
  (g (f a)) = d (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_map_comp (g o f) P (d oD f) a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connected maps also cancel with equivalences on the other side. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e7"><span class="kn">Definition</span> <span class="nf">cancelL_isequiv_conn_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
         `{IsEquiv _ _ g} `{IsConnMap O _ _ (g o f)}
    : IsConnMap O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2e9"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ea">srefine (isconnected_equiv&#39; O (hfiber (g o f) (g b)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv g</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (g o f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (g o f) (g b) &lt;~&gt; hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_inverse (equiv_functor_sigma_id (<span class="kr">fun</span> <span class="nv">a</span> =&gt; equiv_ap g (f a) b))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cancelL_equiv_conn_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B &lt;~&gt; C)
         `{IsConnMap O _ _ (g o f)}
    : IsConnMap O f
    := cancelL_isequiv_conn_map f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The constant map to [Unit] is connected just when its domain is. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2eb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2eb"><span class="kn">Definition</span> <span class="nf">isconnected_conn_map_to_unit</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
             `{IsConnMap O _ _ (const_tt A)}
  : IsConnected O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (const_tt A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (const_tt A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv O (hfiber (const_tt A) tt)
              (equiv_sigma_contr _) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local]
  <span class="kn">Hint Immediate</span> isconnected_conn_map_to_unit : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ed">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_to_unit_isconnected</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
         `{IsConnected O A}
  : IsConnMap O (const_tt A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (const_tt A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (const_tt A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ef"><span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected O A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber (const_tt A) u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv O A
              (equiv_sigma_contr _)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
 <span class="sd">(** Combining the above, we see that if [f] is a connected map with connected codomain, then the domain is connected. *)</span>
</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f0"><span class="kn">Instance</span> <span class="nf">isconnected_conn_map_isconnected</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
         `{IsConnMap O _ _ f} `{IsConnected O B}
   : IsConnected O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f2">rapply isconnected_conn_map_to_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (const_tt A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input">rapply conn_map_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Lemma 7.5.10: A map to a type in [O] exhibits its codomain as the [O]-reflection of its domain if it is [O]-connected.  (The converse is true if and only if [O] is a modality.) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f3"><span class="kn">Definition</span> <span class="nf">isequiv_O_rec_conn_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{In O B}
             (f : A -&gt; B) `{IsConnMap O _ _ f}
  : IsEquiv (O_rec (O := O) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_rec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (O_rec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f5"><span class="nb">refine</span> (isequiv_adjointify _ (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; O A) (to O A)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 O_rec f
   (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) x)) ==
idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk2f6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk2f6"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
 conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A)
   (O_rec f x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 O_rec f
   (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f8"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f
  (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) x) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2f9"><span class="nb">pattern</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
 O_rec f
   (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) b) = b)
  x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2fa"><span class="nb">refine</span> (conn_map_elim f _ _ x); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec f
  (conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) (f a)) =
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (O_rec f)
                (conn_map_comp f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; O A) (to O A) a)
                @ O_rec_beta f a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2fb" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
 conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A)
   (O_rec f x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2fc"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A)
  (O_rec f (to O A a)) = to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2fd"><span class="nb">refine</span> (ap _ (O_rec_beta f a) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; O A) (to O A) (f a) =
to O A a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_map_comp f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; O A) (to O A) a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Lemma 7.5.12 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ConnMapFunctorSigma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>}
            (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
            `{<span class="kr">forall</span> <span class="nv">a</span>, IsConnMap O (g a)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2fe"><span class="kn">Definition</span> <span class="nf">equiv_O_hfiber_functor_sigma</span> (<span class="nv">b</span>:B) (<span class="nv">v</span>:Q b)
    : O (hfiber (functor_sigma f g) (b;v)) &lt;~&gt; O (hfiber f b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber (functor_sigma f g) (b; v)) &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk2ff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber (functor_sigma f g) (b; v)) &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk300">equiv_via (O {w : hfiber f b &amp; hfiber (g w.<span class="mi">1</span>) ((w.<span class="mi">2</span>)^ # v)}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber (functor_sigma f g) (b; v)) &lt;~&gt;
O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk301" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk301"><hr></label><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)} &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk302">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber (functor_sigma f g) (b; v)) &lt;~&gt;
O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_O_functor, hfiber_functor_sigma.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk303">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)} &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk304">equiv_via (O {w : hfiber f b &amp; O (hfiber (g w.<span class="mi">1</span>) ((w.<span class="mi">2</span>)^ # v))}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)} &lt;~&gt;
O
  {w : hfiber f b &amp;
  O (hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk305" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk305"><hr></label><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  O (hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))} &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk306">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)} &lt;~&gt;
O
  {w : hfiber f b &amp;
  O (hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_O_sigma_O.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk307">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O
  {w : hfiber f b &amp;
  O (hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))} &lt;~&gt;
O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk308"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{w : hfiber f b &amp;
O (hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))} &lt;~&gt;
hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_sigma_contr; <span class="nb">intros</span> [a p]; <span class="nb">simpl</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk309">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_functor_sigma</span> `{IsConnMap O _ _ f}
    : IsConnMap O (functor_sigma f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30b"><span class="nb">intros</span> [b v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber (functor_sigma f g) (b; v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv&#39; _ (equiv_inverse (equiv_O_hfiber_functor_sigma b v))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30c"><span class="kn">Definition</span> <span class="nf">conn_map_base_inhabited</span> (<span class="nv">inh</span> : <span class="kr">forall</span> <span class="nv">b</span>, Q b)
               `{IsConnMap O _ _ (functor_sigma f g)}
    : IsConnMap O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma f g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma f g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30e"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (g a)</span></span></span><br><span><var>inh</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma f g)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv _ (equiv_O_hfiber_functor_sigma b (inh b))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ConnMapFunctorSigma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Lemma 7.5.13.  The &quot;if&quot; direction is a special case of [conn_map_functor_sigma], so we prove only the &quot;only if&quot; direction. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk30f"><span class="kn">Definition</span> <span class="nf">conn_map_fiber</span>
             {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a)
             `{IsConnMap O _ _ (functor_sigma idmap f)}
  : <span class="kr">forall</span> <span class="nv">a</span>, IsConnMap O (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma idmap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk310" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk310"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma idmap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsConnMap O (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk311"><span class="nb">intros</span> a q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma idmap f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (hfiber (f a) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk312" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk312"><span class="nb">refine</span> (isconnected_equiv&#39; O (hfiber (functor_sigma idmap f) (a;q)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O (functor_sigma idmap f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_sigma idmap f) (a; q) &lt;~&gt;
hfiber (f a) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (hfiber_functor_sigma_idmap P Q f a q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Lemma 7.5.14: Connected maps are inverted by [O]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk313">#[export] <span class="kn">Instance</span> <span class="nf">O_inverts_conn_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
         `{IsConnMap O _ _ f}
    : O_inverts O f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk314"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk315">rapply O_inverts_from_extendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O Z -&gt; ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; rapply extendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** As a consequence, connected maps between modal types are equivalences. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_conn_map_ino</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
         `{In O A} `{In O B} `{IsConnMap O _ _ f}
    : IsEquiv f
    := isequiv_commsq&#39; f (O_functor O f) (to O A) (to O B) (to_O_natural O f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connectedness is preserved by [O_functor]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk316" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk316">#[export] <span class="kn">Instance</span> <span class="nf">conn_map_O_functor</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsConnMap O _ _ f}
    : IsConnMap O (O_functor O f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (O_functor O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk317"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (O_functor O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk318"><span class="nb">unfold</span> O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; to O B (f x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply conn_map_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connected maps are preserved by coproducts *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk319"><span class="kn">Definition</span> <span class="nf">conn_map_sum</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span>} (<span class="nv">f</span> : A -&gt; A&#39;) (<span class="nv">g</span> : B -&gt; B&#39;)
             `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
    : IsConnMap O (functor_sum f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_sum f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31b"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O g</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A&#39; + B&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A&#39; + B&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A + B, P (functor_sum f g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (functor_sum f g) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> extension_functor_sum; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Connected maps are preserved by coequalizers *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31c"><span class="kn">Definition</span> <span class="nf">conn_map_functor_coeq</span> {<span class="nv">B</span> <span class="nv">A</span> <span class="nv">B&#39;</span> <span class="nv">A&#39;</span>}
             {<span class="nv">f</span> <span class="nv">g</span> : B -&gt; A} {<span class="nv">f&#39;</span> <span class="nv">g&#39;</span> : B&#39; -&gt; A&#39;}
             (<span class="nv">h</span> : B -&gt; B&#39;) (<span class="nv">k</span> : A -&gt; A&#39;)
             (<span class="nv">p</span> : k o f == f&#39; o h) (<span class="nv">q</span> : k o g == g&#39; o h)
             `{IsConnMap O _ _ k} `{IsConnMap O _ _ h}
    : IsConnMap O (functor_coeq h k p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31e"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (functor_coeq h k p q) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk31f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk31f"><span class="nb">apply</span> extension_functor_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> k (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; P (coeq x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk320" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk320"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : B&#39;, P (coeq (g&#39; x)),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk321" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk321">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> k (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; P (coeq x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk322">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : B&#39;, P (coeq (g&#39; x)),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And by pushouts *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk323"><span class="kn">Definition</span> <span class="nf">conn_map_functor_pushout</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> <span class="nv">C&#39;</span>}
             (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : A -&gt; C) {<span class="nv">f&#39;</span> : A&#39; -&gt; B&#39;} {<span class="nv">g&#39;</span> : A&#39; -&gt; C&#39;}
             (<span class="nv">h</span> : A -&gt; A&#39;) (<span class="nv">k</span> : B -&gt; B&#39;) (<span class="nv">l</span> : C -&gt; C&#39;)
             (<span class="nv">p</span> : k o f == f&#39; o h) (<span class="nv">q</span> : l o g == g&#39; o h)
             `{IsConnMap O _ _ h} `{IsConnMap O _ _ k} `{IsConnMap O _ _ l}
    : IsConnMap O (functor_pushout h k l p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk324"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk325"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (functor_pushout h k l p q) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk326" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk326"><span class="nb">apply</span> extension_functor_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> (functor_sum k l)
  (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; + C&#39; =&gt; P (coeq x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk327" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk327"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : A&#39;, P (coeq (inr (g&#39; x))),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; u x = v x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk328">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> (functor_sum k l)
  (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; + C&#39; =&gt; P (coeq x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> extendable_functor_sum; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk329">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : A&#39;, P (coeq (inr (g&#39; x))),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ConnectedMaps</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Containment of (reflective) subuniverses *)</span>

<span class="sd">(** One subuniverse is contained in another if every [O1]-modal type is [O2]-modal.  We define this parametrized by three universes: [O1] and [O2] are reflective subuniverses of [Type@{i1}] and [Type@{i2}] respectively, and the relation says that all types in [Type@{j}] that [O1]-modal are also [O2]-modal.  This implies [j &lt;= i1] and [j &lt;= i2], of course.  The most common application is when [i1 = i2 = j], but it&#39;s sometimes useful to talk about a subuniverse of a larger universe agreeing with a subuniverse of a smaller universe on the smaller universe.  *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">O_leq</span>@{i1 i2 j} (O1 : Subuniverse@{i1}) (O2 : Subuniverse@{i2})
  := inO_leq : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{j}), In O1 A -&gt; In O2 A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> inO_leq O1 O2 {_} A _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> subuniverse_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;O1 &lt;= O2&quot;</span> := (O_leq O1 O2) : subuniverse_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> subuniverse_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32a"><span class="kn">Instance</span> <span class="nf">reflexive_O_leq</span> : Reflexive O_leq | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive O_leq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive O_leq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> O A ?; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32c"><span class="kn">Instance</span> <span class="nf">transitive_O_leq</span> : Transitive O_leq | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive O_leq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive O_leq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32e"><span class="nb">intros</span> O1 O2 O3 O12 O23 A ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2, O3</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>O12</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>O23</var><span class="hyp-type"><b>: </b><span>O2 &lt;= O3</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O3 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk32f">rapply (@inO_leq O2 O3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2, O3</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>O12</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>O23</var><span class="hyp-type"><b>: </b><span>O2 &lt;= O3</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (@inO_leq O1 O2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk330"><span class="kn">Definition</span> <span class="nf">mapinO_O_leq</span> (<span class="nv">O1</span> <span class="nv">O2</span> : Subuniverse) `{O1 &lt;= O2}
           {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{MapIn O1 A B f}
  : MapIn O2 f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O1 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O2 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk331"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MapIn O1 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn O2 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; rapply (inO_leq O1 O2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This implies that every [O2]-connected type is [O1]-connected, and similarly for maps and equivalences.  We give universe annotations so that [O1] and [O2] don&#39;t have to be on the same universe, but we do have to have [i1 &lt;= i2] for this statement.  When [i2 &lt;= i1] it seems that the statement might not be true unless the RSU on the larger universe is accessibly extended from the smaller one; see [Localization.v].  *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk332"><span class="kn">Definition</span> <span class="nf">isconnected_O_leq</span>@{i1 i2}
           (O1 : ReflectiveSubuniverse@{i1}) (O2 : ReflectiveSubuniverse@{i2}) `{O_leq@{i1 i2 i1} O1 O2}
           (A : <span class="kt">Type</span>@{i1}) `{IsConnected O2 A}
  : IsConnected O1 A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O1 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk333"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O1 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk334"><span class="nb">apply</span> isconnected_from_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
In O1 C -&gt; <span class="kr">forall</span> <span class="nv">f</span> : A -&gt; C, NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk335"><span class="nb">intros</span> C C1 f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected O2 A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C1</var><span class="hyp-type"><b>: </b><span>In O1 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (isconnected_elim O2); srapply inO_leq; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This one has the same universe constraint [i1 &lt;= i2]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk336"><span class="kn">Definition</span> <span class="nf">conn_map_O_leq</span>@{i1 i2}
           (O1 : ReflectiveSubuniverse@{i1}) (O2 : ReflectiveSubuniverse@{i2}) `{O_leq@{i1 i2 i1} O1 O2}
           {A B : <span class="kt">Type</span>@{i1}} (f : A -&gt; B) `{IsConnMap O2 A B f}
  : IsConnMap O1 f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O2 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O1 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk337"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O2 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O1 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We could prove this by applying [isconnected_O_leq] fiberwise, but unless we were very careful that would collapse the two universes [i1] and [i2].  So instead we just give an analogous direct proof. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk338"><span class="nb">apply</span> conn_map_from_extension_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O2 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, In O1 (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a), ExtensionAlong f P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk339"><span class="nb">intros</span> P P_inO g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O2 f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O1 (P b)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong f P g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33a">rapply (extension_conn_map_elim O2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O2 f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, In O1 (P b)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, In O2 (P b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; rapply (inO_leq O1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is Lemma 2.12(i) in CORS, again with the same universe constraint [i1 &lt;= i2]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33b"><span class="kn">Definition</span> <span class="nf">O_inverts_O_leq</span>@{i1 i2}
           (O1 : ReflectiveSubuniverse@{i1}) (O2 : ReflectiveSubuniverse@{i2}) `{O_leq@{i1 i2 i1} O1 O2}
           {A B : <span class="kt">Type</span>@{i1}} (f : A -&gt; B) `{O_inverts O2 f}
  : O_inverts O1 f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O2 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O1 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O2 f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O1 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33d"><span class="nb">apply</span> O_inverts_from_extendable@{i1 i1 i1 i1 i1}; <span class="nb">intros</span> Z Z_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O2 f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O1 Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33e"><span class="nb">pose</span> (inO_leq O1 O2 Z _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O2 f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O1 Z</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>inO_leq O1 O2 Z Z_inO</span></span><span class="hyp-type"><b>: </b><span>In O2 Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk33f"><span class="nb">apply</span> (lift_extendablealong@{i1 i1 i1 i1 i1 i1 i2 i1 i1 i2 i1}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O2 f</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O1 Z</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>inO_leq O1 O2 Z Z_inO</span></span><span class="hyp-type"><b>: </b><span>In O2 Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> f (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ooextendable_O_inverts O2); <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Equality of (reflective) subuniverses *)</span>

<span class="sd">(** Two subuniverses are the same if they have the same modal types.  The universe parameters are the same as for [O_leq]: [O1] and [O2] are reflective subuniverses of [Type@{i1}] and [Type@{i2}], and the relation says that they agree when restricted to [Type@{j}], where [j &lt;= i1] and [j &lt;= i2]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">O_eq</span>@{i1 i2 j} (O1 : Subuniverse@{i1}) (O2 : Subuniverse@{i2}) :=
{
  O_eq_l :: O_leq@{i1 i2 j} O1 O2 ;
  O_eq_r :: O_leq@{i2 i1 j} O2 O1 ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;&lt;=&gt;&quot;</span> := O_eq : subuniverse_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_O_eq</span> <span class="nv">O1</span> <span class="nv">O2</span> : _ &lt;~&gt; O_eq O1 O2 := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk340"><span class="kn">Instance</span> <span class="nf">reflexive_O_eq</span> : Reflexive O_eq | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk341"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk342"><span class="kn">Instance</span> <span class="nf">transitive_O_eq</span> : Transitive O_eq | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk343"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> O1 O2 O3; <span class="nb">split</span>; <span class="bp">exact</span> (<span class="nb">transitivity</span> (y := O2) _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk344"><span class="kn">Instance</span> <span class="nf">symmetric_O_eq</span> : Symmetric O_eq | <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk345"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric O_eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> O1 O2 [? ?]; <span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_subuniverse</span> : _ &lt;~&gt; Subuniverse := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk346"><span class="kn">Definition</span> <span class="nf">equiv_path_subuniverse</span> `{Univalence} (O1 O2 : Subuniverse)
  : (O1 &lt;=&gt; O2) &lt;~&gt; (O1 = O2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 &lt;=&gt; O2 &lt;~&gt; O1 = O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk347" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk347"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 &lt;=&gt; O2 &lt;~&gt; O1 = O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk348"><span class="nb">refine</span> (_ oE (issig_O_eq O1 O2)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : O1 &lt;= O2 &amp; O2 &lt;= O1} &lt;~&gt; O1 = O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk349"><span class="nb">revert</span> O1 O2; <span class="nb">refine</span> (equiv_path_along_equiv issig_subuniverse _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b0</span>
 <span class="nv">b1</span> : {H : <span class="kt">Type</span> -&gt; <span class="kt">Type</span> &amp;
      {_ : Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (H T) &amp;
      <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
      H T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; H U}},
{_ : issig_subuniverse b0 &lt;= issig_subuniverse b1 &amp;
issig_subuniverse b1 &lt;= issig_subuniverse b0} &lt;~&gt;
b0 = b1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34a"><span class="nb">cbn</span>; <span class="nb">intros</span> O1 O2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>{H : <span class="kt">Type</span> -&gt; <span class="kt">Type</span> &amp;
{_ : Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (H T) &amp;
<span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
H T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; H U}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_
: {|
    In_internal := O1.<span class="mi">1</span>;
    hprop_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">1</span>;
    inO_equiv_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">2</span>
  |} &lt;=
  {|
    In_internal := O2.<span class="mi">1</span>;
    hprop_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">1</span>;
    inO_equiv_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">2</span>
  |} &amp;
{|
  In_internal := O2.<span class="mi">1</span>;
  hprop_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">1</span>;
  inO_equiv_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">2</span>
|} &lt;=
{|
  In_internal := O1.<span class="mi">1</span>;
  hprop_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">1</span>;
  inO_equiv_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">2</span>
|}} &lt;~&gt; O1 = O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34b"><span class="nb">refine</span> (equiv_path_sigma_hprop O1 O2 oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>{H : <span class="kt">Type</span> -&gt; <span class="kt">Type</span> &amp;
{_ : Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (H T) &amp;
<span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
H T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; H U}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_
: {|
    In_internal := O1.<span class="mi">1</span>;
    hprop_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">1</span>;
    inO_equiv_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">2</span>
  |} &lt;=
  {|
    In_internal := O2.<span class="mi">1</span>;
    hprop_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">1</span>;
    inO_equiv_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">2</span>
  |} &amp;
{|
  In_internal := O2.<span class="mi">1</span>;
  hprop_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">1</span>;
  inO_equiv_inO_internal := (O2.<span class="mi">2</span>).<span class="mi">2</span>
|} &lt;=
{|
  In_internal := O1.<span class="mi">1</span>;
  hprop_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">1</span>;
  inO_equiv_inO_internal := (O1.<span class="mi">2</span>).<span class="mi">2</span>
|}} &lt;~&gt; O1.<span class="mi">1</span> = O2.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34c"><span class="nb">destruct</span> O1 <span class="kr">as</span> [O1 [O1h ?]]; <span class="nb">destruct</span> O2 <span class="kr">as</span> [O2 [O2h ?]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}} &lt;~&gt; O1 = O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34d"><span class="nb">refine</span> (equiv_path_arrow _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}} &lt;~&gt; O1 == O2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk34e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk34e">srapply (equiv_iff_hprop).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  {_
  : {|
      In_internal := O1;
      hprop_inO_internal := O1h;
      inO_equiv_inO_internal := proj2
    |} &lt;=
    {|
      In_internal := O2;
      hprop_inO_internal := O2h;
      inO_equiv_inO_internal := proj0
    |} &amp;
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &lt;=
  {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk34f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk34f"><hr></label><div class="goal-conclusion">{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}} -&gt; O1 == O2</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk350" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk350"><hr></label><div class="goal-conclusion">O1 == O2 -&gt;
{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk351">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  {_
  : {|
      In_internal := O1;
      hprop_inO_internal := O1h;
      inO_equiv_inO_internal := proj2
    |} &lt;=
    {|
      In_internal := O2;
      hprop_inO_internal := O2h;
      inO_equiv_inO_internal := proj0
    |} &amp;
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &lt;=
  {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply istrunc_sigma; <span class="nb">unfold</span> O_leq; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk352">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}} -&gt; O1 == O2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk353"><span class="nb">intros</span> [h k] A; <span class="nb">specialize</span> (h A); <span class="nb">specialize</span> (k A); <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A -&gt; O2 A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>O2 A -&gt; O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 A = O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_universe_uncurried, equiv_iff_hprop; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk354" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk354">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 == O2 -&gt;
{_
: {|
    In_internal := O1;
    hprop_inO_internal := O1h;
    inO_equiv_inO_internal := proj2
  |} &lt;=
  {|
    In_internal := O2;
    hprop_inO_internal := O2h;
    inO_equiv_inO_internal := proj0
  |} &amp;
{|
  In_internal := O2;
  hprop_inO_internal := O2h;
  inO_equiv_inO_internal := proj0
|} &lt;=
{|
  In_internal := O1;
  hprop_inO_internal := O1h;
  inO_equiv_inO_internal := proj2
|}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk355"><span class="nb">intros</span> h; <span class="nb">split</span>; <span class="nb">intros</span> A e; <span class="nb">specialize</span> (h A); <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O2 A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk356" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O2 A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk356"><hr></label><div class="goal-conclusion">O1 A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk357"><span class="mi">1</span>:<span class="nb">rewrite</span> &lt;- h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk358" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O2 A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk358"><hr></label><div class="goal-conclusion">O1 A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk359"><span class="mi">2</span>:<span class="nb">rewrite</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O1 A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk35a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>O1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O1h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O1 T)</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O1 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O1 U</span></span></span><br><span><var>O2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>O2h</var><span class="hyp-type"><b>: </b><span>Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (O2 T)</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
O2 T -&gt; <span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; O2 U</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>O1 A = O2 A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>O2 A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk35a"><hr></label><div class="goal-conclusion">O2 A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="bp">exact</span> e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It should also be true that if [O1] and [O2] are reflective subuniverses, then [O1 &lt;=&gt; O2] is equivalent to [O1 = O2 :&gt; ReflectiveSubuniverse].  Probably [contr_typeof_O_unit] should be useful in proving that. *)</span>

<span class="sd">(** Reflections into one subuniverse are also reflections into an equal one.  Unfortunately these almost certainly can&#39;t be [Instance]s for fear of infinite loops, since [&lt;=&gt;] is reflexive. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk35b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk35b"><span class="kn">Definition</span> <span class="nf">prereflects_O_leq</span>
           (<span class="nv">O1</span> <span class="nv">O2</span> : Subuniverse) `{O1 &lt;= O2}
           (A : <span class="kt">Type</span>) `{PreReflects O1 A}
  : PreReflects O2 A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk35c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk35c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk35d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk35d"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk35e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk35e"><hr></label><div class="goal-conclusion">In O2 <span class="nl">?O_reflector</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk35f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk35f"><hr></label><div class="goal-conclusion">A -&gt; <span class="nl">?O_reflector</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk360">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_reflector O1 A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk361" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk361">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O2 (O_reflector O1 A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply (inO_leq O1 O2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk362" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk362">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;= O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; O_reflector O1 A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to O1 A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk363" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk363"><span class="kn">Definition</span> <span class="nf">reflects_O_eq</span>
           (<span class="nv">O1</span> <span class="nv">O2</span> : Subuniverse) `{O1 &lt;=&gt; O2}
           (A : <span class="kt">Type</span>) `{Reflects O1 A}
  : @Reflects O2 A (prereflects_O_leq O1 O2 A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;=&gt; O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk364" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk364"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;=&gt; O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflects O1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects O2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk365" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk365"><span class="nb">constructor</span>; <span class="nb">intros</span> B B_inO2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;=&gt; O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflects O1 A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B_inO2</var><span class="hyp-type"><b>: </b><span>In O2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O2 A)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O2 A =&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk366"><span class="nb">pose proof</span> (inO_leq O2 O1 _ B_inO2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O1, O2</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O1 &lt;=&gt; O2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PreReflects O1 A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflects O1 A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B_inO2</var><span class="hyp-type"><b>: </b><span>In O2 B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>In O1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O2 A)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector O2 A =&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (extendable_to_O O1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Separated subuniverses *)</span>

<span class="sd">(** For any subuniverse [O], a type is [O]-separated iff all its identity types are [O]-modal.  We will study these further in [Separated.v], but we put the definition here because it&#39;s needed in [Descent.v]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk367" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk367"><span class="kn">Definition</span> <span class="nf">Sep</span> (<span class="nv">O</span> : Subuniverse) : Subuniverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk368"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk369" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk369"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk36a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk36a"><hr></label><div class="goal-conclusion">Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (<span class="nl">?In_internal</span> T)</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk36b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk36b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
<span class="nl">?In_internal</span> T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; <span class="nl">?In_internal</span> U</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk36c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk36c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A; <span class="bp">exact</span> (<span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:A), In O (x = y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk36d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext -&gt;
<span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>,
IsHProp
  ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, In O (x = y)) T)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk36e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, In O (x = y)) T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U,
IsEquiv f -&gt;
(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, In O (x = y)) U</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk36f"><span class="nb">intros</span> T U ? f ? x y; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Subuniverse</span></span></span><br><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : T, In O (x = y)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>T -&gt; U</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO&#39; _ (equiv_ap f^-<span class="mi">1</span> x y)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">inO_paths_SepO</span> (<span class="nv">O</span> : Subuniverse)
       {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">A_inO</span> : In (Sep O) A} (<span class="nv">x</span> <span class="nv">y</span> : A)
  : In O (x = y)
  := A_inO x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: Where to put this?  Morally it goes with the study of [&lt;&lt;] in [Modality.v] and [&lt;&lt;&lt;] in [Descent.v] and [Sep] in [Separated.v], but it doesn&#39;t actually need any of those relations, only [O&#39; &lt;= Sep O], and it would also be nice to have it next to  [O_inverts_functor_coeq].  It&#39;s a variation on the latter: if [O&#39; &lt;= Sep O], then for [O&#39;] to invert [functor_coeq h k] it suffices that it invert [k] and that [h] be [O]-connected (by [conn_map_OO_inverts], which has different hypotheses but applies in many of the same examples, that is a weaker assumption). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk370" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk370"><span class="kn">Definition</span> <span class="nf">OO_inverts_functor_coeq</span>
           (<span class="nv">O</span> <span class="nv">O&#39;</span> : ReflectiveSubuniverse) `{O&#39; &lt;= Sep O}
           {B A : <span class="kt">Type</span>} (f g : B -&gt; A)
           {B&#39; A&#39; : <span class="kt">Type</span>} (f&#39; g&#39; : B&#39; -&gt; A&#39;)
           (h : B -&gt; B&#39;) (k : A -&gt; A&#39;)
           (p : k o f == f&#39; o h) (q : k o g == g&#39; o h)
           `{O_inverts O&#39; k} `{IsConnMap O _ _ h}
  : O_inverts O&#39; (functor_coeq h k p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O&#39; (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk371"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O&#39; (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk372"><span class="nb">apply</span> O_inverts_from_extendable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Z</span> : <span class="kt">Type</span>,
In O&#39; Z -&gt;
ExtendableAlong <span class="mi">2</span> (functor_coeq h k p q)
  (<span class="kr">fun</span> <span class="nv">_</span> : Coeq f&#39; g&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk373" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk373"><span class="nb">intros</span> Z Z_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> (functor_coeq h k p q)
  (<span class="kr">fun</span> <span class="nv">_</span> : Coeq f&#39; g&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk374"><span class="nb">apply</span> extendable_functor_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> k (<span class="kr">fun</span> <span class="nv">_</span> : A&#39; =&gt; Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk375" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk375"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : B&#39; -&gt; Z,
ExtendableAlong <span class="mi">2</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk376" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk376">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">2</span> k (<span class="kr">fun</span> <span class="nv">_</span> : A&#39; =&gt; Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply (ooextendable_O_inverts O&#39;); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk377" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk377">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : B&#39; -&gt; Z,
ExtendableAlong <span class="mi">2</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk378" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk378"><span class="nb">pose</span> (inO_leq O&#39; (Sep O)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z_inO</var><span class="hyp-type"><b>: </b><span>In O&#39; Z</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>inO_leq O&#39; (Sep O)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, In O&#39; A -&gt; In (Sep O) A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : B&#39; -&gt; Z,
ExtendableAlong <span class="mi">2</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u v; rapply (extendable_conn_map_inO O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And a similar property for pushouts *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk379"><span class="kn">Definition</span> <span class="nf">OO_inverts_functor_pushout</span>
           (<span class="nv">O</span> <span class="nv">O&#39;</span> : ReflectiveSubuniverse) `{O&#39; &lt;= Sep O}
           {A B C A&#39; B&#39; C&#39;}
           (f : A -&gt; B) (g : A -&gt; C) {f&#39; : A&#39; -&gt; B&#39;} {g&#39; : A&#39; -&gt; C&#39;}
           (h : A -&gt; A&#39;) (k : B -&gt; B&#39;) (l : C -&gt; C&#39;)
           (p : k o f == f&#39; o h) (q : l o g == g&#39; o h)
           `{IsConnMap O _ _ h} `{O_inverts O&#39; k} `{O_inverts O&#39; l}
  : O_inverts O&#39; (functor_pushout h k l p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O&#39; (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk37a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O&#39; (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk37b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk37b">napply (OO_inverts_functor_coeq O O&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O&#39; &lt;= Sep O</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk37c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk37c"><hr></label><div class="goal-conclusion">O_inverts O&#39; (functor_sum k l)</div></blockquote><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk37d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk37d"><hr></label><div class="goal-conclusion">IsConnMap O h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk37e"><span class="mi">1</span>,<span class="mi">3</span>:<span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>O_inverts0</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; k</span></span></span><br><span><var>O_inverts1</var><span class="hyp-type"><b>: </b><span>O_inverts O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O&#39; (functor_sum k l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_inverts_functor_sum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And similar properties for connected maps *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk37f"><span class="kn">Definition</span> <span class="nf">OO_conn_map_functor_coeq</span>
           (<span class="nv">O</span> <span class="nv">O&#39;</span> : ReflectiveSubuniverse) `{O&#39; &lt;= Sep O}
           {B A B&#39; A&#39;}
           {f g : B -&gt; A} {f&#39; g&#39; : B&#39; -&gt; A&#39;}
           (h : B -&gt; B&#39;) (k : A -&gt; A&#39;)
           (p : k o f == f&#39; o h) (q : k o g == g&#39; o h)
           `{IsConnMap O&#39; _ _ k} `{IsConnMap O _ _ h}
  : IsConnMap O&#39; (functor_coeq h k p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O&#39; (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk380" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk380"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O&#39; (functor_coeq h k p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk381"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (functor_coeq h k p q) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk382" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk382"><span class="nb">apply</span> extension_functor_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> k (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; P (coeq x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk383" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk383"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : B&#39;, P (coeq (g&#39; x)),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk384">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> k (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; P (coeq x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk385" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk385">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>B, A, B', A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>B&#39; -&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Coeq f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Coeq f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Coeq f g, P (functor_coeq h k p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : B&#39;, P (coeq (g&#39; x)),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">pose</span> (inO_leq O&#39; (Sep O));
    <span class="nb">intros</span>; rapply (ooextendable_conn_map_inO O).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk386" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk386"><span class="kn">Definition</span> <span class="nf">OO_conn_map_functor_pushout</span>
           (<span class="nv">O</span> <span class="nv">O&#39;</span> : ReflectiveSubuniverse) `{O&#39; &lt;= Sep O}
           {A B C A&#39; B&#39; C&#39;}
           (f : A -&gt; B) (g : A -&gt; C) {f&#39; : A&#39; -&gt; B&#39;} {g&#39; : A&#39; -&gt; C&#39;}
           (h : A -&gt; A&#39;) (k : B -&gt; B&#39;) (l : C -&gt; C&#39;)
           (p : k o f == f&#39; o h) (q : l o g == g&#39; o h)
           `{IsConnMap O _ _ h} `{IsConnMap O&#39; _ _ k} `{IsConnMap O&#39; _ _ l}
  : IsConnMap O&#39; (functor_pushout h k l p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O&#39; (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk387" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk387"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap O&#39; (functor_pushout h k l p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk388" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk388"><span class="nb">apply</span> conn_map_from_extension_elim; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (functor_pushout h k l p q) P d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk389"><span class="nb">apply</span> extension_functor_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> (functor_sum k l)
  (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; + C&#39; =&gt; P (coeq x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="reflectivesubuniverse-v-chk38a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><label class="goal-separator" for="reflectivesubuniverse-v-chk38a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : A&#39;, P (coeq (inr (g&#39; x))),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; u x = v x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk38b" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk38b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong <span class="mi">1</span> (functor_sum k l)
  (<span class="kr">fun</span> <span class="nv">x</span> : B&#39; + C&#39; =&gt; P (coeq x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> extendable_functor_sum; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="reflectivesubuniverse-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="reflectivesubuniverse-v-chk38c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O, O'</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>O&#39; &lt;= Sep O</span></span></span><br><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt; C&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>C -&gt; C&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == f&#39; o h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>l o g == g&#39; o h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap O h</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; k</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>IsConnMap O&#39; l</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Pushout f&#39; g&#39; -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Pushout f&#39; g&#39;, In O&#39; (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Pushout f g,
P (functor_pushout h k l p q a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> <span class="nv">v</span> : <span class="kr">forall</span> <span class="nv">x</span> : A&#39;, P (coeq (inr (g&#39; x))),
ExtendableAlong <span class="mi">1</span> h (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; u x = v x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">pose</span> (inO_leq O&#39; (Sep O));
    <span class="nb">intros</span>; rapply ooextendable_conn_map_inO.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> inO_isequiv_to_O : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> inO_unsigma : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> isconnected_conn_map_to_unit : typeclass_instances.</span></span></pre>
</div>
</div></body>
</html>
