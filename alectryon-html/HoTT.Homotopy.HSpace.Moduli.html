<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Moduli.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types HSpace.Core HSpace.Coherent HSpace.Pointwise
  Pointed Homotopy.EvaluationFibration.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The moduli type of coherent H-space structures *)</span>

<span class="sd">(** When [A] is a left-invertible coherent H-space, we construct an equivalence between the (&quot;moduli&quot;) type of coherent H-space structures on [A] and the type [A -&gt;* (A -&gt;** A)]. By the smash-hom adjunction for pointed types, due to Floris van Doorn in HoTT, the latter is also equivalent to the type [Smash A A -&gt;* A].</span>

<span class="sd">This equivalence generalizes a formula of Arkowitz--Curjel and Copeland for spaces, and appears as Theorem 2.27 in https://arxiv.org/abs/2301.02636v1 *)</span>

<span class="sd">(** ** Paths between H-space structures *)</span>

<span class="sd">(** Paths between H-space structures correspond to homotopies between the underlying binary operations which respect the identities. This is the type of the latter. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1"><span class="kn">Definition</span> <span class="nf">path_ishspace_type</span> {<span class="nv">X</span> : pType} (<span class="nv">mu</span> <span class="nv">nu</span> : IsHSpace X) : <span class="kt">Type</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3"><span class="nb">destruct</span> mu <span class="kr">as</span> [mu mu_lid mu_rid], nu <span class="kr">as</span> [nu nu_lid nu_rid].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4"><span class="nb">refine</span> { h : <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span>, mu x0 x1 = nu x0 x1 &amp; prod (<span class="kr">forall</span> <span class="nv">x</span>:X, _) (<span class="kr">forall</span> <span class="nv">x</span>:X, _) }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk5"><hr></label><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (mu_lid x = h pt x @ nu_lid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (mu_rid x = h x pt @ nu_rid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Transport of left and right identities of binary operations along paths between the underlying functions. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk8"><span class="kn">Local Definition</span> <span class="nf">transport_binop_lr_id</span> `{Funext} {X : <span class="kt">Type</span>} {x : X}
  {mu nu : X -&gt; X -&gt; X} `{mu_lid : <span class="kr">forall</span> <span class="nv">y</span>, mu x y = y}
  `{mu_rid : <span class="kr">forall</span> <span class="nv">y</span>, mu y x = y} (p : mu = nu)
  : transport (<span class="kr">fun</span> <span class="nv">m</span> : X -&gt; X -&gt; X =&gt;
                 (<span class="kr">forall</span> <span class="nv">y</span>, m x y = y) * (<span class="kr">forall</span> <span class="nv">y</span>, m y x = y))
      p (mu_lid, mu_rid)
    = (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (ap100 p _ _)^ @ mu_lid y,
         <span class="kr">fun</span> <span class="nv">y</span> =&gt; (ap100 p _ _)^ @ mu_rid y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>X -&gt; X -&gt; X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu x y = y</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu y x = y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>mu = nu</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">m</span> : X -&gt; X -&gt; X =&gt;
   (<span class="kr">forall</span> <span class="nv">y</span> : X, m x y = y) *
   (<span class="kr">forall</span> <span class="nv">y</span> : X, m y x = y)) p (mu_lid, mu_rid) =
(<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; (ap100 p x y)^ @ mu_lid y,
<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; (ap100 p y x)^ @ mu_rid y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>X -&gt; X -&gt; X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu x y = y</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu y x = y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>mu = nu</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">m</span> : X -&gt; X -&gt; X =&gt;
   (<span class="kr">forall</span> <span class="nv">y</span> : X, m x y = y) *
   (<span class="kr">forall</span> <span class="nv">y</span> : X, m y x = y)) p 
  (mu_lid, mu_rid) =
(<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; (ap100 p x y)^ @ mu_lid y,
<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; (ap100 p y x)^ @ mu_rid y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chka"><span class="nb">induction</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>X -&gt; X -&gt; X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu x y = y</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu y x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mu_lid, mu_rid) =
(<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; <span class="mi">1</span> @ mu_lid y, <span class="kr">fun</span> <span class="nv">y</span> : X =&gt; <span class="mi">1</span> @ mu_rid y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chkb"><span class="nb">apply</span> path_prod&#39;; funext y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>X -&gt; X -&gt; X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu x y = y</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu y x = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mu_lid y = <span class="mi">1</span> @ mu_lid y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>X -&gt; X -&gt; X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu x y = y</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : X, mu y x = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="moduli-v-chkc"><hr></label><div class="goal-conclusion">mu_rid y = <span class="mi">1</span> @ mu_rid y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">exact</span> (concat_1p _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Characterization of paths between H-space structures. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chkd"><span class="kn">Definition</span> <span class="nf">equiv_path_ishspace</span> `{Funext} {X : pType} (mu nu : IsHSpace X)
  : path_ishspace_type mu nu &lt;~&gt; (mu = nu).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_ishspace_type mu nu &lt;~&gt; mu = nu</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu, nu</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_ishspace_type mu nu &lt;~&gt; mu = nu</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chkf"><span class="nb">destruct</span> mu <span class="kr">as</span> [mu mu_lid mu_rid], nu <span class="kr">as</span> [nu nu_lid nu_rid];
    <span class="nb">unfold</span> path_ishspace_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{h : <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1 &amp;
((<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
 (<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x))%type} &lt;~&gt;
{|
  hspace_op := mu;
  hspace_left_identity := mu_lid;
  hspace_right_identity := mu_rid
|} =
{|
  hspace_op := nu;
  hspace_left_identity := nu_lid;
  hspace_right_identity := nu_rid
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk10">nrefine (equiv_ap_inv&#39; issig_ishspace _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{h : <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1 &amp;
((<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
 (<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x))%type} &lt;~&gt;
issig_ishspace^-<span class="mi">1</span>
  {|
    hspace_op := mu;
    hspace_left_identity := mu_lid;
    hspace_right_identity := mu_rid
  |} =
issig_ishspace^-<span class="mi">1</span>
  {|
    hspace_op := nu;
    hspace_left_identity := nu_lid;
    hspace_right_identity := nu_rid
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk11">nrefine (equiv_path_sigma _ _ _ oE _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{h : <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">x1</span> : X, mu x0 x1 = nu x0 x1 &amp;
((<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
 (<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x))%type} &lt;~&gt;
{p : mu = nu &amp;
transport
  (<span class="kr">fun</span> <span class="nv">mu</span> : X -&gt; X -&gt; X =&gt;
   ((<span class="kr">forall</span> <span class="nv">x</span> : X, mu pt x = x) *
    (<span class="kr">forall</span> <span class="nv">x</span> : X, mu x pt = x))%type) p
  (mu_lid, mu_rid) = (nu_lid, nu_rid)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk12"><span class="nb">apply</span> (equiv_functor_sigma&#39; (equiv_path_arrow2 _ _)); <span class="nb">intro</span> h; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x) &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">mu</span> : X -&gt; X -&gt; X =&gt;
   ((<span class="kr">forall</span> <span class="nv">x</span> : X, mu pt x = x) *
    (<span class="kr">forall</span> <span class="nv">x</span> : X, mu x pt = x))%type)
  (path_forall mu nu
     (functor_forall idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
  (mu_lid, mu_rid) = (nu_lid, nu_rid)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk13">nrefine (equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">mu</span> : X -&gt; X -&gt; X =&gt;
   ((<span class="kr">forall</span> <span class="nv">x</span> : X, mu pt x = x) *
    (<span class="kr">forall</span> <span class="nv">x</span> : X, mu x pt = x))%type)
  (path_forall mu nu
     (functor_forall idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
  (mu_lid, mu_rid) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk14"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x) &lt;~&gt;
<span class="nl">?Goal</span> = (nu_lid, nu_rid)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk15"><span class="mi">1</span>: <span class="nb">apply</span> transport_binop_lr_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x) &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
 (ap100
    (path_forall mu nu
       (functor_forall idmap
          (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
    pt y)^ @ mu_lid y,
<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
(ap100
   (path_forall mu nu
      (functor_forall idmap
         (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
   y pt)^ @ mu_rid y) = 
(nu_lid, nu_rid)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk16">nrefine (equiv_path_prod _ _ oE _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_lid x = h pt x @ nu_lid x) *
(<span class="kr">forall</span> <span class="nv">x</span> : X, mu_rid x = h x pt @ nu_rid x) &lt;~&gt;
((<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
  (ap100
     (path_forall mu nu
        (functor_forall idmap
           (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
     pt y)^ @ mu_lid y) = nu_lid) *
((<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
  (ap100
     (path_forall mu nu
        (functor_forall idmap
           (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
     y pt)^ @ mu_rid y) = nu_rid)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk17"><span class="nb">apply</span> equiv_functor_prod&#39;;
    nrefine (equiv_path_forall _ _ oE _);
    <span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mu_lid x = h pt x @ nu_lid x &lt;~&gt;
(ap100
   (path_forall mu nu
      (functor_forall idmap
         (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
   pt x)^ @ mu_lid x = nu_lid x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>mu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity mu pt</span></span></span><br><span><var>mu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity mu pt</span></span></span><br><span><var>nu</var><span class="hyp-type"><b>: </b><span>SgOp X</span></span></span><br><span><var>nu_lid</var><span class="hyp-type"><b>: </b><span>LeftIdentity nu pt</span></span></span><br><span><var>nu_rid</var><span class="hyp-type"><b>: </b><span>RightIdentity nu pt</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, mu x y = nu x y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk18"><hr></label><div class="goal-conclusion">mu_rid x = h x pt @ nu_rid x &lt;~&gt;
(ap100
   (path_forall mu nu
      (functor_forall idmap
         (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; path_forall (mu a) (nu a)) h))
   x pt)^ @ mu_rid x = nu_rid x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: nrefine (equiv_moveR_Vp _ _ _ oE _);
    <span class="nb">apply</span> equiv_concat_r;
    <span class="nb">apply</span> whiskerR; <span class="nb">symmetry</span>;
    <span class="nb">apply</span> ap100_path_arrow2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Sections of evaluation fibrations *)</span>

<span class="sd">(** We first show that coherent H-space structures on a pointed type correspond to pointed sections of the evaluation fibration [ev A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk19"><span class="kn">Definition</span> <span class="nf">equiv_iscohhspace_psect</span> `{Funext} (A : pType)
  : IsCohHSpace A &lt;~&gt; pSect (ev A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt; pSect (ev A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt; pSect (ev A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1b"><span class="nb">refine</span> (issig_psect (ev A) oE _^-<span class="mi">1</span>%equiv oE (issig_iscohhspace A)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : A -&gt; selfmaps A &amp;
{p : s pt = pt &amp;
{H : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ev A (s x)) == idmap &amp;
H pt = ap (ev A) p @ point_eq (ev A)}}} &lt;~&gt;
{hspace_op : SgOp A &amp;
{hspace_left_identity : LeftIdentity hspace_op pt &amp;
{hspace_right_identity : RightIdentity hspace_op pt &amp;
hspace_left_identity pt = hspace_right_identity pt}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1c"><span class="nb">unfold</span> SgOp, LeftIdentity, RightIdentity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : A -&gt; selfmaps A &amp;
{p : s pt = pt &amp;
{H : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ev A (s x)) == idmap &amp;
H pt = ap (ev A) p @ point_eq (ev A)}}} &lt;~&gt;
{hspace_op : A -&gt; A -&gt; A &amp;
{hspace_left_identity
: <span class="kr">forall</span> <span class="nv">y</span> : A, hspace_op pt y = y &amp;
{hspace_right_identity
: <span class="kr">forall</span> <span class="nv">x</span> : A, hspace_op x pt = x &amp;
hspace_left_identity pt = hspace_right_identity pt}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1d"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> mu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>A -&gt; selfmaps A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : mu pt = pt &amp;
{H : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ev A (mu x)) == idmap &amp;
H pt = ap (ev A) p @ point_eq (ev A)}} &lt;~&gt;
{hspace_left_identity : <span class="kr">forall</span> <span class="nv">y</span> : A, mu pt y = y &amp;
{hspace_right_identity : <span class="kr">forall</span> <span class="nv">x</span> : A, mu x pt = x &amp;
hspace_left_identity pt = hspace_right_identity pt}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1e"><span class="nb">apply</span> (equiv_functor_sigma&#39; (equiv_apD10 _ _ _)); <span class="nb">intro</span> H1; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>A -&gt; selfmaps A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>mu pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; mu x pt) == idmap &amp;
H pt = ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt) H1 @ <span class="mi">1</span>} &lt;~&gt;
{hspace_right_identity : <span class="kr">forall</span> <span class="nv">x</span> : A, mu x pt = x &amp;
apD10 H1 pt = hspace_right_identity pt}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk1f"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> H2; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>A -&gt; selfmaps A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>mu pt = pt</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; mu x pt) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H2 pt = ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt) H1 @ <span class="mi">1</span> &lt;~&gt;
apD10 H1 pt = H2 pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk20"><span class="nb">refine</span> (equiv_path_inverse _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>A -&gt; selfmaps A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>mu pt = pt</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; mu x pt) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H2 pt = ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt) H1 @ <span class="mi">1</span> &lt;~&gt;
H2 pt = apD10 H1 pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk21"><span class="nb">apply</span> equiv_concat_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>mu</var><span class="hyp-type"><b>: </b><span>A -&gt; selfmaps A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>mu pt = pt</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; mu x pt) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt) H1 @ <span class="mi">1</span> = apD10 H1 pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Our next goal is to see that when [A] is a left-invertible H-space, then the fibration [ev A] is trivial. We begin with two results that allow the domain to be a general pointed type [B]. We&#39;ll later just need the case when [B] is [A]. *)</span>

<span class="sd">(** This lemma says that the family [fun a =&gt; B -&gt;* [A,a]] is trivial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk22"><span class="kn">Lemma</span> <span class="nf">equiv_pmap_hspace</span> `{Funext} {A B : pType}
  (a : A) `{IsHSpace A} `{!IsEquiv (hspace_op a)}
  : (B -&gt;* A) &lt;~&gt; (B -&gt;* [A,a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) &lt;~&gt; (B -&gt;* [A, a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) &lt;~&gt; (B -&gt;* [A, a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk24">napply pequiv_pequiv_postcompose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;~&gt;* [A, a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply pequiv_hspace_left_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The next result is a consequence of the previous lemma. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk25"><span class="kn">Proposition</span> <span class="nf">equiv_map_pmap_hspace</span> `{Funext} {A B : pType}
  `{IsHSpace A} `{<span class="kr">forall</span> <span class="nv">a</span>:A, IsEquiv (a *.)}
  : (B -&gt;* A) * A &lt;~&gt; (B -&gt; A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) * A &lt;~&gt; (B -&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) * A &lt;~&gt; (B -&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk27"><span class="nb">transitivity</span> {a : A  &amp; {f : B -&gt; A &amp; f pt = a}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) * A &lt;~&gt; {a : A &amp; {f : B -&gt; A &amp; f pt = a}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk28"><hr></label><div class="goal-conclusion">{a : A &amp; {f : B -&gt; A &amp; f pt = a}} &lt;~&gt; (B -&gt; A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk29"><span class="mi">2</span>: <span class="bp">exact</span> (equiv_sigma_contr _ oE (equiv_sigma_symm _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) * A &lt;~&gt; {a : A &amp; {f : B -&gt; A &amp; f pt = a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2a"><span class="nb">refine</span> (_ oE (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>%equiv oE equiv_prod_symm _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : A &amp; B -&gt;* A} &lt;~&gt;
{a : A &amp; {f : B -&gt; A &amp; f pt = a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2b"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B -&gt;* A) &lt;~&gt; {f : B -&gt; A &amp; f pt = a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((issig_pmap B [A,a])^-<span class="mi">1</span>%equiv oE equiv_pmap_hspace a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The equivalence [equiv_map_pmap_hspace] is pointed when [B] is [A]. (Note that [selfmaps A] is pointed at [idmap].) This is a pointed equivalence between the domains of [psnd : (A -&gt;* A) * A -&gt;* A] and [ev A : selfmaps A -&gt; A], respectively. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2c"><span class="kn">Proposition</span> <span class="nf">pequiv_map_pmap_hspace</span> `{Funext} {A : pType}
  `{IsHSpace A} `{<span class="kr">forall</span> <span class="nv">a</span>:A, IsEquiv (a *.)}
  : [(A -&gt;* A) * A, (pmap_idmap, pt)] &lt;~&gt;* selfmaps A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[(A -&gt;* A) * A, (pmap_idmap, pt)] &lt;~&gt;* selfmaps A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[(A -&gt;* A) * A, (pmap_idmap, pt)] &lt;~&gt;* selfmaps A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk2e">snapply Build_pEquiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[(A -&gt;* A) * A, (pmap_idmap, pt)] &lt;~&gt; selfmaps A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk2f"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk30"><span class="mi">1</span>: <span class="bp">exact</span> equiv_map_pmap_hspace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_map_pmap_hspace pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk31"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pt * x) = idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_forall, hspace_left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** When [A] is coherent, the pointed equivalence [pequiv_map_pmap_hspace] is a pointed equivalence over [A], i.e., a trivialization of [ev A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk32"><span class="kn">Proposition</span> <span class="nf">hspace_ev_trivialization</span> `{Funext} {A : pType}
  `{IsCoherent A} `{<span class="kr">forall</span> <span class="nv">a</span>:A, IsEquiv (a *.)}
  : ev A o* pequiv_map_pmap_hspace ==* psnd (A:=[A -&gt;* A, pmap_idmap]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ev A o* pequiv_map_pmap_hspace ==* psnd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ev A o* pequiv_map_pmap_hspace ==* psnd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk34">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ev A o* pequiv_map_pmap_hspace == psnd</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk35"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (ev A o* pequiv_map_pmap_hspace) @
(dpoint_eq psnd)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk36">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ev A o* pequiv_map_pmap_hspace == psnd</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk37"><span class="nb">intros</span> [f x]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * f pt = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (dpoint_eq f) @ hspace_right_identity _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk38">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x0</span> : [(A -&gt;* A) * A, (pmap_idmap, pt)] =&gt;
  (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt;* A) (<span class="nv">x</span> : A) =&gt;
   ap (hspace_op x) (dpoint_eq f) @
   hspace_right_identity x
   :
   (ev A o* pequiv_map_pmap_hspace) (f, x) =
   psnd (f, x)) (fst x0) (snd x0))
 :
 ev A o* pequiv_map_pmap_hspace == psnd) pt =
dpoint_eq (ev A o* pequiv_map_pmap_hspace) @
(dpoint_eq psnd)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk39"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ hspace_right_identity pt =
(ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt)
   (path_forall (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pt * x) idmap
      hspace_left_identity) @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3a"><span class="nb">refine</span> (concat_1p _ @ _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt)
   (path_forall (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pt * x) idmap
      hspace_left_identity) @ <span class="mi">1</span>) @ <span class="mi">1</span> =
hspace_right_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3b"><span class="nb">refine</span> (concat_p1 _ @ concat_p1 _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; A =&gt; f pt)
  (path_forall (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pt * x) idmap
     hspace_left_identity) = hspace_right_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3c"><span class="nb">refine</span> (ap10_path_forall _ _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_left_identity pt = hspace_right_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> iscoherent.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The equivalence [IsCohHSpace A &lt;~&gt; (A -&gt;* (A -&gt;** A))] *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3d"><span class="kn">Theorem</span> <span class="nf">equiv_cohhspace_ppmap</span> `{Funext} {A : pType}
  `{IsCoherent A} `{<span class="kr">forall</span> <span class="nv">a</span>:A, IsEquiv (hspace_op a)}
  : IsCohHSpace A &lt;~&gt; (A -&gt;* (A -&gt;** A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt; (A -&gt;* (A -&gt;** A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt; (A -&gt;* (A -&gt;** A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk3f"><span class="nb">refine</span> (_ oE equiv_iscohhspace_psect A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pSect (ev A) &lt;~&gt; (A -&gt;* (A -&gt;** A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk40"><span class="nb">refine</span> (_ oE (equiv_pequiv_pslice_psect _ _ _ hspace_ev_trivialization^*)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pSect psnd &lt;~&gt; (A -&gt;* (A -&gt;** A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk41"><span class="nb">refine</span> (_ oE equiv_psect_psnd (A:=[A -&gt;* A, pmap_idmap])).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt;* [A -&gt;* A, pmap_idmap]) &lt;~&gt; (A -&gt;* (A -&gt;** A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk42"><span class="nb">refine</span> (pequiv_pequiv_postcompose _); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsCoherent A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (hspace_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt;** A) &lt;~&gt;* [A -&gt;* A, pmap_idmap]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply pequiv_hspace_left_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here is a third characterization of the type of coherent H-space structures. It simply involves shuffling the data around and using [Funext]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk43"><span class="kn">Definition</span> <span class="nf">equiv_iscohhspace_ptd_action</span> `{Funext} (A : pType)
  : IsCohHSpace A &lt;~&gt; { act : <span class="kr">forall</span> <span class="nv">a</span>, A -&gt;* [A,a] &amp; act pt ==* pmap_idmap }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : IsPointed A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : IsPointed A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk45"><span class="nb">refine</span> (_ oE (issig_iscohhspace A)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{hspace_op : SgOp A &amp;
{hspace_left_identity : LeftIdentity hspace_op pt &amp;
{hspace_right_identity : RightIdentity hspace_op pt &amp;
hspace_left_identity pt = hspace_right_identity pt}}} &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : IsPointed A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk46"><span class="nb">unfold</span> IsPointed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{hspace_op : SgOp A &amp;
{hspace_left_identity : LeftIdentity hspace_op pt &amp;
{hspace_right_identity : RightIdentity hspace_op pt &amp;
hspace_left_identity pt = hspace_right_identity pt}}} &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* First we shuffle the data on the LHS to be of this form: *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk47">equiv_via {s : {act : A -&gt; (A -&gt; A) &amp; <span class="kr">forall</span> <span class="nv">a</span>, act a pt = a} &amp; {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{hspace_op : SgOp A &amp;
{hspace_left_identity : LeftIdentity hspace_op pt &amp;
{hspace_right_identity : RightIdentity hspace_op pt &amp;
hspace_left_identity pt = hspace_right_identity pt}}} &lt;~&gt;
{s : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a}
&amp; {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk48"><hr></label><div class="goal-conclusion">{s : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a}
&amp; {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}} &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk49"><span class="mi">1</span>: make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a}
&amp; {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}} &lt;~&gt;
{act : <span class="kr">forall</span> <span class="nv">a</span> : A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Then we break up [-&gt;*] and [==*] on the RHS using issig lemmas, and handle a trailing [@ 1]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4a">snapply equiv_functor_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, A -&gt;* [A, a])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk4b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a},
(<span class="kr">fun</span>
   <span class="nv">s</span> : {act : A -&gt; A -&gt; A &amp;
       <span class="kr">forall</span> <span class="nv">a0</span> : A, act a0 pt = a0} =&gt;
 {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">act</span> : <span class="kr">forall</span> <span class="nv">a0</span> : A, A -&gt;* [A, a0] =&gt;
 act pt ==* pmap_idmap) (<span class="nl">?f</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, A -&gt;* [A, a])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4d"><span class="nb">refine</span> (equiv_functor_forall_id (<span class="kr">fun</span> <span class="nv">a</span> =&gt; issig_pmap A [A,a]) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : IsPointed A, {f : A -&gt; [A, a] &amp; f pt = pt})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4e"><span class="nb">unfold</span> IsPointed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, {f : A -&gt; [A, a] &amp; f pt = pt})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply equiv_sig_coind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a},
(<span class="kr">fun</span>
   <span class="nv">s</span> : {act : A -&gt; A -&gt; A &amp;
       <span class="kr">forall</span> <span class="nv">a0</span> : A, act a0 pt = a0} =&gt;
 {h : s.<span class="mi">1</span> pt == idmap &amp; h pt = s.<span class="mi">2</span> pt}) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">act</span> : <span class="kr">forall</span> <span class="nv">a0</span> : A, A -&gt;* [A, a0] =&gt;
 act pt ==* pmap_idmap)
  ((equiv_functor_forall_id
      (<span class="kr">fun</span> <span class="nv">a0</span> : IsPointed A =&gt; issig_pmap A [A, a0])
    oE (equiv_sig_coind (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; A -&gt; A)
          (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">f</span> : A -&gt; [A, x]) =&gt; f pt = pt)
        :
        {act : A -&gt; A -&gt; A &amp;
        <span class="kr">forall</span> <span class="nv">a0</span> : A, act a0 pt = a0} &lt;~&gt;
        (<span class="kr">forall</span> <span class="nv">a0</span> : IsPointed A,
         {f : A -&gt; [A, a0] &amp; f pt = pt}))) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk50"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : {act : A -&gt; A -&gt; A &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a},
{h : a.<span class="mi">1</span> pt == idmap &amp; h pt = a.<span class="mi">2</span> pt} &lt;~&gt;
{| pointed_fun := a.<span class="mi">1</span> pt; dpoint_eq := a.<span class="mi">2</span> pt |} ==*
pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk51"><span class="nb">intros</span> [act p]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{h : act pt == idmap &amp; h pt = p pt} &lt;~&gt;
{| pointed_fun := act pt; dpoint_eq := p pt |} ==*
pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk52"><span class="nb">refine</span> (issig_phomotopy _ _ oE _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{h : act pt == idmap &amp; h pt = p pt} &lt;~&gt;
{p0 : act pt == idmap &amp; p0 pt = p pt @ <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk53"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, act a pt = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>act pt == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q pt = p pt &lt;~&gt; q pt = p pt @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_concat_r; <span class="nb">symmetry</span>; <span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that any homogeneous type is a coherent H-space.  This generalizes [ishspace_homogeneous]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk54"><span class="kn">Definition</span> <span class="nf">iscohhspace_homogeneous</span> `{Funext} {A : pType} `{IsHomogeneous A}
  : IsCohHSpace A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk56"><span class="nb">apply</span> (equiv_iscohhspace_ptd_action A)^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{act : <span class="kr">forall</span> <span class="nv">a</span> : IsPointed A, A -&gt;* [A, a] &amp;
act pt ==* pmap_idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk57"><span class="kr">exists</span> <span class="nv">homogeneous_pt_id</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">homogeneous_pt_id pt ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> homogeneous_pt_id_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** One can also show directly that the H-space structure defined by [ishspace_homogeneous] is coherent. This also avoids [Funext]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk58"><span class="kn">Definition</span> <span class="nf">iscoherent_homogeneous</span> {<span class="nv">A</span> : pType} `{IsHomogeneous A}
  : @IsCoherent A (ishspace_homogeneous).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5a"><span class="nb">unfold</span> IsCoherent; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr (ishomogeneous pt) pt =
ap (ishomogeneous pt)
  (moveR_equiv_V pt pt (point_eq (ishomogeneous pt))^) @
point_eq (ishomogeneous pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5b"><span class="nb">set</span> (f := ishomogeneous pt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr (ishomogeneous pt) pt =
ap (ishomogeneous pt)
  (moveR_equiv_V pt pt (point_eq (ishomogeneous pt))^) @
point_eq (ishomogeneous pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5c"><span class="nb">change</span> (eisretr f pt = ap f (moveR_equiv_V pt pt (point_eq f)^) @ point_eq f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f pt =
ap f (moveR_equiv_V pt pt (point_eq f)^) @ point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5d"><span class="nb">rewrite</span> &lt;- (point_eq f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f pt = ap f (moveR_equiv_V pt pt <span class="mi">1</span>^) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5e"><span class="nb">unfold</span> moveR_equiv_V; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f pt = ap f (<span class="mi">1</span> @ eissect f pt) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk5f">rhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eisretr f pt = ap f (<span class="mi">1</span> @ eissect f pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk60">lhs napply (eisadj f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (eissect f pt) = ap f (<span class="mi">1</span> @ eissect f pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk61"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ishomogeneous pt</span></span><span class="hyp-type"><b>: </b><span>A &lt;~&gt;* [A, pt]</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f pt = <span class="mi">1</span> @ eissect f pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using either of these, we can &quot;upgrade&quot; any left-invertible H-space structure to a coherent one. This one has a prime because the direct proof below computes better. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk62"><span class="kn">Definition</span> <span class="nf">iscohhspace_hspace&#39;</span> (<span class="nv">A</span> : pType)
  `{IsHSpace A} `{<span class="kr">forall</span> <span class="nv">a</span>, IsEquiv (a *.)}
  : IsCohHSpace A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk64">snapply Build_IsCohHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk65"><hr></label><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk66">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk67">napply ishspace_homogeneous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHomogeneous A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ishomogeneous_hspace.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk68">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> iscoherent_homogeneous.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The new multiplication is homotopic to the original one.  Relative to this, we expect that one of the identity laws also agrees, but that the other does not. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk69"><span class="kn">Definition</span> <span class="nf">iscohhspace_hspace&#39;_beta_mu</span> `{Funext} (A : pType)
  {m : IsHSpace A} `{<span class="kr">forall</span> <span class="nv">a</span>, IsEquiv (a *.)}
  : @hspace_op A (@ishspace_cohhspace A (iscohhspace_hspace&#39; A)) = @hspace_op A m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_op = hspace_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_op = hspace_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6b"><span class="nb">cbn</span>. <span class="c">(* [*], [sg_op] and [hspace_op] all denote the original operation. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; a * (sg_op pt)^-<span class="mi">1</span> b) = hspace_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6c">funext a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (sg_op pt)^-<span class="mi">1</span> b = hspace_op a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6d"><span class="nb">refine</span> (ap (a *.) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(sg_op pt)^-<span class="mi">1</span> b = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6e"><span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b = pt * b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here&#39;s a different proof that directly upgrades an H-space structure, leaving the multiplication and left-identity definitionally the same, but changing the right-identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk6f"><span class="kn">Definition</span> <span class="nf">iscohhspace_hspace</span> (<span class="nv">A</span> : pType)
  {<span class="nv">m</span> : IsHSpace A} `{<span class="kr">forall</span> <span class="nv">a</span>, IsEquiv (a *.)}
  : IsCohHSpace A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCohHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk71">snapply Build_IsCohHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk72"><hr></label><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk73"><span class="mi">1</span>: snapply Build_IsHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="moduli-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk74"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?hspace_op</span> pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="moduli-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk75"><hr></label><div class="goal-conclusion">RightIdentity <span class="nl">?hspace_op</span> pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="moduli-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><label class="goal-separator" for="moduli-v-chk76"><hr></label><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk77">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@hspace_op A m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk78">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity hspace_op pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@hspace_left_identity A m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity hspace_op pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7a"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_op a pt = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7b">lhs <span class="bp">exact</span> (ap (a *.) (hspace_right_identity pt))^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * hspace_op pt pt = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7c">lhs <span class="bp">exact</span> (ap (a *.) (hspace_left_identity pt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * pt = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (hspace_right_identity a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCoherent A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7e"><span class="nb">unfold</span> IsCoherent; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_left_identity pt =
(ap (sg_op pt) (hspace_right_identity pt))^ @
(ap (sg_op pt) (hspace_left_identity pt) @
 hspace_right_identity pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk7f"><span class="nb">apply</span> moveL_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sg_op pt) (hspace_right_identity pt) @
hspace_left_identity pt =
ap (sg_op pt) (hspace_left_identity pt) @
hspace_right_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk80">lhs napply concat_A1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_left_identity (hspace_op pt pt) @
hspace_right_identity pt =
ap (sg_op pt) (hspace_left_identity pt) @
hspace_right_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk81"><span class="nb">refine</span> (_ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_left_identity (hspace_op pt pt) =
ap (sg_op pt) (hspace_left_identity pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="moduli-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="moduli-v-chk82"><span class="nb">apply</span> (cancelR _ _ (hspace_left_identity pt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hspace_left_identity (hspace_op pt pt) @
hspace_left_identity pt =
ap (sg_op pt) (hspace_left_identity pt) @
hspace_left_identity pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_A1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
