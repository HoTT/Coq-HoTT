<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Group.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types HProp HFiber HSet.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.IdentitySystems.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> (notations) Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (hints) Classes.interfaces.abstract_algebra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (hints) Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We only export the parts of these that will be most useful to users of this file. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.canonical_names (SgOp, sg_op, MonUnit, mon_unit,
    LeftIdentity, left_identity, RightIdentity, right_identity,
    Inverse, inv, Associative, simple_associativity, associativity, associative_flip,
    LeftInverse, left_inverse, RightInverse, right_inverse, Commutative, commutativity).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> canonical_names.BinOpNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.abstract_algebra (IsGroup(..), group_monoid, inverse_l, inverse_r,
    IsSemiGroup(..), sg_set, sg_ass,
    IsMonoid(..), monoid_left_id, monoid_right_id, monoid_semigroup,
    IsMonoidPreserving(..), monmor_unitmor, monmor_sgmor,
    IsSemiGroupPreserving, preserves_sg_op, IsUnitPreserving, preserves_mon_unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.theory.groups.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">G</span> H A B C f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> group_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Groups *)</span>

<span class="sd">(** A group is an abstraction of several common situations in mathematics. For example, consider the symmetries of an object.  Two symmetries can be combined; there is a symmetry that does nothing; and any symmetry can be reversed. Such situations arise in geometry, algebra and, importantly for us, homotopy theory. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> wc_iso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Definition of a Group *)</span>

<span class="sd">(** A group consists of a type, an operation on that type, a unit and an inverse that satisfy the group axioms in [IsGroup]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Group</span> := Build_Group_internal {
  group_type :&gt; <span class="kt">Type</span>;
  group_sgop :: SgOp group_type;
  group_unit :: MonUnit group_type;
  group_inverse :: Inverse group_type;
  group_isgroup :: IsGroup group_type;
  <span class="sd">(** This axiom is redundant, but will allow the &quot;opposite&quot; group to be definitionally involutive. *)</span>
  group_assoc_opp : Associative (flip group_sgop);
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_sgop {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_unit {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_inverse {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_isgroup {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_assoc_opp {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We should never need to unfold the proof that something is a group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Opaque</span> group_isgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_group</span> : _ &lt;~&gt; Group
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the main constructor that is used to build groups.</span>

<span class="sd">It differs from [Build_Group_internal] by removing the redundant second proof of associativity. There is a technical reason for keeping the second axiom around, see the definition of [grp_op].</span>

<span class="sd">Note that we could have given the fields of [IsGroup] in a completely unbundled manner, but this has a negative impact on performance since every time a [Group] term is unfolded, the axioms appear in the arguments.</span>

<span class="sd">It is therefore advised to use this constructor in combination with a tactic like [repeat split] when building groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1"><span class="kn">Definition</span> <span class="nf">Build_Group</span> (<span class="nv">G</span> : <span class="kt">Type</span>)
  `(op : SgOp G, unit : MonUnit G, inv : Inverse G, grp : !IsGroup G)
  : Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>grp</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>grp</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3">napply (Build_Group_internal G op unit inv grp).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>grp</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative (flip op)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply associative_flip.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Proof automation *)</span>
<span class="sd">(** Many times in group theoretic proofs we want some form of automation for obvious identities. Here we implement such a behavior. *)</span>

<span class="sd">(** We create a database of hints for the group theory library *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Create HintDb</span> group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Our group laws can be proven easily with tactics such as [rapply associativity]. However this requires a typeclass search on more general algebraic structures. Therefore we explicitly list many groups laws here so that Coq can use them. We also create hints for each law in our groups database. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupLaws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_assoc</span> := associativity x y z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_unit_l</span> := left_identity x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_unit_r</span> := right_identity x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_l</span> := left_inverse x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_r</span> := right_inverse x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupLaws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_assoc  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_unit_l : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_unit_r : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_inv_l  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_inv_r  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given path types in a product we may want to decompose. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Extern</span> <span class="mi">5</span> (@paths (_ * _) _ _) =&gt; (<span class="nb">apply</span> path_prod) : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** Given path types in a sigma type of a hprop family (i.e. a subset) we may want to decompose. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Extern</span> <span class="mi">6</span> (@paths (sig _) _ _) =&gt; (rapply path_sigma_hprop) : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We also declare a tactic (notation) for automatically solving group laws *)</span>
<span class="sd">(** TODO: improve this tactic so that it also rewrites and is able to solve basic group lemmas. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;grp_auto&quot;</span> := <span class="nb">hnf</span>; <span class="nb">intros</span>; <span class="nb">eauto with</span> group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Some basic properties of groups *)</span>

<span class="sd">(** Groups are pointed sets with point the identity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_group</span> (<span class="nv">G</span> : Group)
  : IsPointed G := @mon_unit G _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ptype_group</span> : Group -&gt; pType
  := <span class="kr">fun</span> <span class="nv">G</span> =&gt; [G, _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">ptype_group</span> : Group &gt;-&gt; pType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** An element acting like the identity is unique. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">identity_unique</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A}
  (<span class="nv">x</span> <span class="nv">y</span> : A) {<span class="nv">p</span> : LeftIdentity Aop x} {<span class="nv">q</span> : RightIdentity Aop y}
  : x = y := (q x)^ @ p y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">identity_unique&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A}
  (<span class="nv">x</span> <span class="nv">y</span> : A) {<span class="nv">p</span> : LeftIdentity Aop x} {<span class="nv">q</span> : RightIdentity Aop y}
  : y = x := (identity_unique x y)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element acting like an inverse is unique. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4"><span class="kn">Definition</span> <span class="nf">inverse_unique</span> `{IsMonoid A}
  (a x y : A) {p : x * a = mon_unit} {q : a * y = mon_unit}
  : x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = <span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = <span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6"><span class="nb">refine</span> ((right_identity x)^ @ ap _ q^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = <span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (a * y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7"><span class="nb">refine</span> (associativity _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = <span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * a * y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * y) p @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = <span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** With other assumptions, the right inverse law follows from the left inverse law. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9"><span class="kn">Definition</span> <span class="nf">right_inverse_left_inverse</span> (<span class="nv">G</span> : <span class="kt">Type</span>) `{IsHSet G}
  `(SgOp G, MonUnit G, Inverse G, !Associative (.*.),
    !LeftIdentity (.*.) mon_unit,
    !LeftInverse (.*.) (^) mon_unit)
  : RightInverse (.*.) (^) mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc">lhs_V rapply left_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * (x * x^) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd"><span class="nb">apply</span> (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * _ = x) (left_inverse x^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x^)^ * x^ * (x * x^) = (x^)^ * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke">lhs_V rapply simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x^)^ * (x^ * (x * x^)) = (x^)^ * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf">napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * (x * x^) = x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10">lhs rapply simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x * x^ = x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11">lhs napply (ap (.* x^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk12"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> * x^ = x^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13"><span class="mi">1</span>: <span class="nb">apply</span> left_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * x^ = x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Opaque</span> right_inverse_left_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** With other assumptions, the right identity law follows from the left identity law. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14"><span class="kn">Definition</span> <span class="nf">right_identity_left_identity</span> (<span class="nv">G</span> : <span class="kt">Type</span>) `{IsHSet G}
  `(SgOp G, MonUnit G, Inverse G, !Associative (.*.),
    !LeftIdentity (.*.) mon_unit,
    !LeftInverse (.*.) (^) mon_unit)
  : RightIdentity (.*.) mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * <span class="mi">1</span> = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17">lhs_V rapply left_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * (x * <span class="mi">1</span>) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18">rhs_V rapply left_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * (x * <span class="mi">1</span>) = <span class="mi">1</span> * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19"><span class="nb">apply</span> (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * _ = x * _) (left_inverse x^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x^)^ * x^ * (x * <span class="mi">1</span>) = (x^)^ * x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a">lhs_V rapply simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x^)^ * (x^ * (x * <span class="mi">1</span>)) = (x^)^ * x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b">rhs_V rapply simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x^)^ * (x^ * (x * <span class="mi">1</span>)) = (x^)^ * (x^ * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c">napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * (x * <span class="mi">1</span>) = x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d">lhs rapply simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x * <span class="mi">1</span> = x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e">lhs <span class="bp">exact</span> (ap (.* mon_unit) (left_inverse x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * <span class="mi">1</span> = x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f">lhs <span class="nb">apply</span> left_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op inv <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> left_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Opaque</span> right_identity_left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** When building a group we can choose to omit the right inverse law and right identity law, since they follow from the left ones. Note that as before with [Build_Group], the extra associativity axiom is omitted. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20"><span class="kn">Definition</span> <span class="nf">Build_Group&#39;</span> (<span class="nv">G</span> : <span class="kt">Type</span>) `{IsHSet G}
  `(op : SgOp G, unit : MonUnit G, inv : Inverse G, !Associative (.*.),
    !LeftIdentity (.*.) mon_unit, !LeftInverse (.*.) (^) mon_unit)
  : Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk22">snapply (Build_Group G op unit inv); <span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk23"><hr></label><div class="goal-conclusion">Associative sg_op</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk24"><hr></label><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk25"><hr></label><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk26"><hr></label><div class="goal-conclusion">LeftInverse sg_op canonical_names.inv <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk27"><hr></label><div class="goal-conclusion">RightInverse sg_op canonical_names.inv <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk28"><span class="mi">1</span>-<span class="mi">3</span>, <span class="mi">5</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk29"><hr></label><div class="goal-conclusion">RightInverse sg_op canonical_names.inv <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply right_identity_left_identity; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet G</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>Associative0</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>LeftIdentity0</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op <span class="mi">1</span></span></span></span><br><span><var>LeftInverse0</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op canonical_names.inv <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op canonical_names.inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply right_inverse_left_inverse; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is a variant of [issig_group] that drops the opposite axiom. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2c"><span class="kn">Definition</span> <span class="nf">issig_group&#39;</span> `{Funext}
  : {G : <span class="kt">Type</span> &amp; {op : SgOp G &amp; {unit : MonUnit G &amp; {inv : Inverse G
    &amp; @IsGroup G op unit inv}}}}
   &lt;~&gt; Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{G : <span class="kt">Type</span> &amp;
{op : SgOp G &amp;
{unit : MonUnit G &amp; {inv : Inverse G &amp; IsGroup G}}}} &lt;~&gt;
Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{G : <span class="kt">Type</span> &amp;
{op : SgOp G &amp;
{unit : MonUnit G &amp; {inv : Inverse G &amp; IsGroup G}}}} &lt;~&gt;
Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2e">nrefine (issig_group oE _^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H : <span class="kt">Type</span> &amp;
{H0 : SgOp H &amp;
{H1 : MonUnit H &amp;
{H2 : Inverse H &amp;
{_ : IsGroup H &amp; Associative (flip H0)}}}}} &lt;~&gt;
{G : <span class="kt">Type</span> &amp;
{op : SgOp G &amp;
{unit : MonUnit G &amp; {inv : Inverse G &amp; IsGroup G}}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2f">napply equiv_functor_sigma_id; <span class="nb">intros</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H0 : SgOp G &amp;
{H1 : MonUnit G &amp;
{H2 : Inverse G &amp;
{_ : IsGroup G &amp; Associative (flip H0)}}}} &lt;~&gt;
{op : SgOp G &amp;
{unit : MonUnit G &amp; {inv : Inverse G &amp; IsGroup G}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk30">napply equiv_functor_sigma_id; <span class="nb">intros</span> op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H1 : MonUnit G &amp;
{H2 : Inverse G &amp;
{_ : IsGroup G &amp; Associative (flip op)}}} &lt;~&gt;
{unit : MonUnit G &amp; {inv : Inverse G &amp; IsGroup G}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk31">napply equiv_functor_sigma_id; <span class="nb">intros</span> unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H2 : Inverse G &amp;
{_ : IsGroup G &amp; Associative (flip op)}} &lt;~&gt;
{inv : Inverse G &amp; IsGroup G}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk32">napply equiv_functor_sigma_id; <span class="nb">intros</span> inv; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : IsGroup G &amp; Associative (flip op)} &lt;~&gt; IsGroup G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk33">rapply (equiv_iff_hprop pr1 (<span class="kr">fun</span> <span class="nv">g</span> =&gt; (g; _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>inv</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative (flip op)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> z y x; <span class="nb">symmetry</span>; rapply simple_associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group homomorphisms *)</span>

<span class="sd">(** Group homomorphisms are maps between groups that preserve the group operation. They allow us to compare groups and map their structure to one another. This is useful for determining if two groups are really the same, in which case we say they are &quot;isomorphic&quot;. *)</span>

<span class="sd">(** A group homomorphism consists of a map between groups and a proof that the map preserves the group operation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">GroupHomomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) := Build_GroupHomomorphism {
  grp_homo_map :&gt; group_type G -&gt; group_type H;
  issemigrouppreserving_grp_homo :: IsSemiGroupPreserving grp_homo_map;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> grp_homo_map {G H}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_GroupHomomorphism {G H} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> issemigrouppreserving_grp_homo {G H} f _ : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Basic properties of group homomorphisms *)</span>

<span class="sd">(** Group homomorphisms preserve group operations. This is an alias for [issemigrouppreserving_grp_homo] with the identity written explicitly. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_op</span>
  : <span class="kr">forall</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">x</span> <span class="nv">y</span> : G), f (x * y) = f x * f y
  := @issemigrouppreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_op : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are unit preserving. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk34"><span class="kn">Instance</span> <span class="nf">isunitpreserving_grp_homo</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : GroupHomomorphism G H)
  : IsUnitPreserving f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk36"><span class="nb">unfold</span> IsUnitPreserving.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk37"><span class="nb">apply</span> (group_cancelL (f mon_unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">1</span> * f <span class="mi">1</span> = f <span class="mi">1</span> * <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk38">rhs napply grp_unit_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">1</span> * f <span class="mi">1</span> = f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk39">rhs_V rapply (ap  _ (monoid_left_id _ mon_unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">1</span> * f <span class="mi">1</span> = f (<span class="mi">1</span> * <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3a"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (<span class="mi">1</span> * <span class="mi">1</span>) = f <span class="mi">1</span> * f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply issemigrouppreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We usually don&#39;t need access to the proof, so we mark this as opaque for a very slight speedup. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> isunitpreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms preserve identities. This is an alias for the previous statement. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_unit</span>
  : <span class="kr">forall</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H), f mon_unit = mon_unit
  := @isunitpreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_unit : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Therefore, group homomorphisms are monoid homomorphisms. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ismonoidpreserving_grp_homo</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : GroupHomomorphism G H)
  : IsMonoidPreserving f
  := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are pointed maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_GroupHomomorphism</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) : G -&gt;* H
  := Build_pMap f (isunitpreserving_grp_homo f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pmap_GroupHomomorphism</span> : GroupHomomorphism &gt;-&gt; pForall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_GroupHomomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) : _ &lt;~&gt; GroupHomomorphism G H
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Function extensionality for group homomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3b"><span class="kn">Definition</span> <span class="nf">equiv_path_grouphomomorphism</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  {<span class="nv">g</span> <span class="nv">h</span> : GroupHomomorphism G H} : g == h &lt;~&gt; g = h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3d"><span class="nb">refine</span> ((equiv_ap (issig_GroupHomomorphism G H)^-<span class="mi">1</span> _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt;
(issig_GroupHomomorphism G H)^-<span class="mi">1</span> g =
(issig_GroupHomomorphism G H)^-<span class="mi">1</span> h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3e"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt;
((issig_GroupHomomorphism G H)^-<span class="mi">1</span> g).<span class="mi">1</span> =
((issig_GroupHomomorphism G H)^-<span class="mi">1</span> h).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are sets, in the presence of funext. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3f"><span class="kn">Instance</span> <span class="nf">ishset_grouphomomorphism</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsHSet (GroupHomomorphism G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupHomomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupHomomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk41"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation (GroupHomomorphism G H) paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g; <span class="bp">exact</span> (istrunc_equiv_istrunc _ equiv_path_grouphomomorphism).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms preserve inverses. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk42"><span class="kn">Definition</span> <span class="nf">grp_homo_inv</span> {<span class="nv">G</span> <span class="nv">H</span>} (<span class="nv">f</span> : GroupHomomorphism G H)
  : <span class="kr">forall</span> <span class="nv">x</span>, f x^ = (f x)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, f x^ = (f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* This can also be proved using [:= preserves_inverse.] from Classes/theory/groups.v.  That uses [rewrite] and is marked [Qed]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, f x^ = (f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk44"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x^ = (f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk45"><span class="nb">apply</span> (inverse_unique (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x^ * f x = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk46"><hr></label><div class="goal-conclusion">f x * (f x)^ = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk47">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x^ * f x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk48"><span class="nb">refine</span> (_ @ grp_homo_unit f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x^ * f x = f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk49"><span class="nb">refine</span> ((grp_homo_op f _ x)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x^ * x) = f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4a"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * (f x)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_inv : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity map is a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_id</span> {<span class="nv">G</span> : Group} : GroupHomomorphism G G
  := Build_GroupHomomorphism idmap _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The composition of the underlying functions of two group homomorphisms is also a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4c"><span class="kn">Definition</span> <span class="nf">grp_homo_compose</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group}
  : GroupHomomorphism H K -&gt; GroupHomomorphism G H -&gt; GroupHomomorphism G K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H K -&gt;
GroupHomomorphism G H -&gt; GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H K -&gt;
GroupHomomorphism G H -&gt; GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4e"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism H K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_GroupHomomorphism (f o g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group Isomorphisms *)</span>

<span class="sd">(** Group isomorphisms are group homomorphisms whose underlying map happens to be an equivalence. They allow us to consider two groups to be the &quot;same&quot;. They can be inverted and composed just like equivalences. *)</span>

<span class="sd">(** An isomorphism of groups is defined as group homomorphism that is an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">GroupIsomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) := Build_GroupIsomorphism {
  grp_iso_homo :&gt; GroupHomomorphism G H;
  isequiv_group_iso :: IsEquiv grp_iso_homo;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can build an isomorphism from an operation-preserving equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4f"><span class="kn">Definition</span> <span class="nf">Build_GroupIsomorphism&#39;</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : G &lt;~&gt; H) (<span class="nv">h</span> : IsSemiGroupPreserving f)
  : GroupIsomorphism G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk51">srapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><label class="goal-separator" for="group-v-chk52"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk53"><span class="mi">1</span>: srapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := f;
    issemigrouppreserving_grp_homo := h
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_GroupIsomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group)
  : _ &lt;~&gt; GroupIsomorphism G H := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying equivalence of a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_groupisomorphism</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H -&gt; G &lt;~&gt; H
  := <span class="kr">fun</span> <span class="nv">f</span> =&gt; Build_Equiv G H f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">equiv_groupisomorphism</span> : GroupIsomorphism &gt;-&gt; Equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying pointed equivalence of a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_groupisomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group}
  : GroupIsomorphism A B -&gt; (A &lt;~&gt;* B)
  := <span class="kr">fun</span> <span class="nv">f</span> =&gt; Build_pEquiv f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pequiv_groupisomorphism</span> : GroupIsomorphism &gt;-&gt; pEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Funext for group isomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk54"><span class="kn">Definition</span> <span class="nf">equiv_path_groupisomorphism</span> `{F : Funext} {G H : Group}
  (f g : GroupIsomorphism G H)
  : f == g &lt;~&gt; f = g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk56"><span class="nb">refine</span> ((equiv_ap (issig_GroupIsomorphism G H)^-<span class="mi">1</span> _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt;
(issig_GroupIsomorphism G H)^-<span class="mi">1</span> f =
(issig_GroupIsomorphism G H)^-<span class="mi">1</span> g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk57"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt;
((issig_GroupIsomorphism G H)^-<span class="mi">1</span> f).<span class="mi">1</span> =
((issig_GroupIsomorphism G H)^-<span class="mi">1</span> g).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms form a set. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk58"><span class="kn">Definition</span> <span class="nf">ishset_groupisomorphism</span> `{F : Funext} {G H : Group}
  : IsHSet (GroupIsomorphism G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupIsomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupIsomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5a"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation (GroupIsomorphism G H) paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g; <span class="bp">exact</span> (istrunc_equiv_istrunc _ (equiv_path_groupisomorphism _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity map is an equivalence and therefore a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_iso_id</span> {<span class="nv">G</span> : Group} : GroupIsomorphism G G
  := Build_GroupIsomorphism _ _ grp_homo_id _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms can be composed by composing the underlying group homomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_iso_compose</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group}
  (<span class="nv">g</span> : GroupIsomorphism H K) (<span class="nv">f</span> : GroupIsomorphism G H)
  : GroupIsomorphism G K
  := Build_GroupIsomorphism _ _ (grp_homo_compose g f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms can be inverted. The inverse map of the underlying equivalence also preserves the group operation and unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5b"><span class="kn">Definition</span> <span class="nf">grp_iso_inverse</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H -&gt; GroupIsomorphism H G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H -&gt; GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H -&gt; GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5d"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5e">srapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="group-v-chk5f"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_GroupHomomorphism f^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := f^-<span class="mi">1</span>;
    issemigrouppreserving_grp_homo := monmor_sgmor
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a reflexive relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">reflexive_groupisomorphism</span>
  : Reflexive GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> =&gt; grp_iso_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a symmetric relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">symmetric_groupisomorphism</span>
  : Symmetric GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> =&gt; grp_iso_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a transitive relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">transitive_groupisomorphism</span>
  : Transitive GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; grp_iso_compose g f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under univalence, equality of groups is equivalent to isomorphism of groups. This is the structure identity principle for groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk62"><span class="kn">Definition</span> <span class="nf">equiv_path_group&#39;</span> {<span class="nv">U</span> : Univalence} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H &lt;~&gt; G = H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk64">equiv_via {f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt;
{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk65"><hr></label><div class="goal-conclusion">{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f} &lt;~&gt; G = H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk66"><span class="mi">1</span>: make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f} &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk67"><span class="nb">revert</span> G H; <span class="nb">apply</span> (equiv_path_issig_contr issig_group).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp;
    {H2 : Inverse H &amp;
    {_ : IsGroup H &amp; Associative (flip H0)}}}}},
{f : issig_group b &lt;~&gt; issig_group b &amp;
IsSemiGroupPreserving f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="group-v-chk68"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {H : <span class="kt">Type</span> &amp;
     {H0 : SgOp H &amp;
     {H1 : MonUnit H &amp;
     {H2 : Inverse H &amp;
     {_ : IsGroup H &amp; Associative (flip H0)}}}}},
Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp;
    {H2 : Inverse H &amp;
    {_ : IsGroup H &amp; Associative (flip H0)}}}}} &amp;
  {f : issig_group b1 &lt;~&gt; issig_group b2 &amp;
  IsSemiGroupPreserving f}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp;
    {H2 : Inverse H &amp;
    {_ : IsGroup H &amp; Associative (flip H0)}}}}},
{f : issig_group b &lt;~&gt; issig_group b &amp;
IsSemiGroupPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6a"><span class="nb">intros</span> [G [? [? [? ?]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>{_ : IsGroup G &amp; Associative (flip proj1)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f
: issig_group (G; proj1; proj0; proj2; proj3) &lt;~&gt;
  issig_group (G; proj1; proj0; proj2; proj3) &amp;
IsSemiGroupPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6b"><span class="kr">exists</span> <span class="mi">1</span>%equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>{_ : IsGroup G &amp; Associative (flip proj1)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {H : <span class="kt">Type</span> &amp;
     {H0 : SgOp H &amp;
     {H1 : MonUnit H &amp;
     {H2 : Inverse H &amp;
     {_ : IsGroup H &amp; Associative (flip H0)}}}}},
Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp;
    {H2 : Inverse H &amp;
    {_ : IsGroup H &amp; Associative (flip H0)}}}}} &amp;
  {f : issig_group b1 &lt;~&gt; issig_group b2 &amp;
  IsSemiGroupPreserving f}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6d"><span class="nb">intros</span> [G [op [unit [neg [ax assoc_op]]]]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp;
    {H2 : Inverse H &amp;
    {_ : IsGroup H &amp; Associative (flip H0)}}}}} &amp;
  {f : G &lt;~&gt; b2.<span class="mi">1</span> &amp; IsSemiGroupPreserving f}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6e">contr_sigsig G (equiv_idmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {y
  : {H0 : SgOp G &amp;
    {H1 : MonUnit G &amp;
    {H2 : Inverse G &amp;
    {_ : IsGroup G &amp; Associative (flip H0)}}}} &amp;
  IsSemiGroupPreserving <span class="mi">1</span>%equiv}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6f">srefine (Build_Contr _ ((_;(_;(_;(_; _))));_) _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative (flip op)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><label class="goal-separator" for="group-v-chk70"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><label class="goal-separator" for="group-v-chk71"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp;
      {H2 : Inverse G &amp;
      {_ : IsGroup G &amp; Associative (flip H0)}}}} &amp;
    IsSemiGroupPreserving idmap},
((op; unit; neg; ax; <span class="nl">?Goal</span>); <span class="nl">?Goal0</span>) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk72"><span class="mi">1</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><label class="goal-separator" for="group-v-chk73"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp;
      {H2 : Inverse G &amp;
      {_ : IsGroup G &amp; Associative (flip H0)}}}} &amp;
    IsSemiGroupPreserving idmap},
((op; unit; neg; ax; assoc_op); <span class="nl">?Goal</span>) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk74"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp;
      {H2 : Inverse G &amp;
      {_ : IsGroup G &amp; Associative (flip H0)}}}} &amp;
    IsSemiGroupPreserving idmap},
((op; unit; neg; ax; assoc_op);
abstract_algebra.id_sg_morphism) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk75"><span class="nb">intros</span> [[op&#39; [unit&#39; [neg&#39; [ax&#39; assoc_op&#39;]]]] eq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((op; unit; neg; ax; assoc_op);
abstract_algebra.id_sg_morphism) =
((op&#39;; unit&#39;; neg&#39;; ax&#39;; assoc_op&#39;); eq)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk76"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(op; unit; neg; ax; assoc_op) =
(op&#39;; unit&#39;; neg&#39;; ax&#39;; assoc_op&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk77"><span class="nb">refine</span> (@ap _ _ (<span class="kr">fun</span> <span class="nv">x</span> : { oun :
      { oo : SgOp G &amp; { u : MonUnit G &amp; Inverse G}}
      &amp; { _ : @IsGroup G oun.<span class="mi">1</span> oun.<span class="mi">2</span>.<span class="mi">1</span> oun.<span class="mi">2</span>.<span class="mi">2</span>
        &amp; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">y</span> <span class="nv">x</span>, oun.<span class="mi">1</span> (oun.<span class="mi">1</span> x y) z = oun.<span class="mi">1</span> x (oun.<span class="mi">1</span> y z)}}
      =&gt; (x.<span class="mi">1</span>.<span class="mi">1</span> ; x.<span class="mi">1</span>.<span class="mi">2</span>.<span class="mi">1</span> ; x.<span class="mi">1</span>.<span class="mi">2</span>.<span class="mi">2</span> ; (x.<span class="mi">2</span>.<span class="mi">1</span>; x.<span class="mi">2</span>.<span class="mi">2</span>)))
      ((op;unit;neg);(ax; assoc_op)) ((op&#39;;unit&#39;;neg&#39;);(ax&#39;; assoc_op&#39;)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((op; unit; neg); ax; assoc_op) =
((op&#39;; unit&#39;; neg&#39;); ax&#39;; assoc_op&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk78"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(op; unit; neg) = (op&#39;; unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk79">srefine (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">op = op&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><label class="goal-separator" for="group-v-chk7a"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">_</span> : SgOp G =&gt; {_ : MonUnit G &amp; Inverse G}) 
  <span class="nl">?p</span> (unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7b"><span class="mi">1</span>: funext x y; <span class="nb">apply</span> eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">_</span> : SgOp G =&gt; {_ : MonUnit G &amp; Inverse G})
  (path_forall op op&#39;
     ((<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       path_forall (op x) (op&#39; x)
         ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; eq x y) : op x == op&#39; x))
      :
      op == op&#39;)) (unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7c"><span class="nb">rewrite</span> transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7d"><span class="nb">pose</span> (f := Build_GroupHomomorphism
        (G:=Build_Group_internal G op unit neg ax assoc_op)
        (H:=Build_Group_internal G op&#39; unit&#39; neg&#39; ax&#39; assoc_op&#39;)
        idmap eq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7e">srefine (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unit = unit&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk7f"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : MonUnit G =&gt; Inverse G) <span class="nl">?p</span> neg =
neg&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk80"><span class="mi">1</span>: <span class="bp">exact</span> (grp_homo_unit f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : MonUnit G =&gt; Inverse G)
  (grp_homo_unit f) neg = neg&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk81">lhs napply transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">neg = neg&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk82">funext x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op</var><span class="hyp-type"><b>: </b><span>Associative (flip op)</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Inverse G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>assoc_op'</var><span class="hyp-type"><b>: </b><span>Associative (flip op&#39;)</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax;
    group_assoc_opp := assoc_op
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;;
    group_assoc_opp := assoc_op&#39;
  |}</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">neg x = neg&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_inv f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version with nicer universe variables. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_group</span>@{u v | u &lt; v} {U : Univalence} {G H : Group@{u}}
  : GroupIsomorphism G H &lt;~&gt; (paths@{v} G H)
  := equiv_path_group&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Simple group equivalences *)</span>

<span class="sd">(** Left multiplication is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk83"><span class="kn">Instance</span> <span class="nf">isequiv_group_left_op</span> {<span class="nv">G</span> : Group}
  : <span class="kr">forall</span> (<span class="nv">x</span> : G), IsEquiv (x *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk85"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk86">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk87"><hr></label><div class="goal-conclusion">sg_op x o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk88"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o sg_op x == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk89"><span class="mi">1</span>: <span class="bp">exact</span> (x^ *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op x o sg_op x^ == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk8a"><hr></label><div class="goal-conclusion">sg_op x^ o sg_op x == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8b"><span class="kp">all</span>: <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (x^ * y) = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk8c"><hr></label><div class="goal-conclusion">x^ * (x * y) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8d"><span class="kp">all</span>: <span class="nb">refine</span> (grp_assoc _ _ _ @ _ @ grp_unit_l y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ * y = <span class="mi">1</span> * y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk8e"><hr></label><div class="goal-conclusion">x^ * x * y = <span class="mi">1</span> * y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8f"><span class="kp">all</span>: <span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * y) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk90"><hr></label><div class="goal-conclusion">x^ * x = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk91"><span class="mi">1</span>: <span class="nb">apply</span> grp_inv_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right multiplication is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk92"><span class="kn">Instance</span> <span class="nf">isequiv_group_right_op</span> (<span class="nv">G</span> : Group)
  : <span class="kr">forall</span> (<span class="nv">x</span> : G), IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk94"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk95">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk96"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk97"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk98"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * x^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x^) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk99"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x^) o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9a"><span class="kp">all</span>: <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * x^ * x = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk9b"><hr></label><div class="goal-conclusion">y * x * x^ = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9c"><span class="kp">all</span>: <span class="nb">refine</span> ((grp_assoc _ _ _)^ @ _ @ grp_unit_r y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * (x^ * x) = y * <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk9d"><hr></label><div class="goal-conclusion">y * (x * x^) = y * <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9e"><span class="kp">all</span>: <span class="nb">refine</span> (ap (y *.) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk9f"><hr></label><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka0"><span class="mi">1</span>: <span class="nb">apply</span> grp_inv_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The operation inverting group elements is an equivalence. Note that, since the order of the operation will change after inversion, this isn&#39;t a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka1"><span class="kn">Instance</span> <span class="nf">isequiv_group_inverse</span> {<span class="nv">G</span> : Group}
  : IsEquiv ((^) : G -&gt; G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (inv : G -&gt; G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (inv : G -&gt; G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka3">srapply isequiv_involution.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inv o inv == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> inverse_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Reasoning with equations in groups. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupEquations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Inverses are involutive. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_inv</span> : x^^ = x := inverse_involutive x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Inverses distribute over the group operation. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_op</span> : (x * y)^ = y^ * x^ := inverse_sg_op x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The inverse of the unit is the unit. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_unit</span> : mon_unit^ = mon_unit := inverse_mon_unit (G :=G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_V_gg</span> : x^ * (x * y) = y
    := grp_assoc _ _ _ @ ap (.* y) (grp_inv_l x) @ grp_unit_l y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_g_Vg</span> : x * (x^ * y) = y
    := grp_assoc _ _ _ @ ap (.* y) (grp_inv_r x) @ grp_unit_l y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_gg_V</span> : (x * y) * y^ = x
    := (grp_assoc _ _ _)^ @ ap (x *.) (grp_inv_r y) @ grp_unit_r x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_gV_g</span> : (x * y^) * y = x
    := (grp_assoc _ _ _)^ @ ap (x *.) (grp_inv_l y) @ grp_unit_r x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_1g_g1</span> : x = y &lt;~&gt; <span class="mi">1</span> * x = y * <span class="mi">1</span>
    := equiv_concat_r (grp_unit_r _)^ _ oE equiv_concat_l (grp_unit_l _) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_g1_1g</span> : x = y &lt;~&gt; x * <span class="mi">1</span> = <span class="mi">1</span> * y
    := equiv_concat_r (grp_unit_l _)^ _ oE equiv_concat_l (grp_unit_r _) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupEquations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Cancellation lemmas *)</span>

<span class="sd">(** Group elements can be cancelled both on the left and the right. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelL</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> : G} <span class="nv">z</span> : x = y &lt;~&gt; z * x = z * y
  := equiv_ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; z * x) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelR</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> : G} <span class="nv">z</span> : x = y &lt;~&gt; x * z = y * z
  := equiv_ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group movement lemmas *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Since left/right multiplication is an equivalence, we can use lemmas about moving equivalences around to prove group movement lemmas. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving group elements *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_gM</span> : x * z^ = y &lt;~&gt; x = y * z
    := equiv_moveL_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_Mg</span> : y^ * x = z &lt;~&gt; x = y * z
    := equiv_moveL_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; y * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_gM</span> : x = z * y^ &lt;~&gt; x * y = z
    := equiv_moveR_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * y) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_Mg</span> : y = x^ * z &lt;~&gt; x * y = z
    := equiv_moveR_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; x * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving inverses.*)</span>
  <span class="sd">(** These are the inverses of the previous but are included here for completeness*)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_gV</span> : x = y * z &lt;~&gt; x * z^ = y
    := equiv_moveR_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_Vg</span> : x = y * z &lt;~&gt; y^ * x = z
    := equiv_moveR_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; y * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_gV</span> :  x * y = z &lt;~&gt; x = z * y^
    := equiv_moveL_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * y) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_Vg</span> :  x * y = z &lt;~&gt; y = x^ * z
    := equiv_moveL_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; x * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We close the section here so the previous lemmas generalise their assumptions. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving elements equal to unit. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_1M</span> : x * y^ = <span class="mi">1</span> &lt;~&gt; x = y
    := equiv_concat_r (grp_unit_l _) _ oE grp_moveL_gM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_M1</span> : y^ * x = <span class="mi">1</span> &lt;~&gt; x = y
    := equiv_concat_r (grp_unit_r _) _ oE grp_moveL_Mg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_1V</span> : x * y = <span class="mi">1</span> &lt;~&gt; x = y^
    := equiv_concat_r (grp_unit_l _) _ oE grp_moveL_gV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_V1</span> : y * x = <span class="mi">1</span> &lt;~&gt; x = y^
    := equiv_concat_r (grp_unit_r _) _ oE grp_moveL_Vg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_1M</span> : <span class="mi">1</span> = y * x^ &lt;~&gt; x = y
    := (equiv_concat_l (grp_unit_l _) _)^-<span class="mi">1</span> oE grp_moveR_gM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_M1</span> : <span class="mi">1</span> = x^ * y &lt;~&gt; x = y
    := (equiv_concat_l (grp_unit_r _) _)^-<span class="mi">1</span> oE grp_moveR_Mg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_1V</span> : <span class="mi">1</span> = y * x &lt;~&gt; x^ = y
    := (equiv_concat_l (grp_unit_l _) _)^-<span class="mi">1</span> oE grp_moveR_gV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_V1</span> : mon_unit = x * y &lt;~&gt; x^ = y
    := (equiv_concat_l (grp_unit_r _) _)^-<span class="mi">1</span> oE grp_moveR_Vg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Cancelling elements equal to unit. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelL1</span> : x = mon_unit &lt;~&gt; z * x = z
    := (equiv_concat_r (grp_unit_r _) _ oE grp_cancelL z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelR1</span> : x = mon_unit &lt;~&gt; x * z = z
    := (equiv_concat_r (grp_unit_l _) _) oE grp_cancelR z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Commutation *)</span>

<span class="sd">(** If [g] commutes with [h], then [g] commutes with the inverse [-h]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka4"><span class="kn">Definition</span> <span class="nf">grp_commutes_inv</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> <span class="nv">h</span> : G) (<span class="nv">p</span> : g * h = h * g)
  : g * h^ = h^ * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h^ = h^ * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h^ = h^ * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka6"><span class="nb">apply</span> grp_moveR_gV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h^ * g * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka7">rhs_V <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h^ * (g * h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_moveL_Vg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [g] commutes with [h] and [h&#39;], then [g] commutes with their product [h * h&#39;]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka8"><span class="kn">Definition</span> <span class="nf">grp_commutes_op</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> <span class="nv">h</span> <span class="nv">h&#39;</span> : G)
  (<span class="nv">p</span> : g * h = h * g) (<span class="nv">p&#39;</span> : g * h&#39; = h&#39; * g)
  : g * (h * h&#39;) = (h * h&#39;) * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkaa">lhs <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * h&#39; = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkab">lhs <span class="bp">exact</span> (ap (.* h&#39;) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g * h&#39; = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkac">lhs_V <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (g * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkad">lhs <span class="bp">exact</span> (ap (h *.) p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (h&#39; * g) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> simple_associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Power operation *)</span>

<span class="sd">(** For a given [g : G] we can define the function [Int -&gt; G] sending an integer to that power of [g]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> : G) (<span class="nv">n</span> : Int) : G
  := int_iter (g *.) n mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any homomorphism respects [grp_pow]. In other words, [fun g =&gt; grp_pow g n] is natural. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkae"><span class="kn">Lemma</span> <span class="nf">grp_pow_natural</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : f (grp_pow g n) = grp_pow (f g) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (grp_pow g n) = grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (grp_pow g n) = grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb0">lhs snapply (int_iter_commute_map _ ((f g) *.)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; f (g * x)) == (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; f g * f x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chkb1"><hr></label><div class="goal-conclusion">int_iter (sg_op (f g)) n (f <span class="mi">1</span>) = grp_pow (f g) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb2"><span class="mi">1</span>: napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op (f g)) n (f <span class="mi">1</span>) = grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ap (int_iter _ n)), grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** All powers of the unit are the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb3"><span class="kn">Definition</span> <span class="nf">grp_pow_unit</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int)
  : grp_pow (G:=G) mon_unit n = mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow <span class="mi">1</span> n = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow <span class="mi">1</span> n = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb5">snapply (int_iter_invariant n _ (<span class="kr">fun</span> <span class="nv">g</span> =&gt; g = mon_unit)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, x = <span class="mi">1</span> -&gt; <span class="mi">1</span> * x = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chkb6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, x = <span class="mi">1</span> -&gt; <span class="mi">1</span>^ * x = <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chkb7"><hr></label><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb8"><span class="mi">1</span>, <span class="mi">2</span>: <span class="nb">apply</span> paths_ind_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * <span class="mi">1</span> = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chkb9"><hr></label><div class="goal-conclusion"><span class="mi">1</span>^ * <span class="mi">1</span> = <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chkba"><hr></label><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>^ * <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbd">lhs napply grp_unit_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_inv_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that powers don&#39;t preserve the group operation as it is not commutative. This does hold in an abelian group so such a result will appear later. *)</span>

<span class="sd">(** The next two results tell us how [grp_pow] unfolds. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow_succ</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n.+<span class="mi">1</span>)%int = g * grp_pow g n
  := int_iter_succ_l _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow_pred</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n.-<span class="mi">1</span>)%int = g^ * grp_pow g n
  := int_iter_pred_l _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] satisfies an additive law of exponents. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbf"><span class="kn">Definition</span> <span class="nf">grp_pow_add</span> {<span class="nv">G</span> : Group} (<span class="nv">m</span> <span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n + m)%int = grp_pow g n * grp_pow g m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (n + m)%int = grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (n + m)%int = grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc1">lhs napply int_iter_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc2"><span class="nb">induction</span> n; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) m <span class="mi">1</span> = <span class="mi">1</span> * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) = grp_pow g n * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chkc3"><hr></label><div class="goal-conclusion">int_iter (sg_op g) n.+<span class="mi">1</span>%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow g m</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chkc4"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc5"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="bp">exact</span> (grp_unit_l _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) = grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) n.+<span class="mi">1</span>%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chkc6"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc7"><span class="mi">1</span>: <span class="nb">rewrite</span> int_iter_succ_l, grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) = grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) =
g * grp_pow g n * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chkc8"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc9"><span class="mi">2</span>: <span class="nb">rewrite</span> int_iter_pred_l, grp_pow_pred; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) = grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * int_iter (sg_op g) n (int_iter (sg_op g) m <span class="mi">1</span>) =
g * grp_pow g n * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m <span class="mi">1</span>) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chkca"><hr></label><div class="goal-conclusion">g^ *
int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m <span class="mi">1</span>) =
g^ * grp_pow g (- n)%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span> : rhs_V srapply associativity;
        <span class="nb">apply</span> ap, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] commutes negative exponents to powers of the inverse *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcb"><span class="kn">Definition</span> <span class="nf">grp_pow_neg</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (int_neg n) = grp_pow g^ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = grp_pow g^ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = grp_pow g^ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcd">lhs napply int_iter_neg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g)^-<span class="mi">1</span> n <span class="mi">1</span> = grp_pow g^ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkce"><span class="nb">cbn</span>; <span class="nb">unfold</span> grp_pow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g^) n <span class="mi">1</span> = int_iter (sg_op g^) n <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* These agree, except for the proofs that [sg_op g^] is an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> int_iter_agree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using a negative power in [grp_pow] is the same as first using a positive power and then inverting the result. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcf"><span class="kn">Definition</span> <span class="nf">grp_pow_neg_inv</span> {<span class="nv">G</span>: Group} (<span class="nv">m</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (- m)%int = (grp_pow g m)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int = (grp_pow g m)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int = (grp_pow g m)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd1"><span class="nb">apply</span> grp_moveL_1V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int * grp_pow g m = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd2">lhs_V napply grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m + m)%int = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> int_add_neg_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Combining the two previous results gives that a power of an inverse is the inverse of the power. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd3"><span class="kn">Definition</span> <span class="nf">grp_pow_neg_inv&#39;</span> {<span class="nv">G</span>: Group} (<span class="nv">n</span>: Int) (<span class="nv">g</span> : G)
  : grp_pow g^ n = (grp_pow g n)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g^ n = (grp_pow g n)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g^ n = (grp_pow g n)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd5">lhs_V napply grp_pow_neg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = (grp_pow g n)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pow_neg_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] satisfies a multiplicative law of exponents. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd6"><span class="kn">Definition</span> <span class="nf">grp_pow_int_mul</span> {<span class="nv">G</span> : Group} (<span class="nv">m</span> <span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (m * n)%int = grp_pow (grp_pow g m) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd8"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = grp_pow (grp_pow g m) <span class="mi">0</span>%int</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><label class="goal-separator" for="group-v-chkd9"><hr></label><div class="goal-conclusion">grp_pow g (m * n.+<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><label class="goal-separator" for="group-v-chkda"><hr></label><div class="goal-conclusion">grp_pow g (m * (- n).-<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = grp_pow (grp_pow g m) <span class="mi">0</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdc"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> int_mul_0_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n.+<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkde"><span class="nb">rewrite</span> int_mul_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m + m * n)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdf"><span class="nb">rewrite</span> grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g m * grp_pow g (m * n)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke0"><span class="nb">rewrite</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g m * grp_pow g (m * n)%int =
grp_pow g m * grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_cancelL, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * (- n).-<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke2"><span class="nb">rewrite</span> int_mul_pred_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m + m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke3"><span class="nb">rewrite</span> grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int * grp_pow g (m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke4"><span class="nb">rewrite</span> grp_pow_neg_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_pow g m)^ * grp_pow g (m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke5"><span class="nb">rewrite</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_pow g m)^ * grp_pow g (m * - n)%int =
(grp_pow g m)^ * grp_pow (grp_pow g m) (- n)%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_cancelL, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [h] commutes with [g], then [h] commutes with [grp_pow g n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke6"><span class="kn">Definition</span> <span class="nf">grp_pow_commutes</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> <span class="nv">h</span> : G)
  (<span class="nv">p</span> : h * g = g * h)
  : h * (grp_pow g n) = (grp_pow g n) * h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke8"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g <span class="mi">0</span>%int = grp_pow g <span class="mi">0</span>%int * h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><label class="goal-separator" for="group-v-chke9"><hr></label><div class="goal-conclusion">h * grp_pow g n.+<span class="mi">1</span>%int = grp_pow g n.+<span class="mi">1</span>%int * h</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><label class="goal-separator" for="group-v-chkea"><hr></label><div class="goal-conclusion">h * grp_pow g (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g <span class="mi">0</span>%int = grp_pow g <span class="mi">0</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_g1_1g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n.+<span class="mi">1</span>%int = grp_pow g n.+<span class="mi">1</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chked"><span class="nb">rewrite</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (g * grp_pow g n) = g * grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply grp_commutes_op; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkef"><span class="nb">rewrite</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (g^ * grp_pow g (- n)%int) =
g^ * grp_pow g (- n)%int * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf0">napply grp_commutes_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g^ = g^ * h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkf1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><label class="goal-separator" for="group-v-chkf1"><hr></label><div class="goal-conclusion">h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf2"><span class="mi">2</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g^ = g^ * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_commutes_inv, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow g n] commutes with [g]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf3"><span class="kn">Definition</span> <span class="nf">grp_pow_commutes&#39;</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : g * grp_pow g n = grp_pow g n * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * grp_pow g n = grp_pow g n * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * grp_pow g n = grp_pow g n * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_pow_commutes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [g] and [h] commute, then [grp_pow (g * h) n] = (grp_pow g n) * (grp_pow h n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf5"><span class="kn">Definition</span> <span class="nf">grp_pow_mul</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> <span class="nv">h</span> : G)
  (<span class="nv">c</span> : g * h = h * g)
  : grp_pow (g * h) n = (grp_pow g n) * (grp_pow h n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n = grp_pow g n * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n = grp_pow g n * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf7"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) <span class="mi">0</span>%int =
grp_pow g <span class="mi">0</span>%int * grp_pow h <span class="mi">0</span>%int</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkf8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><label class="goal-separator" for="group-v-chkf8"><hr></label><div class="goal-conclusion">grp_pow (g * h) n.+<span class="mi">1</span>%int =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow h n.+<span class="mi">1</span>%int</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkf9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><label class="goal-separator" for="group-v-chkf9"><hr></label><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) <span class="mi">0</span>%int =
grp_pow g <span class="mi">0</span>%int * grp_pow h <span class="mi">0</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span> * <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; napply grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n.+<span class="mi">1</span>%int =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow h n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfd"><span class="nb">rewrite</span> <span class="mi">3</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow (g * h) n =
g * grp_pow g n * (h * grp_pow h n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfe"><span class="nb">rewrite</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * (grp_pow g n * grp_pow h n) =
g * grp_pow g n * (h * grp_pow h n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkff"><span class="nb">rewrite</span> <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow g n * grp_pow h n =
g * grp_pow g n * h * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk100"><span class="nb">apply</span> grp_cancelR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow g n = g * grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk101"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * grp_pow g n) = g * (grp_pow g n * h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk102"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk103"><span class="nb">apply</span> grp_pow_commutes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g = g * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> c^%path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk104">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk105"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk106"><span class="nb">rewrite</span> <span class="mi">3</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g * h)^ * grp_pow (g * h) (- n)%int =
g^ * grp_pow g (- n)%int * (h^ * grp_pow h (- n)%int)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk107"><span class="nb">rewrite</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g * h)^ * (grp_pow g (- n)%int * grp_pow h (- n)%int) =
g^ * grp_pow g (- n)%int * (h^ * grp_pow h (- n)%int)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk108"><span class="nb">rewrite</span> <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g * h)^ * grp_pow g (- n)%int * grp_pow h (- n)%int =
g^ * grp_pow g (- n)%int * h^ * grp_pow h (- n)%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk109"><span class="nb">apply</span> grp_cancelR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g * h)^ * grp_pow g (- n)%int =
g^ * grp_pow g (- n)%int * h^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10a"><span class="nb">rewrite</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(h * g)^ * grp_pow g (- n)%int =
g^ * grp_pow g (- n)%int * h^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10b"><span class="nb">rewrite</span> grp_inv_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g^ * h^ * grp_pow g (- n)%int =
g^ * grp_pow g (- n)%int * h^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10c"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g^ * (h^ * grp_pow g (- n)%int) =
g^ * (grp_pow g (- n)%int * h^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10d"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h^ * grp_pow g (- n)%int = grp_pow g (- n)%int * h^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10e"><span class="nb">apply</span> grp_pow_commutes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h^ * g = g * h^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> grp_commutes_inv, c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The category of Groups *)</span>

<span class="sd">(** ** Groups together with homomorphisms form a 1-category whose equivalences are the group isomorphisms. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_group</span> : IsGraph Group
  := Build_IsGraph Group GroupHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We add this coercion to make it easier to use a group isomorphism where Coq expects a category morphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isHom_GroupIsomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) : GroupIsomorphism G H -&gt; Hom G H := idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">isHom_GroupIsomorphism</span>  : GroupIsomorphism &gt;-&gt; Hom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_group</span> : Is01Cat Group :=
  Build_Is01Cat Group _ (@grp_homo_id) (@grp_homo_compose).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Helper notation so that the wildcat instances can easily be inferred. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">grp_homo_map&#39;</span> A B := (@grp_homo_map A B : _ -&gt; (group_type A $-&gt; _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_group</span> : Is2Graph Group
  := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> =&gt; isgraph_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} : IsGraph (A $-&gt; B)
  := isgraph_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} : Is01Cat (A $-&gt; B)
  := is01cat_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0gpd_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group}: Is0Gpd (A $-&gt; B)
  := is0gpd_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10f"><span class="kn">Instance</span> <span class="nf">is0functor_postcomp_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : Group} (<span class="nv">h</span> : B $-&gt; C)
  : Is0Functor (@cat_postcomp Group _ _ A B C h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_postcomp A h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk110"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_postcomp A h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk111"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A $-&gt; B,
(a $-&gt; b) -&gt; cat_postcomp A h a $-&gt; cat_postcomp A h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g p a ; <span class="bp">exact</span> (ap h (p a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk112"><span class="kn">Instance</span> <span class="nf">is0functor_precomp_grouphomomorphism</span>
       {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : Group} (<span class="nv">h</span> : A $-&gt; B)
  : Is0Functor (@cat_precomp Group _ _ A B C h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_precomp C h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_precomp C h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk114"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B $-&gt; C,
(a $-&gt; b) -&gt; cat_precomp C h a $-&gt; cat_precomp C h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [f ?] [g ?] p a ; <span class="bp">exact</span> (p (h a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group forms a 1Cat *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk115"><span class="kn">Instance</span> <span class="nf">is1cat_group</span> : Is1Cat Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply Build_Is1Cat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under [Funext], the category of groups has morphism extensionality. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk117"><span class="kn">Instance</span> <span class="nf">hasmorext_group</span> `{Funext} : HasMorExt Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk118"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk119"><span class="nb">intros</span> A B f g; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11a">snapply @isequiv_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g -&gt; f == g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk11b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chk11b"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?f</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk11c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chk11c"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == GpdHom_path</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11d"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk11e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chk11e"><hr></label><div class="goal-conclusion">equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv == GpdHom_path</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11f"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv == GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms become equivalences in the category of groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk120"><span class="kn">Instance</span> <span class="nf">hasequivs_group</span>
  : HasEquivs Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk121"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk122"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, <span class="nl">?CatEquiv&#39;</span> a b -&gt; a $-&gt; b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b),
<span class="nl">?CatIsEquiv&#39;</span> a b f -&gt; <span class="nl">?CatEquiv&#39;</span> a b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, <span class="nl">?CatEquiv&#39;</span> a b -&gt; b $-&gt; a</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?CatIsEquiv&#39;</span> a b (<span class="nl">?cate_fun&#39;</span> a b f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : <span class="nl">?CatIsEquiv&#39;</span> a b f),
<span class="nl">?cate_fun&#39;</span> a b (<span class="nl">?cate_buildequiv&#39;</span> a b f fe) $== f</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_inv&#39;</span> a b f $o <span class="nl">?cate_fun&#39;</span> a b f $== Id a</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_fun&#39;</span> a b f $o <span class="nl">?cate_inv&#39;</span> a b f $== Id b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt; <span class="nl">?CatIsEquiv&#39;</span> a b f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk123">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> GroupIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk124">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">f</span> =&gt; IsEquiv f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk125">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, GroupIsomorphism a b -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> G H f; <span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk126">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b f -&gt;
GroupIsomorphism a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Build_GroupIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk127">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, GroupIsomorphism a b -&gt; b $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> G H; <span class="bp">exact</span> grp_iso_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk128">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b
  ((<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
    isHom_GroupIsomorphism G H f0) a b f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk129">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : (<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0)
        a b f),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 isHom_GroupIsomorphism G H f0) a b
  {| grp_iso_homo := f; isequiv_group_iso := fe |} $==
f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">x</span> : GroupIsomorphism G H) =&gt;
 isHom_GroupIsomorphism H G (grp_iso_inverse x)) a b f $o
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 isHom_GroupIsomorphism G H f0) a b f $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ????; <span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 isHom_GroupIsomorphism G H f0) a b f $o
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">x</span> : GroupIsomorphism G H) =&gt;
 isHom_GroupIsomorphism H G (grp_iso_inverse x)) a b f $==
Id b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ????; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt;
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12d"><span class="nb">intros</span> G H f g p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>H $-&gt; G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $o g $== Id H</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $o f $== Id G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f</span> : G $-&gt; H) =&gt; IsEquiv f) G H f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_adjointify f g p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12e"><span class="kn">Instance</span> <span class="nf">is1cat_strong</span> `{Funext} : Is1Cat_Strong Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat_Strong Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat_Strong Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk130">rapply Build_Is1Cat_Strong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o g $o f = h $o (g $o f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk131"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o (g $o f) = h $o g $o f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk132"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b), Id b $o f = f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk133" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk133"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b), f $o Id a = f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">intro</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [group_type] map is a 1-functor. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk134"><span class="kn">Instance</span> <span class="nf">is0functor_type_group</span> : Is0Functor group_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk136"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @grp_homo_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk137"><span class="kn">Instance</span> <span class="nf">is1functor_type_group</span> : Is1Functor group_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Build_Is1Functor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [ptype_group] map is a 1-functor. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk139"><span class="kn">Instance</span> <span class="nf">is0functor_ptype_group</span> : Is0Functor ptype_group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13b"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply @pmap_GroupHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13c"><span class="kn">Instance</span> <span class="nf">is1functor_ptype_group</span> : Is1Functor ptype_group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="bp">by</span> <span class="nb">apply</span> phomotopy_homotopy_hset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a group element [a0 : A] over [b : B], multiplication by [a] establishes an equivalence between the kernel and the fiber over [b]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13e"><span class="kn">Lemma</span> <span class="nf">equiv_grp_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">b</span> : B)
  : <span class="kr">forall</span> (<span class="nv">a0</span> : hfiber f b), hfiber f b &lt;~&gt; hfiber f mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f b &lt;~&gt; hfiber f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f b &lt;~&gt; hfiber f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk140"><span class="nb">intros</span> [a0 p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber f <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk141"><span class="nb">refine</span> (equiv_transport (hfiber f) (right_inverse b) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber f (b * b^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk142">snapply Build_Equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f (b * b^)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><label class="goal-separator" for="group-v-chk143"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk144">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f (b * b^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk145">srapply (functor_hfiber (h := (.* a0^)) (k := (.* b^))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; y * b^) o f ==
f o (<span class="kr">fun</span> <span class="nv">y</span> : A =&gt; y * a0^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk146"><span class="nb">intro</span> a; <span class="nb">cbn</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a * a0^) = f a * b^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk147">rhs_V <span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f a * x^) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a * a0^) = f a * (f a0)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_op f _ _ @ ap (f a *.) (grp_homo_inv f a0)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk148">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (functor_hfiber
     ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ((grp_homo_op f a (inv a0) @
         ap (sg_op (f a)) (grp_homo_inv f a0)) @
        ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f a * inv x) p)^%path
       :
       f a * b^ = f (a * a0^))
      :
      (<span class="kr">fun</span> <span class="nv">y</span> : B =&gt; y * b^) o f ==
      f o (<span class="kr">fun</span> <span class="nv">y</span> : A =&gt; y * a0^)) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply isequiv_functor_hfiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The trivial group *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk149"><span class="kn">Definition</span> <span class="nf">grp_trivial</span> : Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply (Build_Group&#39; Unit (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt) tt (<span class="kr">fun</span> <span class="nv">_</span> =&gt; tt));
    <span class="kp">only</span> <span class="mi">1</span>: <span class="bp">exact</span> _; <span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Map out of trivial group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14b"><span class="kn">Definition</span> <span class="nf">grp_trivial_rec</span> (<span class="nv">G</span> : Group) : GroupHomomorphism grp_trivial G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14d">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14e"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14f"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; group_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (<span class="kr">fun</span> <span class="nv">_</span> : grp_trivial =&gt; group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">symmetry</span>; <span class="nb">apply</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Map into trivial group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk150"><span class="kn">Definition</span> <span class="nf">grp_trivial_corec</span> (<span class="nv">G</span> : Group) : GroupHomomorphism G grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk151"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk152">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; grp_trivial</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk153"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk154"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">_</span> : G =&gt; tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">symmetry</span>; <span class="bp">exact</span> (grp_unit_l _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group is a pointed category. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk155"><span class="kn">Instance</span> <span class="nf">ispointedcat_group</span> : IsPointedCat Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk156"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk157">snapply Build_IsPointedCat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial <span class="nl">?zero_object</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal <span class="nl">?zero_object</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk158">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_trivial.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk159">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15a"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : grp_trivial $-&gt; G &amp;
<span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15b"><span class="kr">exists</span> (<span class="nv">grp_trivial_rec</span> <span class="nv">G</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, grp_trivial_rec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15c"><span class="nb">intros</span> g []; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>grp_trivial $-&gt; G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_unit g)^%path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15e"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G $-&gt; grp_trivial &amp;
<span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15f"><span class="kr">exists</span> (<span class="nv">grp_trivial_corec</span> <span class="nv">G</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial,
grp_trivial_corec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk160"><span class="nb">intros</span> g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tt = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_const</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} : GroupHomomorphism G H
  := zero_morphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Opposite Group *)</span>

<span class="sd">(** The opposite group of a group is the group with the same elements but with the group operation reversed. Our technical choice for including a redundant associativity axiom in the definition of a group from before comes into play here. All we have to do to define the opposite group is to shuffle some data around. Since we are only shuffling, this operation becomes definitionally involutive. We make this choice because it is a great help in later proofs.  *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk161"><span class="kn">Definition</span> <span class="nf">grp_op</span> : Group -&gt; Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk162"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk163"><span class="nb">intros</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk164">snapply Build_Group_internal; <span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk165" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk165"><hr></label><div class="goal-conclusion">SgOp <span class="nl">?group_type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk166" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk166"><hr></label><div class="goal-conclusion">MonUnit <span class="nl">?group_type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk167" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk167"><hr></label><div class="goal-conclusion">Inverse <span class="nl">?group_type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk168"><hr></label><div class="goal-conclusion">IsHSet <span class="nl">?group_type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk169" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk169"><hr></label><div class="goal-conclusion">Associative sg_op</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk16a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk16a"><hr></label><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk16b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk16b"><hr></label><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk16c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk16c"><hr></label><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk16d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk16d"><hr></label><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk16e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk16e"><hr></label><div class="goal-conclusion">Associative (flip <span class="nl">?group_sgop</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> G.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk170">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (flip (.*.)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk171">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonUnit G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inverse G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk173">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk174">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> group_assoc_opp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk175">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk176">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk177">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk178">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk179">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative (flip (flip sg_op))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Taking the inverse is an isomorphism from the group to the opposite group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17a"><span class="kn">Definition</span> <span class="nf">grp_op_iso_inv</span> (<span class="nv">G</span> : Group)
  : G $&lt;~&gt; (grp_op G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G ‚âÖ grp_op G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G ‚âÖ grp_op G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17c">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G (grp_op G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk17d"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G (grp_op G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17f">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; grp_op G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk180" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk180"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk181">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; grp_op G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk182">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving inv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk183"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * y)^ = x^ * y^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply grp_inv_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk184">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := inv;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt; grp_inv_op y x)
      :
      IsSemiGroupPreserving inv
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The direct product of groups *)</span>

<span class="sd">(** The cartesian product of the underlying sets of two groups has a natural group structure. We call this the direct product of groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk185"><span class="kn">Definition</span> <span class="nf">grp_prod</span> : Group -&gt; Group -&gt; Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk186"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk187"><span class="nb">intros</span> G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk188">snapply (Build_Group (G * H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk189" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk189"><hr></label><div class="goal-conclusion">MonUnit (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk18a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk18a"><hr></label><div class="goal-conclusion">Inverse (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk18b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk18b"><hr></label><div class="goal-conclusion">IsGroup (G * H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18c"><span class="mi">4</span>: <span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk18d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk18d"><hr></label><div class="goal-conclusion">MonUnit (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk18e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk18e"><hr></label><div class="goal-conclusion">Inverse (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk18f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk18f"><hr></label><div class="goal-conclusion">IsHSet (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk190" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk190"><hr></label><div class="goal-conclusion">Associative sg_op</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk191" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk191"><hr></label><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk192"><hr></label><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk193" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk193"><hr></label><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk194" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk194"><hr></label><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk195">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk196"><span class="nb">intros</span> [g1 h1] [g2 h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G * H)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (g1 * g2, h1 * h2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk197">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonUnit (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="mi">1</span>, <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk198">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inverse (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_prod inv inv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk199">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y z; <span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> simple_associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> right_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> left_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> right_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Maps into the direct product can be built by mapping separately into each factor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19f"><span class="kn">Proposition</span> <span class="nf">grp_prod_corec</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group} (<span class="nv">f</span> : K $-&gt; G) (<span class="nv">g</span> : K $-&gt; H)
  : K $-&gt; (grp_prod G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a1">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K -&gt; grp_prod G H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><label class="goal-separator" for="group-v-chk1a2"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K -&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> : K =&gt; (f x, g x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">x</span> : K =&gt; (f x, g x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a5"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (x * y), g (x * y)) = (f x, g x) * (f y, g y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_prod_corec] satisfies a definitional naturality property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_corec_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">A</span> <span class="nv">B</span> : Group}
  (<span class="nv">f</span> : X $-&gt; Y) (<span class="nv">g0</span> : Y $-&gt; A) (<span class="nv">g1</span> : Y $-&gt; B)
  : grp_prod_corec g0 g1 $o f $== grp_prod_corec (g0 $o f) (g1 $o f)
  := <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left factor injects into the direct product. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_inl</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : H $-&gt; grp_prod H K
  := grp_prod_corec grp_homo_id grp_homo_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left injection is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a6"><span class="kn">Instance</span> <span class="nf">isembedding_grp_prod_inl</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : IsEmbedding (@grp_prod_inl H K).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a8"><span class="nb">apply</span> isembedding_isinj_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjective grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a9"><span class="nb">intros</span> h0 h1 p; <span class="nb">cbn</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h0, h1</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(h0, group_unit) = (h1, group_unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h0 = h1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fst ((equiv_path_prod _ _)^-<span class="mi">1</span> p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right factor injects into the direct product. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_inr</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : K $-&gt; grp_prod H K
  := grp_prod_corec grp_homo_const grp_homo_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right injection is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1aa"><span class="kn">Instance</span> <span class="nf">isembedding_grp_prod_inr</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : IsEmbedding (@grp_prod_inr H K).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ac"><span class="nb">apply</span> isembedding_isinj_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjective grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ad"><span class="nb">intros</span> k0 k1 q; <span class="nb">cbn</span> <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>k0, k1</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(group_unit, k0) = (group_unit, k1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k0 = k1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd ((equiv_path_prod _ _)^-<span class="mi">1</span> q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given two pairs of isomorphic groups, their pairwise direct products are isomorphic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ae"><span class="kn">Definition</span> <span class="nf">grp_iso_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : Group}
  : A ‚âÖ B -&gt; C ‚âÖ D -&gt; (grp_prod A C) ‚âÖ (grp_prod B D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B -&gt; C ‚âÖ D -&gt; grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1af"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B -&gt; C ‚âÖ D -&gt; grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b0"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b1">srapply Build_GroupIsomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A C &lt;~&gt; grp_prod B D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1b2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><label class="goal-separator" for="group-v-chk1b2"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b3"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_functor_prod (f:=f) (g:=g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving equiv_functor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b5"><span class="nb">unfold</span> functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b6"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (fst (x * y)), g (snd (x * y))) =
(f (fst x), g (snd x)) * (f (fst y), g (snd y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b7"><span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (f (fst (x * y)), g (snd (x * y))) =
fst ((f (fst x), g (snd x)) * (f (fst y), g (snd y)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><label class="goal-separator" for="group-v-chk1b8"><hr></label><div class="goal-conclusion">snd (f (fst (x * y)), g (snd (x * y))) =
snd ((f (fst x), g (snd x)) * (f (fst y), g (snd y)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The first projection of the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b9"><span class="kn">Definition</span> <span class="nf">grp_prod_pr1</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupHomomorphism (grp_prod G H) G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bb">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1bc"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bd"><span class="mi">1</span>: <span class="bp">exact</span> fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving fst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ?; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The first projection is a surjection. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">issurj_grp_prod_pr1</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsSurjection (@grp_prod_pr1 G H)
  := issurj_retr grp_prod_inl (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The second projection of the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1be"><span class="kn">Definition</span> <span class="nf">grp_prod_pr2</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupHomomorphism (grp_prod G H) H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c0">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H -&gt; H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1c1"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c2"><span class="mi">1</span>: <span class="bp">exact</span> snd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ?; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pairs in direct products can be decomposed *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c3"><span class="kn">Definition</span> <span class="nf">grp_prod_decompose</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">g</span> : G) (<span class="nv">h</span> : H)
  : (g, h) = ((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g, h) = ((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g, h) = ((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c5">snapply path_prod; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)) = fst (g, h)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><label class="goal-separator" for="group-v-chk1c6"><hr></label><div class="goal-conclusion">snd (((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)) = snd (g, h)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)) = fst (g, h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snapply grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (((g, <span class="mi">1</span>) : grp_prod G H) * (<span class="mi">1</span>, h)) = snd (g, h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snapply grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The second projection is a surjection. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">issurj_grp_prod_pr2</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsSurjection (@grp_prod_pr2 G H)
  := issurj_retr grp_prod_inr (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [Group] is a category with binary products given by the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c9"><span class="kn">Instance</span> <span class="nf">hasbinaryproducts_group</span> : HasBinaryProducts Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cb"><span class="nb">intros</span> G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BinaryProduct G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cc">snapply Build_BinaryProduct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1cd"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; G</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk1ce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1ce"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; H</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk1cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1cf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Group,
(z $-&gt; G) -&gt; (z $-&gt; H) -&gt; z $-&gt; <span class="nl">?cat_binprod&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk1d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1d0"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
<span class="nl">?cat_pr1</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk1d1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1d1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
<span class="nl">?cat_pr2</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== g</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk1d2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1d2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; <span class="nl">?cat_binprod&#39;</span>),
<span class="nl">?cat_pr1</span> $o f $== <span class="nl">?cat_pr1</span> $o g -&gt;
<span class="nl">?cat_pr2</span> $o f $== <span class="nl">?cat_pr2</span> $o g -&gt; f $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_prod G H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H $-&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H $-&gt; H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Group,
(z $-&gt; G) -&gt; (z $-&gt; H) -&gt; z $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d7"><span class="nb">intros</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(K $-&gt; G) -&gt; (K $-&gt; H) -&gt; K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_corec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
grp_prod_pr1 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) z f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d9"><span class="nb">intros</span> K f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod_pr1 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) K f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Id _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
grp_prod_pr2 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) z f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1db"><span class="nb">intros</span> K f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod_pr2 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) K f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Id _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1dc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; grp_prod G H),
grp_prod_pr1 $o f $== grp_prod_pr1 $o g -&gt;
grp_prod_pr2 $o f $== grp_prod_pr2 $o g -&gt; f $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1dd"><span class="nb">intros</span> K f g p q a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>K $-&gt; grp_prod G H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_prod_pr1 $o f $== grp_prod_pr1 $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_prod_pr2 $o f $== grp_prod_pr2 $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; (p a) (q a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Properties of maps to and from the trivial group *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1de"><span class="kn">Instance</span> <span class="nf">isinitial_grp_trivial</span> : IsInitial grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e0"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : grp_trivial $-&gt; G &amp;
<span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e1"><span class="kr">exists</span> (<span class="nv">grp_trivial_rec</span> <span class="nv">_</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, grp_trivial_rec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e2"><span class="nb">intros</span> g [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>grp_trivial $-&gt; G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G tt = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_unit g)^%path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e3"><span class="kn">Instance</span> <span class="nf">contr_grp_homo_trivial_source</span> `{Funext} G
  : Contr (GroupHomomorphism grp_trivial G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism grp_trivial G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism grp_trivial G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e5">snapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1e6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism grp_trivial G,
<span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e7"><span class="mi">1</span>: <span class="bp">exact</span> (grp_trivial_rec _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism grp_trivial G,
grp_trivial_rec G = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e8"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e9">rapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ea"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G tt = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1eb"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g tt = grp_trivial_rec G tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ec"><span class="kn">Instance</span> <span class="nf">isterminal_grp_trivial</span> : IsTerminal grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ed"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ee"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G $-&gt; grp_trivial &amp;
<span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ef"><span class="kr">exists</span> (<span class="nv">grp_trivial_corec</span> <span class="nv">_</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial,
grp_trivial_corec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f0"><span class="nb">intros</span> g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_corec G x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f1"><span class="kn">Instance</span> <span class="nf">contr_grp_homo_trivial_target</span> `{Funext} G
  : Contr (GroupHomomorphism G grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism G grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism G grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f3">snapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1f4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1f4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism G grp_trivial,
<span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f5"><span class="mi">1</span>: <span class="bp">exact</span> (pr1 (isterminal_grp_trivial _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism G grp_trivial,
(isterminal_grp_trivial G).<span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f6"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f7">rapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f8"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f9"><span class="kn">Instance</span> <span class="nf">ishprop_grp_iso_trivial</span> `{Funext} (G : Group)
  : IsHProp (G ‚âÖ grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (G ‚âÖ grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1fa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (G ‚âÖ grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1fb"><span class="nb">apply</span> equiv_hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G ‚âÖ grp_trivial, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1fc"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G ‚âÖ grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_groupisomorphism; <span class="nb">intro</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Free groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">FactorsThroughFreeGroup</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group)
  (<span class="nv">i</span> : S -&gt; F_S) (<span class="nv">A</span> : Group) (<span class="nv">g</span> : S -&gt; A) : <span class="kt">Type</span>
  := {f : F_S $-&gt; A &amp; f o i == g}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Universal property of a free group on a set (type). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsFreeGroupOn</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group) (<span class="nv">i</span> : S -&gt; F_S)
  := contr_isfreegroupon :: <span class="kr">forall</span> (<span class="nv">A</span> : Group) (<span class="nv">g</span> : S -&gt; A),
      Contr (FactorsThroughFreeGroup S F_S i A g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A group is free if there exists a generating type on which it is a free group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsFreeGroup</span> (<span class="nv">F_S</span> : Group)
  := isfreegroup : {S : _ &amp; {i : _ &amp; IsFreeGroupOn S F_S i}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isfreegroup_isfreegroupon</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group) (<span class="nv">i</span> : S -&gt; F_S)
  {<span class="nv">H</span> : IsFreeGroupOn S F_S i}
  : IsFreeGroup F_S
  := (S; i; H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Further properties of group homomorphisms. *)</span>

<span class="sd">(** Commutativity can be transferred across isomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1fd"><span class="kn">Definition</span> <span class="nf">commutative_iso_commutative</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  {<span class="nv">C</span> : Commutative (@group_sgop G)} (<span class="nv">f</span> : GroupIsomorphism G H)
  : Commutative (@group_sgop H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1fe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ff"><span class="nb">unfold</span> Commutative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : H, group_sgop x y = group_sgop y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk200">rapply (equiv_ind f); <span class="nb">intro</span> g1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : H,
group_sgop (f g1) y = group_sgop y (f g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk201">rapply (equiv_ind f); <span class="nb">intro</span> g2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_sgop (f g1) (f g2) = group_sgop (f g2) (f g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk202"><span class="nb">refine</span> ((preserves_sg_op _ _)^ @ _ @ (preserves_sg_op _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (g1 * g2) = f (g2 * g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk203"><span class="nb">refine</span> (ap f _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g1 * g2 = g2 * g1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If two group homomorphisms agree on two elements, then they agree on their product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk204"><span class="kn">Definition</span> <span class="nf">grp_homo_op_agree</span> {<span class="nv">G</span> <span class="nv">G&#39;</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : G $-&gt; H) (<span class="nv">f&#39;</span> : G&#39; $-&gt; H)
  {<span class="nv">x</span> <span class="nv">y</span> : G} {<span class="nv">x&#39;</span> <span class="nv">y&#39;</span> : G&#39;} (<span class="nv">p</span> : f x = f&#39; x&#39;) (<span class="nv">q</span> : f y = f&#39; y&#39;)
  : f (x * y) = f&#39; (x&#39; * y&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y) = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk205"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y) = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk206">lhs napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f y = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk207">rhs napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f y = f&#39; x&#39; * f&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The group movement lemmas can be extended to when there is a homomorphism involved.  For now, we only include these two. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_moveL_1V</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">x</span> <span class="nv">y</span> : A)
  : f (x * y) = group_unit &lt;~&gt; (f x = - f y)
  := grp_moveL_1V oE equiv_concat_l (grp_homo_op f x y)^ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk208"><span class="kn">Definition</span> <span class="nf">grp_homo_moveL_1M</span>  {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">x</span> <span class="nv">y</span> : A)
  : f (x * y^) = group_unit &lt;~&gt; (f x = f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y^) = group_unit &lt;~&gt; f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk209"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y^) = group_unit &lt;~&gt; f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20a"><span class="nb">refine</span> (grp_moveL_1M oE equiv_concat_l _^ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y^) = f x * (f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20b">lhs napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f y^ = f x * (f y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, grp_homo_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Conjugation *)</span>

<span class="sd">(** Conjugation by a group element is a homomorphism. Often we need to use properties about group homomorphisms in order to prove things about conjugation, so it is helpful to define it directly as a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20c"><span class="kn">Definition</span> <span class="nf">grp_conj</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G) : G $-&gt; G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G $-&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G $-&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20e">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk20f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk20f"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk210">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">y</span> =&gt; x * y * x^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk211">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; x * y * x^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk212"><span class="nb">intros</span> y z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (y * z) * x^ = x * y * x^ * (x * z * x^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk213">rhs napply grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (y * z) * x^ = x * y * x^ * (x * z) * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk214"><span class="nb">apply</span> (ap (.* x^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (y * z) = x * y * x^ * (x * z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk215">rhs napply grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (y * z) = x * y * x^ * x * z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk216">lhs napply grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * z = x * y * x^ * x * z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk217"><span class="nb">apply</span> (ap (.* z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y = x * y * x^ * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> grp_inv_gV_g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugation by the unit element is the identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk218"><span class="kn">Definition</span> <span class="nf">grp_conj_unit</span> {<span class="nv">G</span> : Group} : grp_conj (G:=G) <span class="mi">1</span> $== Id _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj <span class="mi">1</span> $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk219"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj <span class="mi">1</span> $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21a"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj <span class="mi">1</span> x = Id G x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21b"><span class="nb">apply</span> grp_moveR_gV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * x = Id G x * <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> napply grp_1g_g1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugation commutes with group homomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21c"><span class="kn">Definition</span> <span class="nf">grp_homo_conj</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : G $-&gt; H) (<span class="nv">x</span> : G)
  : f $o grp_conj x $== grp_conj (f x) $o f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o grp_conj x $== grp_conj (f x) $o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o grp_conj x $== grp_conj (f x) $o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21e"><span class="nb">intros</span> z; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * z * x^) = f x * f z * (f x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !grp_homo_op, grp_homo_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugation respects composition. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21f"><span class="kn">Definition</span> <span class="nf">grp_conj_op</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> : G)
  : grp_conj (x * y) $== grp_conj x $o grp_conj y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x * y) $== grp_conj x $o grp_conj y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk220"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x * y) $== grp_conj x $o grp_conj y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk221"><span class="nb">intros</span> z; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * y * z * (x * y)^ = x * (y * z * y^) * x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_inv_op, !grp_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugating by an element then its inverse is the identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk222"><span class="kn">Definition</span> <span class="nf">grp_conj_inv_r</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G)
  : grp_conj x $o grp_conj x^ $== Id _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x $o grp_conj x^ $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk223"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x $o grp_conj x^ $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk224"><span class="nb">refine</span> ((grp_conj_op _ _)^$ $@ _ $@ grp_conj_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x * x^) $== grp_conj <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk225"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x * x^) y = grp_conj <span class="mi">1</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk226">napply (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; grp_conj x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugating by an inverse then the element is the identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk227"><span class="kn">Definition</span> <span class="nf">grp_conj_inv_l</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G)
  : grp_conj x^ $o grp_conj x $== Id _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x^ $o grp_conj x $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk228"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj x^ $o grp_conj x $== Id G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk229"><span class="nb">refine</span> ((grp_conj_op _ _)^$ $@ _ $@ grp_conj_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x^ * x) $== grp_conj <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk22a"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_conj (x^ * x) y = grp_conj <span class="mi">1</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk22b">napply (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; grp_conj x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x^ * x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conjugation is a group automorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_iso_conj</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G) : G $&lt;~&gt; G
  := cate_adjointify (grp_conj x) (grp_conj x^)
      (grp_conj_inv_r _) (grp_conj_inv_l _).</span></span></pre>
</div>
</div></body>
</html>
