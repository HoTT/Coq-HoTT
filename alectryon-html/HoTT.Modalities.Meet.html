<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Meet.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Extensions HFiber Truncations NullHomotopy Limits.Pullback.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Descent Lex Separated.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We construct &quot;canonical&quot; binary meets of reflective subuniverses (that is, whose underlying subuniverse is an intersection), without assuming accessibility.  In particular, we will show:</span>

<span class="sd">1. Given two reflective subuniverses L and O, if [L O X] is [O]-modal, then it is a reflection into the canonical meet.  In particular, this is always the case if [L] preserves [O]-modal types; this is Theorem 3.30 of RSS.</span>

<span class="sd">1. If L and O are lex modalities satisfying an additional &quot;composability&quot; condition, then the composite functor [L o O] converges to a reflection into the canonical meet after n+2 applications when applied to an n-type for some finite n.</span>

<span class="sd">The latter gives in particular a synthetic approach to higher sheafification (stack completion).  As described at https://ncatlab.org/nlab/show/plus+construction+on+presheaves, for any site C the topos of presheaves on its Grothendieck topology is cohesive and even totally connected, so that its shape and sharp modalities are both lex.  Their canonical meet is the topos of sheaves for the given topology, and the composite functor [shape o sharp] is the usual &quot;plus construction&quot; on (higher) presheaves.  Thus, we recover synthetically the result that an n-truncated type can be stackified by (n+2) applications of the plus construction.  We also refer to [L o O] as a &quot;plus construction&quot; in the general case of reflective subuniverses.  *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">RSUMeet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">L</span> <span class="nv">O</span> : ReflectiveSubuniverse).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The canonical meet of two subuniverses is their intersection. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1"><span class="kn">Definition</span> <span class="nf">Meet</span> : Subuniverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><label class="goal-separator" for="meet-v-chk4"><hr></label><div class="goal-conclusion">Funext -&gt; <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsHProp (<span class="nl">?In_internal</span> T)</div></blockquote><input class="alectryon-extra-goal-toggle" id="meet-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><label class="goal-separator" for="meet-v-chk5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
<span class="nl">?In_internal</span> T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; <span class="nl">?In_internal</span> U</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> X; <span class="bp">exact</span> (In L X * In O X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext -&gt;
<span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>,
IsHProp ((<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; In L X * In O X) T)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? X; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
(<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; In L X * In O X) T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U,
IsEquiv f -&gt; (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; In L X * In O X) U</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> T U [? ?] f feq; <span class="nb">split</span>; <span class="bp">exact</span> (inO_equiv_inO _ f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">inO_inmeet_l</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{im : In Meet X} : In L X := fst im.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">inO_inmeet_r</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{im : In Meet X} : In O X := snd im.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The basic tool in studying its reflectivity is the &quot;plus construction&quot; that applies the two reflectors in sequence. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Plus</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := L (O X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">inO_plus_l</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : In L (Plus X) := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This is not necessarily a reflector, but it is a well-pointed endofunctor. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_plus</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : X -&gt; Plus X
    := to L (O X) o to O X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_functor</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) : Plus X -&gt; Plus Y
    := O_functor L (O_functor O f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk9"><span class="kn">Definition</span> <span class="nf">to_plus_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
    : plus_functor f o to_plus X == to_plus Y o f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_functor f o to_plus X == to_plus Y o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_functor f o to_plus X == to_plus Y o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_functor f (to_plus X x) = to_plus Y (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkc"><span class="nb">unfold</span> plus_functor, to_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor L (O_functor O f) (to L (O X) (to O X x)) =
to L (O Y) (to O Y (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkd"><span class="nb">refine</span> (to_O_natural L (O_functor O f) (to O X x) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to L (O Y) (O_functor O f (to O X x)) =
to L (O Y) (to O Y (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chke"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O f (to O X x) = to O Y (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkf"><span class="kn">Definition</span> <span class="nf">wellpointed_plus</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
    : to_plus (Plus X) == plus_functor (to_plus X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus (Plus X) == plus_functor (to_plus X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus (Plus X) == plus_functor (to_plus X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk11">rapply (@O_indpaths L).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : O X =&gt; to_plus (Plus X) (to L (O X) x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : O X =&gt;
 plus_functor (to_plus X) (to L (O X) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk12"><span class="nb">intros</span> ox.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ox</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus (Plus X) (to L (O X) ox) =
plus_functor (to_plus X) (to L (O X) ox)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk13"><span class="nb">unfold</span> to_plus, plus_functor; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ox</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to L (O (Plus X)) (to O (Plus X) (to L (O X) ox)) =
O_functor L
  (O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)))
  (to L (O X) ox)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk14"><span class="nb">refine</span> (_ @ (to_O_natural L _ ox)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ox</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to L (O (Plus X)) (to O (Plus X) (to L (O X) ox)) =
to L (O (Plus X))
  (O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)) ox)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk15"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ox</var><span class="hyp-type"><b>: </b><span>O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (Plus X) (to L (O X) ox) =
O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)) ox</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk16"><span class="nb">revert</span> ox; <span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to O (Plus X) (to L (O X) (to O X x)) =
O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x))
  (to O X x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((to_O_natural O _ x)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Moreover, it has the desired factorization property of a reflector (though it may not belong to the meet subuniverse itself). *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk17"><span class="kn">Definition</span> <span class="nf">ooextendable_plus</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} `{In Meet Y}
    : ooExtendableAlong (to_plus X) (<span class="kr">fun</span> <span class="nv">_</span>  =&gt; Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to_plus X) (<span class="kr">fun</span> <span class="nv">_</span> : Plus X =&gt; Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to_plus X) (<span class="kr">fun</span> <span class="nv">_</span> : Plus X =&gt; Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ooextendable_compose _ (to O X) (to L (O X)));
      rapply extendable_to_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_rec</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} `{In Meet Q} (f : P -&gt; Q)
    : Plus P -&gt; Q
    := (fst (ooextendable_plus <span class="mi">1</span>%nat) f).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_rec_beta</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} `{In Meet Q} (f : P -&gt; Q) (x : P)
    : plus_rec f (to_plus P x) = f x
    := (fst (ooextendable_plus <span class="mi">1</span>%nat) f).<span class="mi">2</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_indpaths</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} `{In Meet Q} (g h : Plus P -&gt; Q)
             (p : g o to_plus P == h o to_plus P)
    : g == h
    := (fst (snd (ooextendable_plus <span class="mi">2</span>%nat) g h) p).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plus_indpaths_beta</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>} `{In Meet Q} (g h : Plus P -&gt; Q)
             (p : g o (to_plus P) == h o (to_plus P)) (x : P)
    : plus_indpaths g h p (to_plus P x) = p x
    := (fst (snd (ooextendable_plus <span class="mi">2</span>%nat) g h) p).<span class="mi">2</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Moreover, its fixed points, as a pointed endofunctor, are the types in the meet. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk19"><span class="kn">Definition</span> <span class="nf">isequiv_plus_inmeet</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{In Meet X} : IsEquiv (to_plus X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to_plus X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to_plus X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1b">rapply (isequiv_compose (to O X) (to L (O X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to L (O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1c"><span class="nb">apply</span> isequiv_to_O_inO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Meet X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In L (O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO X (to O X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1d"><span class="kn">Definition</span> <span class="nf">inmeet_isequiv_plus</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{IsEquiv _ _ (to_plus X)} : In Meet X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk1f"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In L X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk20"><hr></label><div class="goal-conclusion">In O X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk21">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In L X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inO_equiv_inO (Plus X) (to_plus X)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk23">srapply inO_to_O_retract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O X -&gt; X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk24"><hr></label><div class="goal-conclusion"><span class="nl">?mu</span> o to O X == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk25">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O X -&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((to_plus X)^-<span class="mi">1</span> o (to L (O X))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk26">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv (to_plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_plus X)^-<span class="mi">1</span> o to L (O X) o to O X == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> (eissect (to_plus X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It follows that if [Plus X] ever *does* lie in the meet, then it is a reflection. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk27">#[export] <span class="kn">Instance</span> <span class="nf">prereflects_plus_inO</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{In O (Plus X)}
    : PreReflects Meet X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk29"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk2a"><hr></label><div class="goal-conclusion">In Meet <span class="nl">?O_reflector</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="meet-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk2b"><hr></label><div class="goal-conclusion">X -&gt; <span class="nl">?O_reflector</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Plus X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Meet (Plus X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; Plus X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_plus.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk2f">#[export] <span class="kn">Instance</span> <span class="nf">reflects_plus_inO</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{In O (Plus X)}
    : Reflects Meet X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In O (Plus X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects Meet X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">intros</span>; <span class="bp">exact</span> ooextendable_plus.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Recalling that a type is connected for a reflective subuniverse if and only if its reflector is nullhomotopic, we define a type to be &quot;plus-connected&quot; if its map to plus is nullhomotopic.  If the meet is reflective, this coincides with connectedness for that reflective subuniverse. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PlusConnected</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := NullHomotopy (to_plus X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk31"><span class="kn">Definition</span> <span class="nf">plusconnected_equiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X &lt;~&gt; Y)
    : PlusConnected X -&gt; PlusConnected Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected X -&gt; PlusConnected Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected X -&gt; PlusConnected Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk33"><span class="nb">intros</span> [px e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>Plus X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, to_plus X x = px</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk34"><span class="kr">exists</span> (<span class="nv">plus_functor</span> <span class="nv">f</span> <span class="nv">px</span>); <span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>Plus X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, to_plus X x = px</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus Y y = plus_functor f px</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk35"><span class="nb">refine</span> (_ @ ap (plus_functor f) (e (f^-<span class="mi">1</span> y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>Plus X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, to_plus X x = px</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus Y y = plus_functor f (to_plus X (f^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk36"><span class="nb">rewrite</span> to_plus_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Y</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>Plus X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, to_plus X x = px</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus Y y = to_plus Y (f (f^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> ap, eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Similarly, we say a map is plus-connected if all of its fibers are. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PlusConnMap</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) := <span class="kr">forall</span> <span class="nv">y</span>, PlusConnected (hfiber f y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">RSUMeet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Let&#39;s now assume we are trying to intersect two lex modalities. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">LexMeet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">L</span> <span class="nv">O</span> : Modality) `{Lex L} `{Lex O}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The plus construction, being a composite of two lex functors, is also lex.  Thus, it preserves path-types. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk37"><span class="kn">Definition</span> <span class="nf">plus_path</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : Plus L O (x = y) &lt;~&gt; (to_plus L O X x = to_plus L O X y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (x = y) &lt;~&gt; to_plus L O X x = to_plus L O X y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (x = y) &lt;~&gt; to_plus L O X x = to_plus L O X y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk39"><span class="nb">refine</span> (equiv_path_O L (to O X x) (to O X y) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (x = y) &lt;~&gt; L (to O X x = to O X y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3a"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (x = y) &lt;~&gt; to O X x = to O X y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_path_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3b"><span class="kn">Definition</span> <span class="nf">plus_path_to_plus</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : plus_path x y o to_plus L O (x = y) == @ap _ _ (to_plus L O X) x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_path x y o to_plus L O (x = y) ==
ap (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_path x y o to_plus L O (x = y) ==
ap (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3d"><span class="nb">intros</span> p; <span class="nb">unfold</span> plus_path, to_plus, equiv_path_O, equiv_path_OO, path_OO.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   equiv_fun := O_rec (ap (to L (O_reflector O X)));
   equiv_isequiv :=
     isequiv_path_OO L L (to O X x) (to O X y)
 |}
 oE equiv_O_functor L
      {|
        equiv_fun := O_rec (ap (to O X));
        equiv_isequiv := isequiv_path_OO O O x y
      |}) (to L (O (x = y)) (to O (x = y) p)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (ap
     (to (modality_subuniv L)
        (O_reflector (modality_subuniv O) X)))
  (O_functor L
     (O_rec (ap (to (modality_subuniv O) X)))
     (to (modality_subuniv L) (O (x = y))
        (to (modality_subuniv O) (x = y) p))) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   to (modality_subuniv L) (O X)
     (to (modality_subuniv O) X x)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk3f"><span class="nb">rewrite</span> to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (ap
     (to (modality_subuniv L)
        (O_reflector (modality_subuniv O) X)))
  (to L
     (to (modality_subuniv O) X x =
      to (modality_subuniv O) X y)
     (O_rec (ap (to (modality_subuniv O) X))
        (to (modality_subuniv O) (x = y) p))) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   to (modality_subuniv L) (O X)
     (to (modality_subuniv O) X x)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk40"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (to (modality_subuniv L)
     (O_reflector (modality_subuniv O) X))
  (O_rec (ap (to (modality_subuniv O) X))
     (to (modality_subuniv O) (x = y) p)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   to (modality_subuniv L) (O X)
     (to (modality_subuniv O) X x)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk41"><span class="nb">rewrite</span> (ap_compose (to O X) (to L (O X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (to (modality_subuniv L)
     (O_reflector (modality_subuniv O) X))
  (O_rec (ap (to (modality_subuniv O) X))
     (to (modality_subuniv O) (x = y) p)) =
ap (to L (O X)) (ap (to O X) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk42"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec (ap (to (modality_subuniv O) X))
  (to (modality_subuniv O) (x = y) p) = ap (to O X) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This implies that plus-connected types are closed under path-spaces. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk43"><span class="kn">Definition</span> <span class="nf">plusconnected_path</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> : X)
             (<span class="nv">pc</span> : PlusConnected L O X) : PlusConnected L O (x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnected L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected L O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnected L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected L O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk45"><span class="nb">unfold</span> PlusConnected <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to_plus L O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk46"><span class="nb">apply</span> (cancelL_nullhomotopy_equiv _ (plus_path x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   plus_path x y (to_plus L O (x = y) x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk47"><span class="nb">apply</span> (nullhomotopy_homotopic (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (plus_path_to_plus x y u)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>NullHomotopy (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (ap (to_plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nullhomotopy_ap; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And hence plus-connected maps are closed under diagonals. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk48"><span class="kn">Definition</span> <span class="nf">plusconnmap_diagonal</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
    : PlusConnMap L O f -&gt; PlusConnMap L O (diagonal f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O f -&gt; PlusConnMap L O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O f -&gt; PlusConnMap L O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4a"><span class="nb">intros</span> pc p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pullback f f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected L O (hfiber (diagonal f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4b"><span class="nb">refine</span> (plusconnected_equiv L O (hfiber_diagonal f p)^-<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pullback f f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnected L O ((p.<span class="mi">1</span>; (p.<span class="mi">2</span>).<span class="mi">2</span>) = ((p.<span class="mi">2</span>).<span class="mi">1</span>; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> plusconnected_path, pc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The plus-construction also preserves fibers. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4c"><span class="kn">Definition</span> <span class="nf">plus_hfiber</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">y</span> : Y)
    : Plus L O (hfiber f y) &lt;~&gt; hfiber (plus_functor L O f) (to_plus L O Y y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (hfiber f y) &lt;~&gt;
hfiber (plus_functor L O f) (to_plus L O Y y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (hfiber f y) &lt;~&gt;
hfiber (plus_functor L O f) (to_plus L O Y y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4e"><span class="nb">refine</span> (equiv_O_functor_hfiber L (O_functor O f) (to O Y y) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (hfiber f y) &lt;~&gt;
L (hfiber (O_functor O f) (to O Y y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk4f"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (hfiber f y) &lt;~&gt; hfiber (O_functor O f) (to O Y y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_O_functor_hfiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk50"><span class="kn">Definition</span> <span class="nf">plus_hfiber_to_plus</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">y</span> : Y)
    : plus_hfiber f y o to_plus L O (hfiber f y)
      == functor_hfiber (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (to_plus_natural L O f u)^) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_hfiber f y o to_plus L O (hfiber f y) ==
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_hfiber f y o to_plus L O (hfiber f y) ==
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk52"><span class="nb">intros</span> [x q]; <span class="nb">unfold</span> plus_hfiber, to_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_O_functor_hfiber L (O_functor O f) (to O Y y)
 oE equiv_O_functor L (equiv_O_functor_hfiber O f y))
  (to L (O (hfiber f y)) (to O (hfiber f y) (x; q))) =
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y (x; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk53"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_hfiber L (O_functor O f)
  (to (modality_subuniv O) Y y)
  (O_functor L (O_functor_hfiber O f y)
     (to (modality_subuniv L) (O (hfiber f y))
        (to (modality_subuniv O) (hfiber f y) (x; q)))) =
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y (x; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk54"><span class="nb">rewrite</span> to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor_hfiber L (O_functor O f)
  (to (modality_subuniv O) Y y)
  (to L
     (hfiber (O_functor O f)
        (to (modality_subuniv O) Y y))
     (O_functor_hfiber O f y
        (to (modality_subuniv O) (hfiber f y) (x; q)))) =
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y (x; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk55"><span class="nb">rewrite</span> O_functor_hfiber_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : O X =&gt; (to_O_natural L (O_functor O f) u)^)
  (to (modality_subuniv O) Y y)
  (O_functor_hfiber O f y
     (to (modality_subuniv O) (hfiber f y) (x; q))) =
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt; (to_plus_natural L O f u)^) y (x; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk56"><span class="nb">unfold</span> O_functor_hfiber, functor_hfiber, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to (modality_subuniv L) (O X)
   (O_rec
      (<span class="kr">fun</span> <span class="nv">X0</span> : hfiber f y =&gt;
       (to (modality_subuniv O) X X0.<span class="mi">1</span>;
       to_O_natural O f X0.<span class="mi">1</span> @
       ap (to (modality_subuniv O) Y) X0.<span class="mi">2</span>))
      (to (modality_subuniv O) (hfiber f y) (x; q))).<span class="mi">1</span>;
((to_O_natural L (O_functor O f)
    (O_rec
       (<span class="kr">fun</span> <span class="nv">X0</span> : hfiber f y =&gt;
        (to (modality_subuniv O) X X0.<span class="mi">1</span>;
        to_O_natural O f X0.<span class="mi">1</span> @
        ap (to (modality_subuniv O) Y) X0.<span class="mi">2</span>))
       (to (modality_subuniv O) (hfiber f y) (x; q))).<span class="mi">1</span>)^)^ @
ap (to (modality_subuniv L) (O Y))
  (O_rec
     (<span class="kr">fun</span> <span class="nv">X0</span> : hfiber f y =&gt;
      (to (modality_subuniv O) X X0.<span class="mi">1</span>;
      to_O_natural O f X0.<span class="mi">1</span> @
      ap (to (modality_subuniv O) Y) X0.<span class="mi">2</span>))
     (to (modality_subuniv O) (hfiber f y) (x; q))).<span class="mi">2</span>) =
(to (modality_subuniv L) (O X)
   (to (modality_subuniv O) X x);
((to_plus_natural L O f x)^)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk57"><span class="nb">rewrite</span> O_rec_beta; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to (modality_subuniv L) (O X)
   (to (modality_subuniv O) X x);
((to_O_natural L (O_functor O f)
    (to (modality_subuniv O) X x))^)^ @
ap (to (modality_subuniv L) (O Y))
  (to_O_natural O f x @
   ap (to (modality_subuniv O) Y) q)) =
(to (modality_subuniv L) (O X)
   (to (modality_subuniv O) X x);
((to_plus_natural L O f x)^)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk58"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((to_O_natural L (O_functor O f)
    (to (modality_subuniv O) X x))^)^ @
ap (to (modality_subuniv L) (O Y))
  (to_O_natural O f x @
   ap (to (modality_subuniv O) Y) q) =
((to_plus_natural L O f x)^)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk59"><span class="nb">unfold</span> to_plus_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((to_O_natural L (O_functor O f)
    (to (modality_subuniv O) X x))^)^ @
ap (to (modality_subuniv L) (O Y))
  (to_O_natural O f x @
   ap (to (modality_subuniv O) Y) q) =
((to_O_natural L (O_functor O f) (to O X x) @
  ap (to L (O Y)) (to_O_natural O f x))^)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5a"><span class="nb">rewrite</span> !inv_V, ap_pp, concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_O_natural L (O_functor O f)
   (to (modality_subuniv O) X x) @
 ap (to (modality_subuniv L) (O Y))
   (to_O_natural O f x)) @
ap (to (modality_subuniv L) (O Y))
  (ap (to (modality_subuniv O) Y) q) =
(to_O_natural L (O_functor O f) (to O X x) @
 ap (to L (O Y)) (to_O_natural O f x)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5b"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (to (modality_subuniv L) (O Y))
  (ap (to (modality_subuniv O) Y) q) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5c"><span class="nb">rewrite</span> &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   to (modality_subuniv L) (O Y)
     (to (modality_subuniv O) Y x)) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And pullbacks. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5d"><span class="kn">Definition</span> <span class="nf">equiv_plus_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : Plus L O (Pullback f g) &lt;~&gt; Pullback (plus_functor L O f) (plus_functor L O g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (Pullback f g) &lt;~&gt;
Pullback (plus_functor L O f) (plus_functor L O g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (Pullback f g) &lt;~&gt;
Pullback (plus_functor L O f) (plus_functor L O g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk5f"><span class="nb">refine</span> (equiv_O_pullback L (O_functor O f) (O_functor O g) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Plus L O (Pullback f g) &lt;~&gt;
L (Pullback (O_functor O f) (O_functor O g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk60"><span class="nb">apply</span> equiv_O_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (Pullback f g) &lt;~&gt;
Pullback (O_functor O f) (O_functor O g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_O_pullback.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And diagonals. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk61"><span class="kn">Definition</span> <span class="nf">diagonal_plus_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
    : diagonal (plus_functor L O f) == equiv_plus_pullback f f o plus_functor L O (diagonal f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (plus_functor L O f) ==
equiv_plus_pullback f f
o plus_functor L O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (plus_functor L O f) ==
equiv_plus_pullback f f
o plus_functor L O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk63"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Plus L O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">diagonal (plus_functor L O f) x =
equiv_plus_pullback f f
  (plus_functor L O (diagonal f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk64"><span class="nb">refine</span> (diagonal_O_functor L (O_functor O f) x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Plus L O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_O_pullback L (O_functor O f) (O_functor O f)
  (O_functor L (diagonal (O_functor O f)) x) =
equiv_plus_pullback f f
  (plus_functor L O (diagonal f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk65"><span class="nb">apply</span> (ap (equiv_O_pullback L (O_functor O f) (O_functor O f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Plus L O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor L (diagonal (O_functor O f)) x =
equiv_O_functor L (equiv_O_pullback O f f)
  (plus_functor L O (diagonal f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk66"><span class="nb">refine</span> (O_functor_homotopy L _ _ (diagonal_O_functor O f) x @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Plus L O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor L
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   equiv_O_pullback O f f (O_functor O (diagonal f) x))
  x =
equiv_O_functor L (equiv_O_pullback O f f)
  (plus_functor L O (diagonal f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk67"><span class="nb">unfold</span> plus_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Plus L O A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor L
  (<span class="kr">fun</span> <span class="nv">x</span> : O A =&gt;
   equiv_O_pullback O f f (O_functor O (diagonal f) x))
  x =
equiv_O_functor L (equiv_O_pullback O f f)
  (O_functor L (O_functor O (diagonal f)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_functor_compose L _ _ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Recall that a modality is characterized by connectedness of the units.  Analogously, we can now prove that the plus-units are all plus-connected.  This is equivalently a sort of coherence axiom for the homotopy [wellpointed_plus], that when precomposed with [to_plus] it becomes [to_plus_natural]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk68"><span class="kn">Definition</span> <span class="nf">plusconnmap_to_plus</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : PlusConnMap L O (to_plus L O X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6a"><span class="nb">intros</span> y; <span class="nb">unfold</span> PlusConnected.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to_plus L O (hfiber (to_plus L O X) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6b"><span class="nb">apply</span> (cancelL_nullhomotopy_equiv _ (plus_hfiber (to_plus L O X) y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to_plus L O X) y =&gt;
   plus_hfiber (to_plus L O X) y
     (to_plus L O (hfiber (to_plus L O X) y) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6c"><span class="nb">apply</span> (nullhomotopy_homotopic (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (plus_hfiber_to_plus (to_plus L O X) y u)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy
  (functor_hfiber
     (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt;
      (to_plus_natural L O (to_plus L O X) u)^) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6d"><span class="nb">unfold</span> NullHomotopy, hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0
: {x : Plus L O X &amp;
  plus_functor L O (to_plus L O X) x =
  to_plus L O (Plus L O X) y} &amp;
<span class="kr">forall</span> <span class="nv">x</span> : {x : X &amp; to_plus L O X x = y},
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt;
   (to_plus_natural L O (to_plus L O X) u)^) y x = y0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk6e"><span class="nb">unshelve</span> <span class="nb">refine</span> ((y ; _) ; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_functor L O (to_plus L O X) y =
to_plus L O (Plus L O X) y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><label class="goal-separator" for="meet-v-chk6f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : X &amp; to_plus L O X x = y},
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt;
   (to_plus_natural L O (to_plus L O X) u)^) y x =
(y; <span class="nl">?Goal</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk70">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plus_functor L O (to_plus L O X) y =
to_plus L O (Plus L O X) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> wellpointed_plus.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk71">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Plus L O X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : X &amp; to_plus L O X x = y},
functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt;
   (to_plus_natural L O (to_plus L O X) u)^) y x =
(y; (wellpointed_plus L O X y)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk72"><span class="nb">intros</span> [x p]; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber
  (<span class="kr">fun</span> <span class="nv">u</span> : X =&gt;
   (to_plus_natural L O (to_plus L O X) u)^)
  (to_plus L O X x) (x; <span class="mi">1</span>) =
(to_plus L O X x;
(wellpointed_plus L O X (to_plus L O X x))^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk73"><span class="nb">unfold</span> functor_hfiber, functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(to_plus L O X x;
((to_plus_natural L O (to_plus L O X) x)^)^ @ <span class="mi">1</span>) =
(to_plus L O X x;
(wellpointed_plus L O X (to_plus L O X x))^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk74"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((to_plus_natural L O (to_plus L O X) x)^)^ @ <span class="mi">1</span> =
(wellpointed_plus L O X (to_plus L O X x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk75"><span class="nb">rewrite</span> inv_V, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus_natural L O (to_plus L O X) x =
(wellpointed_plus L O X (to_plus L O X x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk76"><span class="nb">unfold</span> wellpointed_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus_natural L O (to_plus L O X) x =
(O_indpaths (to_plus L O (Plus L O X))
   (plus_functor L O (to_plus L O X))
   (<span class="kr">fun</span> <span class="nv">ox</span> : O X =&gt;
    ap (to L (O (Plus L O X)))
      (O_indpaths
         (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O X =&gt;
          to O (Plus L O X) (to L (O X) x))
         (O_functor O
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)))
         (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
          (to_O_natural O
             (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; to L (O X) (to O X x0)) x)^)
         ox) @
    (to_O_natural L
       (O_functor O
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x))) ox)^)
   (to_plus L O X x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk77"><span class="nb">rewrite</span> !O_indpaths_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus_natural L O (to_plus L O X) x =
(ap (to L (O (Plus L O X)))
   (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)) x)^ @
 (to_O_natural L
    (O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)))
    (to O X x))^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk78"><span class="nb">rewrite</span> inv_pp, ap_V, !inv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_plus_natural L O (to_plus L O X) x =
to_O_natural L
  (O_functor O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x)))
  (to O X x) @
ap (to L (O (Plus L O X)))
  (to_O_natural O (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; to L (O X) (to O X x))
     x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Recall also (from [nsep_iff_trunc_to_O]) that a type is n-separated for a lex modality [O] if and only if its [O]-unit is an n-truncated map.  We can now prove the analogous fact for the plus-construction.  We state this using [MapIn (Tr n)] instead of [IsTrunc n] because we have more useful lemmas for [MapIn]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk79"><span class="kn">Definition</span> <span class="nf">nsep_iff_trunc_plus</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">X</span> : <span class="kt">Type</span>)
    : In (nSep n (Meet L O)) X &lt;-&gt; MapIn (Tr n) (to_plus L O X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk7b"><span class="nb">revert</span> X; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> X; <span class="nb">split</span>; <span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">2</span>)) (to_plus L O X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">2</span>)) (to_plus L O X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk7c"><hr></label><div class="goal-conclusion">In (nSep (-<span class="mi">2</span>) (Meet L O)) X</div></blockquote><input class="alectryon-extra-goal-toggle" id="meet-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chk7d"><hr></label><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</div></blockquote><input class="alectryon-extra-goal-toggle" id="meet-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br></div><label class="goal-separator" for="meet-v-chk7e"><hr></label><div class="goal-conclusion">In (nSep n.+<span class="mi">1</span> (Meet L O)) X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">2</span>)) (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk80"><span class="nb">apply</span> contr_map_isequiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isequiv_plus_inmeet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">2</span>)) (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep (-<span class="mi">2</span>) (Meet L O)) X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk82"><span class="nb">apply</span> inmeet_isequiv_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">2</span>)) (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isequiv_contr_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk84"><span class="nb">apply</span> istruncmap_from_ap; <span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (ap (to_plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk85"><span class="nb">apply</span> istruncmap_mapinO_tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (ap (to_plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk86"><span class="nb">pose</span> (i := fst (IHn _) (H x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>fst (IHn (x = y)) (H x y)</span></span><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (to_plus L O (x = y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (ap (to_plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (mapinO_homotopic _ _ (plus_path_to_plus x y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk87">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n.+<span class="mi">1</span> (Meet L O)) X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk88"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n (Meet L O)) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk89"><span class="nb">apply</span> (snd (IHn (x = y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (to_plus L O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8a"><span class="nb">pose</span> (i := istruncmap_ap n (to_plus L O X) x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>istruncmap_ap n (to_plus L O X) x y</span></span><span class="hyp-type"><b>: </b><span>IsTruncMap n (ap (to_plus L O X))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (to_plus L O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8b"><span class="nb">apply</span> mapinO_tr_istruncmap <span class="kr">in</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to_plus L O X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (to_plus L O (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8c"><span class="nb">apply</span> (mapinO_homotopic _ ((plus_path x y)^-<span class="mi">1</span> o (@ap _ _ (to_plus L O X) x y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to_plus L O X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (plus_path x y)^-<span class="mi">1</span> (ap (to_plus L O X) x0)) ==
to_plus L O (x = y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to_plus L O X))</span></span></span><br></div><label class="goal-separator" for="meet-v-chk8d"><hr></label><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (plus_path x y)^-<span class="mi">1</span> (ap (to_plus L O X) x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to_plus L O X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (plus_path x y)^-<span class="mi">1</span> (ap (to_plus L O X) x0)) ==
to_plus L O (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> plus_path_to_plus.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk8f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X &lt;-&gt;
MapIn (Tr n) (to_plus L O X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) (ap (to_plus L O X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (plus_path x y)^-<span class="mi">1</span> (ap (to_plus L O X) x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply mapinO_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We now make one more assumption, that the plus-construction inverts plus-connected embeddings.  In the case of the plus-construction for stacks, this corresponds roughly to the &quot;local character&quot; condition on a Grothendieck topology. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">composing</span> : <span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y)
                              (<span class="nv">fe</span> : IsEmbedding f) (<span class="nv">fc</span> : PlusConnMap L O f),
              IsEquiv (plus_functor L O f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This implies, by induction, that the plus-construction decreases the truncation-level of any finitely truncated plus-connected map. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk90"><span class="kn">Definition</span> <span class="nf">istruncmap_plus_functor</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
             `{MapIn (Tr n.+<span class="mi">1</span>) _ _ f} (pc : PlusConnMap L O f)
    : MapIn (Tr n) (plus_functor L O f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (plus_functor L O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk91"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">1</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (plus_functor L O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk92"><span class="nb">generalize dependent</span> f; <span class="nb">revert</span> X Y; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> X Y f ? pc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">2</span>)) (plus_functor L O f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><label class="goal-separator" for="meet-v-chk93"><hr></label><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (plus_functor L O f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk94">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">2</span>)) (plus_functor L O f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> mapinO_tr_istruncmap, contr_map_isequiv, composing; <span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk95">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (plus_functor L O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk96"><span class="nb">pose</span> (O_eq_Tr n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (plus_functor L O f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk97"><span class="nb">apply</span> (mapinO_O_leq (Sep (Tr n)) _), mapinO_from_diagonal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (diagonal (plus_functor L O f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk98">napply (mapinO_homotopic (Tr n) _ (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (diagonal_plus_functor f u)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">u</span> : Plus L O X =&gt;
   equiv_plus_pullback f f
     (plus_functor L O (diagonal f) u))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk99"><span class="nb">apply</span> mapinO_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (plus_functor L O (diagonal f))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><label class="goal-separator" for="meet-v-chk9a"><hr></label><div class="goal-conclusion">MapIn (Tr n) (equiv_plus_pullback f f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk9b"><span class="mi">2</span>:rapply mapinO_isequiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (plus_functor L O (diagonal f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk9c"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (diagonal f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><label class="goal-separator" for="meet-v-chk9d"><hr></label><div class="goal-conclusion">PlusConnMap L O (diagonal f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk9e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chk9f"><span class="nb">apply</span> mapinO_diagonal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Sep (Tr n.+<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka0"><span class="nb">pose</span> (O_eq_Tr n.+<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br><span><var>o0</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n.+<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">2</span> &lt;=&gt; Sep (Tr n.+<span class="mi">1</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Sep (Tr n.+<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (mapinO_O_leq _ (Sep (Tr n.+<span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
MapIn (Tr n.+<span class="mi">1</span>) f -&gt;
PlusConnMap L O f -&gt;
MapIn (Tr n) (plus_functor L O f)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n.+<span class="mi">2</span>) f</span></span></span><br><span><var>pc</var><span class="hyp-type"><b>: </b><span>PlusConnMap L O f</span></span></span><br><span><var>o</var><span><span class="hyp-body"><b>:= </b><span>O_eq_Tr n</span></span><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> &lt;=&gt; Sep (Tr n)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O (diagonal f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> plusconnmap_diagonal; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It follows, by applying this to the plus-unit and using well-pointedness, that the plus-construction on *types* decreases their plus-separatedness. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka2"><span class="kn">Definition</span> <span class="nf">nsep_plus</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">X</span> : <span class="kt">Type</span>) `{In (nSep n.+<span class="mi">1</span> (Meet L O)) X}
    : In (nSep n (Meet L O)) (Plus L O X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n (Meet L O)) (Plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (nSep n (Meet L O)) (Plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka4"><span class="nb">apply</span> nsep_iff_trunc_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (to_plus L O (Plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka5">nrefine (mapinO_homotopic _ _ (<span class="kr">fun</span> <span class="nv">u</span> =&gt; (wellpointed_plus L O X u)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) (plus_functor L O (to_plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka6"><span class="nb">apply</span> mapinO_tr_istruncmap, istruncmap_plus_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chka7"><hr></label><div class="goal-conclusion">PlusConnMap L O (to_plus L O X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n.+<span class="mi">1</span>) (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istruncmap_mapinO_tr, nsep_iff_trunc_plus; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PlusConnMap L O (to_plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> plusconnmap_to_plus.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Therefore, if a type starts out as n-plus-separated, then n+2 applications of the plus-construction suffice to make it (-2)-plus-separated, i.e. in the meet subuniverse.  Hence it has a reflection. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkaa">#[export] <span class="kn">Instance</span> <span class="nf">prereflects_plus_nsep</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">X</span> : <span class="kt">Type</span>) `{In (nSep n (Meet L O)) X}
    : PreReflects (Meet L O) X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkac"><span class="nb">generalize dependent</span> X; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> X ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X -&gt;
PreReflects (Meet L O) X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chkad"><hr></label><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkae">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply prereflects_in.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkaf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In (nSep n (Meet L O)) X -&gt;
PreReflects (Meet L O) X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb0"><span class="nb">specialize</span> (IHn (Plus L O X) (nsep_plus n X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreReflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb1"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chkb2"><hr></label><div class="goal-conclusion">In (Meet L O) <span class="nl">?O_reflector</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="meet-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chkb3"><hr></label><div class="goal-conclusion">X -&gt; <span class="nl">?O_reflector</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (O_reflector (Meet L O) (Plus L O X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Meet L O) (O_reflector (Meet L O) (Plus L O X))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>PreReflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; O_reflector (Meet L O) (Plus L O X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (to (Meet L O) (Plus L O X) o to_plus L O X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb7">#[export] <span class="kn">Instance</span> <span class="nf">reflects_plus_nsep</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">X</span> : <span class="kt">Type</span>) `{In (nSep n (Meet L O)) X}
    : Reflects (Meet L O) X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkb9"><span class="nb">generalize dependent</span> X; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> X ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
(<span class="nv">H</span> : In (nSep n (Meet L O)) X),
Reflects (Meet L O) X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><label class="goal-separator" for="meet-v-chkba"><hr></label><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkbb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep (-<span class="mi">2</span>) (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply reflects_in.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkbc">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
(<span class="nv">H</span> : In (nSep n (Meet L O)) X),
Reflects (Meet L O) X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkbd"><span class="nb">specialize</span> (IHn (Plus L O X) (nsep_plus n X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflects (Meet L O) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkbe"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In (Meet L O) Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to (Meet L O) X)
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector (Meet L O) X =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkbf"><span class="nb">apply</span> (ooextendable_compose _ (to_plus L O X) (to (Meet L O) (Plus L O X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In (Meet L O) Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to (Meet L O) (Plus L O X))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector (Meet L O) X =&gt; Q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="meet-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In (Meet L O) Q</span></span></span><br></div><label class="goal-separator" for="meet-v-chkc0"><hr></label><div class="goal-conclusion">ooExtendableAlong (to_plus L O X)
  (<span class="kr">fun</span> <span class="nv">_</span> : Plus L O X =&gt; Q)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkc1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In (Meet L O) Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to (Meet L O) (Plus L O X))
  (<span class="kr">fun</span> <span class="nv">_</span> : O_reflector (Meet L O) X =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (@extendable_to_O (Meet L O) (Plus L O X)); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="meet-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="meet-v-chkc2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L, O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>Lex0</var><span class="hyp-type"><b>: </b><span>Lex L</span></span></span><br><span><var>Lex1</var><span class="hyp-type"><b>: </b><span>Lex O</span></span></span><br><span><var>composing</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; Y),
IsEmbedding f -&gt;
PlusConnMap L O f -&gt;
IsEquiv (plus_functor L O f)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (nSep n.+<span class="mi">1</span> (Meet L O)) X</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Reflects (Meet L O) (Plus L O X)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q_inO</var><span class="hyp-type"><b>: </b><span>In (Meet L O) Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to_plus L O X)
  (<span class="kr">fun</span> <span class="nv">_</span> : Plus L O X =&gt; Q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ooextendable_plus.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LexMeet</span>.</span></span></pre>
</div>
</div></body>
</html>
