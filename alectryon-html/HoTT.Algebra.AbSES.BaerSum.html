<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>BaerSum.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbGroups.AbelianGroup AbGroups.Biproduct AbGroups.AbHom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbSES.Core AbSES.Pullback AbSES.Pushout AbSES.DirectSum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.HSpace.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The Baer sum of two short exact sequences, lemmas and consequences. *)</span>

<span class="sd">(** The Baer sum of two short exact sequences is obtained from the pointwise direct sum by pushing forward along the codiagonal and then pulling back along the diagonal. (Swapping the order of pushing forward and pulling back produces an isomorphic short exact sequence.) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_baer_sum</span> `{Univalence} {B A : AbGroup@{u}} (E F : AbSES B A)
  : AbSES B A
  := abses_pullback ab_diagonal (abses_pushout ab_codiagonal (abses_direct_sum E F)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** [AbSES&#39;] is a bifunctor *)</span>

<span class="sd">(** Given a morphism [f] of short exact sequences, the pushout of the domain along [f_1] equals the pullback of the codomain along [f_3]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk1"><span class="kn">Lemma</span> <span class="nf">abses_pushout_is_pullback&#39;</span> `{Univalence} {A A&#39; B B&#39; : AbGroup@{u}}
      {E : AbSES B A} {E&#39; : AbSES B&#39; A&#39;} (f : AbSESMorphism E E&#39;)
  : abses_pushout (component1 f) E $== abses_pullback (component3 f) E&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>E'</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E E&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $==
abses_pullback (component3 f) E&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>E'</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E E&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $==
abses_pullback (component3 f) E&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The morphism [f : E -&gt; E&#39;] factors as [E -&gt; f_1 E -&gt; E&#39;], where the first map is the map defining the pushout [f_1 E] and the second map is denoted [abses_pushout_morphism_rec f] below.  This second map is the identity on the first component, so it presents its domain as the pullback of [E&#39;] along [f_3]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pullback_component1_id&#39; (abses_pushout_morphism_rec f) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a morphism [f] of short exact sequences, the pushout of the domain along [f_1] equals the pullback of the codomain along [f_3]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_is_pullback</span> `{Univalence} {A A&#39; B B&#39; : AbGroup}
      {E : AbSES B A} {E&#39; : AbSES B&#39; A&#39;} (f : AbSESMorphism E E&#39;)
  : abses_pushout (component1 f) E = abses_pullback (component3 f) E&#39;
  := equiv_path_abses_iso (abses_pushout_is_pullback&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3"><span class="kn">Definition</span> <span class="nf">abses_pushout_pullback_reorder&#39;</span> `{Univalence} {A A&#39; B B&#39; : AbGroup}
  (E : AbSES B A) (f : A $-&gt; A&#39;) (g : B&#39; $-&gt; B)
  : abses_pushout f (abses_pullback g E) $== abses_pullback g (abses_pushout f E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) $==
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) $==
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* There are morphisms [Eg -&gt; E] and [E -&gt; fE] by definition of the pullback and pushout. We define [F : Eg -&gt; fE] to be the composite. Its first and third components are [f o id] and [id o g]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5"><span class="nb">pose</span> (F := absesmorphism_compose (abses_pushout_morphism E f) (abses_pullback_morphism E g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>F</var><span><span class="hyp-body"><b>:= </b><span>absesmorphism_compose (abses_pushout_morphism E f)
  (abses_pullback_morphism E g)</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pullback g E)
  (abses_pushout f E)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) $==
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We change [F] to a morphism that is the same except that the first and third components are [f] and [g]. Then [abses_pushout_is_pullback] shows that the pushout of [Eg] along [f] is equal to the pullback of [fE] along [g]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (abses_pushout_is_pullback&#39; (Build_AbSESMorphism f (component2 F) g _ _)); <span class="nb">apply</span> F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the statement that [AbSES&#39;] is a bifunctor, but we state it separately because Coq is slow to unify [IsBifunctor AbSES&#39;] against goals written in this form. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk6"><span class="kn">Definition</span> <span class="nf">abses_pushout_pullback_reorder</span> `{Univalence} {A A&#39; B B&#39; : AbGroup}
  (E : AbSES B A) (f : A $-&gt; A&#39;) (g : B&#39; $-&gt; B)
  : abses_pushout f (abses_pullback g E) = abses_pullback g (abses_pushout f E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk8"><span class="nb">apply</span> equiv_path_abses_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso
  (abses_pushout f (abses_pullback g E))
  (abses_pullback g (abses_pushout f E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pullback_reorder&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0bifunctor_abses&#39;</span> `{Univalence}
  : Is0Bifunctor (AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>)
  := Build_Is0Bifunctor&#39;&#39; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk9"><span class="kn">Instance</span> <span class="nf">is1bifunctor_abses&#39;</span> `{Univalence}
  : Is1Bifunctor (AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor (AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor (AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chkb">snapply Build_Is1Bifunctor&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup^op, Is1Functor (AbSES&#39; a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="baersum-v-chkc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : AbGroup, Is1Functor (flip AbSES&#39; b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="baersum-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="baersum-v-chkd"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a1</span> : AbGroup^op) (<span class="nv">f</span> : a0 $-&gt; a1)
(<span class="nv">b0</span> <span class="nv">b1</span> : AbGroup) (<span class="nv">g</span> : b0 $-&gt; b1),
fmap01 AbSES&#39; a1 g $o fmap10 AbSES&#39; f b0 $==
fmap10 AbSES&#39; f b1 $o fmap01 AbSES&#39; a0 g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chke"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a1</span> : AbGroup^op) (<span class="nv">f</span> : a0 $-&gt; a1)
(<span class="nv">b0</span> <span class="nv">b1</span> : AbGroup) (<span class="nv">g</span> : b0 $-&gt; b1),
fmap01 AbSES&#39; a1 g $o fmap10 AbSES&#39; f b0 $==
fmap10 AbSES&#39; f b1 $o fmap01 AbSES&#39; a0 g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chkf"><span class="nb">intros</span> ? ? g ? ? f E; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES&#39; a0 b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pushout_pullback_reorder E f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a short exact sequence [A -&gt; E -&gt; B] and maps [f : A -&gt; A&#39;], [g : B&#39; -&gt; B], we can change the order of pushing out along [f] and pulling back along [g]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk10"><span class="kn">Lemma</span> <span class="nf">abses_reorder_pullback_pushout</span> `{Univalence} {A A&#39; B B&#39; : AbGroup}
      (E : AbSES B A) (f : A $-&gt; A&#39;) (g : B&#39; $-&gt; B)
  : abses_pushout f (abses_pullback g E) = abses_pullback g (abses_pushout f E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* There are morphisms [Eg -&gt; E] and [E -&gt; fE] by definition of the pullback and pushout. We define [F : Eg -&gt; fE] to be the composite. Its first and third components are [f o id] and [id o g]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk12"><span class="nb">pose</span> (F := absesmorphism_compose (abses_pushout_morphism E f) (abses_pullback_morphism E g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>F</var><span><span class="hyp-body"><b>:= </b><span>absesmorphism_compose (abses_pushout_morphism E f)
  (abses_pullback_morphism E g)</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pullback g E)
  (abses_pushout f E)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_pullback g E) =
abses_pullback g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We change [F] to a morphism that is the same except that the first and third components are [f] and [g]. Then [abses_pushout_is_pullback] shows that the pushout of [Eg] along [f] is equal to the pullback of [fE] along [g]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (abses_pushout_is_pullback (Build_AbSESMorphism f (component2 F) g _ _)); <span class="nb">apply</span> F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Baer sum distributes over pullbacks. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk13"><span class="kn">Lemma</span> <span class="nf">baer_sum_distributive_pullbacks</span> `{Univalence} {A B B&#39; : AbGroup}
  {E : AbSES B A} (f g : ab_hom B&#39; B)
  : abses_pullback (f + g) E = abses_baer_sum (abses_pullback f E) (abses_pullback g E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (f + g) E =
abses_baer_sum (abses_pullback f E)
  (abses_pullback g E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (f + g) E =
abses_baer_sum (abses_pullback f E)
  (abses_pullback g E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk15"><span class="nb">unfold</span> abses_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (f + g) E =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk16"><span class="nb">refine</span> ((abses_pullback_compose (B1:=ab_biprod B B) _ _ E)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_prod_corec f g)
  (abses_pullback ab_codiagonal E) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk17"><span class="nb">refine</span> (ap (abses_pullback _) (abses_pushout_is_pullback (abses_codiagonal E))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_prod_corec f g)
  (abses_pushout (component1 (abses_codiagonal E))
     (abses_direct_sum E E)) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk18"><span class="nb">unfold</span> abses_codiagonal, component1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_prod_corec f g)
  (abses_pushout ab_codiagonal (abses_direct_sum E E)) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk19"><span class="nb">refine</span> (_^ @ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> =
abses_pullback (grp_prod_corec f g)
  (abses_pushout ab_codiagonal (abses_direct_sum E E))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk1a"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="baersum-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk1b"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk1c"><span class="mi">1</span>,<span class="mi">3</span>: <span class="nb">apply</span> abses_reorder_pullback_pushout.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pullback (grp_prod_corec f g)
     (abses_direct_sum E E)) =
abses_pushout ab_codiagonal
  (abses_pullback ab_diagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk1d"><span class="nb">refine</span> (ap (abses_pushout _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_prod_corec f g)
  (abses_direct_sum E E) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk1e"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">h</span> =&gt; abses_pullback h _) (ab_biprod_corec_diagonal _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (functor_ab_biprod f g $o ab_diagonal)
  (abses_direct_sum E E) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk1f"><span class="nb">refine</span> ((abses_pullback_compose _ _ (abses_direct_sum E E))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom B&#39; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pullback (functor_ab_biprod f g)
     (abses_direct_sum E E)) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (abses_pullback _) (abses_directsum_distributive_pullbacks f g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Baer sum is commutative. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk20"><span class="kn">Lemma</span> <span class="nf">baer_sum_commutative</span> `{Univalence} {A B : AbGroup} (E F : AbSES B A)
  : abses_baer_sum E F = abses_baer_sum F E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E F = abses_baer_sum F E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E F = abses_baer_sum F E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk22"><span class="nb">unfold</span> abses_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal (abses_direct_sum E F)) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The next line uses that [direct_sum_swap $o ab_diagonal] is definitionally equal to [ab_diagonal]: *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk23"><span class="nb">refine</span> (_ @ abses_pullback_compose ab_diagonal direct_sum_swap _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal (abses_direct_sum E F)) =
abses_pullback ab_diagonal
  (abses_pullback direct_sum_swap
     (abses_pushout ab_codiagonal
        (abses_direct_sum F E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk24"><span class="nb">refine</span> (ap (abses_pullback ab_diagonal) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal (abses_direct_sum E F) =
abses_pullback direct_sum_swap
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk25"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; abses_pushout f _) ab_codiagonal_swap^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (ab_codiagonal $o direct_sum_swap)
  (abses_direct_sum E F) =
abses_pullback direct_sum_swap
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk26"><span class="nb">refine</span> ((abses_pushout_compose _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pushout direct_sum_swap
     (abses_direct_sum E F)) =
abses_pullback direct_sum_swap
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk27"><span class="nb">refine</span> (ap _ (abses_pushout_is_pullback (abses_swap_morphism E F)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pullback
     (component3 (abses_swap_morphism E F))
     (abses_direct_sum F E)) =
abses_pullback direct_sum_swap
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk28"><span class="nb">unfold</span> abses_swap_morphism, component3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pullback direct_sum_swap
     (abses_direct_sum F E)) =
abses_pullback direct_sum_swap
  (abses_pushout ab_codiagonal (abses_direct_sum F E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pullback_reorder.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right unit law for the Baer sum says that for all [E : AbSES B A], [E + E_0 = E], where [E_0] is the split short exact sequence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk29"><span class="kn">Lemma</span> <span class="nf">baer_sum_unit_r</span> `{Univalence} {A B : AbGroup} (E : AbSES B A)
  : abses_baer_sum E (point (AbSES B A)) = E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (point (AbSES B A)) = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (point (AbSES B A)) = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2b"><span class="nb">refine</span> (ap (abses_baer_sum E) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">point (AbSES B A) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk2c"><hr></label><div class="goal-conclusion">abses_baer_sum E <span class="nl">?Goal</span> = E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">point (AbSES B A) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pullback_const E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (abses_pullback grp_homo_const E) = E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk2f"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">F</span> =&gt; abses_baer_sum F (abses_pullback grp_homo_const E)) (abses_pullback_id E)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_pullback grp_homo_id E)
  (abses_pullback grp_homo_const E) = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk30"><span class="nb">refine</span> ((baer_sum_distributive_pullbacks grp_homo_id grp_homo_const)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_homo_id + grp_homo_const) E = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk31"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; abses_pullback f E) (grp_unit_r (G := ab_hom _ _) _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_id E = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pullback_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left unit law for the Baer sum is analogous. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">baer_sum_unit_l</span> `{Univalence} {A B : AbGroup} (E : AbSES B A)
  : abses_baer_sum (point (AbSES B A)) E = E
  := baer_sum_commutative _ _ @ baer_sum_unit_r _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For any [E : AbSES B A], the pullback of [E] along [-id_B] acts as an additive inverse for [E] with respect to the Baer sum. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk32"><span class="kn">Lemma</span> <span class="nf">baer_sum_inverse_l</span> `{Univalence} {A B : AbGroup} (E : AbSES B A)
  : abses_baer_sum E (abses_pullback (- grp_homo_id) E) = point (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (abses_pullback (- grp_homo_id) E) =
point (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (abses_pullback (- grp_homo_id) E) =
point (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk34"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">F</span> =&gt; abses_baer_sum F (abses_pullback _ E)) (abses_pullback_id E)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_pullback grp_homo_id E)
  (abses_pullback (- grp_homo_id) E) =
point (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk35"><span class="nb">refine</span> ((baer_sum_distributive_pullbacks grp_homo_id (-grp_homo_id))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_homo_id - grp_homo_id) E =
point (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk36"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; abses_pullback f _) (grp_inv_r (G := ab_hom _ _) _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback <span class="mi">0</span> E = point (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> abses_pullback_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right inverse law follows by commutativity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">baer_sum_inverse_r</span> `{Univalence} {A B : AbGroup} (E : AbSES B A)
  : abses_baer_sum (abses_pullback (-grp_homo_id) E) E = point (AbSES B A)
  := baer_sum_commutative _ _ @ baer_sum_inverse_l _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Baer sum distributes over pushouts. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk37"><span class="kn">Lemma</span> <span class="nf">baer_sum_distributive_pushouts</span> `{Univalence}
      {A A&#39; B : AbGroup} {E : AbSES B A&#39;} (f g : ab_hom A&#39; A)
  : abses_pushout (f + g) E = abses_baer_sum (abses_pushout f E) (abses_pushout g E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (f + g) E =
abses_baer_sum (abses_pushout f E) (abses_pushout g E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (f + g) E =
abses_baer_sum (abses_pushout f E) (abses_pushout g E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk39"><span class="nb">unfold</span> abses_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (f + g) E =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pushout f E)
        (abses_pushout g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3a"><span class="nb">refine</span> (abses_pushout_compose (A1 := ab_biprod A A) _ _ E @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pushout (grp_prod_corec f g) E) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pushout f E)
        (abses_pushout g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3b"><span class="nb">refine</span> (_ @ abses_pushout_pullback_reorder _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_codiagonal
  (abses_pushout (grp_prod_corec f g) E) =
abses_pushout ab_codiagonal
  (abses_pullback ab_diagonal
     (abses_direct_sum (abses_pushout f E)
        (abses_pushout g E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3c"><span class="nb">refine</span> (ap (abses_pushout ab_codiagonal) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (grp_prod_corec f g) E =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3d"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; abses_pushout f E) (ab_biprod_corec_diagonal f g) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (functor_ab_biprod f g $o ab_diagonal) E =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3e"><span class="nb">refine</span> (abses_pushout_compose _ _ E @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (functor_ab_biprod f g)
  (abses_pushout ab_diagonal E) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk3f"><span class="nb">refine</span> (ap (abses_pushout _) (abses_pushout_is_pullback (abses_diagonal E)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (functor_ab_biprod f g)
  (abses_pullback (component3 (abses_diagonal E))
     (abses_direct_sum E E)) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk40"><span class="nb">refine</span> (abses_pushout_pullback_reorder _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>ab_hom A&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (component3 (abses_diagonal E))
  (abses_pushout (functor_ab_biprod f g)
     (abses_direct_sum E E)) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout g E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (abses_pullback _) (abses_directsum_distributive_pushouts f g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Our next goal is to prove that the Baer sum is associative.  Rather than showing this directly, we first prove [baer_sum_twist], which says that [abses_baer_sum (abses_baer_sum E F) G = abses_baer_sum (abses_baer_sum G F) E].  The proof of this mimics the proof of commutativity above.  Then we prove associativity by combining this with commutativity. *)</span>

<span class="sd">(** The trinary Baer sum of three short exact sequences. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_trinary_baer_sum</span> `{Univalence}
  {A B : AbGroup@{u}} (E F G : AbSES B A)
  : AbSES B A
  := abses_pullback ab_triagonal
       (abses_pushout ab_cotriagonal
          (abses_direct_sum (abses_direct_sum E F) G)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For [E, F, G : AbSES B A], the Baer sum of [E], [F] and [G] (associated left) is equal to the trinary Baer sum of [E], [F] and [G]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk41"><span class="kn">Lemma</span> <span class="nf">baer_sum_is_trinary</span> `{Univalence} {A B : AbGroup@{u}} (E F G : AbSES B A)
  : abses_baer_sum (abses_baer_sum E F) G = abses_trinary_baer_sum E F G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_trinary_baer_sum E F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_trinary_baer_sum E F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk43"><span class="nb">unfold</span> abses_baer_sum, abses_trinary_baer_sum, ab_triagonal, ab_cotriagonal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum
        (abses_pullback ab_diagonal
           (abses_pushout ab_codiagonal
              (abses_direct_sum E F))) G)) =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout
     (ab_codiagonal $o
      functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk44"><span class="nb">refine</span> (ap (abses_pullback _ o abses_pushout _) _^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
abses_direct_sum
  (abses_pullback ab_diagonal
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F))) G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk45"><hr></label><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal <span class="nl">?Goal</span>) =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout
     (ab_codiagonal $o
      functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
abses_direct_sum
  (abses_pullback ab_diagonal
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F))) G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk47"><span class="nb">refine</span> (_ @ ap (abses_direct_sum _) (abses_pullback_id G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
abses_direct_sum
  (abses_pullback ab_diagonal
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F)))
  (abses_pullback grp_homo_id G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk48"><span class="nb">refine</span> (_ @ abses_directsum_distributive_pullbacks _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id)
  (abses_direct_sum
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F)) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk49"><span class="nb">refine</span> (ap (abses_pullback _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> =
abses_direct_sum
  (abses_pushout ab_codiagonal (abses_direct_sum E F))
  G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4a"><span class="nb">refine</span> (_ @ ap (abses_direct_sum _) (abses_pushout_id G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> =
abses_direct_sum
  (abses_pushout ab_codiagonal (abses_direct_sum E F))
  (abses_pushout grp_homo_id G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_directsum_distributive_pushouts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_pullback
        (functor_ab_biprod ab_diagonal grp_homo_id)
        (abses_pushout
           (functor_ab_biprod ab_codiagonal
              grp_homo_id)
           (abses_direct_sum (abses_direct_sum E F) G)))) =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout
     (ab_codiagonal $o
      functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4c"><span class="nb">refine</span> (ap (abses_pullback _) (abses_pushout_pullback_reorder _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_diagonal
  (abses_pullback
     (functor_ab_biprod ab_diagonal grp_homo_id)
     (abses_pushout ab_codiagonal
        (abses_pushout
           (functor_ab_biprod ab_codiagonal
              grp_homo_id)
           (abses_direct_sum (abses_direct_sum E F) G)))) =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout
     (ab_codiagonal $o
      functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4d"><span class="nb">refine</span> (abses_pullback_compose _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout ab_codiagonal
     (abses_pushout
        (functor_ab_biprod ab_codiagonal grp_homo_id)
        (abses_direct_sum (abses_direct_sum E F) G))) =
abses_pullback
  (functor_ab_biprod ab_diagonal grp_homo_id $o
   ab_diagonal)
  (abses_pushout
     (ab_codiagonal $o
      functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4e"><span class="nb">refine</span> (ap (abses_pullback _) _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout
  (ab_codiagonal $o
   functor_ab_biprod ab_codiagonal grp_homo_id)
  (abses_direct_sum (abses_direct_sum E F) G) =
abses_pushout ab_codiagonal
  (abses_pushout
     (functor_ab_biprod ab_codiagonal grp_homo_id)
     (abses_direct_sum (abses_direct_sum E F) G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For [E, F, G : AbSES B A], we can &quot;twist&quot; the order of the trinary Baer sum as follows. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk4f"><span class="kn">Lemma</span> <span class="nf">twist_trinary_baer_sum</span> `{Univalence}
  {A B : AbGroup@{u}} (E F G : AbSES B A)
  : abses_trinary_baer_sum E F G = abses_trinary_baer_sum G F E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_trinary_baer_sum E F G =
abses_trinary_baer_sum G F E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_trinary_baer_sum E F G =
abses_trinary_baer_sum G F E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk51"><span class="nb">unfold</span> abses_trinary_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_triagonal
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum E F) G)) =
abses_pullback ab_triagonal
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The next line uses the fact that [ab_triagonal] is definitionally equal to [ab_biprod_twist $o ab_triagonal]: *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk52"><span class="nb">refine</span> (_ @ abses_pullback_compose ab_triagonal ab_biprod_twist _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback ab_triagonal
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum E F) G)) =
abses_pullback ab_triagonal
  (abses_pullback ab_biprod_twist
     (abses_pushout ab_cotriagonal
        (abses_direct_sum (abses_direct_sum G F) E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk53"><span class="nb">refine</span> (ap (abses_pullback _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_cotriagonal
  (abses_direct_sum (abses_direct_sum E F) G) =
abses_pullback ab_biprod_twist
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk54"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; abses_pushout f _) ab_cotriagonal_twist^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (ab_cotriagonal $o ab_biprod_twist)
  (abses_direct_sum (abses_direct_sum E F) G) =
abses_pullback ab_biprod_twist
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk55"><span class="nb">refine</span> (abses_pushout_compose _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_cotriagonal
  (abses_pushout ab_biprod_twist
     (abses_direct_sum (abses_direct_sum E F) G)) =
abses_pullback ab_biprod_twist
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk56"><span class="nb">refine</span> (ap _ (abses_pushout_is_pullback (abses_twist_directsum E F G)) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_cotriagonal
  (abses_pullback
     (component3 (abses_twist_directsum E F G))
     (abses_direct_sum (abses_direct_sum G F) E)) =
abses_pullback ab_biprod_twist
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk57"><span class="nb">unfold</span> abses_twist_directsum, component3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout ab_cotriagonal
  (abses_pullback ab_biprod_twist
     (abses_direct_sum (abses_direct_sum G F) E)) =
abses_pullback ab_biprod_twist
  (abses_pushout ab_cotriagonal
     (abses_direct_sum (abses_direct_sum G F) E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pushout_pullback_reorder _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It now follows that we can twist the order of the summands in the Baer sum. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk58"><span class="kn">Lemma</span> <span class="nf">baer_sum_twist</span> `{Univalence} {A B : AbGroup@{u}} (E F G : AbSES B A)
  : abses_baer_sum (abses_baer_sum E F) G = abses_baer_sum (abses_baer_sum G F) E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_baer_sum (abses_baer_sum G F) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_baer_sum (abses_baer_sum G F) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5a"><span class="nb">refine</span> ((baer_sum_is_trinary E F G) @ _ @ (baer_sum_is_trinary G F E)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_trinary_baer_sum E F G =
abses_trinary_baer_sum G F E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> twist_trinary_baer_sum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** From these results, it finally follows that the Baer sum is associative. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5b"><span class="kn">Lemma</span> <span class="nf">baer_sum_associative</span> `{Univalence}
  {A B : AbGroup@{u}} (E F G : AbSES B A)
  : abses_baer_sum (abses_baer_sum E F) G = abses_baer_sum E (abses_baer_sum F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_baer_sum E (abses_baer_sum F G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum E F) G =
abses_baer_sum E (abses_baer_sum F G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5d"><span class="nb">refine</span> ((baer_sum_twist _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum (abses_baer_sum G F) E =
abses_baer_sum E (abses_baer_sum F G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5e"><span class="nb">refine</span> (baer_sum_commutative _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum E (abses_baer_sum G F) =
abses_baer_sum E (abses_baer_sum F G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk5f"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_baer_sum G F = abses_baer_sum F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> baer_sum_commutative.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Baer sum makes [AbSES B A] into an H-space. (In fact, a coherent H-space, but we leave that for now.) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk60"><span class="kn">Instance</span> <span class="nf">ishspace_abses</span> `{Univalence} {B A : AbGroup}
  : IsHSpace (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk61"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk62">snapply Build_IsHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (AbSES B A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk63"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?hspace_op</span> (point (AbSES B A))</div></blockquote><input class="alectryon-extra-goal-toggle" id="baersum-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk64"><hr></label><div class="goal-conclusion">RightIdentity <span class="nl">?hspace_op</span> (point (AbSES B A))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_baer_sum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity abses_baer_sum (point (AbSES B A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span>; <span class="nb">apply</span> baer_sum_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity abses_baer_sum (point (AbSES B A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span>; <span class="nb">apply</span> baer_sum_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0bifunctor_abses</span> `{Univalence}
  : Is0Bifunctor (AbSES : AbGroup^op -&gt; AbGroup -&gt; pType)
  := Build_Is0Bifunctor&#39;&#39; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk68"><span class="kn">Instance</span> <span class="nf">is1bifunctor_abses</span> `{Univalence}
  : Is1Bifunctor (AbSES : AbGroup^op -&gt; AbGroup -&gt; pType).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor (AbSES : AbGroup^op -&gt; AbGroup -&gt; pType)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor (AbSES : AbGroup^op -&gt; AbGroup -&gt; pType)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk6a">snapply Build_Is1Bifunctor&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup^op, Is1Functor (AbSES a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk6b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : AbGroup, Is1Functor (flip AbSES b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="baersum-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk6c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a1</span> : AbGroup^op) (<span class="nv">f</span> : a0 $-&gt; a1)
(<span class="nv">b0</span> <span class="nv">b1</span> : AbGroup) (<span class="nv">g</span> : b0 $-&gt; b1),
fmap01 AbSES a1 g $o fmap10 AbSES f b0 $==
fmap10 AbSES f b1 $o fmap01 AbSES a0 g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk6d"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a1</span> : AbGroup^op) (<span class="nv">f</span> : a0 $-&gt; a1)
(<span class="nv">b0</span> <span class="nv">b1</span> : AbGroup) (<span class="nv">g</span> : b0 $-&gt; b1),
fmap01 AbSES a1 g $o fmap10 AbSES f b0 $==
fmap10 AbSES f b1 $o fmap01 AbSES a0 g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk6e"><span class="nb">intros</span> ? ? f ? ? g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 AbSES a1 g $o fmap10 AbSES f b0 $==
fmap10 AbSES f b1 $o fmap01 AbSES a0 g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk6f">rapply hspace_phomotopy_from_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace (AbSES a1 b1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk70"><hr></label><div class="goal-conclusion">fmap01 AbSES a1 g $o fmap10 AbSES f b0 ==
fmap10 AbSES f b1 $o fmap01 AbSES a0 g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk71"><span class="mi">1</span>: <span class="bp">exact</span> ishspace_abses.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 AbSES a1 g $o fmap10 AbSES f b0 ==
fmap10 AbSES f b1 $o fmap01 AbSES a0 g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk72"><span class="nb">intro</span> E; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>a0, a1</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a0 $-&gt; a1</span></span></span><br><span><var>b0, b1</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b0 $-&gt; b1</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES a0 b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout g (abses_pullback f E) =
abses_pullback f (abses_pushout g E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pullback_reorder.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pushouts and pullbacks respect the Baer sum *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk73"><span class="kn">Definition</span> <span class="nf">baer_sum_pushout</span> `{Univalence}
  {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;) (E F : AbSES B A)
  : abses_pushout f (abses_baer_sum E F)
    = abses_baer_sum (abses_pushout f E) (abses_pushout f F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_baer_sum E F) =
abses_baer_sum (abses_pushout f E) (abses_pushout f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f (abses_baer_sum E F) =
abses_baer_sum (abses_pushout f E) (abses_pushout f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk75"><span class="nb">unfold</span> abses_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f
  (abses_pullback ab_diagonal
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F))) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pushout f E)
        (abses_pushout f F)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk76"><span class="nb">refine</span> (abses_pushout_pullback_reorder _ _ _
            @ ap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f
  (abses_pushout ab_codiagonal (abses_direct_sum E F)) =
abses_pushout ab_codiagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout f F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk77"><span class="nb">refine</span> ((abses_pushout_compose _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (f $o ab_codiagonal)
  (abses_direct_sum E F) =
abses_pushout ab_codiagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout f F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk78"><span class="nb">refine</span> (abses_pushout_homotopic _ _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o ab_codiagonal == <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk79"><hr></label><div class="goal-conclusion">abses_pushout <span class="nl">?Goal</span> (abses_direct_sum E F) =
abses_pushout ab_codiagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout f F))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7a"><span class="mi">1</span>: <span class="nb">apply</span> ab_codiagonal_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (ab_codiagonal $o functor_ab_biprod f f)
  (abses_direct_sum E F) =
abses_pushout ab_codiagonal
  (abses_direct_sum (abses_pushout f E)
     (abses_pushout f F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7b"><span class="nb">refine</span> (abses_pushout_compose _ _ _ @ ap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (functor_ab_biprod f f)
  (abses_direct_sum E F) =
abses_direct_sum (abses_pushout f E)
  (abses_pushout f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_directsum_distributive_pushouts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7c"><span class="kn">Definition</span> <span class="nf">baer_sum_pullback</span> `{Univalence}
  {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B) (E F : AbSES B A)
  : abses_pullback f (abses_baer_sum E F)
    = abses_baer_sum (abses_pullback f E) (abses_pullback f F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f (abses_baer_sum E F) =
abses_baer_sum (abses_pullback f E)
  (abses_pullback f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f (abses_baer_sum E F) =
abses_baer_sum (abses_pullback f E)
  (abses_pullback f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7e"><span class="nb">unfold</span> abses_baer_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f
  (abses_pullback ab_diagonal
     (abses_pushout ab_codiagonal
        (abses_direct_sum E F))) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback f F)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk7f"><span class="nb">refine</span> (abses_pullback_compose _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (ab_diagonal $o f)
  (abses_pushout ab_codiagonal (abses_direct_sum E F)) =
abses_pullback ab_diagonal
  (abses_pushout ab_codiagonal
     (abses_direct_sum (abses_pullback f E)
        (abses_pullback f F)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk80"><span class="nb">refine</span> ((abses_pushout_pullback_reorder _ _ _)^
            @ ap _ _
              @ abses_pushout_pullback_reorder _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (ab_diagonal $o f)
  (abses_direct_sum E F) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback f F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk81"><span class="nb">refine</span> (abses_pullback_homotopic
            _ (functor_ab_biprod f f $o ab_diagonal) _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_diagonal $o f ==
functor_ab_biprod f f $o ab_diagonal</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="baersum-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="baersum-v-chk82"><hr></label><div class="goal-conclusion">abses_pullback (functor_ab_biprod f f $o ab_diagonal)
  (abses_direct_sum E F) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback f F))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk83"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (functor_ab_biprod f f $o ab_diagonal)
  (abses_direct_sum E F) =
abses_pullback ab_diagonal
  (abses_direct_sum (abses_pullback f E)
     (abses_pullback f F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="baersum-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="baersum-v-chk84"><span class="nb">refine</span> ((abses_pullback_compose _ _ _)^ @ ap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (functor_ab_biprod f f)
  (abses_direct_sum E F) =
abses_direct_sum (abses_pullback f E)
  (abses_pullback f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_directsum_distributive_pullbacks.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
