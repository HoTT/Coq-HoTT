<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>UnitCounitCoercions.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Coercions between the various (co)unit definitions *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk0"><span class="kn">Require Import</span> Category.Core Functor.Core NaturalTransformation.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Adjoint.UnitCounit Adjoint.Dual.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Composition.Core Functor.Identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HoTT.Tactics Basics.Trunc Types.Sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Basics.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Polymorphism</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Asymmetric Patterns</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> natural_transformation_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> category_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> morphism_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">equivalences</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">from_unit_counit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Ltac</span> <span class="nf">unit_counit_of_t</span> :=
      <span class="kp">repeat</span>
        <span class="kr">match goal with</span>
          | _ =&gt; <span class="nb">split</span>
          | _ =&gt; <span class="nb">intro</span>
          | _ =&gt; <span class="kp">progress</span> <span class="nb">auto with</span> morphism
          | _ =&gt; <span class="kp">progress</span> <span class="nb">simpl</span>
          | _ =&gt; <span class="nb">rewrite</span> !composition_of
          | [ |- <span class="kp">context</span>[components_of <span class="nl">?T</span>] ]
            =&gt; (try_associativity_quick <span class="nb">simpl</span> <span class="nb">rewrite</span> &lt;- (commutes T));
              try_associativity_quick
                <span class="kp">progress</span>
                <span class="nb">rewrite</span> <span class="nl">?unit_counit_equation_1</span>, <span class="nl">?unit_counit_equation_2</span>
          | [ |- <span class="kp">context</span>[components_of <span class="nl">?T</span>] ]
            =&gt; (try_associativity_quick <span class="nb">simpl</span> <span class="nb">rewrite</span> (commutes T));
              try_associativity_quick
                <span class="kp">progress</span>
                <span class="nb">rewrite</span> <span class="nl">?unit_counit_equation_1</span>, <span class="nl">?unit_counit_equation_2</span>
          | _ =&gt; <span class="kp">progress</span> path_induction
        <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** unit+counit+zig+zag ‚Üí unit+UMP *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk1"><span class="kn">Definition</span> <span class="nf">adjunction_unit__of__adjunction_unit_counit</span>
               <span class="nv">C</span> <span class="nv">D</span> <span class="nv">F</span> <span class="nv">G</span> (<span class="nv">A</span> : @AdjunctionUnitCounit C D F G)
    : AdjunctionUnit F G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AdjunctionUnit F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AdjunctionUnit F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk3"><span class="kr">exists</span> (<span class="nv">unit</span> <span class="nv">A</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">c</span> : C) (<span class="nv">d</span> : D)
(<span class="nv">f</span> : morphism C c (G _0 d)%object),
Contr
  {g : morphism D (F _0 c)%object d &amp;
  G _1 g o unit A c = f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk4"><span class="nb">intros</span> c d f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {g : morphism D (F _0 c)%object d &amp;
  G _1 g o unit A c = f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk5"><span class="nb">apply</span> contr_inhabited_hprop;
        [ <span class="nb">apply</span> hprop_allpath
        | (<span class="kr">exists</span> (<span class="nv">counit</span> <span class="nv">A</span> <span class="nv">d</span> <span class="nv">o</span> <span class="nv">F</span> <span class="nv">_1</span> <span class="nv">f</span>));
          <span class="kp">abstract</span> unit_counit_of_t ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : {g : morphism D (F _0 c)%object d &amp;
     G _1 g o unit A c = f}, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk6"><span class="nb">intros</span> [? ?] [? ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>G _1 proj1 o unit A c = f</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>G _1 proj0 o unit A c = f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(proj1; proj2) = (proj0; proj3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk7"><span class="nb">apply</span> path_sigma_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>G _1 proj1 o unit A c = f</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>G _1 proj0 o unit A c = f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : (proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">g</span> : morphism D (F _0 c)%object d =&gt;
   G _1 g o unit A c = f) p (proj1; proj2).<span class="mi">2</span> =
(proj0; proj3).<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk8"><span class="kr">let</span> <span class="nv">A</span> := <span class="kr">match goal with</span> |- @sig <span class="nl">?A</span> <span class="nl">?P</span> =&gt; <span class="kp">constr</span>:(A) <span class="kr">end</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">assert</span> (H : A);
        [
        | <span class="kr">exists</span> <span class="nv">H</span>;
            <span class="bp">exact</span> (center _) ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>G _1 proj1 o unit A c = f</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>G _1 proj0 o unit A c = f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnitCounit F G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>morphism C c (G _0 d)%object</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>G _1 proj1 o unit A c = f</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>morphism D (F _0 c)%object d</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>G _1 proj0 o unit A c = f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1 = proj0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">let</span> <span class="nv">x</span> := <span class="kr">match goal with</span> |- <span class="nl">?x</span> = <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(x) <span class="kr">end</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">y</span> := <span class="kr">match goal with</span> |- <span class="nl">?x</span> = <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(y) <span class="kr">end</span> <span class="kr">in</span>
      <span class="nb">rewrite</span> &lt;- (right_identity _ _ _ x),
      &lt;- (right_identity _ _ _ y),
      &lt;- !(unit_counit_equation_1 A),
      &lt;- <span class="nl">?associativity</span>;
        <span class="kp">repeat</span> <span class="nb">simpl</span> <span class="nb">rewrite</span> &lt;- (commutes (counit A));
        (try_associativity_quick <span class="nb">rewrite</span> &lt;- !composition_of);
        <span class="kp">repeat</span> <span class="nb">apply</span> ap;
        <span class="nb">etransitivity</span>; [ | <span class="nb">symmetry</span> ]; <span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** unit+counit+zig+zag ‚Üí counit+UMP *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">adjunction_counit__of__adjunction_unit_counit</span>
               <span class="nv">C</span> <span class="nv">D</span> <span class="nv">F</span> <span class="nv">G</span> (<span class="nv">A</span> : @AdjunctionUnitCounit C D F G)
    : AdjunctionCounit F G
      := adjunction_counit__op__adjunction_unit
           (adjunction_unit__of__adjunction_unit_counit A^op).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">from_unit_counit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">to_unit_counit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">to_unit_counit_nt</span> helper commutes_tac :=
      <span class="nb">simpl</span>;
      <span class="nb">intros</span>;
      <span class="nb">apply</span> helper;
      <span class="kp">repeat</span> <span class="kr">match goal with</span>
               | _ =&gt; <span class="bp">reflexivity</span>
               | _ =&gt; <span class="nb">rewrite</span> !composition_of
               | _ =&gt; <span class="kp">progress</span>
                        <span class="nb">rewrite</span> <span class="nl">?identity_of</span>, <span class="nl">?left_identity</span>, <span class="nl">?right_identity</span>
               | [ |- <span class="kp">context</span>[<span class="nl">?x</span>.<span class="mi">1</span>] ]
                 =&gt; try_associativity_quick <span class="nb">simpl</span> <span class="nb">rewrite</span> x.<span class="mi">2</span>
               | [ |- <span class="kp">context</span>[components_of <span class="nl">?T</span>] ]
                 =&gt; simpl_do_clear commutes_tac (commutes T)
             <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** unit+UMP ‚Üí unit+counit+zig+zag *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">from_unit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> <span class="nv">C</span> <span class="nv">D</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">F</span> : Functor C D.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">G</span> : Functor D C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chka"><span class="kn">Lemma</span> <span class="nf">counit_natural_transformation__of__adjunction_unit_helper</span>
            (<span class="nv">A</span> : AdjunctionUnit F G)
            <span class="nv">s</span> <span class="nv">d</span> (<span class="nv">m</span> : morphism D s d)
            (<span class="nv">eta</span> := A.<span class="mi">1</span>)
            (<span class="nv">eps</span> := <span class="kr">fun</span> <span class="nv">X</span> =&gt; (@center _ (A.<span class="mi">2</span> (G X) X <span class="mi">1</span>)).<span class="mi">1</span>)
      : G _1 (eps d o F _1 (G _1 m)) o eta (G s) = G _1 m
        -&gt; G _1 (m o eps s) o eta (G s) = G _1 m
        -&gt; eps d o F _1 (G _1 m) = m o eps s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>s, d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>morphism D s d</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 (eps d o F _1 (G _1 m)) o eta (G _0 s)%object =
G _1 m -&gt;
G _1 (m o eps s) o eta (G _0 s)%object = G _1 m -&gt;
eps d o F _1 (G _1 m) = m o eps s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>s, d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>morphism D s d</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 (eps d o F _1 (G _1 m)) o eta (G _0 s)%object =
G _1 m -&gt;
G _1 (m o eps s) o eta (G _0 s)%object = G _1 m -&gt;
eps d o F _1 (G _1 m) = m o eps s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>s, d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>morphism D s d</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>G _1 (eps d o F _1 (G _1 m)) o eta (G _0 s)%object =
G _1 m</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>G _1 (m o eps s) o eta (G _0 s)%object = G _1 m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eps d o F _1 (G _1 m) = m o eps s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">transitivity</span> (@center _ (A.<span class="mi">2</span> _ _ (G _1 m))).<span class="mi">1</span>; [ <span class="nb">symmetry</span> | ];
        <span class="kr">let</span> <span class="nv">x</span> := <span class="kr">match goal with</span> |- _ = <span class="nl">?x</span> =&gt; <span class="kp">constr</span>:(x) <span class="kr">end</span> <span class="kr">in</span>
        <span class="nb">refine</span> ((<span class="kr">fun</span> <span class="nv">H</span> =&gt; ap pr1 (@contr _ (A.<span class="mi">2</span> _ _ (G _1 m)) (x; H))) _);
        <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chkd"><span class="kn">Definition</span> <span class="nf">counit_natural_transformation__of__adjunction_unit</span>
                 (<span class="nv">A</span> : AdjunctionUnit F G)
      : NaturalTransformation (F o G) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation (F o G) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation (F o G) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chkf"><span class="nb">refine</span> (Build_NaturalTransformation
                  (F o G) <span class="mi">1</span>
                  (<span class="kr">fun</span> <span class="nv">d</span> =&gt; (@center _ (A.<span class="mi">2</span> (G d) d <span class="mi">1</span>)).<span class="mi">1</span>)
                  _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : D) (<span class="nv">m</span> : morphism D s d),
(center
   {g : morphism D (F _0 (G _0 d))%object d &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 d)%object = <span class="mi">1</span>}).<span class="mi">1</span> o (F o G) _1 m =
<span class="mi">1</span> _1 m
o (center
     {g : morphism D (F _0 (G _0 s))%object s &amp;
     G _1 g o A.<span class="mi">1</span> (G _0 s)%object = <span class="mi">1</span>}).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
            to_unit_counit_nt
              counit_natural_transformation__of__adjunction_unit_helper
              <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; try_associativity_quick <span class="nb">rewrite</span> &lt;- H)
          ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk10"><span class="kn">Definition</span> <span class="nf">zig__of__adjunction_unit</span>
                 (<span class="nv">A</span> : AdjunctionUnit F G)
                 (<span class="nv">Y</span> : C)
                 (<span class="nv">eta</span> := A.<span class="mi">1</span>)
                 (<span class="nv">eps</span> := <span class="kr">fun</span> <span class="nv">X</span> =&gt; (@center _ (A.<span class="mi">2</span> (G X) X <span class="mi">1</span>)).<span class="mi">1</span>)
      : G _1 (eps (F Y) o F _1 (eta Y)) o eta Y = eta Y
        -&gt; eps (F Y) o F _1 (eta Y) = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 (eps (F _0 Y)%object o F _1 (eta Y)) o eta Y =
eta Y -&gt; eps (F _0 Y)%object o F _1 (eta Y) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 (eps (F _0 Y)%object o F _1 (eta Y)) o eta Y =
eta Y -&gt; eps (F _0 Y)%object o F _1 (eta Y) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk12"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>G _1 (eps (F _0 Y)%object o F _1 (eta Y)) o eta Y =
eta Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eps (F _0 Y)%object o F _1 (eta Y) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk13"><span class="nb">etransitivity</span>; [ <span class="nb">symmetry</span> | ];
        simpl_do_clear
          <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; <span class="nb">apply</span> H)
                 (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">H</span> =&gt; (@contr _ (A.<span class="mi">2</span> _ _ (A.<span class="mi">1</span> Y)) (y; H))..<span class="mi">1</span>);
        <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>G _1 (eps (F _0 Y)%object o F _1 (eta Y)) o eta Y =
eta Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 <span class="mi">1</span> o A.<span class="mi">1</span> Y = A.<span class="mi">1</span> Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk14"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>eta</var><span><span class="hyp-body"><b>:= </b><span>A.<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>NaturalTransformation <span class="mi">1</span> (G o F)</span></span></span></span><br><span><var>eps</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">X</span> : D =&gt;
(center
   {g : morphism D (F _0 (G _0 X))%object X &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 X)%object = <span class="mi">1</span>}).<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : D, morphism D (F _0 (G _0 X))%object X</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>G _1 (eps (F _0 Y)%object o F _1 (eta Y)) o eta Y =
eta Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G _1 <span class="mi">1</span> o A.<span class="mi">1</span> Y = A.<span class="mi">1</span> Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> <span class="nl">?identity_of</span>, <span class="nl">?left_identity</span>, <span class="nl">?right_identity</span>;
          <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk15"><span class="kn">Definition</span> <span class="nf">adjunction_unit_counit__of__adjunction_unit</span>
                 (<span class="nv">A</span> : AdjunctionUnit F G)
      : AdjunctionUnitCounit F G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AdjunctionUnitCounit F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AdjunctionUnitCounit F G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="unitcounitcoercions-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="unitcounitcoercions-v-chk17"><span class="kr">exists</span> <span class="nv">A</span>.<span class="mi">1</span>
               (counit_natural_transformation__of__adjunction_unit A);
        <span class="nb">simpl</span>;
        <span class="nb">intros</span>;
        <span class="kp">try</span> <span class="kr">match goal with</span>
              | [ |- <span class="kp">context</span>[<span class="nl">?x</span>.<span class="mi">1</span>] ] =&gt; <span class="bp">exact</span> x.<span class="mi">2</span>
            <span class="kr">end</span>;
        [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>C, D</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor C D</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Functor D C</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AdjunctionUnit F G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(center
   {g
   : morphism D (F _0 (G _0 (F _0 Y)))%object
       (F _0 Y)%object &amp;
   G _1 g o A.<span class="mi">1</span> (G _0 (F _0 Y))%object = <span class="mi">1</span>}).<span class="mi">1</span>
o F _1 (A.<span class="mi">1</span> Y) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (to_unit_counit_nt
                    zig__of__adjunction_unit
                    <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; try_associativity_quick <span class="nb">rewrite</span> &lt;- H)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">from_unit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** counit+UMP ‚Üí unit+counit+zig+zag *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">adjunction_unit_counit__of__adjunction_counit</span>
               <span class="nv">C</span> <span class="nv">D</span> <span class="nv">F</span> <span class="nv">G</span> (<span class="nv">A</span> : @AdjunctionCounit C D F G)
    : AdjunctionUnitCounit F G
      := ((adjunction_unit_counit__of__adjunction_unit
             (adjunction_unit__op__adjunction_counit__inv A))^op)%adjunction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">to_unit_counit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">equivalences</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">adjunction_unit__of__adjunction_unit_counit</span>
: AdjunctionUnitCounit &gt;-&gt; AdjunctionUnit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">adjunction_counit__of__adjunction_unit_counit</span>
: AdjunctionUnitCounit &gt;-&gt; AdjunctionCounit.</span></span></pre>
</div>
</div></body>
</html>
