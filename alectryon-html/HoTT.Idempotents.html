<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Idempotents.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber Constant.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.IdentitySystems.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Idempotents and their splittings *)</span>

<span class="sd">(** ** Basic definitions *)</span>

<span class="sd">(** *** Retracts *)</span>

<span class="sd">(** A *retract* of a type [X] is a type [A] equipped with a pair of morphisms [r : X -&gt; A] and [s : A -&gt; X] such that the composite [r o s] is the identity of [A]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">RetractOf</span> {<span class="nv">X</span> : <span class="kt">Type</span>} :=
  { retract_type : <span class="kt">Type</span> ;
    retract_retr : X -&gt; retract_type ;
    retract_sect : retract_type -&gt; X ;
    retract_issect : retract_retr o retract_sect == idmap }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> RetractOf X : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> retract_type / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> retract_retr / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> retract_sect / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> retract_issect / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For example, here is the identity retraction. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">idmap_retractof</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : RetractOf X
  := Build_RetractOf X X idmap idmap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Retractions can be composed with equivalences on either side. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1"><span class="kn">Definition</span> <span class="nf">retractof_equiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) `{feq : IsEquiv _ _ f}
: RetractOf X -&gt; RetractOf Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf X -&gt; RetractOf Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf X -&gt; RetractOf Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3"><span class="nb">intros</span> [A r s H]; <span class="nb">refine</span> (Build_RetractOf Y A (r o f^-<span class="mi">1</span>) (f o s) _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (f^-<span class="mi">1</span> (f (s x))) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap r (eissect f (s x)) @ H x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retractof_equiv&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X &lt;~&gt; Y)
: RetractOf X -&gt; RetractOf Y
  := retractof_equiv f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk4"><span class="kn">Definition</span> <span class="nf">equiv_retractof</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
           {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : retract_type R -&gt; B) `{feq : IsEquiv _ _ f}
: RetractOf X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>retract_type R -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>retract_type R -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6"><span class="nb">destruct</span> R <span class="kr">as</span> [A r s H]; <span class="nb">refine</span> (Build_RetractOf X B (f o r) (s o f^-<span class="mi">1</span>) _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>retract_type
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |} -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r (s (f^-<span class="mi">1</span> x))) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f (H (f^-<span class="mi">1</span> x)) @ eisretr f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_retractof&#39;</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
           {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : retract_type R &lt;~&gt; B)
: RetractOf X
  := equiv_retractof R f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A commuting retract of the domain of map induces a retract of its fibers. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7"><span class="kn">Definition</span> <span class="nf">retractof_hfiber</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X) (<span class="nv">f</span> : X -&gt; Y)
           (<span class="nv">g</span> : retract_type R -&gt; Y) (<span class="nv">p</span> : g o retract_retr R == f)
           (<span class="nv">y</span> : Y)
: RetractOf (hfiber f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>retract_type R -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g o retract_retr R == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>retract_type R -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g o retract_retr R == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9"><span class="nb">destruct</span> R <span class="kr">as</span> [A r s H]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka"><span class="nb">simple refine</span> (Build_RetractOf (hfiber f y) (hfiber g y) _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y -&gt; hfiber g y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkb"><hr></label><div class="goal-conclusion">hfiber g y -&gt; hfiber f y</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkc"><hr></label><div class="goal-conclusion"><span class="nl">?retract_retr</span> o <span class="nl">?retract_sect</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y -&gt; hfiber g y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke"><span class="nb">intros</span> [x q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber g y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf"><span class="kr">exists</span> (<span class="nv">r</span> <span class="nv">x</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (r x) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x @ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber g y -&gt; hfiber f y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11"><span class="nb">intros</span> [a q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12"><span class="kr">exists</span> (<span class="nv">s</span> <span class="nv">a</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (s a) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((p (s a))^ @ ap g (H a) @ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X0</span> : hfiber f y =&gt;
 (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">q</span> : f x = y) =&gt; (r x; p x @ q)) X0.<span class="mi">1</span>
   X0.<span class="mi">2</span>)
o (<span class="kr">fun</span> <span class="nv">X0</span> : hfiber g y =&gt;
   (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : g a = y) =&gt;
    (s a; ((p (s a))^ @ ap g (H a)) @ q)) X0.<span class="mi">1</span> X0.<span class="mi">2</span>) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14"><span class="nb">intros</span> [a q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r (s a); p (s a) @ (((p (s a))^ @ ap g (H a)) @ q)) =
(a; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15"><span class="nb">simple refine</span> (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (s a) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk16"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g x = y) <span class="nl">?p</span>
  (p (s a) @ (((p (s a))^ @ ap g (H a)) @ q)) = q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (s a) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk18">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (r x)) == f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g a = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g x = y) (H a)
  (p (s a) @ (((p (s a))^ @ ap g (H a)) @ q)) = q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
        <span class="nb">rewrite</span> transport_paths_Fl, !concat_p_pp, concat_pp_V, concat_Vp, concat_1p;
        <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Retraction preserves contractibility **)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">contr_retracttype</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X ) (<span class="nv">contra</span> : Contr X) : Contr (retract_type R )
  := contr_retract (retract_retr R) (retract_sect R) (retract_issect R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Like any record type, [RetractOf X] is equivalent to a nested sigma-type.  We use a product at one place in the middle, rather than a sigma, to simplify the next proof. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk19"><span class="kn">Definition</span> <span class="nf">issig_retractof</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
: { A : <span class="kt">Type</span> &amp; {r : X -&gt; A &amp; {s : A -&gt; X &amp; r o s == idmap }}}
  &lt;~&gt; RetractOf X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{A : <span class="kt">Type</span> &amp;
{r : X -&gt; A &amp; {s : A -&gt; X &amp; r o s == idmap}}} &lt;~&gt;
RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{A : <span class="kt">Type</span> &amp;
{r : X -&gt; A &amp; {s : A -&gt; X &amp; r o s == idmap}}} &lt;~&gt;
RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">issig.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Path spaces of types of retractions *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PathRetractOf</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R&#39;</span> <span class="nv">R</span> : RetractOf X)
  := { Ap : retract_type R&#39; &lt;~&gt; retract_type R &amp;
     { rp : Ap o retract_retr R&#39; == retract_retr R &amp;
     { sp : retract_sect R&#39; o Ap^-<span class="mi">1</span> == retract_sect R &amp;
            <span class="kr">forall</span> <span class="nv">a</span>, ap Ap (retract_issect R&#39; (Ap^-<span class="mi">1</span> a))
                         @ eisretr Ap a
                      = rp (retract_sect R&#39; (Ap^-<span class="mi">1</span> a))
                           @ ap (retract_retr R) (sp a)
                           @ retract_issect R a } } }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1b"><span class="kn">Definition</span> <span class="nf">equiv_path_retractof</span> `{ua : Univalence} {X : <span class="kt">Type</span>}
           (R&#39; R : RetractOf X)
  : PathRetractOf X R&#39; R &lt;~&gt; R&#39; = R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R', R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathRetractOf X R&#39; R &lt;~&gt; R&#39; = R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R', R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathRetractOf X R&#39; R &lt;~&gt; R&#39; = R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1d"><span class="nb">revert</span> R&#39; R; <span class="nb">apply</span> (equiv_path_issig_contr (issig_retractof X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}},
PathRetractOf X (issig_retractof X b)
  (issig_retractof X b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk1e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {A : <span class="kt">Type</span> &amp;
     {r : X -&gt; A &amp;
     {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}},
Contr
  {b2
  : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}} &amp;
  PathRetractOf X (issig_retractof X b1)
    (issig_retractof X b2)}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk1f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}},
PathRetractOf X (issig_retractof X b)
  (issig_retractof X b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk20"><span class="nb">intros</span> [A [r [s H]]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathRetractOf X
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |}
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk21"><span class="kr">exists</span> <span class="nv">equiv_idmap</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{rp
: (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="mi">1</span>%equiv
     (retract_retr
        {|
          retract_type := A;
          retract_retr := r;
          retract_sect := s;
          retract_issect := H
        |} x)) ==
  retract_retr
    {|
      retract_type := A;
      retract_retr := r;
      retract_sect := s;
      retract_issect := H
    |} &amp;
{sp
: (<span class="kr">fun</span>
     <span class="nv">x</span> : retract_type
           {|
             retract_type := A;
             retract_retr := r;
             retract_sect := s;
             retract_issect := H
           |} =&gt;
   retract_sect
     {|
       retract_type := A;
       retract_retr := r;
       retract_sect := s;
       retract_issect := H
     |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> x)) ==
  retract_sect
    {|
      retract_type := A;
      retract_retr := r;
      retract_sect := s;
      retract_issect := H
    |} &amp;
<span class="kr">forall</span>
<span class="nv">a</span> : retract_type
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |},
ap <span class="mi">1</span>%equiv
  (retract_issect
     {|
       retract_type := A;
       retract_retr := r;
       retract_sect := s;
       retract_issect := H
     |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> a)) @ eisretr <span class="mi">1</span>%equiv a =
(rp
   (retract_sect
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> a)) @
 ap
   (retract_retr
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |}) (sp a)) @
retract_issect
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |} a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk22"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>%path).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{sp
: (<span class="kr">fun</span>
     <span class="nv">x</span> : retract_type
           {|
             retract_type := A;
             retract_retr := r;
             retract_sect := s;
             retract_issect := H
           |} =&gt;
   retract_sect
     {|
       retract_type := A;
       retract_retr := r;
       retract_sect := s;
       retract_issect := H
     |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> x)) ==
  retract_sect
    {|
      retract_type := A;
      retract_retr := r;
      retract_sect := s;
      retract_issect := H
    |} &amp;
<span class="kr">forall</span>
<span class="nv">a</span> : retract_type
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |},
ap <span class="mi">1</span>%equiv
  (retract_issect
     {|
       retract_type := A;
       retract_retr := r;
       retract_sect := s;
       retract_issect := H
     |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> a)) @ eisretr <span class="mi">1</span>%equiv a =
(<span class="mi">1</span> @
 ap
   (retract_retr
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |}) (sp a)) @
retract_issect
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |} a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk23"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>%path).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : retract_type
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |},
ap <span class="mi">1</span>%equiv
  (retract_issect
     {|
       retract_type := A;
       retract_retr := r;
       retract_sect := s;
       retract_issect := H
     |} ((<span class="mi">1</span>%equiv)^-<span class="mi">1</span> a)) @ eisretr <span class="mi">1</span>%equiv a =
(<span class="mi">1</span> @
 ap
   (retract_retr
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |}) <span class="mi">1</span>) @
retract_issect
  {|
    retract_type := A;
    retract_retr := r;
    retract_sect := s;
    retract_issect := H
  |} a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk24"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, ap idmap (H a) @ <span class="mi">1</span> = <span class="mi">1</span> @ H a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; equiv_p1_1q (ap_idmap (H a))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {A : <span class="kt">Type</span> &amp;
     {r : X -&gt; A &amp;
     {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}},
Contr
  {b2
  : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}} &amp;
  PathRetractOf X (issig_retractof X b1)
    (issig_retractof X b2)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk26"><span class="nb">intros</span> [A [r [s H]]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {b2
  : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}} &amp;
  PathRetractOf X
    {|
      retract_type := A;
      retract_retr := r;
      retract_sect := s;
      retract_issect := H
    |}
    {|
      retract_type := b2.<span class="mi">1</span>;
      retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
      retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
      retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
    |}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk27"><span class="nb">unfold</span> PathRetractOf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {b2
  : {A : <span class="kt">Type</span> &amp;
    {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}}} &amp;
  {Ap
  : retract_type
      {|
        retract_type := A;
        retract_retr := r;
        retract_sect := s;
        retract_issect := H
      |} &lt;~&gt;
    retract_type
      {|
        retract_type := b2.<span class="mi">1</span>;
        retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
        retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
        retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
      |} &amp;
  {rp
  : (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
     Ap
       (retract_retr
          {|
            retract_type := A;
            retract_retr := r;
            retract_sect := s;
            retract_issect := H
          |} x)) ==
    retract_retr
      {|
        retract_type := b2.<span class="mi">1</span>;
        retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
        retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
        retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
      |} &amp;
  {sp
  : (<span class="kr">fun</span>
       <span class="nv">x</span> : retract_type
             {|
               retract_type := b2.<span class="mi">1</span>;
               retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
               retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
               retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
             |} =&gt;
     retract_sect
       {|
         retract_type := A;
         retract_retr := r;
         retract_sect := s;
         retract_issect := H
       |} (Ap^-<span class="mi">1</span> x)) ==
    retract_sect
      {|
        retract_type := b2.<span class="mi">1</span>;
        retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
        retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
        retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
      |} &amp;
  <span class="kr">forall</span>
  <span class="nv">a</span> : retract_type
        {|
          retract_type := b2.<span class="mi">1</span>;
          retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
          retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
          retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
        |},
  ap Ap
    (retract_issect
       {|
         retract_type := A;
         retract_retr := r;
         retract_sect := s;
         retract_issect := H
       |} (Ap^-<span class="mi">1</span> a)) @ eisretr Ap a =
  (rp
     (retract_sect
        {|
          retract_type := A;
          retract_retr := r;
          retract_sect := s;
          retract_issect := H
        |} (Ap^-<span class="mi">1</span> a)) @
   ap
     (retract_retr
        {|
          retract_type := b2.<span class="mi">1</span>;
          retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
          retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
          retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
        |}) (sp a)) @
  retract_issect
    {|
      retract_type := b2.<span class="mi">1</span>;
      retract_retr := (b2.<span class="mi">2</span>).<span class="mi">1</span>;
      retract_sect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span>;
      retract_issect := ((b2.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">2</span>
    |} a}}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk28">contr_sigsig A (equiv_idmap A); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {y
  : {r : X -&gt; A &amp;
    {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}} &amp;
  {rp : (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r x) == y.<span class="mi">1</span> &amp;
  {sp : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s x) == (y.<span class="mi">2</span>).<span class="mi">1</span> &amp;
  <span class="kr">forall</span> <span class="nv">a</span> : A,
  ap idmap (H a) @ <span class="mi">1</span> =
  (rp (s a) @ ap y.<span class="mi">1</span> (sp a)) @ (y.<span class="mi">2</span>).<span class="mi">2</span> a}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk29">contr_sigsig r (<span class="kr">fun</span> <span class="nv">x</span>:X =&gt; idpath (r x)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {y : {s : A -&gt; X &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap}
  &amp;
  {sp : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s x) == y.<span class="mi">1</span> &amp;
  <span class="kr">forall</span> <span class="nv">a</span> : A,
  ap idmap (H a) @ <span class="mi">1</span> = (<span class="mi">1</span> @ ap r (sp a)) @ y.<span class="mi">2</span> a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2a">contr_sigsig s (<span class="kr">fun</span> <span class="nv">x</span>:A =&gt; idpath (s x)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {y : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap &amp;
  <span class="kr">forall</span> <span class="nv">a</span> : A, ap idmap (H a) @ <span class="mi">1</span> = <span class="mi">1</span> @ y a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2b"><span class="nb">refine</span> (contr_equiv&#39; {K : r o s == idmap &amp; H == K} _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{K : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap &amp; H == K} &lt;~&gt;
{y : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap &amp;
<span class="kr">forall</span> <span class="nv">a</span> : A, ap idmap (H a) @ <span class="mi">1</span> = <span class="mi">1</span> @ y a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2c"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H == K &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, ap idmap (H a) @ <span class="mi">1</span> = <span class="mi">1</span> @ K a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2d"><span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intros</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H a = K a &lt;~&gt; ap idmap (H a) @ <span class="mi">1</span> = <span class="mi">1</span> @ K a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk2e"><span class="nb">apply</span> equiv_concat_lr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (H a) @ <span class="mi">1</span> = H a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk2f"><hr></label><div class="goal-conclusion">K a = <span class="mi">1</span> @ K a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (H a) @ <span class="mi">1</span> = H a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _ @ ap_idmap (H a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H, K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K a = <span class="mi">1</span> @ K a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_retractof</span> `{ua : Univalence} {X : <span class="kt">Type</span>} {R&#39; R : RetractOf X}
           Ap rp sp Hp
  : R&#39; = R
  := equiv_path_retractof R&#39; R (Ap;rp;sp;Hp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Splittings *)</span>

<span class="sd">(** If an endomap [f : X -&gt; X] arises from a retract as [s o r], we say that that retract is a *splitting* of [f]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retract_idem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
: (X -&gt; X)
  := retract_sect R o retract_retr R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> retract_idem {_} _ / x .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Splitting</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
  := { R : RetractOf X &amp; retract_idem R == f}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For example, here is the canonical splitting of the identity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">splitting_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : @Splitting X idmap
  := (idmap_retractof X ; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pre-idempotents *)</span>

<span class="sd">(** An &quot;idempotent&quot; is a map that at least &quot;ought&quot; to be splittable.  The naive definition of idempotent, which is correct in set-level mathematics, is a morphism [f : X -&gt; X] such that [forall x, f (f x) = f x].  We will call this a &quot;pre-idempotent&quot;. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsPreIdempotent</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
  := isidem : <span class="kr">forall</span> <span class="nv">x</span>, f (f x) = f x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> isidem {X} f {_} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk32"><span class="kn">Definition</span> <span class="nf">ispreidem_homotopic</span> {<span class="nv">X</span> : <span class="kt">Type</span>}
           (<span class="nv">f</span> : X -&gt; X) `{IsPreIdempotent _ f} {g : X -&gt; X} (p : f == g)
: IsPreIdempotent g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk34"><span class="nb">intros</span> x; <span class="nb">refine</span> (_ @ isidem f x @ p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (g x) = f (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk35"><span class="nb">refine</span> (_ @ (p (f x))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (g x) = g (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap; <span class="nb">symmetry</span>; <span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ispreidem_homotopic / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PreIdempotent</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := { f : X -&gt; X &amp; IsPreIdempotent f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preidempotent_pr1</span> {<span class="nv">X</span> : <span class="kt">Type</span>} : PreIdempotent X -&gt; X -&gt; X := pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">preidempotent_pr1</span> : PreIdempotent &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispreidem_preidem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : PreIdempotent X)
: IsPreIdempotent f
  := f.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity function has a canonical structure of a pre-idempotent. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispreidem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : @IsPreIdempotent X idmap
  := <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk36"><span class="kn">Definition</span> <span class="nf">preidem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : PreIdempotent X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreIdempotent X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PreIdempotent X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> <span class="nv">idmap</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any pre-idempotent on a set splits. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk38"><span class="kn">Definition</span> <span class="nf">split_preidem_set</span> (<span class="nv">X</span> : <span class="kt">Type</span>) `{IsHSet X} (f : PreIdempotent X)
: Splitting f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3a"><span class="nb">simple refine</span> (Build_RetractOf X { x : X &amp; f x = x }
                                 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (f x ; isidem f x)) pr1 _ ; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk3b"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := {x : X &amp; f x = x};
    retract_retr := <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x);
    retract_sect := pr1;
    retract_issect := <span class="nl">?retract_issect</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3d"><span class="nb">intros</span> [x p]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f x; isidem f x) = (x; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3e"><span class="nb">apply</span> path_sigma <span class="kr">with</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x = x) p (isidem f x) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := {x : X &amp; f x = x};
    retract_retr := <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x);
    retract_sect := pr1;
    retract_issect :=
      (<span class="kr">fun</span> <span class="nv">x0</span> : {x : X &amp; f x = x} =&gt;
       (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">p</span> : f x = x) =&gt;
        path_sigma (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; f x1 = x1)
          (f x; isidem f x) (x; p) p
          (path_ishprop
             (transport (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; f x1 = x1) p
                (isidem f x)) p
           :
           transport (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; f x1 = x1) p
             (f x; isidem f x).<span class="mi">2</span> = (x; p).<span class="mi">2</span>)
        :
        (f (x; p).<span class="mi">1</span>; isidem f (x; p).<span class="mi">1</span>) = (x; p)) x0.<span class="mi">1</span>
         x0.<span class="mi">2</span>)
      :
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk40"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x) == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any weakly constant pre-idempotent splits (Escard√≥) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk41"><span class="kn">Definition</span> <span class="nf">split_preidem_wconst</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : PreIdempotent X)
           `{WeaklyConstant _ _ f}
: Splitting f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk43"><span class="nb">simple refine</span> (Build_RetractOf X (FixedBy f)
                                 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (f x ; isidem f x)) pr1 _ ; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk44"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := FixedBy f;
    retract_retr := <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x);
    retract_sect := pr1;
    retract_issect := <span class="nl">?retract_issect</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk45">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := FixedBy f;
    retract_retr := <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x);
    retract_sect := pr1;
    retract_issect :=
      (<span class="kr">fun</span> <span class="nv">x</span> : FixedBy f =&gt;
       path_ishprop (f x.<span class="mi">1</span>; isidem f x.<span class="mi">1</span>) x)
      :
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (f x; isidem f x)) o pr1 == idmap
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk47"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>WeaklyConstant f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x) == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [f] is pre-idempotent and [f x = x] is collapsible for all [x], then [f] splits (Escard√≥). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk48"><span class="kn">Definition</span> <span class="nf">split_preidem_splitsupp</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : PreIdempotent X)
           (<span class="nv">ss</span> : <span class="kr">forall</span> <span class="nv">x</span>, Collapsible (f x = x))
: Splitting f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk4a"><span class="nb">simple refine</span> (Build_RetractOf X { x : X &amp; FixedBy (@collapse (f x = x) _) }
                                 _ pr1 _ ; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; {x : X &amp; FixedBy collapse}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk4b"><hr></label><div class="goal-conclusion"><span class="nl">?retract_retr</span> o pr1 == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk4c"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := {x : X &amp; FixedBy collapse};
    retract_retr := <span class="nl">?retract_retr</span>;
    retract_sect := pr1;
    retract_issect := <span class="nl">?retract_issect</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; {x : X &amp; FixedBy collapse}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk4e"><span class="nb">intros</span> x; <span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">x</span>); <span class="nb">unfold</span> FixedBy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : f (f x) = f x &amp; collapse x0 = x0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk4f"><span class="kr">exists</span> (<span class="nv">collapse</span> (isidem f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">collapse (collapse (isidem f x)) =
collapse (isidem f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wconst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 (f x;
 (collapse (isidem f x);
 wconst (collapse (isidem f x)) (isidem f x))
 :
 FixedBy collapse)) o pr1 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk51"><span class="nb">intros</span> [x [p q]]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>collapse p = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f x; collapse (isidem f x);
wconst (collapse (isidem f x)) (isidem f x)) =
(x; p; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk52"><span class="nb">apply</span> path_sigma <span class="kr">with</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>collapse p = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; FixedBy collapse) p
  (f x; collapse (isidem f x);
  wconst (collapse (isidem f x)) (isidem f x)).<span class="mi">2</span> =
(x; p; q).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">R</span> : RetractOf X =&gt; retract_idem R == f)
  {|
    retract_type := {x : X &amp; FixedBy collapse};
    retract_retr :=
      <span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      (f x;
      (collapse (isidem f x);
      wconst (collapse (isidem f x)) (isidem f x))
      :
      FixedBy collapse);
    retract_sect := pr1;
    retract_issect :=
      (<span class="kr">fun</span> <span class="nv">x0</span> : {x : X &amp; FixedBy collapse} =&gt;
       (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">proj2</span> : FixedBy collapse) =&gt;
        (<span class="kr">fun</span> (<span class="nv">p</span> : f x = x) (<span class="nv">q</span> : collapse p = p) =&gt;
         path_sigma (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; FixedBy collapse)
           (f x; collapse (isidem f x);
           wconst (collapse (isidem f x)) (isidem f x))
           (x; p; q) p
           (path_ishprop
              (transport
                 (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; FixedBy collapse) p
                 (f x; collapse (isidem f x);
                 wconst (collapse (isidem f x))
                   (isidem f x)).<span class="mi">2</span>) (x; p; q).<span class="mi">2</span>)
         :
         (f (x; p; q).<span class="mi">1</span>;
         collapse (isidem f (x; p; q).<span class="mi">1</span>);
         wconst (collapse (isidem f (x; p; q).<span class="mi">1</span>))
           (isidem f (x; p; q).<span class="mi">1</span>)) = (x; p; q))
          proj2.<span class="mi">1</span> proj2.<span class="mi">2</span>) x0.<span class="mi">1</span> x0.<span class="mi">2</span>)
      :
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
       (f x;
       (collapse (isidem f x);
       wconst (collapse (isidem f x)) (isidem f x))
       :
       FixedBy collapse)) o pr1 == idmap
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk54"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x) == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Moreover, in this case the section is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk55"><span class="kn">Definition</span> <span class="nf">isemb_split_preidem_splitsupp</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : PreIdempotent X)
           (<span class="nv">ss</span> : <span class="kr">forall</span> <span class="nv">x</span>, Collapsible (f x = x))
: IsEmbedding (retract_sect (split_preidem_splitsupp X f ss).<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (retract_sect (split_preidem_splitsupp X f ss).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (retract_sect (split_preidem_splitsupp X f ss).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istruncmap_mapinO_tr; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, if [f] splits with a section that is an embedding, then (it is pre-idempotent and) [f x = x] is collapsible for all [x] (Escard√≥). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk57"><span class="kn">Definition</span> <span class="nf">splitsupp_split_isemb</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; X) (<span class="nv">S</span> : Splitting f)
           `{IsEmbedding (retract_sect S.<span class="mi">1</span>)}
: <span class="kr">forall</span> <span class="nv">x</span>, Collapsible (f x = x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (retract_sect S.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (retract_sect S.<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk59"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (retract_sect S.<span class="mi">1</span>)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5a"><span class="nb">destruct</span> S <span class="kr">as</span> [[A r s H] K]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5b"><span class="nb">assert</span> (c1 : f x = x -&gt; { a : A &amp; s a = x }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = x -&gt; {a : A &amp; s a = x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk5c"><hr></label><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = x -&gt; {a : A &amp; s a = x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5e"><span class="nb">intros</span> p; <span class="kr">exists</span> (<span class="nv">r</span> <span class="nv">x</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s (r x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (K x @ p).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk5f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk60"><span class="nb">assert</span> (c2 : { a : A &amp; s a = x } -&gt; f x = x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; s a = x} -&gt; f x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br><span><var>c2</var><span class="hyp-type"><b>: </b><span>{a : A &amp; s a = x} -&gt; f x = x</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk61"><hr></label><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk62">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; s a = x} -&gt; f x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk63"><span class="nb">intros</span> [a q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>s a = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((K x)^ @ ap (s o r) q^ @ ap s (H a) @ q).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk64">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br><span><var>c2</var><span class="hyp-type"><b>: </b><span>{a : A &amp; s a = x} -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Collapsible (f x = x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk65"><span class="kr">exists</span> (<span class="nv">c2</span> <span class="nv">o</span> <span class="nv">c1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>f x = x -&gt; {a : A &amp; s a = x}</span></span></span><br><span><var>c2</var><span class="hyp-type"><b>: </b><span>{a : A &amp; s a = x} -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">WeaklyConstant (<span class="kr">fun</span> <span class="nv">x</span> : f x = x =&gt; c2 (c1 x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wconst_through_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Quasi-idempotents *)</span>

<span class="sd">(** However, homotopically we may naturally expect to need some coherence on the witness [isidem] of idempotency.  And indeed, in homotopy theory there are pre-idempotents which do not split; we will see an example later on.  We expect a &quot;coherent idempotent&quot; to involve infinitely many data.  However, Lemma 7.3.5.14 of *Higher Algebra* suggests that for an idempotent to admit *some* coherentification, hence also a splitting, it suffices to have *one* additional datum.  By modifying the construction given there, we can show similarly in type theory that any idempotent satisfying an additional coherence datum splits.  We will call a pre-idempotent with this one additional datum a &quot;quasi-idempotent&quot;, since it is related to a fully coherent idempotent similarly to the way having a &quot;quasi-inverse&quot; is related to being a coherent equivalence. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsQuasiIdempotent</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) `{IsPreIdempotent _ f}
  := isidem2 : <span class="kr">forall</span> <span class="nv">x</span>, ap f (isidem f x) = isidem f (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> isidem2 {X} f {_ _} x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk66"><span class="kn">Definition</span> <span class="nf">isqidem_homotopic</span> {<span class="nv">X</span> : <span class="kt">Type</span>}
           (<span class="nv">f</span> : X -&gt; X) `{IsQuasiIdempotent _ f} {g : X -&gt; X} (p : f == g)
: @IsQuasiIdempotent X g (ispreidem_homotopic f p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk68"><span class="nb">intros</span> x; <span class="nb">unfold</span> isidem; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (((ap g (p x)^ @ (p (f x))^) @ isidem f x) @ p x) =
((ap g (p (g x))^ @ (p (f (g x)))^) @ isidem f (g x)) @
p (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk69"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap g (p x)^
      @&#39; (p (f x))^
      @&#39; isidem f x
      @&#39; p x) =
ap g (p (g x))^
@&#39; (p (f (g x)))^
@&#39; isidem f (g x)
@&#39; p (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6a"><span class="nb">rewrite</span> (concat_Ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) (p x)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g ((p (g x))^
      @&#39; ap f (p x)^
      @&#39; isidem f x
      @&#39; p x) =
ap g (p (g x))^
@&#39; (p (f (g x)))^
@&#39; isidem f (g x)
@&#39; p (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6b"><span class="nb">rewrite</span> !ap_pp, !concat_pp_p; <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (p x)^)
@&#39; (ap g (isidem f x)
    @&#39; ap g (p x)) =
(p (f (g x)))^
@&#39; (isidem f (g x)
    @&#39; p (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6c"><span class="nb">rewrite</span> !concat_p_pp; <span class="nb">apply</span> moveL_pM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (p x)^)
@&#39; ap g (isidem f x)
@&#39; ap g (p x)
@&#39; (p (g x))^ = (p (f (g x)))^
                @&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6d"><span class="nb">rewrite</span> (concat_pA_p (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) (p x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (p x)^)
@&#39; ap g (isidem f x)
@&#39; (p (f x))^
@&#39; ap f (p x) = (p (f (g x)))^
                @&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6e"><span class="nb">rewrite</span> (concat_pA_p (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) (isidem _ x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (p x)^)
@&#39; (p (f (f x)))^
@&#39; ap f (isidem f x)
@&#39; ap f (p x) = (p (f (g x)))^
                @&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk6f"><span class="nb">rewrite</span> (concat_Ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) (ap f (p x)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p (f (g x)))^
@&#39; ap f (ap f (p x)^)
@&#39; ap f (isidem f x)
@&#39; ap f (p x) = (p (f (g x)))^
                @&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk70"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (p x)^)
@&#39; (ap f (isidem f x)
    @&#39; ap f (p x)) = isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk71"><span class="nb">rewrite</span> !ap_V; <span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (isidem f x)
@&#39; ap f (p x) = ap f (ap f (p x))
                @&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk72"><span class="nb">rewrite</span> &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (isidem f x)
@&#39; ap f (p x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f (f x)) (p x)
@&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk73"><span class="nb">rewrite</span> isidem2; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isidem f (f x)
@&#39; ap f (p x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f (f x)) (p x)
@&#39; isidem f (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (concat_Ap (isidem f) (p x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">QuasiIdempotent</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := { f : PreIdempotent X &amp; IsQuasiIdempotent f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quasiidempotent_pr1</span> {<span class="nv">X</span> : <span class="kt">Type</span>} : QuasiIdempotent X -&gt; X -&gt; X := pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">quasiidempotent_pr1</span> : QuasiIdempotent &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isqidem_qidem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : QuasiIdempotent X)
: IsQuasiIdempotent f
  := f.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity function has a canonical structure of a quasi-idempotent. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isqidem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : @IsQuasiIdempotent X idmap _
  := <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk74"><span class="kn">Definition</span> <span class="nf">qidem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : QuasiIdempotent X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">QuasiIdempotent X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">QuasiIdempotent X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">preidem_idmap</span> <span class="nv">X</span>); <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We have made [IsPreIdempotent] and [IsQuasiIdempotent] typeclasses as an experiment.  It could be that they should revert back to [Definitions]. *)</span>

<span class="sd">(** ** Split morphisms are quasi-idempotent *)</span>

<span class="sd">(** First we show that given a retract, the composite [s o r] is quasi-idempotent. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk76"><span class="kn">Instance</span> <span class="nf">ispreidem_retract</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
: IsPreIdempotent (retract_idem R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent (retract_idem R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent (retract_idem R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap (retract_sect R) (retract_issect R (retract_retr R x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preidem_retract</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
: PreIdempotent X
:= (retract_idem R ; ispreidem_retract R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ispreidem_retract / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> preidem_retract / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk78"><span class="kn">Instance</span> <span class="nf">isqidem_retract</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
: IsQuasiIdempotent (retract_idem R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent (retract_idem R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent (retract_idem R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7a"><span class="nb">destruct</span> R <span class="kr">as</span> [A r s H]; <span class="nb">intros</span> x; <span class="nb">unfold</span> isidem; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))) =
ap s (H (r (s (r x))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7b"><span class="nb">refine</span> ((ap_compose _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s (ap r (ap s (H (r x)))) = ap s (H (r (s (r x))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7c"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap r (ap s (H (r x))) = H (r (s (r x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7d"><span class="nb">refine</span> ((ap_compose _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r x)) = H (r (s (r x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7e"><span class="nb">refine</span> (cancelR _ _ (H (r x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r x)) @ H (r x) =
H (r (s (r x))) @ H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (concat_A1p H (H (r x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">qidem_retract</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X)
: QuasiIdempotent X
:= (preidem_retract R ; isqidem_retract R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In particular, it follows that any split function is quasi-idempotent. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk7f"><span class="kn">Instance</span> <span class="nf">ispreidem_split</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) (<span class="nv">S</span> : Splitting f)
: IsPreIdempotent f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk81"><span class="nb">destruct</span> S <span class="kr">as</span> [R p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>retract_idem R == f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ispreidem_homotopic _ p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ispreidem_split / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk82"><span class="kn">Instance</span> <span class="nf">isqidem_split</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) (<span class="nv">S</span> : Splitting f)
: @IsQuasiIdempotent X f (ispreidem_split f S).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Splitting f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk84"><span class="nb">destruct</span> S <span class="kr">as</span> [R p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>retract_idem R == f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isqidem_homotopic _ p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> isqidem_split / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quasi-idempotents split *)</span>

<span class="sd">(** We now show the converse, that every quasi-idempotent splits. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Splitting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We need funext because our construction will involve a sequential limit.  We could probably also use a HIT sequential colimit, which is more like what Lurie does.  (Note that, like an interval type, HIT sequential colimits probably imply funext, so our construction uses strictly weaker hypotheses.) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{IsQuasiIdempotent _ f}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">I</span> := isidem f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">J</span> : <span class="kr">forall</span> <span class="nv">x</span>, ap f (I x) = I (f x)
    := isidem2 f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The splitting will be the sequential limit of the sequence [... -&gt; X -&gt; X -&gt; X]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem</span> : <span class="kt">Type</span>
    := { a : nat -&gt; X &amp; <span class="kr">forall</span> <span class="nv">n</span>, f (a n.+<span class="mi">1</span>) = a n }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_pr1</span> : split_idem -&gt; (nat -&gt; X)
    := pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">split_idem_pr1</span> : split_idem &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> split_idem_pr1 / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The section, retraction, and the fact that the composite in one direction is [f] are easy. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_sect</span> : split_idem -&gt; X
    := <span class="kr">fun</span> <span class="nv">a</span> =&gt; a <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> split_idem_sect / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk85"><span class="kn">Definition</span> <span class="nf">split_idem_retr</span> : X -&gt; split_idem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; split_idem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; split_idem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk87"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk88"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt; f (f x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; I x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> split_idem_retr / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_splits</span> (<span class="nv">x</span> : X)
  : split_idem_sect (split_idem_retr x) = f x
    := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** What remains is to show that the composite in the other direction is the identity.  We begin by showing how to construct paths in [split_idem]. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk89"><span class="kn">Definition</span> <span class="nf">path_split_idem</span> {<span class="nv">a</span> <span class="nv">a&#39;</span> : split_idem}
    (<span class="nv">p</span> : a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span>)
    (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">n</span>, a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n)
  : a = a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8b"><span class="nb">simple refine</span> (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> = a&#39;.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk8c"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">a</span> : nat -&gt; X =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, f (a n.+<span class="mi">1</span>) = a n) <span class="nl">?p</span> a.<span class="mi">2</span> = a&#39;.<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> = a&#39;.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8e"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a.<span class="mi">1</span> n = a&#39;.<span class="mi">1</span> n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk8f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">a</span> : nat -&gt; X =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, f (a n.+<span class="mi">1</span>) = a n)
  (path_arrow a.<span class="mi">1</span> a&#39;.<span class="mi">1</span>
     ((<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; p n) : a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span>)) a.<span class="mi">2</span> = a&#39;.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk90"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">a</span> : nat -&gt; X =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, f (a n.+<span class="mi">1</span>) = a n)
  (path_arrow a.<span class="mi">1</span> a&#39;.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; p n)) a.<span class="mi">2</span> n =
a&#39;.<span class="mi">2</span> n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
          <span class="nb">rewrite</span> transport_forall_constant;
          <span class="nb">rewrite</span> transport_paths_FlFr;
          <span class="nb">rewrite</span> ap_apply_l, ap10_path_arrow;
          <span class="nb">rewrite</span> (ap_compose (<span class="kr">fun</span> <span class="nv">b</span> =&gt; b n.+<span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x) _);
          <span class="nb">rewrite</span> ap_apply_l, ap10_path_arrow;
          <span class="nb">rewrite</span> concat_pp_p;
          <span class="nb">apply</span> moveR_Vp; <span class="bp">by</span> <span class="nb">symmetry</span> ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And we verify how those paths compute under [split_idem_sect]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk91"><span class="kn">Definition</span> <span class="nf">sect_path_split_idem</span> {<span class="nv">a</span> <span class="nv">a&#39;</span> : split_idem}
    (<span class="nv">p</span> : a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span>)
    (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">n</span>, a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n)
  : ap split_idem_sect (path_split_idem p q) = p <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap split_idem_sect (path_split_idem p q) = p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap split_idem_sect (path_split_idem p q) = p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk93"><span class="nb">change</span> (ap ((<span class="kr">fun</span> <span class="nv">b</span> =&gt; b <span class="mi">0</span>) o pr1) (path_split_idem p q) = p <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap ((<span class="kr">fun</span> <span class="nv">b</span> : nat -&gt; X =&gt; b <span class="mi">0</span>) o pr1)
  (path_split_idem p q) = p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk94"><span class="nb">refine</span> (ap_compose pr1 (<span class="kr">fun</span> <span class="nv">b</span> =&gt; b <span class="mi">0</span>) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">b</span> : nat -&gt; X =&gt; b <span class="mi">0</span>)
  (ap pr1 (path_split_idem p q)) = p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk95"><span class="nb">refine</span> (ap (ap (<span class="kr">fun</span> <span class="nv">b</span> =&gt; b <span class="mi">0</span>)) (pr1_path_sigma _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">b</span> : nat -&gt; X =&gt; b <span class="mi">0</span>)
  (path_arrow a.<span class="mi">1</span> a&#39;.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; p n)) = p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk96"><span class="nb">refine</span> (ap_apply_l _ <span class="mi">0</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a.<span class="mi">1</span> == a&#39;.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
a.<span class="mi">2</span> n @ p n = ap f (p n.+<span class="mi">1</span>) @ a&#39;.<span class="mi">2</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10 (path_arrow a.<span class="mi">1</span> a&#39;.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; p n)) <span class="mi">0</span> =
p <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap10_path_arrow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Next we show that every element of [split_idem] can be nudged to an equivalent one in which all the elements of [X] occurring are double applications of [f]. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk97"><span class="kn">Local Definition</span> <span class="nf">nudge</span> (<span class="nv">a</span> : split_idem) : split_idem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk99"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; f (f (a (n.+<span class="mi">1</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, f (f (f (a n.+<span class="mi">2</span>))) = f (f (a n.+<span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9a"><span class="kn">Local Definition</span> <span class="nf">nudge_eq</span> <span class="nv">a</span> : nudge a = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nudge a = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nudge a = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9c">transparent <span class="nb">assert</span> (a&#39; : split_idem).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk9d"><hr></label><div class="goal-conclusion">nudge a = a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk9f"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">n</span> =&gt; f (a (n.+<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, f (f (a n.+<span class="mi">2</span>)) = f (a n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nudge a = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka1"><span class="nb">transitivity</span> a&#39;; <span class="nb">simple refine</span> (path_split_idem _ _); <span class="nb">intros</span> n; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a.<span class="mi">1</span> n.+<span class="mi">1</span>)) = f (a.<span class="mi">1</span> n.+<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chka2"><hr></label><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @ <span class="nl">?Goal</span> =
ap f <span class="nl">?Goal</span>@{n:=n.+<span class="mi">1</span>} @ ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chka3"><hr></label><div class="goal-conclusion">f (a.<span class="mi">1</span> n.+<span class="mi">1</span>) = a.<span class="mi">1</span> n</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chka4"><hr></label><div class="goal-conclusion">ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ <span class="nl">?Goal1</span> =
ap f <span class="nl">?Goal1</span>@{n:=n.+<span class="mi">1</span>} @ a.<span class="mi">2</span> n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a.<span class="mi">1</span> n.+<span class="mi">1</span>)) = f (a.<span class="mi">1</span> n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (I (a n.+<span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @ I (a n.+<span class="mi">1</span>) =
ap f (I (a n.+<span class="mi">2</span>)) @ ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((ap_compose f f _ @@ <span class="mi">1</span>)^
               @ concat_Ap I (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
               @ (J _ @@ <span class="mi">1</span>)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a.<span class="mi">1</span> n.+<span class="mi">1</span>) = a.<span class="mi">1</span> n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a.<span class="mi">2</span> n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (a n.+<span class="mi">1</span>);
<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>split_idem</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ a.<span class="mi">2</span> n = ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ a.<span class="mi">2</span> n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we&#39;re ready to prove the final condition.  We prove the two arguments of [path_split_idem] separately, in order to make the first one transparent and the second opaque. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chka9"><span class="kn">Local Definition</span> <span class="nf">split_idem_issect_part1</span> (<span class="nv">a</span> : split_idem) (<span class="nv">n</span> : nat)
  : f (f (a n.+<span class="mi">1</span>)) = f (a <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a n.+<span class="mi">1</span>)) = f (a <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a n.+<span class="mi">1</span>)) = f (a <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkab"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a <span class="mi">1</span>)) = f (a <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>f (f (a n.+<span class="mi">1</span>)) = f (a <span class="mi">0</span>)</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkac"><hr></label><div class="goal-conclusion">f (f (a n.+<span class="mi">2</span>)) = f (a <span class="mi">0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a <span class="mi">1</span>)) = f (a <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f (a.<span class="mi">2</span> <span class="mi">0</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>f (f (a n.+<span class="mi">1</span>)) = f (a <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f (a n.+<span class="mi">2</span>)) = f (a <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a n.+<span class="mi">1</span>))^ @ IH).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkaf"><span class="kn">Local Definition</span> <span class="nf">split_idem_issect_part2</span> (<span class="nv">a</span> : split_idem) (<span class="nv">n</span> : nat)
  : ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @ split_idem_issect_part1 a n =
    ap f ((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @ split_idem_issect_part1 a n) @ I (a.<span class="mi">1</span> <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @ split_idem_issect_part1 a n =
ap f
  ((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @
   split_idem_issect_part1 a n) @ I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @ split_idem_issect_part1 a n =
ap f
  ((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @
   split_idem_issect_part1 a n) @ I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb1"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>)) @ ap f (a.<span class="mi">2</span> <span class="mi">0</span>) =
ap f ((ap f (a.<span class="mi">2</span> <span class="mi">1</span>) @ (I (a.<span class="mi">1</span> <span class="mi">1</span>))^) @ ap f (a.<span class="mi">2</span> <span class="mi">0</span>)) @
I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)) @
split_idem_issect_part1 a n =
ap f
  ((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @
   split_idem_issect_part1 a n) @ I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkb2"><hr></label><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>)) @
((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @
 split_idem_issect_part1 a n) =
ap f
  ((ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>))^) @
   ((ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>) @ (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^) @
    split_idem_issect_part1 a n)) @ I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb3"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>))
@&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>) =
ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>)
      @&#39; (I (a.<span class="mi">1</span> <span class="mi">1</span>))^
      @&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>))
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkb4"><hr></label><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
    @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
    @&#39; split_idem_issect_part1 a n) =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>))^
   @&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
       @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
       @&#39; split_idem_issect_part1 a n))
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>))
@&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>) =
ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>)
      @&#39; (I (a.<span class="mi">1</span> <span class="mi">1</span>))^
      @&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>))
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb6"><span class="nb">rewrite</span> !ap_pp, ap_V, !concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>))
@&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>) =
ap f (ap f (a.<span class="mi">2</span> <span class="mi">1</span>))
@&#39; ((ap f (I (a.<span class="mi">1</span> <span class="mi">1</span>)))^
    @&#39; (ap f (ap f (a.<span class="mi">2</span> <span class="mi">0</span>))
        @&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb7"><span class="nb">apply</span> whiskerL, moveL_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (I (a.<span class="mi">1</span> <span class="mi">1</span>))
@&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>) = ap f (ap f (a.<span class="mi">2</span> <span class="mi">0</span>))
                  @&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb8"><span class="nb">rewrite</span> J.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">I (f (a.<span class="mi">1</span> <span class="mi">1</span>))
@&#39; ap f (a.<span class="mi">2</span> <span class="mi">0</span>) = ap f (ap f (a.<span class="mi">2</span> <span class="mi">0</span>))
                  @&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> &lt;- ap_compose; <span class="nb">symmetry</span>; <span class="nb">apply</span> (concat_Ap I).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
    @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
    @&#39; split_idem_issect_part1 a n) =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>))^
   @&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
       @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
       @&#39; split_idem_issect_part1 a n))
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkba"><span class="nb">rewrite</span> ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
    @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
    @&#39; split_idem_issect_part1 a n) =
ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
      @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>))^)
@&#39; ap f
     (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
      @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
      @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkbb"><span class="nb">refine</span> (_ @ (<span class="mi">1</span> @@ IH) @ concat_p_pp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
    @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
    @&#39; split_idem_issect_part1 a n) =
ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
      @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>))^)
@&#39; (ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
    @&#39; split_idem_issect_part1 a n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkbc"><span class="nb">rewrite</span> !ap_pp, !concat_p_pp, ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
@&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
@&#39; split_idem_issect_part1 a n =
ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (ap f (I (a.<span class="mi">1</span> n.+<span class="mi">2</span>)))^
@&#39; ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkbd"><span class="nb">rewrite</span> J.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
@&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
@&#39; split_idem_issect_part1 a n =
ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">2</span>))
@&#39; (I (f (a.<span class="mi">1</span> n.+<span class="mi">2</span>)))^
@&#39; ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkbe"><span class="nb">rewrite</span> &lt;- !ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ap f (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>))
@&#39; split_idem_issect_part1 a n =
ap f
  (ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
   @&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
   @&#39; split_idem_issect_part1 a n)
@&#39; I (a.<span class="mi">1</span> <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f (f x)) (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
@&#39; ap f (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
@&#39; (I (a.<span class="mi">1</span> n.+<span class="mi">1</span>))^
@&#39; split_idem_issect_part1 a n =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f (f x)) (a.<span class="mi">2</span> n.+<span class="mi">2</span>)
@&#39; (I (f (a.<span class="mi">1</span> n.+<span class="mi">2</span>)))^
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f (f x)) (a.<span class="mi">2</span> n.+<span class="mi">1</span>)
@&#39; split_idem_issect_part1 a n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> ((concat_pA_p (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (I x)^) _ _) @@ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkbf"><span class="kn">Definition</span> <span class="nf">split_idem_issect</span> (<span class="nv">a</span> : split_idem)
  : split_idem_retr (split_idem_sect a) = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retr (split_idem_sect a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retr (split_idem_sect a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc1"><span class="nb">refine</span> (_ @ nudge_eq a); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nudge a = split_idem_retr (split_idem_sect a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc2"><span class="nb">simple refine</span> (path_split_idem _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nudge a).<span class="mi">1</span> == (split_idem_retr (split_idem_sect a)).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chkc3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(nudge a).<span class="mi">2</span> n @ <span class="nl">?p</span> n =
ap f (<span class="nl">?p</span> n.+<span class="mi">1</span>) @
(split_idem_retr (split_idem_sect a)).<span class="mi">2</span> n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nudge a).<span class="mi">1</span> == (split_idem_retr (split_idem_sect a)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (split_idem_issect_part1 a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(nudge a).<span class="mi">2</span> n @ split_idem_issect_part1 a n =
ap f (split_idem_issect_part1 a n.+<span class="mi">1</span>) @
(split_idem_retr (split_idem_sect a)).<span class="mi">2</span> n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (split_idem_issect_part2 a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_retract</span> : RetractOf X
    := Build_RetractOf
         X split_idem split_idem_retr split_idem_sect split_idem_issect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_split</span> : Splitting f
    := (split_idem_retract ; split_idem_splits).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We end this section by showing that we can recover the witness [I] of pre-idempotence from the splitting. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc6"><span class="kn">Definition</span> <span class="nf">split_idem_preidem</span> (<span class="nv">x</span> : X)
  : ap split_idem_sect (split_idem_issect (split_idem_retr x))
    = I x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap split_idem_sect
  (split_idem_issect (split_idem_retr x)) = I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap split_idem_sect
  (split_idem_issect (split_idem_retr x)) = I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc8"><span class="nb">unfold</span> split_idem_issect, nudge_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap split_idem_sect
  ((path_split_idem
      (split_idem_issect_part1 (split_idem_retr x))
      (split_idem_issect_part2 (split_idem_retr x)))^ @
   (path_split_idem
      (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; I (split_idem_retr x n.+<span class="mi">1</span>))
      (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
       ((ap_compose f f ((split_idem_retr x).<span class="mi">2</span> n.+<span class="mi">1</span>) @@
         <span class="mi">1</span>)^ @
        concat_Ap I ((split_idem_retr x).<span class="mi">2</span> n.+<span class="mi">1</span>)) @
       (J ((split_idem_retr x).<span class="mi">1</span> n.+<span class="mi">2</span>) @@ <span class="mi">1</span>)^) @
    path_split_idem
      (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; (split_idem_retr x).<span class="mi">2</span> n)
      (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">1</span>))) = I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkc9"><span class="kp">repeat</span> (<span class="nb">rewrite</span> !ap_pp, <span class="nl">?ap_V</span>, !sect_path_split_idem; <span class="nb">simpl</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent f</span></span></span><br><span><var>I</var><span><span class="hyp-body"><b>:= </b><span>isidem f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f (f x) = f x</span></span></span></span><br><span><var>J</var><span><span class="hyp-body"><b>:= </b><span>isidem2 f</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (I x) = I (f x)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (I x))^ @ (I (f x) @ I x) = I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveR_Vp, whiskerR; <span class="nb">symmetry</span>; <span class="nb">apply</span> J.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** However, the particular witness [J] of quasi-idempotence can *not* in general be recovered from the splitting; we will mention a counterexample below.  This is analogous to how [eissect] and [eisretr] cannot both be recovered after [isequiv_adjointify]; one of them has to be modified. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Splitting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_retract&#39;</span> `{fs : Funext} {X : <span class="kt">Type</span>}
: QuasiIdempotent X -&gt; RetractOf X
:= <span class="kr">fun</span> <span class="nv">f</span> =&gt; split_idem_retract f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_idem_split&#39;</span> `{fs : Funext} {X : <span class="kt">Type</span>}
           (f : QuasiIdempotent X)
: Splitting f
:= split_idem_split f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Splitting already-split idempotents *)</span>

<span class="sd">(** In the other direction, suppose we are given a retract, we deduce from this a quasi-idempotent, and then split it by the above construction.  We will show that the resulting retract is equivalent to the original one, so that [RetractOf X] is itelf a retract of [QuasiIdempotent X]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AlreadySplit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{fs : Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : RetractOf X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">A</span> := retract_type R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">r</span> := retract_retr R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">s</span> := retract_sect R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">H</span> := retract_issect R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We begin by constructing an equivalence between [split_idem (s o r)] and [A].  We want to make this equivalence transparent so that we can reason about it later.  In fact, we want to reason not only about the equivalence function and its inverse, but the section and retraction homotopies!  Therefore, instead of using [equiv_adjointify] we will give the coherence proof explicitly, so that we can control these homotopies.  However, we can (and should) make the coherence proof itself opaque.  Thus, we prove it first, and end it with [Qed].  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkca"><span class="kn">Lemma</span> <span class="nf">equiv_split_idem_retract_isadj</span> (<span class="nv">a</span> : split_idem (s o r))
  : H (r (s (r (split_idem_sect (s o r) a)))) @
      H (r (split_idem_sect (s o r) a)) =
    ap (r o split_idem_sect (s o r))
       (ap (split_idem_retr (s o r))
           (<span class="mi">1</span> @
              ap (split_idem_sect (s o r))
              (split_idem_issect (s o r) a)) @
           split_idem_issect (s o r) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r (s (r (split_idem_sect (s o r) a)))) @
H (r (split_idem_sect (s o r) a)) =
ap (r o split_idem_sect (s o r))
  (ap (split_idem_retr (s o r))
     (<span class="mi">1</span> @
      ap (split_idem_sect (s o r))
        (split_idem_issect (s o r) a)) @
   split_idem_issect (s o r) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkcb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r (s (r (split_idem_sect (s o r) a)))) @
H (r (split_idem_sect (s o r) a)) =
ap (r o split_idem_sect (s o r))
  (ap (split_idem_retr (s o r))
     (<span class="mi">1</span> @
      ap (split_idem_sect (s o r))
        (split_idem_issect (s o r) a)) @
   split_idem_issect (s o r) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkcc"><span class="nb">rewrite</span> ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (<span class="mi">1</span> @
      ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
        (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkcd"><span class="nb">rewrite</span> &lt;- ap_compose; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
  (<span class="mi">1</span> @
   ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkce"><span class="nb">rewrite</span> concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkcf"><span class="nb">rewrite</span> &lt;- (ap_compose (split_idem_sect (s o r)) (r o s o r)
                           (split_idem_issect (s o r) a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r
     (s
        (r
           (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd0"><span class="nb">rewrite</span> (ap_compose _ (r o s o r) (split_idem_issect (s o r) a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd1"><span class="nb">rewrite</span> (ap_compose _ r (split_idem_issect (s o r) a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) @
ap r
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd2"><span class="nb">unfold</span> split_idem_issect, nudge_eq;
      <span class="kp">repeat</span> (<span class="nb">rewrite</span> !ap_pp, <span class="nl">?ap_V</span>, !sect_path_split_idem; <span class="nb">simpl</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
    (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
    (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a <span class="mi">1</span>)) @
  ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>))) @
((ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
 (ap r (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a <span class="mi">1</span>)) @
  ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd3"><span class="nb">unfold</span> isidem; <span class="nb">fold</span> r s H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
    (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (ap s (H (r (a <span class="mi">1</span>)))) @
  ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>))) @
((ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
 (ap r (ap s (H (r (a <span class="mi">1</span>)))) @ ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd4"><span class="nb">rewrite</span> !concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (ap s (H (r (a <span class="mi">1</span>)))) @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>) @
  ((ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
   (ap r (ap s (H (r (a <span class="mi">1</span>)))) @ ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd5"><span class="nb">rewrite</span> &lt;- !ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>) @
  ((ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
      (H (r (a <span class="mi">1</span>))) @ ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd6"><span class="nb">rewrite</span> &lt;- (ap_compose (s o r) r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x)))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (a.<span class="mi">2</span> <span class="mi">0</span>)))^ @
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>) @
  ((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>))^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
      (H (r (a <span class="mi">1</span>))) @ ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd7"><span class="nb">rewrite</span> &lt;- (ap_compose (s o r) (r o s o r)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r (s (r x))))) (a.<span class="mi">2</span> <span class="mi">0</span>))^ @
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>) @
  ((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>))^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
      (H (r (a <span class="mi">1</span>))) @ ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd8"><span class="nb">rewrite</span> (concat_p_Vp (ap (r o s o r) (a.<span class="mi">2</span> <span class="mi">0</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H
  (r
     (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r (s (r x))))) (a.<span class="mi">2</span> <span class="mi">0</span>))^ @
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>))) @
  ap r (a.<span class="mi">2</span> <span class="mi">0</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkd9">rewrite_moveL_Vp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r (s (r x))))) (a.<span class="mi">2</span> <span class="mi">0</span>) @
 H
   (r
      (s
         (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkda"><span class="nb">rewrite</span> (ap_compose (r o s o r) (r o s) (a.<span class="mi">2</span> <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>)) @
 H
   (r
      (s
         (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkdb"><span class="nb">rewrite</span> (concat_A1p H (ap (r o s o r) (a.<span class="mi">2</span> <span class="mi">0</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; r (s (r x))) (a.<span class="mi">2</span> <span class="mi">0</span>)) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkdc"><span class="nb">rewrite</span> (ap_compose r (r o s) (a.<span class="mi">2</span> <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (ap r (a.<span class="mi">2</span> <span class="mi">0</span>))) @
H (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkdd"><span class="nb">rewrite</span> (concat_pA1_p H (ap r (a.<span class="mi">2</span> <span class="mi">0</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @ H (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>))))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
ap r (a.<span class="mi">2</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkde"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @ H (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (a <span class="mi">1</span>))) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkdf"><span class="nb">refine</span> (cancelR _ _ (H (r (a.<span class="mi">1</span> <span class="mi">1</span>%nat))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @ H (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>))))) @
H (r (a.<span class="mi">1</span> <span class="mi">1</span>)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (a <span class="mi">1</span>)))) @
H (r (a.<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke0"><span class="nb">rewrite</span> (concat_pA1_p H (H (r (a <span class="mi">1</span>%nat)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @ H (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>))))) @
H (r (a.<span class="mi">1</span> <span class="mi">1</span>)) =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
   (H (r (a <span class="mi">1</span>))) @
 H (retract_retr R (retract_sect R (r (a <span class="mi">1</span>))))) @
H (r (a <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke1"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">symmetry</span>; <span class="nb">refine</span> (_ @ concat_pp_p _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (s o r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (a <span class="mi">1</span>))) @
(H (retract_retr R (retract_sect R (r (a <span class="mi">1</span>)))) @
 H (r (a <span class="mi">1</span>))) =
(H (r (s (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>)))))) @ H (r (s (r (a.<span class="mi">1</span> <span class="mi">1</span>))))) @
H (r (a.<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_A1p (<span class="kr">fun</span> <span class="nv">x</span> =&gt; H (r (s x)) @ H x) (H (r (a <span class="mi">1</span>%nat)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we can construct the desired equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke2"><span class="kn">Definition</span> <span class="nf">equiv_split_idem_retract</span>
  : split_idem (s o r) &lt;~&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem (s o r) &lt;~&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem (s o r) &lt;~&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke4"><span class="nb">simple refine</span> (Build_Equiv _ _ (r o split_idem_sect (s o r))
              (Build_IsEquiv _ _ _ (split_idem_retr (s o r) o s) _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : split_idem (s o r) =&gt;
 r (split_idem_sect (s o r) x))
o (split_idem_retr (s o r) o s) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chke5"><hr></label><div class="goal-conclusion">split_idem_retr (s o r) o s
o (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (s o r) =&gt;
   r (split_idem_sect (s o r) x)) == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chke6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : split_idem (s o r),
<span class="nl">?eisretr</span>
  ((<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
    r (split_idem_sect (s o r) x0)) x) =
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
   r (split_idem_sect (s o r) x0)) (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : split_idem (s o r) =&gt;
 r (split_idem_sect (s o r) x))
o (split_idem_retr (s o r) o s) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke8"><span class="nb">intros</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>retract_type R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (s (r (s a))) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H _ @ H _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chke9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retr (s o r) o s
o (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (s o r) =&gt;
   r (split_idem_sect (s o r) x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkea"><span class="nb">intros</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
  (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))) =
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkeb"><span class="nb">refine</span> (_ @ split_idem_issect (s o r) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
  (s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a))) =
split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
  (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkec"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s (r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chked"><span class="nb">refine</span> ((split_idem_splits (s o r) _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
  (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
     (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a)) =
split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, split_idem_issect; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : split_idem (s o r),
((<span class="kr">fun</span> <span class="nv">a</span> : retract_type R =&gt;
  H (retract_retr R (retract_sect R a)) @ H a
  :
  r
    (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0))
       (split_idem_retr (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) (s a))) =
  a)
 :
 (<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
  r (split_idem_sect (s o r) x0))
 o (split_idem_retr (s o r) o s) == idmap)
  ((<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
    r (split_idem_sect (s o r) x0)) x) =
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
   r (split_idem_sect (s o r) x0))
  (((<span class="kr">fun</span> <span class="nv">a</span> : split_idem (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) =&gt;
     ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)))
       ((split_idem_splits (s o r)
           (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) a))^ @
        ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)))
          (split_idem_issect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0))
             a)) @ split_idem_issect (s o r) a
     :
     split_idem_retr (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0))
       (s
          (r
             (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0))
                a))) = a)
    :
    split_idem_retr (s o r) o s
    o (<span class="kr">fun</span> <span class="nv">x0</span> : split_idem (s o r) =&gt;
       r (split_idem_sect (s o r) x0)) == idmap) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> a; <span class="nb">simpl</span>; <span class="nb">apply</span> equiv_split_idem_retract_isadj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It is easy to show that this equivalence respects the section and the retraction. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_split_idem_retract_retr</span> (<span class="nv">x</span> : X)
  : equiv_split_idem_retract (split_idem_retr (s o r) x) = r x
    := H (r x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_split_idem_retract_sect</span> (<span class="nv">a</span> : A)
  : split_idem_sect (s o r) (equiv_split_idem_retract^-<span class="mi">1</span> a) = s a
    := ap s (H a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Less trivial is to show that it respects the retract homotopy. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkef"><span class="kn">Definition</span> <span class="nf">equiv_split_idem_retract_issect</span> (<span class="nv">a</span> : A)
  : ap equiv_split_idem_retract
       (split_idem_issect (s o r) (equiv_split_idem_retract^-<span class="mi">1</span> a))
       @ eisretr equiv_split_idem_retract a
    = equiv_split_idem_retract_retr
        (split_idem_sect (s o r) (equiv_split_idem_retract^-<span class="mi">1</span> a))
        @ ap r (equiv_split_idem_retract_sect a)
        @ H a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap equiv_split_idem_retract
  (split_idem_issect (s o r)
     (equiv_split_idem_retract^-<span class="mi">1</span> a)) @
eisretr equiv_split_idem_retract a =
(equiv_split_idem_retract_retr
   (split_idem_sect (s o r)
      (equiv_split_idem_retract^-<span class="mi">1</span> a)) @
 ap r (equiv_split_idem_retract_sect a)) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap equiv_split_idem_retract
  (split_idem_issect (s o r)
     (equiv_split_idem_retract^-<span class="mi">1</span> a)) @
eisretr equiv_split_idem_retract a =
(equiv_split_idem_retract_retr
   (split_idem_sect (s o r)
      (equiv_split_idem_retract^-<span class="mi">1</span> a)) @
 ap r (equiv_split_idem_retract_sect a)) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
     (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s a))) @
(H (retract_retr R (retract_sect R a)) @ H a) =
(equiv_split_idem_retract_retr (s (r (s a))) @
 ap r (equiv_split_idem_retract_sect a)) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf2"><span class="nb">unfold</span> equiv_split_idem_retract_retr, equiv_split_idem_retract_sect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) =&gt;
   r (split_idem_sect (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; s (r x0)) x))
  (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
     (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s a))) @
(H (retract_retr R (retract_sect R a)) @ H a) =
(H (r (s (r (s a)))) @ ap r (ap s (H a))) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf3"><span class="nb">rewrite</span> ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap r
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
        (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s a)))) @
(H (retract_retr R (retract_sect R a)) @ H a) =
(H (r (s (r (s a)))) @ ap r (ap s (H a))) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf4"><span class="nb">unfold</span> split_idem_issect, nudge_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap r
  (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     ((path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
         (split_idem_issect_part1
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (s a)))
         (split_idem_issect_part2
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (s a))))^ @
      (path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
         (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
          isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (s a) n.+<span class="mi">1</span>))
         (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
          ((ap_compose (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
              ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                  (s a)).<span class="mi">2</span> n.+<span class="mi">1</span>) @@ <span class="mi">1</span>)^ @
           concat_Ap (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
             ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                 (s a)).<span class="mi">2</span> n.+<span class="mi">1</span>)) @
          (isidem2 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
             ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                 (s a)).<span class="mi">1</span> n.+<span class="mi">2</span>) @@ <span class="mi">1</span>)^) @
       path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
         (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
          (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
             (s a)).<span class="mi">2</span> n) (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">1</span>)))) @
(H (retract_retr R (retract_sect R a)) @ H a) =
(H (r (s (r (s a)))) @ ap r (ap s (H a))) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf5"><span class="kp">repeat</span> (<span class="nb">rewrite</span> !ap_pp, <span class="nl">?ap_V</span>, !sect_path_split_idem; <span class="nb">simpl</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap r
    (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
       (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s a))))^ @
 (ap r (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s (r (s a)))) @
  ap r (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s a)))) @
(H (retract_retr R (retract_sect R a)) @ H a) =
(H (r (s (r (s a)))) @ ap r (ap s (H a))) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf6"><span class="nb">unfold</span> isidem; <span class="nb">fold</span> A r s H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap r
    (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r (s a))))))^ @
 (ap r (ap s (H (r (s (r (s a)))))) @
  ap r (ap s (H (r (s a)))))) @ (H (r (s a)) @ H a) =
(H (r (s (r (s a)))) @ ap r (ap s (H a))) @ H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf7"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r (s a))))))^
@&#39; (ap r (ap s (H (r (s (r (s a))))))
    @&#39; ap r (ap s (H (r (s a)))))
@&#39; (H (r (s a))
    @&#39; H a) =
H (r (s (r (s a))))
@&#39; ap r (ap s (H a))
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf8"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">apply</span> moveR_Vp; <span class="nb">rewrite</span> !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap r (ap s (H (r (s (r (s a))))))
@&#39; ap r (ap s (H (r (s a))))
@&#39; H (r (s a))
@&#39; H a =
ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r (s a)))))
@&#39; H (r (s (r (s a))))
@&#39; ap r (ap s (H a))
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkf9"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r (s (r (s a)))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap r (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s a))))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** For some reason this last one needs help. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkfa"><span class="nb">rewrite</span> &lt;- (ap_compose (s o r o s) r (H (r (s a)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r (s (r (s a)))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkfb"><span class="nb">rewrite</span> &lt;- (ap_pp (r o s) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (H (r (s (r (s a))))
   @&#39; H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkfc"><span class="nb">rewrite</span> &lt;- (concat_A1p H (H (r (s a)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (ap
     (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt;
      retract_retr R (retract_sect R x)) (H (r (s a)))
   @&#39; H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkfd"><span class="nb">rewrite</span> ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (ap
     (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt;
      retract_retr R (retract_sect R x)) (H (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
     (H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkfe"><span class="nb">rewrite</span> &lt;- (ap_compose (r o s) (r o s) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
     (H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r (s a)))
@&#39; H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chkff"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">apply</span> whiskerL; <span class="nb">rewrite</span> !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r (s a)))
@&#39; H (r (s a))
@&#39; H a =
H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk100"><span class="nb">rewrite</span> (concat_A1p H (H (r (s a)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (retract_retr R (retract_sect R (r (s a))))
@&#39; H (r (s a))
@&#39; H a =
H (r (s (r (s a))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
@&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk101"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r (s a))
@&#39; H a = ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; r (s x)) (H a)
         @&#39; H a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">refine</span> (concat_A1p H (H a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We will also show that it respects the homotopy to the split map.  It&#39;s unclear whether this has any use. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk102"><span class="kn">Definition</span> <span class="nf">equiv_split_idem_retract_splits</span> (<span class="nv">x</span> : X)
  : split_idem_splits (s o r) x
    = ap (split_idem_sect (s o r))
         (eissect equiv_split_idem_retract
                  (split_idem_retr (s o r) x))^
      @ equiv_split_idem_retract_sect
        (equiv_split_idem_retract (split_idem_retr (s o r) x))
        @ ap s (equiv_split_idem_retract_retr x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_splits (s o r) x =
(ap (split_idem_sect (s o r))
   (eissect equiv_split_idem_retract
      (split_idem_retr (s o r) x))^ @
 equiv_split_idem_retract_sect
   (equiv_split_idem_retract
      (split_idem_retr (s o r) x))) @
ap s (equiv_split_idem_retract_retr x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk103"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_splits (s o r) x =
(ap (split_idem_sect (s o r))
   (eissect equiv_split_idem_retract
      (split_idem_retr (s o r) x))^ @
 equiv_split_idem_retract_sect
   (equiv_split_idem_retract
      (split_idem_retr (s o r) x))) @
ap s (equiv_split_idem_retract_retr x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk104"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_splits (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x =
(ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
   (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
      (<span class="mi">1</span> @
       ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
         (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))) @
    split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
      (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))^ @
 equiv_split_idem_retract_sect (r (s (r x)))) @
ap s (equiv_split_idem_retract_retr x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk105"><span class="nb">unfold</span> equiv_split_idem_retract_retr, equiv_split_idem_retract_sect, split_idem_splits.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
(ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
   (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
      (<span class="mi">1</span> @
       ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
         (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))) @
    split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
      (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))^ @
 ap s (H (r (s (r x))))) @ ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk106"><span class="nb">rewrite</span> concat_1p, concat_pp_p, ap_V; <span class="nb">apply</span> moveL_Vp; <span class="nb">rewrite</span> concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
  (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
        (split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
           (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))) @
   split_idem_issect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
     (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x)) =
ap s (H (r (s (r x)))) @ ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Brace yourself. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk107"><span class="nb">unfold</span> split_idem_issect, nudge_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
  (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
        ((path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (split_idem_issect_part1
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                  x))
            (split_idem_issect_part2
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                  x)))^ @
         (path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
             isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
               (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                  x n.+<span class="mi">1</span>))
            (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
             ((ap_compose (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                 ((split_idem_retr (<span class="kr">fun</span> ... =&gt; s ...)
                     x).<span class="mi">2</span> n.+<span class="mi">1</span>) @@ <span class="mi">1</span>)^ @
              concat_Ap
                (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
                ((split_idem_retr
                    (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">2</span> n.+<span class="mi">1</span>)) @
             (isidem2 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
                ((split_idem_retr
                    (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">1</span> n.+<span class="mi">2</span>) @@
              <span class="mi">1</span>)^) @
          path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
             (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">2</span>
               n) (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">1</span>)))) @
   ((path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
       (split_idem_issect_part1 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
          (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))
       (split_idem_issect_part2 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
          (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x)))^ @
    (path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
       (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
        isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
          (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x
             n.+<span class="mi">1</span>))
       (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
        ((ap_compose (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
            ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">2</span>
               n.+<span class="mi">1</span>) @@ <span class="mi">1</span>)^ @
         concat_Ap (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
           ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">2</span>
              n.+<span class="mi">1</span>)) @
        (isidem2 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
           ((split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">1</span>
              n.+<span class="mi">2</span>) @@ <span class="mi">1</span>)^) @
     path_split_idem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
       (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
        (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x).<span class="mi">2</span> n)
       (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">1</span>)))) =
ap s (H (r (s (r x)))) @ ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk108"><span class="kp">repeat</span> (<span class="nb">rewrite</span> !ap_pp, <span class="nl">?ap_V</span>, !sect_path_split_idem; <span class="nb">simpl</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
          (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))))^ @
 (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s (r x)))) @
  ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x)))) @
((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
    (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x))^ @
 (isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (s (r x)) @
  isidem (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) x)) =
ap s (H (r (s (r x)))) @ ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Whew, that&#39;s not so bad. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk109"><span class="nb">unfold</span> isidem; <span class="nb">fold</span> A r s H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))))^ @
 (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (ap s (H (r (s (r x)))))) @
  ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
    (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
       (ap s (H (r x)))))) @
((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))^ @
 (ap s (H (r (s (r x)))) @ ap s (H (r x)))) =
ap s (H (r (s (r x)))) @ ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10a"><span class="kn">Open Scope</span> long_path_scope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
   (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
      (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))))^
@&#39; (ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
      (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
         (ap s (H (r (s (r x))))))
    @&#39; ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
         (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
            (ap s (H (r x)))))
@&#39; ((ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))^
    @&#39; (ap s (H (r (s (r x))))
        @&#39; ap s (H (r x)))) =
ap s (H (r (s (r x))))
@&#39; ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10b"><span class="nb">rewrite</span> !concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
   (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
      (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))))^
@&#39; ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
        (ap s (H (r (s (r x))))))
@&#39; ap (split_idem_sect (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
     (ap (split_idem_retr (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)))
        (ap s (H (r x))))
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ap s (H (r x))))^
@&#39; ap s (H (r (s (r x))))
@&#39; ap s (H (r x)) =
ap s (H (r (s (r x))))
@&#39; ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10c"><span class="nb">rewrite</span> &lt;- !ap_compose; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))))^
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)))^
@&#39; ap s (H (r (s (r x))))
@&#39; ap s (H (r x)) =
ap s (H (r (s (r x))))
@&#39; ap s (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10d"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))))^
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)))^
@&#39; ap s (H (r (s (r x)))) = ap s (H (r (s (r x))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10e"><span class="nb">refine</span> (_ @ (concat_1p _)); <span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))))^
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))
@&#39; (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)))^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk10f"><span class="nb">apply</span> moveR_pV; <span class="nb">rewrite</span> concat_1p, concat_pp_p; <span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x))
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk110"><span class="nb">rewrite</span> &lt;- (ap_compose (s o r o s) (s o r)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; s (r (s (r (s x)))))
  (H (r x))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk111"><span class="nb">rewrite</span> (ap_compose (r o s) s _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
     (H (r (s (r x)))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; s (r (s (r (s x)))))
  (H (r x))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; s (r (s x))) (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk112"><span class="nb">rewrite</span> (ap_compose (r o s) s _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
     (H (r (s (r x)))))
@&#39; ap s
     (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; s (r (s (r (s x)))))
  (H (r x))
@&#39; ap s
     (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk113"><span class="nb">rewrite</span> (ap_compose (r o s o r o s) s _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
     (H (r (s (r x)))))
@&#39; ap s
     (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))) =
ap s
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
     (H (r x)))
@&#39; ap s
     (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk114"><span class="nb">rewrite</span> &lt;- !ap_pp; <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x)) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r x))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk115"><span class="nb">refine</span> (cancelR _ _ (H (r x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (H (r (s (r x))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r x))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk116"><span class="nb">rewrite</span> (concat_pA1_p H (H (r x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (H (r (s (r x))))
@&#39; H (retract_retr R (retract_sect R (r x)))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r x))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk117"><span class="nb">rewrite</span> (concat_pA1_p H (H (r x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (H (r (s (r x))))
@&#39; H (retract_retr R (retract_sect R (r x)))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r x))
@&#39; H (retract_retr R (retract_sect R (r x)))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk118"><span class="nb">refine</span> ((concat_A1p H (H (r (s (r x)))) @@ <span class="mi">1</span>) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (retract_retr R (retract_sect R (r (s (r x)))))
@&#39; H (r (s (r x)))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s (r (s x))))
  (H (r x))
@&#39; H (retract_retr R (retract_sect R (r x)))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk119"><span class="nb">rewrite</span> (ap_compose (r o s) (r o s) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (retract_retr R (retract_sect R (r (s (r x)))))
@&#39; H (r (s (r x)))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x))
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x)))
@&#39; H (retract_retr R (retract_sect R (r x)))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11a"><span class="nb">rewrite</span> (concat_A1p H (ap (r o s) (H (r x)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (retract_retr R (retract_sect R (r (s (r x)))))
@&#39; H (r (s (r x)))
@&#39; H (r x) =
H (r (s (retract_retr R (retract_sect R (r x)))))
@&#39; ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11b"><span class="nb">rewrite</span> !concat_pp_p; <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>A</var><span><span class="hyp-body"><b>:= </b><span>retract_type R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>retract_retr R</span></span><span class="hyp-type"><b>: </b><span>X -&gt; retract_type R</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span>retract_sect R</span></span><span class="hyp-type"><b>: </b><span>retract_type R -&gt; X</span></span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>retract_issect R</span></span><span class="hyp-type"><b>: </b><span>retract_retr R o retract_sect R == idmap</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r (s (r x)))
@&#39; H (r x) =
ap (<span class="kr">fun</span> <span class="nv">x</span> : retract_type R =&gt; r (s x)) (H (r x))
@&#39; H (r x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">refine</span> (concat_A1p H (H (r x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> long_path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AlreadySplit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using these facts, we can show that [RetractOf X] is a retract of [QuasiIdempotent X]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">RetractOfRetracts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{ua : Univalence} {X : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11c"><span class="kn">Definition</span> <span class="nf">retract_retractof_qidem</span> : RetractOf (QuasiIdempotent X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (QuasiIdempotent X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (QuasiIdempotent X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11e"><span class="nb">refine</span> (Build_RetractOf (QuasiIdempotent X)
                            (RetractOf X)
                            split_idem_retract&#39;
                            qidem_retract _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : RetractOf X =&gt;
 split_idem_retract&#39; (qidem_retract x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk11f"><span class="nb">intros</span> R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem_retract&#39; (qidem_retract R) = R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@path_retractof _ _
             (split_idem_retract&#39; (qidem_retract R)) R
             (equiv_split_idem_retract R)
             (equiv_split_idem_retract_retr R)
             (equiv_split_idem_retract_sect R)
             (equiv_split_idem_retract_issect R)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We have a similar result for splittings of a fixed map [f].  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk120"><span class="kn">Definition</span> <span class="nf">splitting_retractof_isqidem</span> (<span class="nv">f</span> : X -&gt; X)
  : RetractOf { I : IsPreIdempotent f &amp; IsQuasiIdempotent f }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf
  {I : IsPreIdempotent f &amp; IsQuasiIdempotent f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk121"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf
  {I : IsPreIdempotent f &amp; IsQuasiIdempotent f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk122"><span class="nb">simple refine</span> (@equiv_retractof&#39;
              _ (@retractof_equiv&#39;
                   (hfiber quasiidempotent_pr1 f) _ _
                   (retractof_hfiber
                      retract_retractof_qidem quasiidempotent_pr1 retract_idem
                      (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) f))
              (Splitting f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber quasiidempotent_pr1 f &lt;~&gt;
{I : IsPreIdempotent f &amp; IsQuasiIdempotent f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk123" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk123"><hr></label><div class="goal-conclusion">retract_type
  (retractof_equiv&#39; <span class="nl">?f</span>
     (retractof_hfiber retract_retractof_qidem
        quasiidempotent_pr1 retract_idem
        (<span class="kr">fun</span> <span class="nv">x</span> : QuasiIdempotent X =&gt; <span class="mi">1</span>) f)) &lt;~&gt;
Splitting f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber quasiidempotent_pr1 f &lt;~&gt;
{I : IsPreIdempotent f &amp; IsQuasiIdempotent f}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk125"><span class="nb">refine</span> ((hfiber_fibration f
                  (<span class="kr">fun</span> <span class="nv">g</span> =&gt; { I : IsPreIdempotent g &amp; @IsQuasiIdempotent _ g I }))^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber quasiidempotent_pr1 f &lt;~&gt; hfiber pr1 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk126"><span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : QuasiIdempotent X &amp; x = f} &lt;~&gt;
{x
: {g : X -&gt; X &amp;
  {I : IsPreIdempotent g &amp; IsQuasiIdempotent g}} &amp;
x.<span class="mi">1</span> = f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk127"><span class="nb">refine</span> (equiv_functor_sigma&#39; (equiv_sigma_assoc _ _)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; _)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{f : PreIdempotent X &amp; IsQuasiIdempotent f}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = f &lt;~&gt; (a.<span class="mi">1</span>).<span class="mi">1</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk128"><span class="nb">destruct</span> a <span class="kr">as</span> [[g I] J]; <span class="nb">unfold</span> quasiidempotent_pr1; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent g</span></span></span><br><span><var>J</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent (g; I)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = f &lt;~&gt; g = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk129">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">retract_type
  (retractof_equiv&#39;
     ((hfiber_fibration f
         (<span class="kr">fun</span> <span class="nv">g</span> : X -&gt; X =&gt;
          {I : IsPreIdempotent g &amp;
          IsQuasiIdempotent g}))^-<span class="mi">1</span>
      oE (equiv_functor_sigma&#39;
            (equiv_sigma_assoc IsPreIdempotent
               (<span class="kr">fun</span> <span class="nv">f</span> : PreIdempotent X =&gt;
                IsQuasiIdempotent f))^-<span class="mi">1</span>
            (<span class="kr">fun</span>
               <span class="nv">a</span> : {f : PreIdempotent X &amp;
                   IsQuasiIdempotent f} =&gt;
             (<span class="kr">fun</span>
                <span class="nv">proj2</span> : {a0 : X -&gt; X &amp;
                        IsPreIdempotent a0} =&gt;
              (<span class="kr">fun</span> (<span class="nv">g</span> : X -&gt; X)
                 (<span class="nv">I</span> : IsPreIdempotent g)
                 (<span class="nv">J</span> : IsQuasiIdempotent (g; I)) =&gt;
               (<span class="mi">1</span> : ((g; I); J).<span class="mi">1</span> = f &lt;~&gt; g = f)
               :
               ((g; I); J) = f &lt;~&gt; g = f) proj2.<span class="mi">1</span>
                proj2.<span class="mi">2</span>) a.<span class="mi">1</span> a.<span class="mi">2</span>
             :
             a = f &lt;~&gt;
             ((equiv_sigma_assoc IsPreIdempotent
                 (<span class="kr">fun</span> <span class="nv">f</span> : PreIdempotent X =&gt;
                  IsQuasiIdempotent f))^-<span class="mi">1</span> a).<span class="mi">1</span> = f)
          :
          hfiber quasiidempotent_pr1 f &lt;~&gt;
          hfiber pr1 f))
     (retractof_hfiber retract_retractof_qidem
        quasiidempotent_pr1 retract_idem
        (<span class="kr">fun</span> <span class="nv">x</span> : QuasiIdempotent X =&gt; <span class="mi">1</span>) f)) &lt;~&gt;
Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber retract_idem f &lt;~&gt; Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12b"><span class="nb">unfold</span> hfiber, Splitting.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : RetractOf X &amp; retract_idem x = f} &lt;~&gt;
{R : RetractOf X &amp; retract_idem R == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12c"><span class="nb">refine</span> (equiv_functor_sigma_id _);
        <span class="nb">intros</span> R; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) = f &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_ap10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And also for splittings of a fixed map that also induce a given witness of pre-idempotency. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Splitting_PreIdempotent</span> (<span class="nv">f</span> : PreIdempotent X)
  := { S : Splitting f &amp;
       <span class="kr">forall</span> <span class="nv">x</span>, ap f (S.<span class="mi">2</span> x)^
                 @ (S.<span class="mi">2</span> (retract_idem S.<span class="mi">1</span> x))^
                 @ ap (retract_sect S.<span class="mi">1</span>) (retract_issect S.<span class="mi">1</span> (retract_retr S.<span class="mi">1</span> x))
                 @ S.<span class="mi">2</span> x
                 = (isidem f x) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12d"><span class="kn">Definition</span> <span class="nf">splitting_preidem_retractof_qidem</span> (<span class="nv">f</span> : PreIdempotent X)
  : RetractOf (IsQuasiIdempotent f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (IsQuasiIdempotent f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RetractOf (IsQuasiIdempotent f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk12f"><span class="nb">simple refine</span> (@equiv_retractof&#39;
              _ (@retractof_equiv&#39;
                   (hfiber (@pr1 _ (<span class="kr">fun</span> <span class="nv">fi</span> =&gt; @IsQuasiIdempotent _ fi.<span class="mi">1</span> fi.<span class="mi">2</span>)) f) _ _
                   (retractof_hfiber
                      retract_retractof_qidem pr1 preidem_retract
                      _ f))
              (Splitting_PreIdempotent f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber pr1 f &lt;~&gt; IsQuasiIdempotent f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk130" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk130"><hr></label><div class="goal-conclusion">preidem_retract o retract_retr retract_retractof_qidem ==
pr1</div></blockquote><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk131"><hr></label><div class="goal-conclusion">retract_type
  (retractof_equiv&#39; <span class="nl">?f</span>
     (retractof_hfiber retract_retractof_qidem pr1
        preidem_retract <span class="nl">?p</span> f)) &lt;~&gt;
Splitting_PreIdempotent f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber pr1 f &lt;~&gt; IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (hfiber_fibration f _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk133">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">preidem_retract o retract_retr retract_retractof_qidem ==
pr1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk134"><span class="nb">intros</span> [[g I] J]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent g</span></span></span><br><span><var>J</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent (g; I)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ((g; I); J) x;
<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
ap (split_idem_sect ((g; I); J))
  (split_idem_issect ((g; I); J)
     (split_idem_retr ((g; I); J) x))) = (g; I)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk135"><span class="nb">refine</span> (path_sigma&#39; _ <span class="mi">1</span> _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent g</span></span></span><br><span><var>J</var><span class="hyp-type"><b>: </b><span>IsQuasiIdempotent (g; I)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 ap (split_idem_sect ((g; I); J))
   (split_idem_issect ((g; I); J)
      (split_idem_retr ((g; I); J) x))) = I</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> x; <span class="nb">apply</span> split_idem_preidem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk136">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">retract_type
  (retractof_equiv&#39;
     (hfiber_fibration f
        (<span class="kr">fun</span> <span class="nv">fi</span> : {x : _ &amp; IsPreIdempotent x} =&gt;
         IsQuasiIdempotent fi.<span class="mi">1</span>))^-<span class="mi">1</span>
     (retractof_hfiber retract_retractof_qidem pr1
        preidem_retract
        ((<span class="kr">fun</span> <span class="nv">x</span> : QuasiIdempotent X =&gt;
          (<span class="kr">fun</span> <span class="nv">proj2</span> : PreIdempotent X =&gt;
           (<span class="kr">fun</span> (<span class="nv">g</span> : X -&gt; X) (<span class="nv">I</span> : IsPreIdempotent g)
              (<span class="nv">J</span> : IsQuasiIdempotent (g; I)) =&gt;
            path_sigma&#39;
              (<span class="kr">fun</span> <span class="nv">f</span> : X -&gt; X =&gt; IsPreIdempotent f) <span class="mi">1</span>
              (path_forall
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                  ap (split_idem_sect (...; J))
                    (split_idem_issect (...; J) (...)))
                 I
                 ((<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   split_idem_preidem (...; J) x0)
                  :
                  (<span class="kr">fun</span> ... =&gt; ap ... ...) == I)
               :
               transport
                 (<span class="kr">fun</span> <span class="nv">f</span> : X -&gt; X =&gt; IsPreIdempotent f)
                 <span class="mi">1</span>
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                  ap (split_idem_sect ...)
                    (split_idem_issect ... ...)) = I)
            :
            preidem_retract
              (retract_retr retract_retractof_qidem
                 ((g; I); J)) = ((g; I); J).<span class="mi">1</span>) proj2.<span class="mi">1</span>
             proj2.<span class="mi">2</span>) x.<span class="mi">1</span> x.<span class="mi">2</span>)
         :
         preidem_retract
         o retract_retr retract_retractof_qidem == pr1)
        f)) &lt;~&gt; Splitting_PreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk137"><span class="nb">simpl</span>; <span class="nb">unfold</span> hfiber, Splitting.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : RetractOf X &amp;
(<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; retract_sect x (retract_retr x x0);
<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
ap (retract_sect x)
  (retract_issect x (retract_retr x x0))) = f} &lt;~&gt;
Splitting_PreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk138"><span class="nb">refine</span> (equiv_sigma_assoc _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : RetractOf X &amp;
(<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; retract_sect x (retract_retr x x0);
<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
ap (retract_sect x)
  (retract_issect x (retract_retr x x0))) = f} &lt;~&gt;
{a : RetractOf X &amp;
{p : retract_idem a == f &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
((ap f ((a; p).<span class="mi">2</span> x)^ @
  ((a; p).<span class="mi">2</span> (retract_idem (a; p).<span class="mi">1</span> x))^) @
 ap (retract_sect (a; p).<span class="mi">1</span>)
   (retract_issect (a; p).<span class="mi">1</span> (retract_retr (a; p).<span class="mi">1</span> x))) @
(a; p).<span class="mi">2</span> x = isidem f x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk139"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> R; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x);
<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
ap (retract_sect R)
  (retract_issect R (retract_retr R x))) = f &lt;~&gt;
{p
: (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) ==
  f &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
((ap f (p x)^ @
  (p (retract_sect R (retract_retr R x)))^) @
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) @ p x =
isidem f x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13a"><span class="nb">refine</span> (_ oE (equiv_path_sigma _ _ _)^-<span class="mi">1</span>); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p
: (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) =
  f.<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">f</span> : X -&gt; X =&gt; IsPreIdempotent f) p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   ap (retract_sect R)
     (retract_issect R (retract_retr R x))) = f.<span class="mi">2</span>} &lt;~&gt;
{p
: (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) ==
  f &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
((ap f (p x)^ @
  (p (retract_sect R (retract_retr R x)))^) @
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) @ p x =
isidem f x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13b"><span class="nb">refine</span> (equiv_functor_sigma&#39; (equiv_ap10 _ _) _); <span class="nb">intros</span> H; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>PreIdempotent X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) =
f.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">f</span> : X -&gt; X =&gt; IsPreIdempotent f) H
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   ap (retract_sect R)
     (retract_issect R (retract_retr R x))) = f.<span class="mi">2</span> &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X,
 ((ap f (ap10 H x)^ @
   (ap10 H (retract_sect R (retract_retr R x)))^) @
  ap (retract_sect R)
    (retract_issect R (retract_retr R x))) @ ap10 H x =
 isidem f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13c"><span class="nb">destruct</span> f <span class="kr">as</span> [f I]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) =
f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">f</span> : X -&gt; X =&gt; IsPreIdempotent f) H
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   ap (retract_sect R)
     (retract_issect R (retract_retr R x))) = I &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X,
 ((ap f (ap10 H x)^ @
   (ap10 H (retract_sect R (retract_retr R x)))^) @
  ap (retract_sect R)
    (retract_issect R (retract_retr R x))) @ ap10 H x =
 isidem f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13d"><span class="nb">destruct</span> H; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) = I &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X,
 (<span class="mi">1</span> @
  ap (retract_sect R)
    (retract_issect R (retract_retr R x))) @ <span class="mi">1</span> =
 isidem
   (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; retract_sect R (retract_retr R x0))
   x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13e"><span class="nb">refine</span> (_ oE (equiv_path_forall _ _)^-<span class="mi">1</span>);
        <span class="nb">unfold</span> pointwise_paths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X,
 ap (retract_sect R)
   (retract_issect R (retract_retr R x)) = I x) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X,
 (<span class="mi">1</span> @
  ap (retract_sect R)
    (retract_issect R (retract_retr R x))) @ <span class="mi">1</span> =
 isidem
   (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; retract_sect R (retract_retr R x0))
   x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk13f"><span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (retract_sect R)
  (retract_issect R (retract_retr R x)) = I x &lt;~&gt;
(<span class="mi">1</span> @
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) @ <span class="mi">1</span> =
isidem
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk140"><span class="nb">unfold</span> isidem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (retract_sect R)
  (retract_issect R (retract_retr R x)) = I x &lt;~&gt;
(<span class="mi">1</span> @
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) @ <span class="mi">1</span> = I x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk141"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsPreIdempotent
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; retract_sect R (retract_retr R x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @
 ap (retract_sect R)
   (retract_issect R (retract_retr R x))) @ <span class="mi">1</span> =
ap (retract_sect R)
  (retract_issect R (retract_retr R x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _ @ concat_1p _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">RetractOfRetracts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Fully coherent idempotents *)</span>

<span class="sd">(** This gives us a way to define fully coherent idempotents.  By Corollary 4.4.5.14 of *Higher Topos Theory*, if we assume univalence then [RetractOf X] has the correct homotopy type of the type of fully coherent idempotents on [X].  However, its defect is that it raises the universe level.  But now that we&#39;ve shown that [RetractOf X] is a retract of the type [QuasiIdempotent X], which is of the same size as [X], we can obtain an equivalent type by splitting the resulting idempotent on [QuasiIdempotent X].</span>

<span class="sd">For convenience, we instead split the idempotent on splittings of a fixed map [f], and then sum them up to obtain the type of idempotents. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CoherentIdempotents</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">ua</span> : Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsIdempotent</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
    := is_coherent_idem : split_idem (retract_idem (splitting_retractof_isqidem f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_IsIdempotent</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
  : Splitting f -&gt; IsIdempotent f
    := (equiv_split_idem_retract (splitting_retractof_isqidem f))^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isidem_isqidem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) `{IsQuasiIdempotent _ f}
  : IsIdempotent f
    := Build_IsIdempotent f (split_idem_split f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk142">#[export] <span class="kn">Instance</span> <span class="nf">ispreidem_isidem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
         `{IsIdempotent _ f} : IsPreIdempotent f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsIdempotent f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk143"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsIdempotent f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPreIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk144"><span class="nb">refine</span> (split_idem_sect (retract_idem (splitting_retractof_isqidem f)) _).<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsIdempotent f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">split_idem
  (retract_idem (splitting_retractof_isqidem f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk145">#[export] <span class="kn">Instance</span> <span class="nf">isqidem_isidem</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X)
         `{IsIdempotent _ f} : @IsQuasiIdempotent X f (ispreidem_isidem f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsIdempotent f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk146"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsIdempotent f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsQuasiIdempotent f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (split_idem_sect (retract_idem (splitting_retractof_isqidem f)) _).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Idempotent</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := { f : X -&gt; X &amp; IsIdempotent f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">idempotent_pr1</span> {<span class="nv">X</span> : <span class="kt">Type</span>} : Idempotent X -&gt; (X -&gt; X) := pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">idempotent_pr1</span> : Idempotent &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isidem_idem</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Idempotent X) : IsIdempotent f
    := f.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The above definitions depend on [Univalence].  Technically this is the case by their construction, since they are a splitting of a map that we only know to be idempotent in the presence of univalence.  This map could be defined, and hence &quot;split&quot;, without univalence; but also only with univalence do we know that they have the right homotopy type.  Thus univalence is used in two places: concluding (meta-theoretically) from HTT 4.4.5.14 that [RetractOf X] has the right homotopy type, and showing (in the next lemma) that it is equivalent to [Idempotent X].  In the absence of univalence, we don&#39;t currently have *any* provably-correct definition of the type of coherent idempotents; it ought to involve an infinite tower of coherences as defined in HTT section 4.4.5.   However, there may be some Yoneda-like meta-theoretic argument which would imply that the above-defined types do have the correct homotopy type without univalence (though almost certainly not without funext). *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk147"><span class="kn">Definition</span> <span class="nf">equiv_idempotent_retractof</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
  : Idempotent X &lt;~&gt; RetractOf X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent X &lt;~&gt; RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk148"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent X &lt;~&gt; RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk149"><span class="nb">transitivity</span> ({ f : X -&gt; X &amp; Splitting f }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent X &lt;~&gt; {f : X -&gt; X &amp; Splitting f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk14a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk14a"><hr></label><div class="goal-conclusion">{f : X -&gt; X &amp; Splitting f} &lt;~&gt; RetractOf X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent X &lt;~&gt; {f : X -&gt; X &amp; Splitting f}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14c"><span class="nb">unfold</span> Idempotent.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : X -&gt; X &amp; IsIdempotent f} &lt;~&gt;
{f : X -&gt; X &amp; Splitting f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14d"><span class="nb">refine</span> (equiv_functor_sigma&#39; (equiv_idmap _) _); <span class="nb">intros</span> f; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIdempotent f &lt;~&gt; Splitting f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (equiv_split_idem_retract (splitting_retractof_isqidem f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : X -&gt; X &amp; Splitting f} &lt;~&gt; RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk14f"><span class="nb">unfold</span> Splitting.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : X -&gt; X &amp; {R : RetractOf X &amp; retract_idem R == f}} &lt;~&gt;
RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk150"><span class="nb">refine</span> (_ oE equiv_sigma_symm _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : RetractOf X &amp; {a : X -&gt; X &amp; retract_idem b == a}} &lt;~&gt;
RetractOf X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk151"><span class="nb">apply</span> equiv_sigma_contr; <span class="nb">intros</span> R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>RetractOf X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {a : X -&gt; X &amp; retract_idem R == a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contr_basedhomotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** For instance, here is the standard coherent idempotent structure on the identity map. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isidem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{i})
  : @IsIdempotent@{i i j} X idmap
    := Build_IsIdempotent idmap (splitting_idmap X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">idem_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{i}) : Idempotent@{i i j} X
  := (idmap ; isidem_idmap X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CoherentIdempotents</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quasi-idempotents need not be fully coherent *)</span>

<span class="sd">(** We have shown that every quasi-idempotent can be &quot;coherentified&quot; into a fully coherent idempotent, analogously to how every quasi-inverse can be coherentified into an equivalence.  However, just as for quasi-inverses, not every witness to quasi-idempotency *is itself* coherent.  This is in contrast to a witness of pre-idempotency, which (if it extends to a quasi-idempotent) can itself be extended to a coherent idempotent; this is roughly the content of [split_idem_preidem] and [splitting_preidem_retractof_qidem].</span>

<span class="sd">  The key step in showing this is to observe that when [f] is the identity, the retract type [Splitting_PreIdempotent f] of [splitting_preidem_retractof_qidem] is equivalent to the type of types-equivalent-to-[X], and hence contractible. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk152"><span class="kn">Definition</span> <span class="nf">contr_splitting_preidem_idmap</span> {<span class="nv">ua</span> : Univalence} (<span class="nv">X</span> : <span class="kt">Type</span>)
: Contr (Splitting_PreIdempotent (preidem_idmap X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Splitting_PreIdempotent (preidem_idmap X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk153"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Splitting_PreIdempotent (preidem_idmap X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk154"><span class="nb">refine</span> (contr_equiv&#39; {Y : <span class="kt">Type</span> &amp; X &lt;~&gt; Y} _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; X &lt;~&gt; Y} &lt;~&gt;
Splitting_PreIdempotent (preidem_idmap X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk155"><span class="nb">transitivity</span> { S : Splitting (preidem_idmap X) &amp;
                     <span class="kr">forall</span> <span class="nv">x</span> : X, (retract_issect S.<span class="mi">1</span>) (retract_retr S.<span class="mi">1</span> x) = ap (retract_retr S.<span class="mi">1</span>) (S.<span class="mi">2</span> x) }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; X &lt;~&gt; Y} &lt;~&gt;
{S : Splitting (preidem_idmap X) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
retract_issect S.<span class="mi">1</span> (retract_retr S.<span class="mi">1</span> x) =
ap (retract_retr S.<span class="mi">1</span>) (S.<span class="mi">2</span> x)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="idempotents-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="idempotents-v-chk156"><hr></label><div class="goal-conclusion">{S : Splitting (preidem_idmap X) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
retract_issect S.<span class="mi">1</span> (retract_retr S.<span class="mi">1</span> x) =
ap (retract_retr S.<span class="mi">1</span>) (S.<span class="mi">2</span> x)} &lt;~&gt;
Splitting_PreIdempotent (preidem_idmap X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk157"><span class="mi">1</span>:make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{S : Splitting (preidem_idmap X) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
retract_issect S.<span class="mi">1</span> (retract_retr S.<span class="mi">1</span> x) =
ap (retract_retr S.<span class="mi">1</span>) (S.<span class="mi">2</span> x)} &lt;~&gt;
Splitting_PreIdempotent (preidem_idmap X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk158"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> [[Y r s eta] ep]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, eta (r x) = ap r (ep x)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X,
 ((ap idmap (ep x)^ @ (ep (s (r x)))^) @
  ap s (eta (r x))) @ ep x = ispreidem_idmap X x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk159"><span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
((ap idmap (ep x)^ @ (ep (s (r x)))^) @
 ap s (eta (r x))) @ ep x = ispreidem_idmap X x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15a"><span class="nb">unfold</span> ispreidem_idmap; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
((ap idmap (ep x)^ @ (ep (s (r x)))^) @
 ap s (eta (r x))) @ ep x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15b"><span class="nb">rewrite</span> ap_idmap, !concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
(ep x)^ @
((ep (s (r x)))^ @ (ap s (eta (r x)) @ ep x)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15c"><span class="nb">refine</span> (equiv_moveR_Vp _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
(ep (s (r x)))^ @ (ap s (eta (r x)) @ ep x) = ep x @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15d"><span class="nb">rewrite</span> concat_p1, concat_p_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
((ep (s (r x)))^ @ ap s (eta (r x))) @ ep x = ep x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15e"><span class="nb">refine</span> (equiv_concat_r (concat_1p _) _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
((ep (s (r x)))^ @ ap s (eta (r x))) @ ep x = <span class="mi">1</span> @ ep x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk15f"><span class="nb">refine</span> (equiv_whiskerR _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
(ep (s (r x)))^ @ ap s (eta (r x)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk160"><span class="nb">refine</span> (equiv_moveR_Vp _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
ap s (eta (r x)) = ep (s (r x)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk161"><span class="nb">rewrite</span> concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
ap s (eta (r x)) = ep (s (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk162"><span class="nb">pose</span> (isequiv_adjointify s r ep eta).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>isequiv_adjointify s r ep eta</span></span><span class="hyp-type"><b>: </b><span>IsEquiv s</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (r x) = ap r (ep x) &lt;~&gt;
ap s (eta (r x)) = ep (s (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk163"><span class="nb">refine</span> (_ oE equiv_ap (ap s) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>isequiv_adjointify s r ep eta</span></span><span class="hyp-type"><b>: </b><span>IsEquiv s</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s (eta (r x)) = ap s (ap r (ep x)) &lt;~&gt;
ap s (eta (r x)) = ep (s (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk164"><span class="nb">apply</span> equiv_concat_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>isequiv_adjointify s r ep eta</span></span><span class="hyp-type"><b>: </b><span>IsEquiv s</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s (ap r (ep x)) = ep (s (r x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk165"><span class="nb">refine</span> (cancelR _ _ (ep x) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>isequiv_adjointify s r ep eta</span></span><span class="hyp-type"><b>: </b><span>IsEquiv s</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap s (ap r (ep x)) @ ep x = ep (s (r x)) @ ep x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="idempotents-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="idempotents-v-chk166"><span class="nb">rewrite</span> &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ua</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; r (s x)) == idmap</span></span></span><br><span><var>ep</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) == idmap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>isequiv_adjointify s r ep eta</span></span><span class="hyp-type"><b>: </b><span>IsEquiv s</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (r x)) (ep x) @ ep x =
ep (s (r x)) @ ep x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_A1p ep (ep x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Therefore, there is a unique coherentification of the canonical witness [preidem_idmap] of pre-idempotency for the identity.  Hence, to show that not every quasi-idempotent is coherent, it suffices to give a witness of quasi-idempotency extending [preidem_idmap] which is nontrivial (i.e. not equal to [qidem_idmap]).  Such a witness is exactly an element of the 2-center, and we know that some types such as [BAut (BAut Bool)] have nontrivial 2-centers.  In [Spaces.BAut.Bool.IncoherentIdempotent] we use this to construct an explicit counterexample. *)</span>


<span class="sd">(** ** A pre-idempotent that is not quasi-idempotent *)</span>

<span class="sd">(** We can also give a specific example of a pre-idempotent that does not split, hence is not coherentifiable and not even quasi-idempotent.  The construction is inspired by Warning 1.2.4.8 in *Higher Algebra*, and can be found in [Spaces.BAut.Cantor]. *)</span></span></pre>
</div>
</div></body>
</html>
