<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Sigma.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Theorems about Sigma-types (dependent sums) *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk0"><span class="kn">Require Import</span> HoTT.Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Arrow Types.Paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B C f g n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In homotopy type theory, we think of elements of [Type] as spaces, homotopy types, or weak omega-groupoids. A type family [P : A -&gt; Type] corresponds to a fibration whose base is [A] and whose fiber over [x] is [P x].</span>

<span class="sd">From such a [P] we can build a total space over the base space [A] so that the fiber over [x : A] is [P x]. This is just Coq&#39;s dependent sum construction, written as [sig P] or [{x : A &amp; P x}]. The elements of [{x : A &amp; P x}] are pairs, written [exist P x y] in Coq, where [x : A] and [y : P x].  In [Overture.v], we defined the notation [(x; y)] to mean [exist _ x y].</span>

<span class="sd">The base and fiber components of a point in the total space are extracted with the two projections [pr1] and [pr2]. *)</span>

<span class="sd">(** ** Eta conversion *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} (u : sig P)
  : (u.<span class="mi">1</span>; u.<span class="mi">2</span>) = u
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eta_sigma / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta2_sigma</span> `{P : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), <span class="kt">Type</span>}
           (u : sig (<span class="kr">fun</span> <span class="nv">a</span> =&gt; sig (P a)))
  : (u.<span class="mi">1</span>; u.<span class="mi">2</span>.<span class="mi">1</span>; u.<span class="mi">2</span>.<span class="mi">2</span>) = u
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eta2_sigma / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta3_sigma</span> `{P : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) (<span class="nv">c</span> : C a b), <span class="kt">Type</span>}
           (u : sig (<span class="kr">fun</span> <span class="nv">a</span> =&gt; sig (<span class="kr">fun</span> <span class="nv">b</span> =&gt; sig (P a b))))
  : (u.<span class="mi">1</span>; u.<span class="mi">2</span>.<span class="mi">1</span>; u.<span class="mi">2</span>.<span class="mi">2</span>.<span class="mi">1</span>; u.<span class="mi">2</span>.<span class="mi">2</span>.<span class="mi">2</span>) = u
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> eta3_sigma / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths *)</span>

<span class="sd">(** A path in a total space is commonly shown component wise. Because we use this over and over, we write down the proofs by hand to make sure they are what we think they should be. *)</span>

<span class="sd">(** With this version of the function, we often have to give [u] and [v] explicitly, so we make them explicit arguments. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_uncurried</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  (<span class="nv">pq</span> : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; p # u.<span class="mi">2</span> = v.<span class="mi">2</span>})
  : u = v
  := <span class="kr">match</span> pq.<span class="mi">2</span> <span class="kr">in</span> (_ = v2) <span class="kr">return</span> u = (v.<span class="mi">1</span>; v2) <span class="kr">with</span>
       | <span class="mi">1</span> =&gt; <span class="kr">match</span> pq.<span class="mi">1</span> <span class="kr">as</span> p <span class="kr">in</span> (_ = v1) <span class="kr">return</span> u = (v1; p # u.<span class="mi">2</span>) <span class="kr">with</span>
                | <span class="mi">1</span> =&gt; <span class="mi">1</span>
              <span class="kr">end</span>
     <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it&#39;s the uncurried one that is proven below to be an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  (<span class="nv">p</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (<span class="nv">q</span> : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  : u = v
  := path_sigma_uncurried P u v (p;q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A contravariant instance of [path_sigma_uncurried] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_uncurried_contra</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  (<span class="nv">pq</span> : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = p^ # v.<span class="mi">2</span>})
  : u = v
  := (path_sigma_uncurried P v u (pq.<span class="mi">1</span>^;pq.<span class="mi">2</span>^))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A variant of [Forall.dpath_forall] from which uses dependent sums to package things. It cannot go into [Forall] because [Sigma] depends on [Forall]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk1"><span class="kn">Definition</span> <span class="nf">dpath_forall&#39;</span>
  {<span class="nv">A</span> : <span class="kt">Type</span> } (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span>: sig P -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">h</span> : x = y)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">p</span>, Q (x ; p)) (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">p</span>, Q (y ; p))
  : (<span class="kr">forall</span> <span class="nv">p</span>, transport Q (path_sigma P (x ; p) (y; _) h <span class="mi">1</span>) (f p) = g (h # p))
    &lt;~&gt; (<span class="kr">forall</span> <span class="nv">p</span>, transportD P (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">fun</span> <span class="nv">p</span> =&gt; Q ( x ; p)) h p (f p) = g (transport P h p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : P x, Q (x; p)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : P y, Q (y; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transport Q
   (path_sigma P (x; p)
      (y;
      <span class="kr">match</span> h <span class="kr">in</span> (_ = a) <span class="kr">return</span> (P a) <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; (x; p).<span class="mi">2</span>
      <span class="kr">end</span>) h <span class="mi">1</span>) (f p) = g (transport P h p)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transportD P (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">p0</span> : P x) =&gt; Q (x; p0)) h
   p (f p) = g (transport P h p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : P x, Q (x; p)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : P y, Q (y; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transport Q
   (path_sigma P (x; p)
      (y;
      <span class="kr">match</span> h <span class="kr">in</span> (_ = a) <span class="kr">return</span> (P a) <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; (x; p).<span class="mi">2</span>
      <span class="kr">end</span>) h <span class="mi">1</span>) (f p) = g (transport P h p)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transportD P (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">p0</span> : P x) =&gt; Q (x; p0)) h
   p (f p) = g (transport P h p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3"><span class="nb">destruct</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : P x, Q (x; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transport Q (path_sigma P (x; p) (x; (x; p).<span class="mi">2</span>) <span class="mi">1</span> <span class="mi">1</span>)
   (f p) = g (transport P <span class="mi">1</span> p)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : P x,
 transportD P (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">p0</span> : P x) =&gt; Q (x; p0)) <span class="mi">1</span>
   p (f p) = g (transport P <span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This version produces only paths between pairs, as opposed to paths between arbitrary inhabitants of dependent sum types.  But it has the advantage that the components of those pairs can more often be inferred, so we make them implicit arguments. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> : P x} {<span class="nv">y&#39;</span> : P x&#39;}
  (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : p # y = y&#39;)
  : (x;y) = (x&#39;;y&#39;)
  := path_sigma P (x;y) (x&#39;;y&#39;) p q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Projections of paths from a total space. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P} (p : u = v)
  : u.<span class="mi">1</span> = v.<span class="mi">1</span>
  := ap pr1 p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* match p with idpath =&gt; 1 end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p ..1&quot;</span> := (pr1_path p) : fibration_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr2_path</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P} (p : u = v)
  : p..<span class="mi">1</span> # u.<span class="mi">2</span> = v.<span class="mi">2</span>
  := (transport_compose P pr1 p u.<span class="mi">2</span>)^
     @ (@apD {x:A &amp; P x} _ pr2 _ _ p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;p ..2&quot;</span> := (pr2_path p) : fibration_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we show how these things compute. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4"><span class="kn">Definition</span> <span class="nf">pr1_path_sigma_uncurried</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (pq : { p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; p # u.<span class="mi">2</span> = v.<span class="mi">2</span> })
  : (path_sigma_uncurried _ _ _ pq)..<span class="mi">1</span> = pq.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P u v pq) ..<span class="mi">1</span> = pq.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P u v pq) ..<span class="mi">1</span> = pq.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6"><span class="nb">destruct</span> u <span class="kr">as</span> [u1 u2]; <span class="nb">destruct</span> v <span class="kr">as</span> [v1 v2]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u1 = v1 &amp; transport P p u2 = v2}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P (u1; u2) (v1; v2) pq) ..<span class="mi">1</span> =
pq.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7"><span class="nb">destruct</span> pq <span class="kr">as</span> [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u1 = v1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P (u1; u2) (v1; v2) (p; q)) ..<span class="mi">1</span> =
(p; q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">simpl</span> <span class="kr">in</span> q; <span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8"><span class="kn">Definition</span> <span class="nf">pr2_path_sigma_uncurried</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (pq : { p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; p # u.<span class="mi">2</span> = v.<span class="mi">2</span> })
  : (path_sigma_uncurried _ _ _ pq)..<span class="mi">2</span>
  = ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport P s u.<span class="mi">2</span>) (pr1_path_sigma_uncurried pq) @ pq.<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P u v pq) ..<span class="mi">2</span> =
ap (<span class="kr">fun</span> <span class="nv">s</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span> =&gt; transport P s u.<span class="mi">2</span>)
  (pr1_path_sigma_uncurried pq) @ pq.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P u v pq) ..<span class="mi">2</span> =
ap (<span class="kr">fun</span> <span class="nv">s</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span> =&gt; transport P s u.<span class="mi">2</span>)
  (pr1_path_sigma_uncurried pq) @ pq.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka"><span class="nb">destruct</span> u <span class="kr">as</span> [u1 u2]; <span class="nb">destruct</span> v <span class="kr">as</span> [v1 v2]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u1 = v1 &amp; transport P p u2 = v2}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P (u1; u2) (v1; v2) pq) ..<span class="mi">2</span> =
ap (<span class="kr">fun</span> <span class="nv">s</span> : u1 = v1 =&gt; transport P s u2)
  (pr1_path_sigma_uncurried pq) @ pq.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb"><span class="nb">destruct</span> pq <span class="kr">as</span> [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u1 = v1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(path_sigma_uncurried P (u1; u2) (v1; v2) (p; q)) ..<span class="mi">2</span> =
ap (<span class="kr">fun</span> <span class="nv">s</span> : u1 = v1 =&gt; transport P s u2)
  (pr1_path_sigma_uncurried (p; q)) @ (p; q).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">simpl</span> <span class="kr">in</span> q; <span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkc"><span class="kn">Definition</span> <span class="nf">eta_path_sigma_uncurried</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (p : u = v)
  : path_sigma_uncurried _ _ _ (p..<span class="mi">1</span>; p..<span class="mi">2</span>) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_uncurried P u v (p ..<span class="mi">1</span>; p ..<span class="mi">2</span>) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_uncurried P u v (p ..<span class="mi">1</span>; p ..<span class="mi">2</span>) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chke"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_uncurried P u u (<span class="mi">1</span> ..<span class="mi">1</span>; <span class="mi">1</span> ..<span class="mi">2</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkf"><span class="kn">Lemma</span> <span class="nf">transport_pr1_path_sigma_uncurried</span>
  `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (pq : { p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span> })
  Q
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x.<span class="mi">1</span>) (@path_sigma_uncurried A P u v pq)
    = transport _ pq.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; Q x.<span class="mi">1</span>)
  (path_sigma_uncurried P u v pq) = transport Q pq.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>pq</var><span class="hyp-type"><b>: </b><span>{p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>}</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; Q x.<span class="mi">1</span>)
  (path_sigma_uncurried P u v pq) = transport Q pq.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk11"><span class="nb">destruct</span> pq <span class="kr">as</span> [p q], u, v; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>proj1 = proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p proj2 = proj3</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; Q x.<span class="mi">1</span>)
  <span class="kr">match</span>
    q <span class="kr">in</span> (_ = v2)
    <span class="kr">return</span> ((proj1; proj2) = (proj0; v2))
  <span class="kr">with</span>
  | <span class="mi">1</span> =&gt;
      <span class="kr">match</span>
        p <span class="kr">in</span> (_ = v1)
        <span class="kr">return</span>
          ((proj1; proj2) = (v1; transport P p proj2))
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; <span class="mi">1</span>
      <span class="kr">end</span>
  <span class="kr">end</span> = transport Q p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk12"><span class="nb">destruct</span> p, q; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; Q x.<span class="mi">1</span>) <span class="mi">1</span> =
transport Q <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (q : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  : (path_sigma _ _ _ p q)..<span class="mi">1</span> = p
  := pr1_path_sigma_uncurried (p; q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Writing it the other way can help [rewrite]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_pr1_path_sigma</span> {<span class="nv">A</span>:<span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">u</span> <span class="nv">v</span> : sig P}
  (<span class="nv">p</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (<span class="nv">q</span> : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  : ap pr1 (path_sigma _ _ _ p q) = p
  := pr1_path_sigma p q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr2_path_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (q : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  : (path_sigma _ _ _ p q)..<span class="mi">2</span>
    = ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport P s u.<span class="mi">2</span>) (pr1_path_sigma p q) @ q
  := pr2_path_sigma_uncurried (p; q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_path_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P} (p : u = v)
  : path_sigma _ _ _ (p..<span class="mi">1</span>) (p..<span class="mi">2</span>) = p
  := eta_path_sigma_uncurried p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_pr1_path_sigma</span>
  `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (q : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  Q
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q x.<span class="mi">1</span>) (@path_sigma A P u v p q)
    = transport _ p
  := transport_pr1_path_sigma_uncurried (p; q) Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This lets us identify the path space of a sigma-type, up to equivalence. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk13"><span class="kn">Instance</span> <span class="nf">isequiv_path_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  : IsEquiv (path_sigma_uncurried P u v) | <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_sigma_uncurried P u v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_sigma_uncurried P u v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk15"><span class="nb">simple refine</span> (Build_IsEquiv
            _ _
            _ (<span class="kr">fun</span> <span class="nv">r</span> =&gt; (r..<span class="mi">1</span>; r..<span class="mi">2</span>))
            eta_path_sigma
            _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">r</span> : u = v =&gt; (r ..<span class="mi">1</span>; r ..<span class="mi">2</span>))
o path_sigma_uncurried P u v == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk16"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span>},
eta_path_sigma (path_sigma_uncurried P u v x) =
ap (path_sigma_uncurried P u v) (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk17"><span class="kp">all</span>: <span class="nb">destruct</span> u, v; <span class="nb">intros</span> [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p (proj1; proj2).<span class="mi">2</span> = (proj0; proj3).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((path_sigma_uncurried P (proj1; proj2) (proj0; proj3)
    (p; q)) ..<span class="mi">1</span>;
(path_sigma_uncurried P (proj1; proj2) (proj0; proj3)
   (p; q)) ..<span class="mi">2</span>) = (p; q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p (proj1; proj2).<span class="mi">2</span> = (proj0; proj3).<span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="sigma-v-chk18"><hr></label><div class="goal-conclusion">eta_path_sigma
  (path_sigma_uncurried P 
     (proj1; proj2) (proj0; proj3) 
     (p; q)) =
ap
  (path_sigma_uncurried P 
     (proj1; proj2) (proj0; proj3)) 
  <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk19"><span class="kp">all</span>: <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>proj1 = proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p proj2 = proj3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">match</span>
   q <span class="kr">in</span> (_ = v2) <span class="kr">return</span> ((proj1; proj2) = (proj0; v2))
 <span class="kr">with</span>
 | <span class="mi">1</span> =&gt;
     <span class="kr">match</span>
       p <span class="kr">in</span> (_ = v1)
       <span class="kr">return</span>
         ((proj1; proj2) = (v1; transport P p proj2))
     <span class="kr">with</span>
     | <span class="mi">1</span> =&gt; <span class="mi">1</span>
     <span class="kr">end</span>
 <span class="kr">end</span> ..<span class="mi">1</span>;
<span class="kr">match</span>
  q <span class="kr">in</span> (_ = v2) <span class="kr">return</span> ((proj1; proj2) = (proj0; v2))
<span class="kr">with</span>
| <span class="mi">1</span> =&gt;
    <span class="kr">match</span>
      p <span class="kr">in</span> (_ = v1)
      <span class="kr">return</span>
        ((proj1; proj2) = (v1; transport P p proj2))
    <span class="kr">with</span>
    | <span class="mi">1</span> =&gt; <span class="mi">1</span>
    <span class="kr">end</span>
<span class="kr">end</span> ..<span class="mi">2</span>) = (p; q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>proj1 = proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p proj2 = proj3</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk1a"><hr></label><div class="goal-conclusion">eta_path_sigma
  <span class="kr">match</span>
    q <span class="kr">in</span> (_ = v2)
    <span class="kr">return</span> ((proj1; proj2) = (proj0; v2))
  <span class="kr">with</span>
  | <span class="mi">1</span> =&gt;
      <span class="kr">match</span>
        p <span class="kr">in</span> (_ = v1)
        <span class="kr">return</span>
          ((proj1; proj2) = (v1; transport P p proj2))
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; <span class="mi">1</span>
      <span class="kr">end</span>
  <span class="kr">end</span> =
ap
  (path_sigma_uncurried P 
     (proj1; proj2) (proj0; proj3)) 
  <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk1b"><span class="kp">all</span>: <span class="nb">destruct</span> q, p; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span>; <span class="mi">1</span> ..<span class="mi">2</span>) = (<span class="mi">1</span>; <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk1c"><hr></label><div class="goal-conclusion"><span class="mi">1</span> =
ap
  (path_sigma_uncurried P 
     (proj1; proj2) (proj1; proj2)) 
  <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_sigma</span> `(P : A -&gt; <span class="kt">Type</span>) (u v : sig P)
  : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp;  p # u.<span class="mi">2</span> = v.<span class="mi">2</span>} &lt;~&gt; (u = v)
  := Build_Equiv _ _ (path_sigma_uncurried P u v) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* A contravariant version of [isequiv_path_sigma&#39;] *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk1d"><span class="kn">Instance</span> <span class="nf">isequiv_path_sigma_contra</span> `{P : A -&gt; <span class="kt">Type</span>} {u v : sig P}
  : IsEquiv (path_sigma_uncurried_contra P u v) | <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_sigma_uncurried_contra P u v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (path_sigma_uncurried_contra P u v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk1f"><span class="nb">apply</span> (isequiv_adjointify (path_sigma_uncurried_contra P u v)
        (<span class="kr">fun</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span> idpath =&gt; (<span class="mi">1</span>; <span class="mi">1</span>) <span class="kr">end</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : u = v =&gt;
 path_sigma_uncurried_contra P u v
   <span class="kr">match</span>
     x <span class="kr">in</span> (_ = s)
     <span class="kr">return</span> {p : u.<span class="mi">1</span> = s.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ s.<span class="mi">2</span>}
   <span class="kr">with</span>
   | <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
   <span class="kr">end</span>) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk20"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ v.<span class="mi">2</span>} =&gt;
 <span class="kr">match</span>
   path_sigma_uncurried_contra P u v x <span class="kr">in</span> (_ = s)
   <span class="kr">return</span> {p : u.<span class="mi">1</span> = s.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ s.<span class="mi">2</span>}
 <span class="kr">with</span>
 | <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
 <span class="kr">end</span>) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk21">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : u = v =&gt;
 path_sigma_uncurried_contra P u v
   <span class="kr">match</span>
     x <span class="kr">in</span> (_ = s)
     <span class="kr">return</span> {p : u.<span class="mi">1</span> = s.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ s.<span class="mi">2</span>}
   <span class="kr">with</span>
   | <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
   <span class="kr">end</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intro</span> r; <span class="nb">induction</span> r; <span class="nb">destruct</span> u <span class="kr">as</span> [u1 u2]; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ v.<span class="mi">2</span>} =&gt;
 <span class="kr">match</span>
   path_sigma_uncurried_contra P u v x <span class="kr">in</span> (_ = s)
   <span class="kr">return</span> {p : u.<span class="mi">1</span> = s.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = transport P p^ s.<span class="mi">2</span>}
 <span class="kr">with</span>
 | <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
 <span class="kr">end</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk23"><span class="nb">destruct</span> u, v; <span class="nb">intros</span> [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(proj1; proj2).<span class="mi">2</span> = transport P p^ (proj0; proj3).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  path_sigma_uncurried_contra P (proj1; proj2)
    (proj0; proj3) (p; q) <span class="kr">in</span> (_ = s)
  <span class="kr">return</span>
    {p : (proj1; proj2).<span class="mi">1</span> = s.<span class="mi">1</span> &amp;
    (proj1; proj2).<span class="mi">2</span> = transport P p^ s.<span class="mi">2</span>}
<span class="kr">with</span>
| <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
<span class="kr">end</span> = (p; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk24"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>proj1 = proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>proj2 = transport P p^ proj3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  path_sigma_uncurried_contra P 
    (proj1; proj2) (proj0; proj3) 
    (p; q) <span class="kr">in</span> (_ = s)
  <span class="kr">return</span>
    {p : proj1 = s.<span class="mi">1</span> &amp; proj2 = transport P p^ s.<span class="mi">2</span>}
<span class="kr">with</span>
| <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
<span class="kr">end</span> = (p; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk25"><span class="nb">destruct</span> p; <span class="nb">simpl</span> <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2, proj3</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>proj2 = proj3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  path_sigma_uncurried_contra P 
    (proj1; proj2) (proj1; proj3) 
    (<span class="mi">1</span>; q) <span class="kr">in</span> (_ = s)
  <span class="kr">return</span>
    {p : proj1 = s.<span class="mi">1</span> &amp; proj2 = transport P p^ s.<span class="mi">2</span>}
<span class="kr">with</span>
| <span class="mi">1</span> =&gt; (<span class="mi">1</span>; <span class="mi">1</span>)
<span class="kr">end</span> = (<span class="mi">1</span>; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* A contravariant version of [equiv_path_sigma] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_sigma_contra</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `(P : A -&gt; <span class="kt">Type</span>) (u v : sig P)
  : {p : u.<span class="mi">1</span> = v.<span class="mi">1</span> &amp; u.<span class="mi">2</span> = p^ # v.<span class="mi">2</span>} &lt;~&gt; (u = v)
  := Build_Equiv _ _ (path_sigma_uncurried_contra P u v) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This identification respects path concatenation. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk26"><span class="kn">Definition</span> <span class="nf">path_sigma_pp_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">u</span> <span class="nv">v</span> <span class="nv">w</span> : sig P}
  (<span class="nv">p1</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (<span class="nv">q1</span> : p1 # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  (<span class="nv">p2</span> : v.<span class="mi">1</span> = w.<span class="mi">1</span>) (<span class="nv">q2</span> : p2 # v.<span class="mi">2</span> = w.<span class="mi">2</span>)
  : path_sigma P u w (p1 @ p2)
      (transport_pp P p1 p2 u.<span class="mi">2</span> @ ap (transport P p2) q1 @ q2)
    = path_sigma P u v p1 q1 @ path_sigma P v w p2 q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v, w</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>u.<span class="mi">1</span> = v.<span class="mi">1</span></span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>transport P p1 u.<span class="mi">2</span> = v.<span class="mi">2</span></span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>v.<span class="mi">1</span> = w.<span class="mi">1</span></span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>transport P p2 v.<span class="mi">2</span> = w.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma P u w (p1 @ p2)
  ((transport_pp P p1 p2 u.<span class="mi">2</span> @ ap (transport P p2) q1) @
   q2) =
path_sigma P u v p1 q1 @ path_sigma P v w p2 q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v, w</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>u.<span class="mi">1</span> = v.<span class="mi">1</span></span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>transport P p1 u.<span class="mi">2</span> = v.<span class="mi">2</span></span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>v.<span class="mi">1</span> = w.<span class="mi">1</span></span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>transport P p2 v.<span class="mi">2</span> = w.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma P u w (p1 @ p2)
  ((transport_pp P p1 p2 u.<span class="mi">2</span> @ ap (transport P p2) q1) @
   q2) =
path_sigma P u v p1 q1 @ path_sigma P v w p2 q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk28"><span class="nb">destruct</span> u, v, w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>proj4</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj5</var><span class="hyp-type"><b>: </b><span>P proj4</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>(proj1; proj2).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span></span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>transport P p1 (proj1; proj2).<span class="mi">2</span> =
(proj0; proj3).<span class="mi">2</span></span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>(proj0; proj3).<span class="mi">1</span> = (proj4; proj5).<span class="mi">1</span></span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>transport P p2 (proj0; proj3).<span class="mi">2</span> =
(proj4; proj5).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma P (proj1; proj2) (proj4; proj5) (p1 @ p2)
  ((transport_pp P p1 p2 (proj1; proj2).<span class="mi">2</span> @
    ap (transport P p2) q1) @ q2) =
path_sigma P (proj1; proj2) (proj0; proj3) p1 q1 @
path_sigma P (proj0; proj3) (proj4; proj5) p2 q2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk29"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>proj4</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj5</var><span class="hyp-type"><b>: </b><span>P proj4</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proj1 = proj0</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>transport P p1 proj2 = proj3</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proj0 = proj4</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>transport P p2 proj3 = proj5</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma P (proj1; proj2) 
  (proj4; proj5) (p1 @ p2)
  ((transport_pp P p1 p2 proj2 @
    ap (transport P p2) q1) @ q2) =
path_sigma P (proj1; proj2) (proj0; proj3) p1 q1 @
path_sigma P (proj0; proj3) (proj4; proj5) p2 q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2a"><span class="nb">destruct</span> p1, p2, q1, q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P proj1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma P (proj1; proj2)
  (proj1; transport P <span class="mi">1</span> (transport P <span class="mi">1</span> proj2)) 
  (<span class="mi">1</span> @ <span class="mi">1</span>)
  ((transport_pp P <span class="mi">1</span> <span class="mi">1</span> proj2 @ ap (transport P <span class="mi">1</span>) <span class="mi">1</span>) @
   <span class="mi">1</span>) =
path_sigma P (proj1; proj2)
  (proj1; transport P <span class="mi">1</span> proj2) <span class="mi">1</span> <span class="mi">1</span> @
path_sigma P (proj1; transport P <span class="mi">1</span> proj2)
  (proj1; transport P <span class="mi">1</span> (transport P <span class="mi">1</span> proj2)) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_pp_pp&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  {<span class="nv">u1</span> <span class="nv">v1</span> <span class="nv">w1</span> : A} {<span class="nv">u2</span> : P u1} {<span class="nv">v2</span> : P v1} {<span class="nv">w2</span> : P w1}
  (<span class="nv">p1</span> : u1 = v1) (<span class="nv">q1</span> : p1 # u2 = v2)
  (<span class="nv">p2</span> : v1 = w1) (<span class="nv">q2</span> : p2 # v2 = w2)
  : path_sigma&#39; P (p1 @ p2)
      (transport_pp P p1 p2 u2 @ ap (transport P p2) q1 @ q2)
    = path_sigma&#39; P p1 q1 @ path_sigma&#39; P p2 q2
  := @path_sigma_pp_pp A P (u1;u2) (v1;v2) (w1;w2) p1 q1 p2 q2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2b"><span class="kn">Definition</span> <span class="nf">path_sigma_p1_1p&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  {<span class="nv">u1</span> <span class="nv">v1</span> : A} {<span class="nv">u2</span> : P u1} {<span class="nv">v2</span> : P v1}
  (<span class="nv">p</span> : u1 = v1) (<span class="nv">q</span> : p # u2 = v2)
  : path_sigma&#39; P p q
    = path_sigma&#39; P p <span class="mi">1</span> @ path_sigma&#39; P <span class="mi">1</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1, v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u1 = v1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; P p q =
path_sigma&#39; P p <span class="mi">1</span> @ path_sigma&#39; P <span class="mi">1</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1, v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u1 = v1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; P p q =
path_sigma&#39; P p <span class="mi">1</span> @ path_sigma&#39; P <span class="mi">1</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2d"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; P <span class="mi">1</span> <span class="mi">1</span> =
path_sigma&#39; P <span class="mi">1</span> <span class="mi">1</span> @ path_sigma&#39; P <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pr1_path] also commutes with the groupoid structure. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} (<span class="nv">u</span> : sig P)
  : (idpath u) ..<span class="mi">1</span> = idpath (u .<span class="mi">1</span>)
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">u</span> <span class="nv">v</span> <span class="nv">w</span> : sig P}
  (<span class="nv">p</span> : u = v) (<span class="nv">q</span> : v = w)
  : (p @ q) ..<span class="mi">1</span> = (p ..<span class="mi">1</span>) @ (q ..<span class="mi">1</span>)
  := ap_pp _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">u</span> <span class="nv">v</span> : sig P} (<span class="nv">p</span> : u = v)
  : p^ ..<span class="mi">1</span> = (p ..<span class="mi">1</span>)^
  := ap_V _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Applying [exist] to one argument is the same as [path_sigma] with reflexivity in the first place. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2e"><span class="kn">Definition</span> <span class="nf">ap_exist</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">y1</span> <span class="nv">y2</span> : P x)
  (<span class="nv">q</span> : y1 = y2)
  : ap (exist P x) q = path_sigma&#39; P <span class="mi">1</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (exist P x) q = path_sigma&#39; P <span class="mi">1</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (exist P x) q = path_sigma&#39; P <span class="mi">1</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Dependent transport is the same as transport along a [path_sigma]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk30"><span class="kn">Definition</span> <span class="nf">transportD_is_transport</span>
  {<span class="nv">A</span>:<span class="kt">Type</span>} (<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>) (<span class="nv">C</span>:sig B -&gt; <span class="kt">Type</span>)
  (<span class="nv">x1</span> <span class="nv">x2</span>:A) (<span class="nv">p</span>:x1=x2) (<span class="nv">y</span>:B x1) (<span class="nv">z</span>:C (x1;y))
  : transportD B (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; C (a;b)) p y z
    = transport C (path_sigma&#39; B p <span class="mi">1</span>) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C (x1; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) =&gt; C (a; b)) p y z =
transport C (path_sigma&#39; B p <span class="mi">1</span>) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C (x1; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) =&gt; C (a; b)) p y z =
transport C (path_sigma&#39; B p <span class="mi">1</span>) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk32"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C (x1; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD B (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) =&gt; C (a; b)) <span class="mi">1</span> y z =
transport C (path_sigma&#39; B <span class="mi">1</span> <span class="mi">1</span>) z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Doubly dependent transport is the same as transport along a [path_sigma]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk33"><span class="kn">Definition</span> <span class="nf">transportDD_is_transport</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>)
  {<span class="nv">a1</span> <span class="nv">a2</span> : A} (<span class="nv">pA</span> : a1 = a2)
  {<span class="nv">b1</span> : B a1} {<span class="nv">b2</span> : B a2} (<span class="nv">pB</span> : transport B pA b1 = b2)
  (<span class="nv">c1</span> : C a1 b1)
  : transportDD B C pA pB c1
    = transport (<span class="kr">fun</span> (<span class="nv">ab</span> : sig B) =&gt; C ab.<span class="mi">1</span> ab.<span class="mi">2</span>) (path_sigma&#39; B pA pB) c1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pA</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B a1</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B a2</span></span></span><br><span><var>pB</var><span class="hyp-type"><b>: </b><span>transport B pA b1 = b2</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C a1 b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportDD B C pA pB c1 =
transport (<span class="kr">fun</span> <span class="nv">ab</span> : {x : _ &amp; B x} =&gt; C ab.<span class="mi">1</span> ab.<span class="mi">2</span>)
  (path_sigma&#39; B pA pB) c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pA</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B a1</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B a2</span></span></span><br><span><var>pB</var><span class="hyp-type"><b>: </b><span>transport B pA b1 = b2</span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C a1 b1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportDD B C pA pB c1 =
transport (<span class="kr">fun</span> <span class="nv">ab</span> : {x : _ &amp; B x} =&gt; C ab.<span class="mi">1</span> ab.<span class="mi">2</span>)
  (path_sigma&#39; B pA pB) c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> pB, pA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Applying a two variable function to a [path_sigma]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk35"><span class="kn">Definition</span> <span class="nf">ap_path_sigma</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">F</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; B)
  {<span class="nv">x</span> <span class="nv">x&#39;</span> : A} {<span class="nv">y</span> : P x} {<span class="nv">y&#39;</span> : P x&#39;} (<span class="nv">p</span> : x = x&#39;) (<span class="nv">q</span> : p # y = y&#39;)
  : ap (sig_rec F) (path_sigma&#39; P p q)
    = ap _ (moveL_transport_V _ p _ _ q)
        @ (transport_arrow_toconst _ _ _)^ @ ap10 (apD F p) y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; B</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>P x&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec F) (path_sigma&#39; P p q) =
(ap (F x) (moveL_transport_V P p y y&#39; q) @
 (transport_arrow_toconst p (F x) y&#39;)^) @
ap10 (apD F p) y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; B</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>P x&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec F) (path_sigma&#39; P p q) =
(ap (F x) (moveL_transport_V P p y y&#39; q) @
 (transport_arrow_toconst p (F x) y&#39;)^) @
ap10 (apD F p) y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Remark: this is also equal to: *)</span>
<span class="c">(*     = ap10 (apD F p^)^ y @ transport_arrow_toconst _ _ _ *)</span>
<span class="c">(*                          @ ap (F x&#39;) (transport2 _ (inv_V p) y @ q). *)</span>

<span class="sd">(** And we can simplify when the first equality is [1]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk37"><span class="kn">Lemma</span> <span class="nf">ap_path_sigma_1p</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} (<span class="nv">F</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; B)
  (<span class="nv">a</span> : A) {<span class="nv">x</span> <span class="nv">y</span> : P a} (<span class="nv">p</span> : x = y)
  : ap (<span class="kr">fun</span> <span class="nv">w</span> =&gt; F w.<span class="mi">1</span> w.<span class="mi">2</span>) (path_sigma&#39; P <span class="mi">1</span> p) = ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; F a z) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">w</span> : {x : _ &amp; P x} =&gt; F w.<span class="mi">1</span> w.<span class="mi">2</span>)
  (path_sigma&#39; P <span class="mi">1</span> p) = ap (<span class="kr">fun</span> <span class="nv">z</span> : P a =&gt; F a z) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">w</span> : {x : _ &amp; P x} =&gt; F w.<span class="mi">1</span> w.<span class="mi">2</span>)
  (path_sigma&#39; P <span class="mi">1</span> p) = ap (<span class="kr">fun</span> <span class="nv">z</span> : P a =&gt; F a z) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Applying a function constructed with [sig_rec] to a [path_sigma] can be computed.  Technically this computation should probably go by way of a 2-variable [ap], and should be done in the dependently typed case. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk39"><span class="kn">Definition</span> <span class="nf">ap_sig_rec_path_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">Q</span> : <span class="kt">Type</span>}
  (<span class="nv">x1</span> <span class="nv">x2</span> : A) (<span class="nv">p</span> : x1 = x2) (<span class="nv">y1</span> : P x1) (<span class="nv">y2</span> : P x2) (<span class="nv">q</span> : p # y1 = y2)
  (<span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q)
  : ap (sig_rec d) (path_sigma&#39; P p q)
    = (transport_const p _)^
        @ (ap ((transport (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Q) p) o (d x1)) (transport_Vp _ p y1))^
          @ (transport_arrow p _ _)^
            @ ap10 (apD d p) (p # y1)
              @ ap (d x2) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>P x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p y1 = y2</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec d) (path_sigma&#39; P p q) =
((((transport_const p (d x1 y1))^ @
   (ap (transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; Q) p o d x1)
      (transport_Vp P p y1))^) @
  (transport_arrow p (d x1) (transport P p y1))^) @
 ap10 (apD d p) (transport P p y1)) @ ap (d x2) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>P x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p y1 = y2</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec d) (path_sigma&#39; P p q) =
((((transport_const p (d x1 y1))^ @
   (ap (transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; Q) p o d x1)
      (transport_Vp P p y1))^) @
  (transport_arrow p (d x1) (transport P p y1))^) @
 ap10 (apD d p) (transport P p y1)) @ ap (d x2) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3b"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P <span class="mi">1</span> y1 = y2</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec d) (path_sigma&#39; P <span class="mi">1</span> q) =
((((transport_const <span class="mi">1</span> (d x1 y1))^ @
   (ap
      (<span class="kr">fun</span> <span class="nv">x</span> : P x1 =&gt;
       transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; Q) <span class="mi">1</span> (d x1 x))
      (transport_Vp P <span class="mi">1</span> y1))^) @
  (transport_arrow <span class="mi">1</span> (d x1) (transport P <span class="mi">1</span> y1))^) @
 ap10 (apD d <span class="mi">1</span>) (transport P <span class="mi">1</span> y1)) @ ap (d x1) q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3c"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sig_rec d) (path_sigma&#39; P <span class="mi">1</span> <span class="mi">1</span>) =
((((transport_const <span class="mi">1</span> (d x1 y1))^ @
   (ap
      (<span class="kr">fun</span> <span class="nv">x</span> : P x1 =&gt;
       transport (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; Q) <span class="mi">1</span> (d x1 x))
      (transport_Vp P <span class="mi">1</span> y1))^) @
  (transport_arrow <span class="mi">1</span> (d x1) (transport P <span class="mi">1</span> y1))^) @
 ap10 (apD d <span class="mi">1</span>) (transport P <span class="mi">1</span> y1)) @ ap (d x1) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A path between paths in a total space is commonly shown component wise. *)</span>

<span class="sd">(** With this version of the function, we often have to give [u] and [v] explicitly, so we make them explicit arguments. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3d"><span class="kn">Definition</span> <span class="nf">path_path_sigma_uncurried</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  (<span class="nv">p</span> <span class="nv">q</span> : u = v)
  (<span class="nv">rs</span> : {r : p..<span class="mi">1</span> = q..<span class="mi">1</span> &amp; transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; transport P x u.<span class="mi">2</span> = v.<span class="mi">2</span>) r p..<span class="mi">2</span> = q..<span class="mi">2</span>})
  : p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>u = v</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>{r : p ..<span class="mi">1</span> = q ..<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span> =&gt; transport P x u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  r p ..<span class="mi">2</span> = q ..<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>u = v</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>{r : p ..<span class="mi">1</span> = q ..<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : u.<span class="mi">1</span> = v.<span class="mi">1</span> =&gt; transport P x u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  r p ..<span class="mi">2</span> = q ..<span class="mi">2</span>}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk3f"><span class="nb">destruct</span> rs, p, u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(proj0; proj3) = (proj0; proj3)</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ..<span class="mi">1</span> = q ..<span class="mi">1</span></span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : (proj0; proj3).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span>
   =&gt;
   transport P x (proj0; proj3).<span class="mi">2</span> =
   (proj0; proj3).<span class="mi">2</span>) proj1 
  <span class="mi">1</span> ..<span class="mi">2</span> = q ..<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk40"><span class="nb">etransitivity</span>; [ | <span class="nb">apply</span> eta_path_sigma ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(proj0; proj3) = (proj0; proj3)</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ..<span class="mi">1</span> = q ..<span class="mi">1</span></span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x</span> : (proj0; proj3).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span>
   =&gt;
   transport P x (proj0; proj3).<span class="mi">2</span> =
   (proj0; proj3).<span class="mi">2</span>) proj1 
  <span class="mi">1</span> ..<span class="mi">2</span> = q ..<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
path_sigma P (proj0; proj3) (proj0; proj3) q ..<span class="mi">1</span> q ..<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk41">path_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>P proj0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(proj0; proj3) = (proj0; proj3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
path_sigma P (proj0; proj3) 
  (proj0; proj3) <span class="mi">1</span> ..<span class="mi">1</span>
  (transport
     (<span class="kr">fun</span> <span class="nv">x</span> : (proj0; proj3).<span class="mi">1</span> = (proj0; proj3).<span class="mi">1</span> =&gt;
      transport P x (proj0; proj3).<span class="mi">2</span> =
      (proj0; proj3).<span class="mi">2</span>) <span class="mi">1</span> 
     <span class="mi">1</span> ..<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it&#39;s the uncurried one that is proven below to be an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_path_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  (<span class="nv">p</span> <span class="nv">q</span> : u = v)
  (<span class="nv">r</span> : p..<span class="mi">1</span> = q..<span class="mi">1</span>)
  (<span class="nv">s</span> : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; transport P x u.<span class="mi">2</span> = v.<span class="mi">2</span>) r p..<span class="mi">2</span> = q..<span class="mi">2</span>)
  : p = q
  := path_path_sigma_uncurried P u v p q (r; s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transport *)</span>

<span class="sd">(** The concrete description of transport in sigmas (and also pis) is rather trickier than in the other types.  In particular, these cannot be described just in terms of transport in simpler types; they require also the dependent transport [transportD].</span>

<span class="sd">  In particular, this indicates why &quot;transport&quot; alone cannot be fully defined by induction on the structure of types, although Id-elim/[transportD] can be (cf. Observational Type Theory).  A more thorough set of lemmas, along the lines of the present ones but dealing with Id-elim rather than just transport, might be nice to have eventually? *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk42"><span class="kn">Definition</span> <span class="nf">transport_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, B a -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">yz</span> : { y : B x1 &amp; C x1 y })
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; { y : B x &amp; C x y }) p yz
    = (p # yz.<span class="mi">1</span> ; transportD _ _ p yz.<span class="mi">1</span> yz.<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; C x y}) p yz =
(transport B p yz.<span class="mi">1</span>; transportD B C p yz.<span class="mi">1</span> yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; C x y}) p yz =
(transport B p yz.<span class="mi">1</span>; transportD B C p yz.<span class="mi">1</span> yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk44"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; C x y}) <span class="mi">1</span> yz =
(transport B <span class="mi">1</span> yz.<span class="mi">1</span>; transportD B C <span class="mi">1</span> yz.<span class="mi">1</span> yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk45"><span class="nb">destruct</span> yz <span class="kr">as</span> [y z].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x1</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>C x1 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; C x y}) <span class="mi">1</span> (y; z) =
(transport B <span class="mi">1</span> (y; z).<span class="mi">1</span>;
transportD B C <span class="mi">1</span> (y; z).<span class="mi">1</span> (y; z).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The special case when the second variable doesn&#39;t depend on the first is simpler. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk46"><span class="kn">Definition</span> <span class="nf">transport_sigma&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">yz</span> : { y : B &amp; C x1 y })
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; { y : B &amp; C x y }) p yz =
      (yz.<span class="mi">1</span> ; transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x yz.<span class="mi">1</span>) p yz.<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B &amp; C x y}) p yz =
(yz.<span class="mi">1</span>; transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x yz.<span class="mi">1</span>) p yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B &amp; C x y}) p yz =
(yz.<span class="mi">1</span>; transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x yz.<span class="mi">1</span>) p yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk48"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>yz</var><span class="hyp-type"><b>: </b><span>{y : B &amp; C x1 y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B &amp; C x y}) <span class="mi">1</span> yz =
(yz.<span class="mi">1</span>; transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x yz.<span class="mi">1</span>) <span class="mi">1</span> yz.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk49"><span class="nb">destruct</span> yz.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>C x1 proj1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B &amp; C x y}) <span class="mi">1</span>
  (proj1; proj2) =
((proj1; proj2).<span class="mi">1</span>;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x (proj1; proj2).<span class="mi">1</span>) <span class="mi">1</span>
  (proj1; proj2).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Or if the second variable contains a first component that doesn&#39;t depend on the first.  Need to think about the naming of these. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4a"><span class="kn">Definition</span> <span class="nf">transport_sigma_&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> <span class="nv">C</span> : A -&gt; <span class="kt">Type</span>}
  {<span class="nv">D</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, B a -&gt; C a -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2)
  (<span class="nv">yzw</span> : { y : B x1 &amp; { z : C x1 &amp; D x1 y z } })
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; { y : B x &amp; { z : C x &amp; D x y z } }) p yzw
    = (p # yzw.<span class="mi">1</span> ; p # yzw.<span class="mi">2</span>.<span class="mi">1</span> ; transportD2 _ _ _ p yzw.<span class="mi">1</span> yzw.<span class="mi">2</span>.<span class="mi">1</span> yzw.<span class="mi">2</span>.<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yzw</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; {z : C x1 &amp; D x1 y z}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; {z : C x &amp; D x y z}}) p yzw =
(transport B p yzw.<span class="mi">1</span>; transport C p (yzw.<span class="mi">2</span>).<span class="mi">1</span>;
transportD2 B C D p yzw.<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>yzw</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; {z : C x1 &amp; D x1 y z}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; {z : C x &amp; D x y z}}) p yzw =
(transport B p yzw.<span class="mi">1</span>; transport C p (yzw.<span class="mi">2</span>).<span class="mi">1</span>;
transportD2 B C D p yzw.<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4c"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; C a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>yzw</var><span class="hyp-type"><b>: </b><span>{y : B x1 &amp; {z : C x1 &amp; D x1 y z}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; {y : B x &amp; {z : C x &amp; D x y z}}) <span class="mi">1</span> yzw =
(transport B <span class="mi">1</span> yzw.<span class="mi">1</span>; transport C <span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">1</span>;
transportD2 B C D <span class="mi">1</span> yzw.<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">1</span> (yzw.<span class="mi">2</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functorial action *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : A -&gt; B) (g : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
  : sig P -&gt; sig Q
  := <span class="kr">fun</span> <span class="nv">u</span> =&gt; (f u.<span class="mi">1</span> ; g u.<span class="mi">1</span> u.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4d"><span class="kn">Definition</span> <span class="nf">ap_functor_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : A -&gt; B) (g : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
  (u v : sig P) (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>) (q : p # u.<span class="mi">2</span> = v.<span class="mi">2</span>)
  : ap (functor_sigma f g) (path_sigma P u v p q)
  = path_sigma Q (functor_sigma f g u) (functor_sigma f g v)
      (ap f p)
      ((transport_compose Q f p (g u.<span class="mi">1</span> u.<span class="mi">2</span>))^
         @ (@ap_transport _ P (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Q (f x)) _ _ p g u.<span class="mi">2</span>)^
           @ ap (g v.<span class="mi">1</span>) q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u.<span class="mi">1</span> = v.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_sigma f g) (path_sigma P u v p q) =
path_sigma Q (functor_sigma f g u)
  (functor_sigma f g v) (ap f p)
  (((transport_compose Q f p (g u.<span class="mi">1</span> u.<span class="mi">2</span>))^ @
    (ap_transport p g u.<span class="mi">2</span>)^) @ ap (g v.<span class="mi">1</span>) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u.<span class="mi">1</span> = v.<span class="mi">1</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u.<span class="mi">2</span> = v.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_sigma f g) (path_sigma P u v p q) =
path_sigma Q (functor_sigma f g u)
  (functor_sigma f g v) (ap f p)
  (((transport_compose Q f p (g u.<span class="mi">1</span> u.<span class="mi">2</span>))^ @
    (ap_transport p g u.<span class="mi">2</span>)^) @ ap (g v.<span class="mi">1</span>) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk4f"><span class="nb">destruct</span> u <span class="kr">as</span> [u1 u2]; <span class="nb">destruct</span> v <span class="kr">as</span> [v1 v2]; <span class="nb">simpl</span> <span class="kr">in</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>P v1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>u1 = v1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport P p u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_sigma f g)
  (path_sigma P (u1; u2) (v1; v2) p q) =
path_sigma Q (functor_sigma f g (u1; u2))
  (functor_sigma f g (v1; v2)) (ap f p)
  (((transport_compose Q f p (g (u1; u2).<span class="mi">1</span> (u1; u2).<span class="mi">2</span>))^ @
    (ap_transport p g (u1; u2).<span class="mi">2</span>)^) @
   ap (g (v1; v2).<span class="mi">1</span>) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk50"><span class="nb">destruct</span> p; <span class="nb">simpl</span> <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2, v2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>u2 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_sigma f g)
  (path_sigma P (u1; u2) (u1; v2) <span class="mi">1</span> q) =
path_sigma Q (functor_sigma f g (u1; u2))
  (functor_sigma f g (u1; v2)) (ap f <span class="mi">1</span>)
  (((transport_compose Q f <span class="mi">1</span> (g (u1; u2).<span class="mi">1</span> (u1; u2).<span class="mi">2</span>))^ @
    (ap_transport <span class="mi">1</span> g (u1; u2).<span class="mi">2</span>)^) @
   ap (g (u1; v2).<span class="mi">1</span>) q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk51"><span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>P u1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_sigma f g)
  (path_sigma P (u1; u2) (u1; u2) <span class="mi">1</span> <span class="mi">1</span>) =
path_sigma Q (functor_sigma f g (u1; u2))
  (functor_sigma f g (u1; u2)) (ap f <span class="mi">1</span>)
  (((transport_compose Q f <span class="mi">1</span> (g (u1; u2).<span class="mi">1</span> (u1; u2).<span class="mi">2</span>))^ @
    (ap_transport <span class="mi">1</span> g (u1; u2).<span class="mi">2</span>)^) @
   ap (g (u1; u2).<span class="mi">1</span>) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalences *)</span>

<span class="sd">(** The converse to [isequiv_functor_sigma] when [f] is [idmap] is [isequiv_from_functor_sigma] in Types/Equiv.v, which also contains Theorem 4.7.7 *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk52"><span class="kn">Instance</span> <span class="nf">isequiv_functor_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  `{IsEquiv A B f} `{<span class="kr">forall</span> <span class="nv">a</span>, @IsEquiv (P a) (Q (f a)) (g a)}
  : IsEquiv (functor_sigma f g) | <span class="mi">1000</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk54">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; Q x} -&gt; {x : _ &amp; P x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk55"><hr></label><div class="goal-conclusion">functor_sigma f g o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="sigma-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk56"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o functor_sigma f g == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; Q x} -&gt; {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk58">napply (functor_sigma f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : B, Q a -&gt; P (f^-<span class="mi">1</span> a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">b</span> <span class="nv">q</span> =&gt; (g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> ((transport Q (eisretr f b)^) q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma f g
o functor_sigma f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">q</span> : Q b) =&gt;
     (g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> (transport Q (eisretr f b)^ q)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5a"><span class="nb">intros</span> [b q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma f g
  (functor_sigma f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">q</span> : Q b) =&gt;
      (g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> (transport Q (eisretr f b)^ q))
     (b; q)) = (b; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5b"><span class="nb">apply</span> (path_sigma&#39; _ (eisretr f _)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Q (eisretr f b)
  (g (f^-<span class="mi">1</span> b)
     ((g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> (transport Q (eisretr f b)^ q))) =
q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5c">lhs napply (ap _ (eisretr (g (f^-<span class="mi">1</span> _)) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Q (eisretr f b)
  (transport Q (eisretr f b)^ q) = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">q</span> : Q b) =&gt;
   (g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> (transport Q (eisretr f b)^ q))
o functor_sigma f g == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5e"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">b</span> : B) (<span class="nv">q</span> : Q b) =&gt;
   (g (f^-<span class="mi">1</span> b))^-<span class="mi">1</span> (transport Q (eisretr f b)^ q))
  (functor_sigma f g (a; p)) = (a; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk5f"><span class="nb">apply</span> (path_sigma&#39; _ (eissect f _)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (eissect f a)
  ((g (f^-<span class="mi">1</span> (f a)))^-<span class="mi">1</span>
     (transport Q (eisretr f (f a))^ (g a p))) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk60">lhs_V rapply (ap_transport _ (<span class="kr">fun</span> <span class="nv">a&#39;</span> =&gt; (g a&#39;) ^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g a)^-<span class="mi">1</span>
  (transport (<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt; Q (f a&#39;)) (eissect f a)
     (transport Q (eisretr f (f a))^ (g a p))) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk61">lhs napply (ap _ (transport_compose _ _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g a)^-<span class="mi">1</span>
  (transport Q (ap f (eissect f a))
     (transport Q (eisretr f (f a))^ (g a p))) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk62">lhs_V napply (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (g _)^-<span class="mi">1</span> (transport Q x _)) (eisadj f _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g a)^-<span class="mi">1</span>
  (transport Q (eisretr f (f a))
     (transport Q (eisretr f (f a))^ (g a p))) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk63">lhs napply (ap _ (transport_pV _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g a)^-<span class="mi">1</span> (g a p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_sigma</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : A -&gt; B) `{IsEquiv A B f}
  (g : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
  `{<span class="kr">forall</span> <span class="nv">a</span>, @IsEquiv (P a) (Q (f a)) (g a)}
  : sig P &lt;~&gt; sig Q
  := Build_Equiv _ _ (functor_sigma f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_sigma&#39;</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : A &lt;~&gt; B)
  (g : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;~&gt; Q (f a))
  : sig P &lt;~&gt; sig Q
  := equiv_functor_sigma f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_sigma_id</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : A -&gt; <span class="kt">Type</span>}
  (g : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;~&gt; Q a)
  : sig P &lt;~&gt; sig Q
  := equiv_functor_sigma&#39; <span class="mi">1</span> g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_sigma_pb</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>}
  (<span class="nv">f</span> : A &lt;~&gt; B)
  : sig (Q o f) &lt;~&gt; sig Q
  := equiv_functor_sigma f (<span class="kr">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>%equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality on logical equivalences *)</span>

<span class="sd">(** At least over a fixed base *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iff_functor_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>}
           (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;-&gt; Q a)
  : sig P &lt;-&gt; sig Q
  := (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; fst (f a)),
    functor_sigma idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; snd (f a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Lemma 3.11.9(i): Summing up a contractible family of types does nothing. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk64"><span class="kn">Instance</span> <span class="nf">isequiv_pr1_contr</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">a</span>, Contr (P a)}
  : IsEquiv (@pr1 A P) | <span class="mi">100</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk66"><span class="nb">refine</span> (isequiv_adjointify (@pr1 A P)
                             (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (a ; center (P a))) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (x; center (P x)).<span class="mi">1</span>) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk67"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; (x.<span class="mi">1</span>; center (P x.<span class="mi">1</span>))) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk68">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (x; center (P x)).<span class="mi">1</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> a; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt; (x.<span class="mi">1</span>; center (P x.<span class="mi">1</span>))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6a"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a; p).<span class="mi">1</span>; center (P (a; p).<span class="mi">1</span>)) = (a; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_sigma&#39; P <span class="mi">1</span> (contr _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sigma_contr</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">a</span>, Contr (P a)}
  : sig P &lt;~&gt; A
  := Build_Equiv _ _ pr1 _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Lemma 3.11.9(ii): Dually, summing up over a contractible type does nothing. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6b"><span class="kn">Definition</span> <span class="nf">equiv_contr_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) `{Contr A}
  : { x : A &amp; P x } &lt;~&gt; P (center A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; P x} &lt;~&gt; P (center A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; P x} &lt;~&gt; P (center A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6d"><span class="nb">refine</span> (equiv_adjointify (<span class="kr">fun</span> <span class="nv">xp</span> =&gt; (contr xp.<span class="mi">1</span>)^ # xp.<span class="mi">2</span>)
                           (<span class="kr">fun</span> <span class="nv">p</span> =&gt; (center A ; p)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : P (center A) =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0)
   (contr (center A; x).<span class="mi">1</span>)^ 
   (center A; x).<span class="mi">2</span>) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk6e"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt;
 (center A;
 transport (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0) (contr x.<span class="mi">1</span>)^ x.<span class="mi">2</span>)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk6f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : P (center A) =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0)
   (contr (center A; x).<span class="mi">1</span>)^ 
   (center A; x).<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk70"><span class="nb">intros</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (center A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P x) (contr (center A))^ p = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">q</span> =&gt; q # p) (path_contr _ <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk71">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; P x} =&gt;
 (center A;
 transport (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0) (contr x.<span class="mi">1</span>)^ x.<span class="mi">2</span>)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk72"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(center A;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P x) 
  (contr (a; p).<span class="mi">1</span>)^ (a; p).<span class="mi">2</span>) = 
(a; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk73"><span class="nb">refine</span> (path_sigma&#39; _ (contr a) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P x) 
  (contr a)
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P x) 
     (contr (a; p).<span class="mi">1</span>)^ (a; p).<span class="mi">2</span>) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Associativity *)</span>

<span class="sd">(** All of the following lemmas are proven easily with the [make_equiv] tactic.  If you have a more complicated rearrangement of sigma-types to do, it is usually possible to do it by putting together these equivalences, but it is often simpler and faster to just use [make_equiv] directly. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk74"><span class="kn">Definition</span> <span class="nf">equiv_sigma_assoc</span> `(P : A -&gt; <span class="kt">Type</span>) (Q : {a : A &amp; P a} -&gt; <span class="kt">Type</span>)
  : {a : A &amp; {p : P a &amp; Q (a;p)}} &lt;~&gt; sig Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>{a : A &amp; P a} -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {p : P a &amp; Q (a; p)}} &lt;~&gt; {x : _ &amp; Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>{a : A &amp; P a} -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {p : P a &amp; Q (a; p)}} &lt;~&gt; {x : _ &amp; Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk76"><span class="kn">Definition</span> <span class="nf">equiv_sigma_assoc&#39;</span> `(P : A -&gt; <span class="kt">Type</span>) (Q : <span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; <span class="kt">Type</span>)
  : {a : A &amp; {p : P a &amp; Q a p}} &lt;~&gt; {ap : sig P &amp; Q ap.<span class="mi">1</span> ap.<span class="mi">2</span>}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {p : P a &amp; Q a p}} &lt;~&gt;
{ap : {x : _ &amp; P x} &amp; Q ap.<span class="mi">1</span> ap.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {p : P a &amp; Q a p}} &lt;~&gt;
{ap : {x : _ &amp; P x} &amp; Q ap.<span class="mi">1</span> ap.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk78"><span class="kn">Definition</span> <span class="nf">equiv_sigma_prod</span> `(Q : (A * B) -&gt; <span class="kt">Type</span>)
  : {a : A &amp; {b : B &amp; Q (a,b)}} &lt;~&gt; sig Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Q (a, b)}} &lt;~&gt; {x : _ &amp; Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A * B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Q (a, b)}} &lt;~&gt; {x : _ &amp; Q x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7a"><span class="kn">Definition</span> <span class="nf">equiv_sigma_prod&#39;</span> `(Q : A -&gt; B -&gt; <span class="kt">Type</span>)
  : {a : A &amp; {b : B &amp; Q a b}} &lt;~&gt; sig (<span class="kr">fun</span> <span class="nv">ab</span> =&gt; Q (fst ab) (snd ab)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Q a b}} &lt;~&gt;
{ab : A * B &amp; Q (fst ab) (snd ab)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Q a b}} &lt;~&gt;
{ab : A * B &amp; Q (fst ab) (snd ab)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7c"><span class="kn">Definition</span> <span class="nf">equiv_sigma_prod0</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  : {a : A &amp; B} &lt;~&gt; A * B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : A &amp; B} &lt;~&gt; A * B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : A &amp; B} &lt;~&gt; A * B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sigma_prod1</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  : {a : A &amp; {b : B &amp; C}} &lt;~&gt; A * B * C
  := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sigma_prod_prod</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : Y -&gt; <span class="kt">Type</span>)
  : {z : X * Y &amp; (P (fst z)) * (Q (snd z))} &lt;~&gt; (sig P) * (sig Q)
  := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetry *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7e"><span class="kn">Definition</span> <span class="nf">equiv_sigma_symm</span> `(P : A -&gt; B -&gt; <span class="kt">Type</span>)
  : {a : A &amp; {b : B &amp; P a b}} &lt;~&gt; {b : B &amp; {a : A &amp; P a b}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; P a b}} &lt;~&gt;
{b : B &amp; {a : A &amp; P a b}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; P a b}} &lt;~&gt;
{b : B &amp; {a : A &amp; P a b}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk80"><span class="kn">Definition</span> <span class="nf">equiv_sigma_symm&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `(P : A -&gt; <span class="kt">Type</span>) `(Q : A -&gt; <span class="kt">Type</span>)
  : { ap : { a : A &amp; P a } &amp; Q ap.<span class="mi">1</span> } &lt;~&gt; { aq : { a : A &amp; Q a } &amp; P aq.<span class="mi">1</span> }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{ap : {a : A &amp; P a} &amp; Q ap.<span class="mi">1</span>} &lt;~&gt;
{aq : {a : A &amp; Q a} &amp; P aq.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk81"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{ap : {a : A &amp; P a} &amp; Q ap.<span class="mi">1</span>} &lt;~&gt;
{aq : {a : A &amp; Q a} &amp; P aq.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk82"><span class="kn">Definition</span> <span class="nf">equiv_sigma_symm0</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
: {a : A &amp; B} &lt;~&gt; {b : B &amp; A}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : A &amp; B} &lt;~&gt; {_ : B &amp; A}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : A &amp; B} &lt;~&gt; {_ : B &amp; A}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Universal mapping properties *)</span>

<span class="sd">(** *** The positive universal property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_sig_ind</span> `{P : A -&gt; <span class="kt">Type</span>} (Q : sig P -&gt; <span class="kt">Type</span>)
  : IsEquiv (sig_ind Q) | <span class="mi">0</span>
  := Build_IsEquiv
       _ _
       (sig_ind Q)
       (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; f (x;y))
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sig_ind</span> `{P : A -&gt; <span class="kt">Type</span>} (Q : sig P -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> (<span class="nv">x</span>:A) (<span class="nv">y</span>:P x), Q (x;y)) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">xy</span>, Q xy)
  := Build_Equiv _ _ (sig_ind Q) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And a curried version *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sig_ind&#39;</span> `{P : A -&gt; <span class="kt">Type</span>} (Q : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> (<span class="nv">x</span>:A) (<span class="nv">y</span>:P x), Q x y) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">xy</span>, Q xy.<span class="mi">1</span> xy.<span class="mi">2</span>)
  := equiv_sig_ind (<span class="kr">fun</span> <span class="nv">xy</span> =&gt; Q xy.<span class="mi">1</span> xy.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** The negative universal property. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sig_coind_uncurried</span>
  `{A : X -&gt; <span class="kt">Type</span>} (P : <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; <span class="kt">Type</span>)
  : { f : <span class="kr">forall</span> <span class="nv">x</span>, A x &amp; <span class="kr">forall</span> <span class="nv">x</span>, P x (f x) }
    -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, sig (P x))
  := <span class="kr">fun</span> <span class="nv">fg</span> =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; (fg.<span class="mi">1</span> x ; fg.<span class="mi">2</span> x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sig_coind</span>
  `{A : X -&gt; <span class="kt">Type</span>} (P : <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; <span class="kt">Type</span>)
  (f : <span class="kr">forall</span> <span class="nv">x</span>, A x) (g : <span class="kr">forall</span> <span class="nv">x</span>, P x (f x))
  : (<span class="kr">forall</span> <span class="nv">x</span>, sig (P x))
  := sig_coind_uncurried P (f;g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_sig_coind</span>
  `{A : X -&gt; <span class="kt">Type</span>} {P : <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; <span class="kt">Type</span>}
  : IsEquiv (sig_coind_uncurried P) | <span class="mi">0</span>
  := Build_IsEquiv
       _ _
       (sig_coind_uncurried P)
       (<span class="kr">fun</span> <span class="nv">h</span> =&gt; exist (<span class="kr">fun</span> <span class="nv">f</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span>, P x (f x))
                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (h x).<span class="mi">1</span>)
                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (h x).<span class="mi">2</span>))
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_sig_coind</span>
  `(A : X -&gt; <span class="kt">Type</span>) (P : <span class="kr">forall</span> <span class="nv">x</span>, A x -&gt; <span class="kt">Type</span>)
  : { f : <span class="kr">forall</span> <span class="nv">x</span>, A x &amp; <span class="kr">forall</span> <span class="nv">x</span>, P x (f x) }
      &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span>, sig (P x))
  := Build_Equiv _ _ (sig_coind_uncurried P) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Sigmas preserve truncation *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk84"><span class="kn">Instance</span> <span class="nf">istrunc_sigma</span> `{P : A -&gt; <span class="kt">Type</span>}
  `{IsTrunc n A} `{<span class="kr">forall</span> <span class="nv">a</span>, IsTrunc n (P a)}
  : IsTrunc n (sig P) | <span class="mi">100</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk86"><span class="nb">generalize dependent</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
IsTrunc n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)) -&gt;
IsTrunc n {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk87">simple_induction&#39; n; <span class="nb">simpl</span>; <span class="nb">intros</span> A P ac Pc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {x : _ &amp; P x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
IsTrunc n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)) -&gt;
IsTrunc n {x : _ &amp; P x}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n.+<span class="mi">1</span> (P a)</span></span></span><br></div><label class="goal-separator" for="sigma-v-chk88"><hr></label><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> {x : _ &amp; P x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk89">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8a"><span class="nb">apply</span> (Build_Contr _ (center A; center (P (center A)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {x : _ &amp; P x},
(center A; center (P (center A))) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8b"><span class="nb">intros</span> [a ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Contr (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(center A; center (P (center A))) = (a; proj2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_sigma&#39; P (contr a) (path_contr _ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
IsTrunc n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)) -&gt;
IsTrunc n {x : _ &amp; P x}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n.+<span class="mi">1</span> (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> {x : _ &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8d"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
IsTrunc n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)) -&gt;
IsTrunc n {x : _ &amp; P x}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n.+<span class="mi">1</span> (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; P x}) 
(<span class="nv">y</span> : {x : _ &amp; P x}), IsTrunc n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8e"><span class="nb">intros</span> u v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
IsTrunc n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)) -&gt;
IsTrunc n {x : _ &amp; P x}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> A</span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n.+<span class="mi">1</span> (P a)</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (u = v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_isequiv_istrunc _ (path_sigma_uncurried P u v)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The sigma of an arbitrary family of *disjoint* hprops is an hprop. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk8f"><span class="kn">Definition</span> <span class="nf">ishprop_sigma_disjoint</span>
  `{P : A -&gt; <span class="kt">Type</span>} `{<span class="kr">forall</span> <span class="nv">a</span>, IsHProp (P a)}
  : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; P y -&gt; x = y) -&gt; IsHProp { x : A &amp; P x }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsHProp (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, P x -&gt; P y -&gt; x = y) -&gt;
IsHProp {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk90"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsHProp (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, P x -&gt; P y -&gt; x = y) -&gt;
IsHProp {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk91"><span class="nb">intros</span> dj; <span class="nb">apply</span> hprop_allpath; <span class="nb">intros</span> [x px] [y py].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsHProp (P a)</span></span></span><br><span><var>dj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, P x -&gt; P y -&gt; x = y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>py</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; px) = (y; py)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk92"><span class="nb">refine</span> (path_sigma&#39; P (dj x y px py) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsHProp (P a)</span></span></span><br><span><var>dj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, P x -&gt; P y -&gt; x = y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>py</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (dj x y px py) px = py</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Subtypes (sigma types whose second components are hprops) *)</span>

<span class="sd">(** To prove equality in a subtype, we only need equality of the first component. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)}
  (u v : sig P)
  : u.<span class="mi">1</span> = v.<span class="mi">1</span> -&gt; u = v
  := path_sigma_uncurried P u v o pr1^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_path_sigma_hprop</span> {<span class="nv">A</span> <span class="nv">P</span>} `{<span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)} {u v : sig P}
  : IsEquiv (@path_sigma_hprop A P _ u v) | <span class="mi">100</span>
  := isequiv_compose _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Immediate</span> isequiv_path_sigma_hprop : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_sigma_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  {<span class="nv">HP</span> : <span class="kr">forall</span> <span class="nv">a</span>, IsHProp (P a)} (<span class="nv">u</span> <span class="nv">v</span> : sig P)
  : (u.<span class="mi">1</span> = v.<span class="mi">1</span>) &lt;~&gt; (u = v)
  := Build_Equiv _ _ (path_sigma_hprop _ _) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_pr1_path_hprop</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">a</span>, IsHProp (P a)} (x y : sig P)
  : IsEquiv (@pr1_path A P x y)
  := _ : IsEquiv (path_sigma_hprop x y)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Immediate</span> isequiv_pr1_path_hprop : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We define this for ease of [SearchAbout IsEquiv ap pr1] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_ap_pr1_hprop</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">a</span>, IsHProp (P a)} (x y : sig P)
  : IsEquiv (@ap _ _ (@pr1 A P) x y)
  := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [path_sigma_hprop] is functorial *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk93"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} (u : sig P)
  : path_sigma_hprop u u <span class="mi">1</span> = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop u u <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop u u <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk95"><span class="nb">unfold</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_uncurried P u u (pr1^-<span class="mi">1</span> <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk96"><span class="nb">unfold</span> isequiv_pr1_contr; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  center (u.<span class="mi">2</span> = u.<span class="mi">2</span>) <span class="kr">in</span> (_ = v2)
  <span class="kr">return</span> (u = (u.<span class="mi">1</span>; v2))
<span class="kr">with</span>
| <span class="mi">1</span> =&gt; <span class="mi">1</span>
<span class="kr">end</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Ugh *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="kr">match</span> p <span class="kr">in</span> (_ = v2) <span class="kr">return</span> (u = (u.<span class="mi">1</span>; v2)) <span class="kr">with</span> <span class="mi">1</span> =&gt; <span class="mi">1</span> <span class="kr">end</span>)
             (contr (idpath u.<span class="mi">2</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk97"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop_V</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} {a b : A} (p : a = b)
  (x : P a) (y : P b)
  : path_sigma_hprop (b;y) (a;x) p^ = (path_sigma_hprop (a;x) (b;y) p)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (b; y) (a; x) p^ =
(path_sigma_hprop (a; x) (b; y) p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (b; y) (a; x) p^ =
(path_sigma_hprop (a; x) (b; y) p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk99"><span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; y) (a; x) <span class="mi">1</span> =
(path_sigma_hprop (a; x) (a; y) <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9a"><span class="nb">rewrite</span> (path_ishprop x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; y) (a; y) <span class="mi">1</span> =
(path_sigma_hprop (a; y) (a; y) <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_sigma_hprop_1 _ @ (ap inverse (path_sigma_hprop_1 _))^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9b"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop_pp</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)}
  {a b c : A}
  (p : a = b) (q : b = c)
  (x : P a) (y : P b) (z : P c)
  : path_sigma_hprop (a;x) (c;z) (p @ q)
    = path_sigma_hprop (a;x) (b;y) p @ path_sigma_hprop (b;y) (c;z) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b = c</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P b</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (c; z) (p @ q) =
path_sigma_hprop (a; x) (b; y) p @
path_sigma_hprop (b; y) (c; z) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>b = c</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>P b</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (c; z) (p @ q) =
path_sigma_hprop (a; x) (b; y) p @
path_sigma_hprop (b; y) (c; z) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9d"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (a; z) (<span class="mi">1</span> @ <span class="mi">1</span>) =
path_sigma_hprop (a; x) (a; y) <span class="mi">1</span> @
path_sigma_hprop (a; y) (a; z) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9e"><span class="nb">rewrite</span> (path_ishprop y x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (a; z) (<span class="mi">1</span> @ <span class="mi">1</span>) =
path_sigma_hprop (a; x) (a; x) <span class="mi">1</span> @
path_sigma_hprop (a; x) (a; z) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chk9f"><span class="nb">rewrite</span> (path_ishprop z x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (a; x) (<span class="mi">1</span> @ <span class="mi">1</span>) =
path_sigma_hprop (a; x) (a; x) <span class="mi">1</span> @
path_sigma_hprop (a; x) (a; x) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka0"><span class="nb">refine</span> (_ @ (ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; z @ _) (path_sigma_hprop_1 _))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma_hprop (a; x) (a; x) (<span class="mi">1</span> @ <span class="mi">1</span>) =
<span class="mi">1</span> @ path_sigma_hprop (a; x) (a; x) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_1p _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The inverse of [path_sigma_hprop] has its own name, so we give special names to the section and retraction homotopies to help [rewrite] out. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop_ap_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} (u v : sig P) (p : u = v)
  : path_sigma_hprop u v (ap pr1 p) = p
  := eisretr (path_sigma_hprop u v) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_sigma_hprop_pr1_path</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} (u v : sig P) (p : u = v)
  : path_sigma_hprop u v p..<span class="mi">1</span> = p
  := eisretr (path_sigma_hprop u v) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_pr1_path_sigma_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} (u v : sig P) (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>)
  : ap pr1 (path_sigma_hprop u v p) = p
  := eissect (path_sigma_hprop u v) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pr1_path_path_sigma_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} (u v : sig P) (p : u.<span class="mi">1</span> = v.<span class="mi">1</span>)
  : (path_sigma_hprop u v p)..<span class="mi">1</span> = p
  := eissect (path_sigma_hprop u v) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Fibers of [functor_sigma] *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka1"><span class="kn">Definition</span> <span class="nf">hfiber_functor_sigma</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
  (<span class="nv">b</span> : B) (<span class="nv">v</span> : Q b)
  : (hfiber (functor_sigma f g) (b; v)) &lt;~&gt;
      {w : hfiber f b &amp; hfiber (g w.<span class="mi">1</span>) ((w.<span class="mi">2</span>)^ # v)}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_sigma f g) (b; v) &lt;~&gt;
{w : hfiber f b &amp;
hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_sigma f g) (b; v) &lt;~&gt;
{w : hfiber f b &amp;
hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka3"><span class="nb">unfold</span> hfiber, functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : {x : _ &amp; P x} &amp; (f x.<span class="mi">1</span>; g x.<span class="mi">1</span> x.<span class="mi">2</span>) = (b; v)} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; g w.<span class="mi">1</span> x = transport Q (w.<span class="mi">2</span>)^ v}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka4"><span class="nb">refine</span> (_ oE equiv_functor_sigma_id _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; <span class="nl">?Goal0</span> x} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; g w.<span class="mi">1</span> x = transport Q (w.<span class="mi">2</span>)^ v}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><label class="goal-separator" for="sigma-v-chka5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {x : _ &amp; P x},
(f a.<span class="mi">1</span>; g a.<span class="mi">1</span> a.<span class="mi">2</span>) = (b; v) &lt;~&gt; <span class="nl">?Goal0</span> a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka6"><span class="mi">2</span>:<span class="nb">intros</span>; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : {x : _ &amp; P x} &amp;
{p : (f a.<span class="mi">1</span>; g a.<span class="mi">1</span> a.<span class="mi">2</span>).<span class="mi">1</span> = (b; v).<span class="mi">1</span> &amp;
transport Q p (f a.<span class="mi">1</span>; g a.<span class="mi">1</span> a.<span class="mi">2</span>).<span class="mi">2</span> = (b; v).<span class="mi">2</span>}} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; g w.<span class="mi">1</span> x = transport Q (w.<span class="mi">2</span>)^ v}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka7"><span class="nb">transitivity</span> {w : {x : A &amp; f x = b} &amp; {x : P w.<span class="mi">1</span> &amp; (w.<span class="mi">2</span>) # (g w.<span class="mi">1</span> x) = v}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : {x : _ &amp; P x} &amp;
{p : (f a.<span class="mi">1</span>; g a.<span class="mi">1</span> a.<span class="mi">2</span>).<span class="mi">1</span> = (b; v).<span class="mi">1</span> &amp;
transport Q p (f a.<span class="mi">1</span>; g a.<span class="mi">1</span> a.<span class="mi">2</span>).<span class="mi">2</span> = (b; v).<span class="mi">2</span>}} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; transport Q w.<span class="mi">2</span> (g w.<span class="mi">1</span> x) = v}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sigma-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><label class="goal-separator" for="sigma-v-chka8"><hr></label><div class="goal-conclusion">{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; transport Q w.<span class="mi">2</span> (g w.<span class="mi">1</span> x) = v}} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; g w.<span class="mi">1</span> x = transport Q (w.<span class="mi">2</span>)^ v}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chka9"><span class="mi">1</span>:make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; transport Q w.<span class="mi">2</span> (g w.<span class="mi">1</span> x) = v}} &lt;~&gt;
{w : {x : A &amp; f x = b} &amp;
{x : P w.<span class="mi">1</span> &amp; g w.<span class="mi">1</span> x = transport Q (w.<span class="mi">2</span>)^ v}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkaa"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> [a p]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : P a &amp; transport Q p (g a x) = v} &lt;~&gt;
{x : P a &amp; g a x = transport Q p^ v}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkab"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> u; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Q p (g a u) = v &lt;~&gt; g a u = transport Q p^ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_moveL_transport_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkac"><span class="kn">Instance</span> <span class="nf">istruncmap_functor_sigma</span> <span class="nv">n</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">P</span> <span class="nv">Q</span>}
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q (f a))
  {<span class="nv">Hf</span> : IsTruncMap n f} {<span class="nv">Hg</span> : <span class="kr">forall</span> <span class="nv">a</span>, IsTruncMap n (g a)}
  : IsTruncMap n (functor_sigma f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTruncMap n (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTruncMap n (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (functor_sigma f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkae"><span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f a)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTruncMap n (g a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (hfiber (functor_sigma f g) (a; b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (hfiber_functor_sigma _ _ _ _ _ _)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Theorem 4.7.6 *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkaf"><span class="kn">Definition</span> <span class="nf">hfiber_functor_sigma_idmap</span> {<span class="nv">A</span>} (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a)
  (<span class="nv">b</span> : A) (<span class="nv">v</span> : Q b)
  : (hfiber (functor_sigma idmap g) (b; v))
      &lt;~&gt; hfiber (g b) v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_sigma idmap g) (b; v) &lt;~&gt;
hfiber (g b) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_sigma idmap g) (b; v) &lt;~&gt;
hfiber (g b) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb1"><span class="nb">refine</span> (_ oE hfiber_functor_sigma P Q idmap g b v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{w : hfiber idmap b &amp;
hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v)} &lt;~&gt;
hfiber (g b) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_contr_sigma
           (<span class="kr">fun</span> (<span class="nv">w</span>:hfiber idmap b) =&gt; hfiber (g w.<span class="mi">1</span>) (transport Q (w.<span class="mi">2</span>)^ v))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb2"><span class="kn">Definition</span> <span class="nf">istruncmap_from_functor_sigma</span> <span class="nv">n</span> {<span class="nv">A</span> <span class="nv">P</span> <span class="nv">Q</span>}
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a)
  `{!IsTruncMap n (functor_sigma idmap g)}
  : <span class="kr">forall</span> <span class="nv">a</span>, IsTruncMap n (g a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n (functor_sigma idmap g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsTruncMap n (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n (functor_sigma idmap g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsTruncMap n (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sigma-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="sigma-v-chkb4"><span class="nb">intros</span> a v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n (functor_sigma idmap g)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (hfiber (g a) v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (hfiber_functor_sigma_idmap _ _ _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
