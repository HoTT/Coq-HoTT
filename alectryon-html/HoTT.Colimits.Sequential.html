<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Sequential.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Sequential colimits *)</span>

<span class="sd">(** We present a proof of the conjecture that sequential colimits in HoTT appropriately commute with Œ£-types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Diagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Sequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Colimit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.IdentitySystems.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [coe] is [transport idmap : (A = B) -&gt; (A -&gt; B)], but is described as the underlying map of an equivalence so that Coq knows that it is an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">coe</span> := (<span class="kr">fun</span> <span class="nv">p</span> =&gt; equiv_fun (equiv_path _ _ p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;a ^+&quot;</span> := (@arr sequence_graph _ _ _ <span class="mi">1</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Mapping spaces into hprops from colimits of sequences can be characterized. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1"><span class="kn">Lemma</span> <span class="nf">equiv_colim_seq_rec</span> `{Funext} (A : Sequence) (P : <span class="kt">Type</span>) `{IsHProp P}
  : (Colimit A -&gt; P) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">n</span>, A n -&gt; P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit A -&gt; P) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit A -&gt; P) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P) &lt;~&gt;
(Colimit A -&gt; P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4"><span class="nb">refine</span> (equiv_colimit_rec P oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P) &lt;~&gt;
Cocone A P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5"><span class="nb">refine</span> (issig_Cocone _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P) &lt;~&gt;
{H : <span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; P
&amp;
<span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> <span class="nv">x</span> : A i =&gt; H j ((A _f g) x)) == H i}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H : <span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; P
&amp;
<span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> <span class="nv">x</span> : A i =&gt; H j ((A _f g) x)) == H i} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7">srapply Build_Equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{H : <span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; P
&amp;
<span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> <span class="nv">x</span> : A i =&gt; H j ((A _f g) x)) == H i} -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n -&gt; P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk8"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9"><span class="mi">1</span>: <span class="bp">exact</span> pr1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a sequential colimit has maps homotopic to a constant map then the colimit is contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka"><span class="kn">Instance</span> <span class="nf">contr_colim_seq_into_prop</span> {<span class="nv">funext</span> : Funext} (<span class="nv">A</span> : Sequence)
  (<span class="nv">a</span> : <span class="kr">forall</span> <span class="nv">n</span>, A n) (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">n</span>, const (a n.+<span class="mi">1</span>) == A _f idpath)
  : Contr (Colimit A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc">transparent <span class="nb">assert</span> (B : Sequence).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chkd"><hr></label><div class="goal-conclusion">Contr (Colimit A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf">srapply Build_Sequence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk10"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="nl">?X</span> n -&gt; <span class="nl">?X</span> n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11"><span class="mi">1</span>: <span class="bp">exact</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, A n -&gt; A n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A n -&gt; A n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (const (a n.+<span class="mi">1</span>)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14">rapply contr_equiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk15"><hr></label><div class="goal-conclusion">Contr <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16"><span class="mi">1</span>: rapply equiv_functor_colimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> ~d~ A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk17"><hr></label><div class="goal-conclusion">Contr (Colimit <span class="nl">?Goal0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18"><span class="mi">1</span>: rapply (equiv_sequence B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B <span class="mi">0</span> &lt;~&gt; A <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk19"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">e</span> : B n &lt;~&gt; A n),
{e&#39; : B n.+<span class="mi">1</span> &lt;~&gt; A n.+<span class="mi">1</span> &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; (e x) ^+) == (<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; e&#39; x ^+)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk1a"><hr></label><div class="goal-conclusion">Contr (Colimit B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1b"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">e</span> : B n &lt;~&gt; A n),
{e&#39; : B n.+<span class="mi">1</span> &lt;~&gt; A n.+<span class="mi">1</span> &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; (e x) ^+) == (<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; e&#39; x ^+)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk1c"><hr></label><div class="goal-conclusion">Contr (Colimit B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">e</span> : B n &lt;~&gt; A n),
{e&#39; : B n.+<span class="mi">1</span> &lt;~&gt; A n.+<span class="mi">1</span> &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; (e x) ^+) == (<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; e&#39; x ^+)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1e"><span class="nb">intros</span> n e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B n &lt;~&gt; A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e&#39; : B n.+<span class="mi">1</span> &lt;~&gt; A n.+<span class="mi">1</span> &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; (e x) ^+) == (<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; e&#39; x ^+)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1f"><span class="kr">exists</span> <span class="nv">equiv_idmap</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B n &lt;~&gt; A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; (e x) ^+) ==
(<span class="kr">fun</span> <span class="nv">x</span> : B n =&gt; <span class="mi">1</span>%equiv x ^+)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk20"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B n &lt;~&gt; A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(e x) ^+ = <span class="mi">1</span>%equiv x ^+</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk21"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>B n &lt;~&gt; A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%equiv x ^+ = (e x) ^+</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H _ (e x)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk22">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk23">srapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Colimit B, <span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk25"><span class="mi">1</span>: <span class="bp">exact</span> (colim (D:=B) <span class="mi">1</span>%nat (a <span class="mi">1</span>%nat)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Colimit B, colim <span class="mi">1</span> (a <span class="mi">1</span>) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk26">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : B i),
colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk27"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) 
(<span class="nv">x</span> : B i),
transport (paths (colim <span class="mi">1</span> (a <span class="mi">1</span>))) 
  (colimp i j g x) (<span class="nl">?q</span> j ((B _f g) x)) = 
<span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk28">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : B i),
colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk29"><span class="nb">intros</span> i x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2a"><span class="nb">induction</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim <span class="mi">0</span> x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk2b"><hr></label><div class="goal-conclusion">colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i.+<span class="mi">1</span> x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2c"><span class="mi">1</span>: <span class="bp">exact</span> (colimp (D:=B) _ _ idpath x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i.+<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2d"><span class="nb">refine</span> (IHi (a i) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim i (a i) = colim i.+<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2e"><span class="nb">refine</span> ((colimp (D:=B) _ _ idpath (a i))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim i.+<span class="mi">1</span> (a i) ^+ = colim i.+<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2f"><span class="nb">refine</span> ((colimp (D:=B) _ _ idpath (a i.+<span class="mi">1</span>))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B i.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim i.+<span class="mi">2</span> (a i.+<span class="mi">1</span>) ^+ = colim i.+<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (colimp (D:=B) _ _ idpath x).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk30">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : B i),
transport (paths (colim <span class="mi">1</span> (a <span class="mi">1</span>))) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">x0</span> : B i0)
    =&gt;
    nat_rect
      (<span class="kr">fun</span> <span class="nv">i1</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">x1</span> : B i1, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i1 x1)
      (<span class="kr">fun</span> <span class="nv">x1</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x1)
      (<span class="kr">fun</span> (<span class="nv">i1</span> : nat)
         (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x1</span> : B i1,
                colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i1 x1)
         (<span class="nv">x1</span> : B i1.+<span class="mi">1</span>) =&gt;
       IHi (a i1) @
       ((colimp i1 i1.+<span class="mi">1</span> <span class="mi">1</span> (a i1))^ @
        ((colimp i1.+<span class="mi">1</span> i1.+<span class="mi">2</span> <span class="mi">1</span> (a i1.+<span class="mi">1</span>))^ @
         colimp i1.+<span class="mi">1</span> i1.+<span class="mi">2</span> <span class="mi">1</span> x1))) i0 x0) j
     ((B _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">x0</span> : B i0) =&gt;
 nat_rect
   (<span class="kr">fun</span> <span class="nv">i1</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : B i1, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i1 x1)
   (<span class="kr">fun</span> <span class="nv">x1</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x1)
   (<span class="kr">fun</span> (<span class="nv">i1</span> : nat)
      (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x1</span> : B i1,
             colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i1 x1)
      (<span class="nv">x1</span> : B i1.+<span class="mi">1</span>) =&gt;
    IHi (a i1) @
    ((colimp i1 i1.+<span class="mi">1</span> <span class="mi">1</span> (a i1))^ @
     ((colimp i1.+<span class="mi">1</span> i1.+<span class="mi">2</span> <span class="mi">1</span> (a i1.+<span class="mi">1</span>))^ @
      colimp i1.+<span class="mi">1</span> i1.+<span class="mi">2</span> <span class="mi">1</span> x1))) i0 x0) i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk31"><span class="nb">intros</span> n m [] x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (paths (colim <span class="mi">1</span> (a <span class="mi">1</span>))) (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x)
  (nat_rect
     (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
      <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
     (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
        (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i,
               colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x) (<span class="nv">x</span> : B i.+<span class="mi">1</span>)
      =&gt;
      IHi (a i) @
      ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
       ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
        colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n.+<span class="mi">1</span> x ^+) =
nat_rect
  (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
  (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
     (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
     (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
   IHi (a i) @
   ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
    ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
     colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk32"><span class="nb">rewrite</span> transport_paths_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (<span class="kr">fun</span> <span class="nv">_</span> : Colimit B =&gt; colim <span class="mi">1</span> (a <span class="mi">1</span>))
    (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x))^ @
 nat_rect
   (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
   (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
   (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
      (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
      (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
    IHi (a i) @
    ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
     ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
      colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n.+<span class="mi">1</span> x ^+) @
ap idmap (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x) =
nat_rect
  (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
  (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
     (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
     (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
   IHi (a i) @
   ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
    ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
     colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk33"><span class="nb">rewrite</span> ap_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span>^ @
 nat_rect
   (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
   (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
   (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
      (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
      (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
    IHi (a i) @
    ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
     ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
      colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n.+<span class="mi">1</span> x ^+) @
ap idmap (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x) =
nat_rect
  (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
  (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
     (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
     (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
   IHi (a i) @
   ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
    ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
     colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk34"><span class="nb">rewrite</span> ap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>funext</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, const (a n.+<span class="mi">1</span>) == A _f <span class="mi">1</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence A (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; const (a n.+<span class="mi">1</span>))</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span>^ @
 nat_rect
   (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
   (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
   (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
      (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
      (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
    IHi (a i) @
    ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
     ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
      colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n.+<span class="mi">1</span> x ^+) @
colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x =
nat_rect
  (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
  (<span class="kr">fun</span> <span class="nv">x</span> : B <span class="mi">0</span> =&gt; colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x)
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat)
     (<span class="nv">IHi</span> : <span class="kr">forall</span> <span class="nv">x</span> : B i, colim <span class="mi">1</span> (a <span class="mi">1</span>) = colim i x)
     (<span class="nv">x</span> : B i.+<span class="mi">1</span>) =&gt;
   IHi (a i) @
   ((colimp i i.+<span class="mi">1</span> <span class="mi">1</span> (a i))^ @
    ((colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> (a i.+<span class="mi">1</span>))^ @
     colimp i.+<span class="mi">1</span> i.+<span class="mi">2</span> <span class="mi">1</span> x))) n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> n; <span class="nb">simpl</span>; hott_simpl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk35"><span class="kn">Definition</span> <span class="nf">seq_shift_from_zero_by</span> {<span class="nv">A</span> : Sequence} (<span class="nv">a</span> : A <span class="mi">0</span>) <span class="nv">k</span> : A k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk37"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>A k</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk38"><hr></label><div class="goal-conclusion">A k.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>A k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A k.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q^+.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;a ^+ k&quot;</span> := (seq_shift_from_zero_by a k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Shiftings; described in the paragraph after Lemma 3.7. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3b"><span class="kn">Definition</span> <span class="nf">seq_pair_shift</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) : sig A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> x <span class="kr">as</span> [n a]; <span class="bp">exact</span> (n.+<span class="mi">1</span>; a^+).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3d"><span class="kn">Definition</span> <span class="nf">seq_pair_shift_by</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) (<span class="nv">k</span> : nat) : sig A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3f"><span class="nb">induction</span> k <span class="kr">as</span> [ | k y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk40"><hr></label><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (seq_pair_shift y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ^++&quot;</span> := (seq_pair_shift x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ^++ k&quot;</span> := (seq_pair_shift_by x k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk43"><span class="kn">Definition</span> <span class="nf">seq_pair_shift_assoc</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) (<span class="nv">k</span> : nat)
  : (x^++)^++k = x^++(k.+<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ^++) ^++ k = x ^++ (k.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ^++) ^++ k = x ^++ (k.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk45"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ^++) ^++ <span class="mi">0</span> = x ^++ <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(x ^++) ^++ k = x ^++ (k.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk46"><hr></label><div class="goal-conclusion">(x ^++) ^++ (k.+<span class="mi">1</span>) = x ^++ (k.+<span class="mi">2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ^++) ^++ <span class="mi">0</span> = x ^++ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(x ^++) ^++ k = x ^++ (k.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ^++) ^++ (k.+<span class="mi">1</span>) = x ^++ (k.+<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap seq_pair_shift q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk49"><span class="kn">Definition</span> <span class="nf">seq_shift_pair_from_zero</span> {<span class="nv">A</span> : Sequence} (<span class="nv">a</span> : A <span class="mi">0</span>) <span class="nv">k</span> : (<span class="mi">0</span>;a)^++k = (k;a^+k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ k = (k; a ^+ k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ k = (k; a ^+ k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4b"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ <span class="mi">0</span> = (<span class="mi">0</span>; a ^+ <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span>; a) ^++ k = (k; a ^+ k)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk4c"><hr></label><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ (k.+<span class="mi">1</span>) = (k.+<span class="mi">1</span>; a ^+ (k.+<span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ <span class="mi">0</span> = (<span class="mi">0</span>; a ^+ <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span>; a) ^++ k = (k; a ^+ k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span>; a) ^++ (k.+<span class="mi">1</span>) = (k.+<span class="mi">1</span>; a ^+ (k.+<span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap seq_pair_shift q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">inj</span> A := (@colim sequence_graph A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">glue</span> A := (<span class="kr">fun</span> <span class="nv">n</span> =&gt; @colimp sequence_graph A n n.+<span class="mi">1</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The uniqueness principle for sequential colimits; Lemma 3.3. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4f"><span class="kn">Definition</span> <span class="nf">seq_colimit_uniq</span> {<span class="nv">A</span> : Sequence} <span class="nv">E</span> (<span class="nv">F</span> <span class="nv">G</span> : Colimit A -&gt; E)
  (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">n</span>, F o inj A n == G o inj A n)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span>, ap F (glue A n a) @ h n a = h n.+<span class="mi">1</span> a^+ @ ap G (glue A n a))
  : F == G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>Colimit A -&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> a ^+ @ ap G (glue A n a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F == G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>Colimit A -&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> a ^+ @ ap G (glue A n a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F == G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk51">srapply (Colimit_ind _ h); <span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>Colimit A -&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> a ^+ @ ap G (glue A n a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; F w = G w)
  (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a) (h n.+<span class="mi">1</span> a ^+) = h n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk52"><span class="nb">generalize</span> (H n a); <span class="nb">generalize</span> (h n a); <span class="nb">destruct</span> (glue A n a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>Colimit A -&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> a ^+ @ ap G (glue A n a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : F (inj A n.+<span class="mi">1</span> a ^+) = G (inj A n.+<span class="mi">1</span> a ^+),
ap F <span class="mi">1</span> @ p = h n.+<span class="mi">1</span> a ^+ @ ap G <span class="mi">1</span> -&gt;
transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; F w = G w) <span class="mi">1</span>
  (h n.+<span class="mi">1</span> a ^+) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p q; srefine ((concat_p1 _)^ @ _); srefine (_ @ (concat_1p _)); <span class="bp">exact</span> q^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The successor sequence from Lemma 3.6. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">succ_seq</span> (<span class="nv">A</span> : Sequence) : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; A k.+<span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; a^+).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The shifted sequence from Lemma 3.7. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">shift_seq</span> (<span class="nv">A</span> : Sequence) <span class="nv">n</span> : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; A (k+n)%nat) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; a^+).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical equivalence between the colimit of the successor sequence and the colimit of the original sequence; Lemma 3.6. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk53"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq</span> <span class="nv">A</span> : Colimit (succ_seq A) -&gt; Colimit A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (succ_seq A) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (succ_seq A) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk55">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
succ_seq A i -&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk56"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (succ_seq A) _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk57">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
succ_seq A i -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; inj _ n.+<span class="mi">1</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk58">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a) j
o (succ_seq A) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue A n.+<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk59"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq_beta_glue</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">a</span>
  : ap (colim_succ_seq_to_colim_seq A) (glue (succ_seq A) n a) = glue A (n.+<span class="mi">1</span>) a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>succ_seq A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_succ_seq_to_colim_seq A)
  (glue (succ_seq A) n a) = glue A n.+<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>succ_seq A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_succ_seq_to_colim_seq A)
  (glue (succ_seq A) n a) = glue A n.+<span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5b"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq_ap_inj</span> <span class="nv">A</span> <span class="nv">n</span> (<span class="nv">a1</span> <span class="nv">a2</span> : succ_seq A n) (<span class="nv">p</span> : a1 = a2)
  : ap (colim_succ_seq_to_colim_seq A) (ap (inj _ n) p) = ap (inj _ n.+<span class="mi">1</span>) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>succ_seq A n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_succ_seq_to_colim_seq A)
  (ap (inj (succ_seq A) n) p) = ap (inj A n.+<span class="mi">1</span>) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>succ_seq A n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_succ_seq_to_colim_seq A)
  (ap (inj (succ_seq A) n) p) = ap (inj A n.+<span class="mi">1</span>) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5d"><span class="kn">Instance</span> <span class="nf">isequiv_colim_succ_seq_to_colim_seq</span> <span class="nv">A</span>
  : IsEquiv (colim_succ_seq_to_colim_seq A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (colim_succ_seq_to_colim_seq A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (colim_succ_seq_to_colim_seq A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5f">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit A -&gt; Colimit (succ_seq A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk60"><hr></label><div class="goal-conclusion">colim_succ_seq_to_colim_seq A o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk61"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o colim_succ_seq_to_colim_seq A == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk62">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit A -&gt; Colimit (succ_seq A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk63">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; Colimit (succ_seq A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk64"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o A _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk65">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; Colimit (succ_seq A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; inj (succ_seq A) n a^+).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk66">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 inj (succ_seq A) n a ^+) j o A _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 inj (succ_seq A) n a ^+) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue (succ_seq A) n a^+).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim_succ_seq_to_colim_seq A
o Colimit_rec (Colimit (succ_seq A))
    {|
      legs :=
        <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n a ^+;
      legs_comm :=
        <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
          (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
        (<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
           <span class="kr">return</span>
             (inj (succ_seq A) n0 ((A _f p0) a) ^+ =
              inj (succ_seq A) n a ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; glue (succ_seq A) n a ^+
         <span class="kr">end</span>)
        :
        (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+) m
        o A _f p ==
        (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+) n
    |} == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk68">srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 colim_succ_seq_to_colim_seq A
   (Colimit_rec (Colimit (succ_seq A))
      {|
        legs :=
          <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+;
        legs_comm :=
          <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
          (<span class="kr">fun</span> <span class="nv">a</span> : A n0 =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
             <span class="kr">return</span>
               (inj (succ_seq A) n1 ((A _f p0) a) ^+ =
                inj (succ_seq A) n0 a ^+)
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a ^+
           <span class="kr">end</span>)
          :
          (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
             (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) m
          o A _f p ==
          (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
             (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+)
            n0
      |} x)) o inj A n == idmap o inj A n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk69"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   colim_succ_seq_to_colim_seq A
     (Colimit_rec (Colimit (succ_seq A))
        {|
          legs :=
            <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
              (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 a0 ^+;
          legs_comm :=
            <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
              (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            =&gt;
            (<span class="kr">fun</span> <span class="nv">a0</span> : A n0 =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
               <span class="kr">return</span>
                 (inj (succ_seq A) n1 ((...) a0) ^+ =
                  inj (succ_seq A) n0 a0 ^+)
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a0 ^+
             <span class="kr">end</span>)
            :
            (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
               (<span class="nv">a0</span> : A n1) =&gt;
             inj (succ_seq A) n1 a0 ^+) m o A _f p ==
            (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
               (<span class="nv">a0</span> : A n1) =&gt;
             inj (succ_seq A) n1 a0 ^+) n0
        |} x)) (glue A n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> a ^+ @ ap idmap (glue A n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 colim_succ_seq_to_colim_seq A
   (Colimit_rec (Colimit (succ_seq A))
      {|
        legs :=
          <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+;
        legs_comm :=
          <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
          (<span class="kr">fun</span> <span class="nv">a</span> : A n0 =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
             <span class="kr">return</span>
               (inj (succ_seq A) n1 ((A _f p0) a) ^+ =
                inj (succ_seq A) n0 a ^+)
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a ^+
           <span class="kr">end</span>)
          :
          (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
             (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) m
          o A _f p ==
          (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
             (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+)
            n0
      |} x)) o inj A n == idmap o inj A n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; glue _ n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   colim_succ_seq_to_colim_seq A
     (Colimit_rec (Colimit (succ_seq A))
        {|
          legs :=
            <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
              (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 a0 ^+;
          legs_comm :=
            <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
              (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            =&gt;
            (<span class="kr">fun</span> <span class="nv">a0</span> : A n0 =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
               <span class="kr">return</span>
                 (inj (succ_seq A) n1 ((...) a0) ^+ =
                  inj (succ_seq A) n0 a0 ^+)
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a0 ^+
             <span class="kr">end</span>)
            :
            (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
               (<span class="nv">a0</span> : A n1) =&gt;
             inj (succ_seq A) n1 a0 ^+) m o A _f p ==
            (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
               (<span class="nv">a0</span> : A n1) =&gt;
             inj (succ_seq A) n1 a0 ^+) n0
        |} x)) (glue A n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0) =&gt;
 glue A n0 a0) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0) =&gt;
 glue A n0 a0) n.+<span class="mi">1</span> a ^+ @ ap idmap (glue A n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6c"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> ap_idmap, ap_compose, Colimit_rec_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_succ_seq_to_colim_seq A)
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n a ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">a</span> : A n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
           <span class="kr">return</span>
             (inj (succ_seq A) n0 ((A _f p0) a) ^+ =
              inj (succ_seq A) n a ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a ^+
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a =
colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span> a ^+ @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> colim_succ_seq_to_colim_seq_beta_glue; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec (Colimit (succ_seq A))
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
      =&gt; inj (succ_seq A) n a ^+;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
      (<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (inj (succ_seq A) n0 ((A _f p0) a) ^+ =
            inj (succ_seq A) n a ^+)
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt; glue (succ_seq A) n a ^+
       <span class="kr">end</span>)
      :
      (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+) m
      o A _f p ==
      (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+) n
  |} o colim_succ_seq_to_colim_seq A == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6e">srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
 Colimit_rec (Colimit (succ_seq A))
   {|
     legs :=
       <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+;
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
       (<span class="kr">fun</span> <span class="nv">a</span> : A n0 =&gt;
        <span class="kr">match</span>
          p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
          <span class="kr">return</span>
            (inj (succ_seq A) n1 ((A _f p0) a) ^+ =
             inj (succ_seq A) n0 a ^+)
        <span class="kr">with</span>
        | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a ^+
        <span class="kr">end</span>)
       :
       (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) m
       o A _f p ==
       (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) n0
   |} (colim_succ_seq_to_colim_seq A x))
o inj (succ_seq A) n == idmap o inj (succ_seq A) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk6f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : succ_seq A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
   Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 a0 ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
         (<span class="kr">fun</span> <span class="nv">a0</span> : A n0 =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
            <span class="kr">return</span>
              (inj (succ_seq A) n1 ((A _f p0) a0) ^+ =
               inj (succ_seq A) n0 a0 ^+)
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a0 ^+
          <span class="kr">end</span>)
         :
         (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a0</span> : A n1) =&gt; inj (succ_seq A) n1 a0 ^+)
           m o A _f p ==
         (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a0</span> : A n1) =&gt; inj (succ_seq A) n1 a0 ^+)
           n0
     |} (colim_succ_seq_to_colim_seq A x))
  (glue (succ_seq A) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> a ^+ @ ap idmap (glue (succ_seq A) n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk70">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
 Colimit_rec (Colimit (succ_seq A))
   {|
     legs :=
       <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 a ^+;
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
       (<span class="kr">fun</span> <span class="nv">a</span> : A n0 =&gt;
        <span class="kr">match</span>
          p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
          <span class="kr">return</span>
            (inj (succ_seq A) n1 ((A _f p0) a) ^+ =
             inj (succ_seq A) n0 a ^+)
        <span class="kr">with</span>
        | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a ^+
        <span class="kr">end</span>)
       :
       (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) m
       o A _f p ==
       (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n1) =&gt; inj (succ_seq A) n1 a ^+) n0
   |} (colim_succ_seq_to_colim_seq A x))
o inj (succ_seq A) n == idmap o inj (succ_seq A) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; glue _ n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk71">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : succ_seq A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
   Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 a0 ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m) =&gt;
         (<span class="kr">fun</span> <span class="nv">a0</span> : A n0 =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
            <span class="kr">return</span>
              (inj (succ_seq A) n1 ((A _f p0) a0) ^+ =
               inj (succ_seq A) n0 a0 ^+)
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 a0 ^+
          <span class="kr">end</span>)
         :
         (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a0</span> : A n1) =&gt; inj (succ_seq A) n1 a0 ^+)
           m o A _f p ==
         (<span class="kr">fun</span> (<span class="nv">n1</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a0</span> : A n1) =&gt; inj (succ_seq A) n1 a0 ^+)
           n0
     |} (colim_succ_seq_to_colim_seq A x))
  (glue (succ_seq A) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : succ_seq A n0) =&gt; glue (succ_seq A) n0 a0) n
  a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : succ_seq A n0) =&gt; glue (succ_seq A) n0 a0)
  n.+<span class="mi">1</span> a ^+ @ ap idmap (glue (succ_seq A) n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk72"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> ap_idmap, ap_compose, Colimit_rec_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>succ_seq A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n a ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">a</span> : A n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
           <span class="kr">return</span>
             (inj (succ_seq A) n0 ((A _f p0) a) ^+ =
              inj (succ_seq A) n a ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a ^+
         <span class="kr">end</span>
     |})
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
           <span class="kr">return</span>
             ((<span class="kr">fun</span> <span class="nv">x</span> : succ_seq A n =&gt;
               inj A n0.+<span class="mi">1</span> (((succ_seq A) _f p0) x)) ==
              (<span class="kr">fun</span> <span class="nv">a</span> : succ_seq A n =&gt; inj A n.+<span class="mi">1</span> a))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span>
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a =
colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span> a ^+ @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (@Colimit_rec_beta_colimp _ A _ _ _ _ <span class="mi">1</span>); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_colim_succ_seq_to_colim_seq</span> <span class="nv">A</span> : Colimit (succ_seq A) &lt;~&gt; Colimit A
  := Build_Equiv _ _ (colim_succ_seq_to_colim_seq A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk73"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq</span> <span class="nv">A</span> <span class="nv">n</span> : Colimit (shift_seq A n) -&gt; Colimit A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A n) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A n) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk75">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n i -&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk76"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (shift_seq A n) _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk77">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n i -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; inj A (k+n)%nat a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk78">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : shift_seq A n k) =&gt; inj A (k + n) a) j
o (shift_seq A n) _f g ==
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : shift_seq A n k) =&gt; inj A (k + n) a) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k l p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue A (k+n)%nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk79"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq_beta_glue</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">k</span> <span class="nv">a</span>
  : ap (colim_shift_seq_to_colim_seq A n) (glue (shift_seq A n) k a) = glue A (k+n)%nat a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_shift_seq_to_colim_seq A n)
  (glue (shift_seq A n) k a) = glue A (k + n) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_shift_seq_to_colim_seq A n)
  (glue (shift_seq A n) k a) = glue A (k + n) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7b"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq_ap_inj</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">k</span> (<span class="nv">a1</span> <span class="nv">a2</span> : shift_seq A n k) (<span class="nv">p</span> : a1 = a2)
  : ap (colim_shift_seq_to_colim_seq A n) (ap (inj _ k) p) = ap (inj _ (k+n)%nat) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>shift_seq A n k</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_shift_seq_to_colim_seq A n)
  (ap (inj (shift_seq A n) k) p) =
ap (inj A (k + n)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>shift_seq A n k</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (colim_shift_seq_to_colim_seq A n)
  (ap (inj (shift_seq A n) k) p) =
ap (inj A (k + n)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7d"><span class="kn">Local Definition</span> <span class="nf">J</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} {<span class="nv">I</span> : <span class="kr">forall</span> <span class="nv">x</span>, Y x -&gt; Z} (<span class="nv">p</span> : x2 = x1)
  : I x2 y = I x1 (coe (ap Y p) y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x2 = x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">I x2 y = I x1 (coe (ap Y p) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x2 = x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">I x2 y = I x1 (coe (ap Y p) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7f"><span class="kn">Local Definition</span> <span class="nf">K</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} <span class="nv">F</span> <span class="nv">G</span> (<span class="nv">p</span> : x1 = x2) :
  G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk81"><span class="kn">Local Definition</span> <span class="nf">L</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} {<span class="nv">F</span> <span class="nv">G</span>} {<span class="nv">I</span> : <span class="kr">forall</span> <span class="nv">x</span>, Y x -&gt; Z} {<span class="nv">p</span> : x2 = x1}
  (<span class="nv">Q</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, I (F x) (G x y) = I x y)
  : Q x2 y @ J p =
    J (ap F p) @ (ap (I (F x1)) (K F G p)^ @
    Q x1 (coe (ap Y p) y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x2 = x1</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q x2 y @ J p =
J (ap F p) @
(ap (I (F x1)) (K F G p)^ @ Q x1 (coe (ap Y p) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x2 = x1</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q x2 y @ J p =
J (ap F p) @
(ap (I (F x1)) (K F G p)^ @ Q x1 (coe (ap Y p) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk83"><span class="nb">destruct</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q x2 y @ <span class="mi">1</span> = <span class="mi">1</span> @ (<span class="mi">1</span> @ Q x2 y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk84"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q x2 y = <span class="mi">1</span> @ Q x2 y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk85"><span class="kn">Instance</span> <span class="nf">isequiv_colim_shift_seq_to_colim_seq</span> `{Funext} A n
  : IsEquiv (colim_shift_seq_to_colim_seq A n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (colim_shift_seq_to_colim_seq A n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (colim_shift_seq_to_colim_seq A n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk87"><span class="nb">induction</span> n <span class="kr">as</span> [ | n e]; srapply isequiv_homotopic&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A <span class="mi">0</span>) &lt;~&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk88"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == colim_shift_seq_to_colim_seq A <span class="mi">0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk89"><hr></label><div class="goal-conclusion">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt; Colimit A</div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk8a"><hr></label><div class="goal-conclusion"><span class="nl">?f0</span> == colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A <span class="mi">0</span>) &lt;~&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8c">srapply equiv_functor_colimit; srapply Build_diagram_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (shift_seq A <span class="mi">0</span>) A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk8d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (shift_seq A <span class="mi">0</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8f">srapply Build_DiagramMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A <span class="mi">0</span> i -&gt; A i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk90"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A <span class="mi">0</span> i),
(A _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j (((shift_seq A <span class="mi">0</span>) _f g) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk91">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A <span class="mi">0</span> i -&gt; A i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; coe (ap A (nat_add_zero_r k))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk92">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A <span class="mi">0</span> i),
(A _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_zero_r k))) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_zero_r k))) j
  (((shift_seq A <span class="mi">0</span>) _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk93"><span class="nb">intros</span> k l p a; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A <span class="mi">0</span> k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path (A (k + <span class="mi">0</span>)) (A k)
   (ap A (nat_add_zero_r k)) a) ^+ =
equiv_path (A (k.+<span class="mi">1</span> + <span class="mi">0</span>)) (A k.+<span class="mi">1</span>)
  (ap A (nat_add_zero_r k.+<span class="mi">1</span>)) a ^+</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (K S (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; a^+) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap A (nat_add_zero_r k));
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
         (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n)
         <span class="kr">return</span>
           ((A _f p0)
              (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                 (ap A (nat_add_zero_r k)) a) =
            equiv_path (A (n + <span class="mi">0</span>)) (A n)
              (ap A (nat_add_zero_r n))
              (((shift_seq A <span class="mi">0</span>) _f p0) a))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
             (nat_add_zero_r k)
       <span class="kr">end</span>
   |} i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk95">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_zero_r k));
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n)
            <span class="kr">return</span>
              ((A _f p0)
                 (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                    (ap A (nat_add_zero_r k)) a) =
               equiv_path (A (n + <span class="mi">0</span>)) (A n)
                 (ap A (nat_add_zero_r n))
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                (nat_add_zero_r k)
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
      equiv_isequiv
        (equiv_path (A (i + <span class="mi">0</span>)) (A i)
           (ap A (nat_add_zero_r i)))
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) ==
colim_shift_seq_to_colim_seq A <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk96"><span class="nb">symmetry</span>; srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A <span class="mi">0</span>
o inj (shift_seq A <span class="mi">0</span>) n ==
equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_zero_r k));
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
            <span class="kr">return</span>
              ((A _f p0)
                 (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                    (ap A (nat_add_zero_r k)) a) =
               equiv_path (A (n0 + <span class="mi">0</span>)) (A n0)
                 (ap A (nat_add_zero_r n0))
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a0</span> : A n0) =&gt; a0 ^+)
                (nat_add_zero_r k)
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
      equiv_isequiv
        (equiv_path (A (i + <span class="mi">0</span>)) (A i)
           (ap A (nat_add_zero_r i)))
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk97"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A <span class="mi">0</span> n),
ap (colim_shift_seq_to_colim_seq A <span class="mi">0</span>)
  (glue (shift_seq A <span class="mi">0</span>) n a) @ <span class="nl">?h0</span> n a =
<span class="nl">?h0</span> n.+<span class="mi">1</span> a ^+ @
ap
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_zero_r k));
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
               <span class="kr">return</span>
                 ((A _f p0)
                    (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                       (ap A (nat_add_zero_r k)) a0) =
                  equiv_path (A (n0 + <span class="mi">0</span>)) (A n0)
                    (ap A (nat_add_zero_r n0))
                    (((shift_seq A <span class="mi">0</span>) _f p0) a0))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt;
                    a1 ^+) (nat_add_zero_r k)
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
         equiv_isequiv
           (equiv_path (A (i + <span class="mi">0</span>)) (A i)
              (ap A (nat_add_zero_r i)))
     |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
     (iscolimit_colimit A)) (glue (shift_seq A <span class="mi">0</span>) n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk98">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A <span class="mi">0</span>
o inj (shift_seq A <span class="mi">0</span>) n ==
equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_zero_r k));
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
            <span class="kr">return</span>
              ((A _f p0)
                 (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                    (ap A (nat_add_zero_r k)) a) =
               equiv_path (A (n0 + <span class="mi">0</span>)) (A n0)
                 (ap A (nat_add_zero_r n0))
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a0</span> : A n0) =&gt; a0 ^+)
                (nat_add_zero_r k)
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
      equiv_isequiv
        (equiv_path (A (i + <span class="mi">0</span>)) (A i)
           (ap A (nat_add_zero_r i)))
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k a; <span class="bp">exact</span> (J (nat_add_zero_r k)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk99">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A <span class="mi">0</span> n),
ap (colim_shift_seq_to_colim_seq A <span class="mi">0</span>)
  (glue (shift_seq A <span class="mi">0</span>) n a) @
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k =&gt; J (nat_add_zero_r k))
 :
 colim_shift_seq_to_colim_seq A <span class="mi">0</span>
 o inj (shift_seq A <span class="mi">0</span>) k ==
 equiv_functor_colimit
   {|
     diag_equiv_map :=
       {|
         DiagramMap_obj :=
           <span class="kr">fun</span> <span class="nv">k0</span> : Graph.graph0 sequence_graph =&gt;
           coe (ap A (nat_add_zero_r k0));
         DiagramMap_comm :=
           <span class="kr">fun</span> (<span class="nv">k0</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
             (<span class="nv">p</span> : Graph.graph1 sequence_graph k0 l)
             (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k0) =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
             <span class="kr">return</span>
               ((A _f p0)
                  (equiv_path (...) (...) (...) a0) =
                equiv_path (A (...)) (A n0)
                  (ap A (...)) ((...) a0))
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               K S
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt; a1 ^+)
                 (nat_add_zero_r k0)
           <span class="kr">end</span>
       |};
     diag_equiv_isequiv :=
       <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
       equiv_isequiv
         (equiv_path (A (i + <span class="mi">0</span>)) (A i)
            (ap A (nat_add_zero_r i)))
   |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
   (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) k) n a =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k =&gt; J (nat_add_zero_r k))
 :
 colim_shift_seq_to_colim_seq A <span class="mi">0</span>
 o inj (shift_seq A <span class="mi">0</span>) k ==
 equiv_functor_colimit
   {|
     diag_equiv_map :=
       {|
         DiagramMap_obj :=
           <span class="kr">fun</span> <span class="nv">k0</span> : Graph.graph0 sequence_graph =&gt;
           coe (ap A (nat_add_zero_r k0));
         DiagramMap_comm :=
           <span class="kr">fun</span> (<span class="nv">k0</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
             (<span class="nv">p</span> : Graph.graph1 sequence_graph k0 l)
             (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k0) =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
             <span class="kr">return</span>
               ((A _f p0)
                  (equiv_path (...) (...) (...) a0) =
                equiv_path (A (...)) (A n0)
                  (ap A (...)) ((...) a0))
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               K S
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt; a1 ^+)
                 (nat_add_zero_r k0)
           <span class="kr">end</span>
       |};
     diag_equiv_isequiv :=
       <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
       equiv_isequiv
         (equiv_path (A (i + <span class="mi">0</span>)) (A i)
            (ap A (nat_add_zero_r i)))
   |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
   (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) k) n.+<span class="mi">1</span>
  a ^+ @
ap
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_zero_r k));
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
               <span class="kr">return</span>
                 ((A _f p0)
                    (equiv_path (A (k + <span class="mi">0</span>)) (A k)
                       (ap A (nat_add_zero_r k)) a0) =
                  equiv_path (A (n0 + <span class="mi">0</span>)) (A n0)
                    (ap A (nat_add_zero_r n0))
                    (((shift_seq A <span class="mi">0</span>) _f p0) a0))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt;
                    a1 ^+) (nat_add_zero_r k)
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
         equiv_isequiv
           (equiv_path (A (i + <span class="mi">0</span>)) (A i)
              (ap A (nat_add_zero_r i)))
     |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
     (iscolimit_colimit A)) (glue (shift_seq A <span class="mi">0</span>) n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k a; <span class="nb">rewrite</span> !Colimit_rec_beta_colimp; <span class="bp">exact</span> (L (glue A)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9b"><span class="nb">transitivity</span> (Colimit (succ_seq (shift_seq A n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt;
Colimit (succ_seq (shift_seq A n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk9c"><hr></label><div class="goal-conclusion">Colimit (succ_seq (shift_seq A n)) &lt;~&gt; Colimit A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt;
Colimit (succ_seq (shift_seq A n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9e">srapply equiv_functor_colimit; srapply Build_diagram_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (shift_seq A n.+<span class="mi">1</span>)
  (succ_seq (shift_seq A n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk9f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka0">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (shift_seq A n.+<span class="mi">1</span>)
  (succ_seq (shift_seq A n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka1">srapply Build_DiagramMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n.+<span class="mi">1</span> i -&gt; succ_seq (shift_seq A n) i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chka2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n.+<span class="mi">1</span> i -&gt; succ_seq (shift_seq A n) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; coe (ap A (nat_add_succ_r k n))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_succ_r k n))) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_succ_r k n))) j
  (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_succ_r k n))) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_succ_r k n))) j
  (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k l p a; <span class="nb">destruct</span> p; rapply (K S (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; a^+) (nat_add_succ_r k n)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka6">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap A (nat_add_succ_r k n));
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
         (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (((succ_seq (shift_seq A n)) _f p0)
              (equiv_path (A (k + n.+<span class="mi">1</span>))
                 (A (k + n).+<span class="mi">1</span>)
                 (ap A (nat_add_succ_r k n)) a) =
            equiv_path (A (n0 + n.+<span class="mi">1</span>)) (A (n0 + n).+<span class="mi">1</span>)
              (ap A (nat_add_succ_r n0 n))
              (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
             (nat_add_succ_r k n)
       <span class="kr">end</span>
   |} i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (succ_seq (shift_seq A n)) &lt;~&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srefine (<span class="nb">transitivity</span> (equiv_colim_succ_seq_to_colim_seq _) (Build_Equiv _ _ _ e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_succ_r k n));
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (equiv_path (A (k + n.+<span class="mi">1</span>))
                       (A (k + n).+<span class="mi">1</span>)
                       (ap A (nat_add_succ_r k n)) a) =
                  equiv_path (A (n0 + n.+<span class="mi">1</span>))
                    (A (n0 + n).+<span class="mi">1</span>)
                    (ap A (nat_add_succ_r n0 n))
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                   (nat_add_succ_r k n)
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
         equiv_isequiv
           (equiv_path (A (i + n.+<span class="mi">1</span>)) (A (i + n).+<span class="mi">1</span>)
              (ap A (nat_add_succ_r i n)))
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) == colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka9"><span class="nb">symmetry</span>; srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
o inj (shift_seq A n.+<span class="mi">1</span>) n0 ==
(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_succ_r k n));
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (equiv_path (A (k + n.+<span class="mi">1</span>))
                       (A (k + n).+<span class="mi">1</span>)
                       (ap A (nat_add_succ_r k n)) a) =
                  equiv_path (A (n1 + n.+<span class="mi">1</span>))
                    (A (n1 + n).+<span class="mi">1</span>)
                    (ap A (nat_add_succ_r n1 n))
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                   (nat_add_succ_r k n)
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
         equiv_isequiv
           (equiv_path (A (i + n.+<span class="mi">1</span>)) (A (i + n).+<span class="mi">1</span>)
              (ap A (nat_add_succ_r i n)))
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) o inj (shift_seq A n.+<span class="mi">1</span>) n0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkaa"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> n0),
ap (colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>)
  (glue (shift_seq A n.+<span class="mi">1</span>) n0 a) @ <span class="nl">?h</span> n0 a =
<span class="nl">?h</span> n0.+<span class="mi">1</span> a ^+ @
ap
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
    equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
     (Colimit (succ_seq (shift_seq A n))) (Colimit A)
     (equiv_functor_colimit
        {|
          diag_equiv_map :=
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
                coe (ap A (nat_add_succ_r k n));
              DiagramMap_comm :=
                <span class="kr">fun</span>
                  (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                  (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
                  (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
                  <span class="kr">return</span>
                    (((succ_seq (...)) _f p0)
                       (equiv_path (A (...))
                          (A (...).+<span class="mi">1</span>) (ap A (...)) a0) =
                     equiv_path (A (n1 + n.+<span class="mi">1</span>))
                       (A (n1 + n).+<span class="mi">1</span>)
                       (ap A (nat_add_succ_r n1 n))
                       (((...) _f p0) a0))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt;
                       a1 ^+) (nat_add_succ_r k n)
                <span class="kr">end</span>
            |};
          diag_equiv_isequiv :=
            <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
            equiv_isequiv
              (equiv_path (A (i + n.+<span class="mi">1</span>))
                 (A (i + n).+<span class="mi">1</span>)
                 (ap A (nat_add_succ_r i n)))
        |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
        (iscolimit_colimit (succ_seq (shift_seq A n))))
     (<span class="nb">transitivity</span>
        (equiv_colim_succ_seq_to_colim_seq
           (shift_seq A n))
        {|
          equiv_fun :=
            colim_shift_seq_to_colim_seq A n;
          equiv_isequiv := e
        |})) (glue (shift_seq A n.+<span class="mi">1</span>) n0 a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkab">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
o inj (shift_seq A n.+<span class="mi">1</span>) n0 ==
(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_succ_r k n));
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (equiv_path (A (k + n.+<span class="mi">1</span>))
                       (A (k + n).+<span class="mi">1</span>)
                       (ap A (nat_add_succ_r k n)) a) =
                  equiv_path (A (n1 + n.+<span class="mi">1</span>))
                    (A (n1 + n).+<span class="mi">1</span>)
                    (ap A (nat_add_succ_r n1 n))
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                   (nat_add_succ_r k n)
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
         equiv_isequiv
           (equiv_path (A (i + n.+<span class="mi">1</span>)) (A (i + n).+<span class="mi">1</span>)
              (ap A (nat_add_succ_r i n)))
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) o inj (shift_seq A n.+<span class="mi">1</span>) n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k a; <span class="bp">exact</span> (J (nat_add_succ_r k n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkac">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> n0),
ap (colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>)
  (glue (shift_seq A n.+<span class="mi">1</span>) n0 a) @
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k =&gt;
  J (nat_add_succ_r k n))
 :
 colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
 o inj (shift_seq A n.+<span class="mi">1</span>) k ==
 (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
  equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
   (Colimit (succ_seq (shift_seq A n))) (Colimit A)
   (equiv_functor_colimit
      {|
        diag_equiv_map :=
          {|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k0</span> : Graph.graph0 sequence_graph =&gt;
              coe (ap A (nat_add_succ_r k0 n));
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k0</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                (<span class="nv">p</span> : Graph.graph1 sequence_graph k0 l)
                (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k0) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
                <span class="kr">return</span>
                  ((...) (...) =
                   equiv_path (...) (...) (...) (...))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt; a1 ^+)
                    (nat_add_succ_r k0 n)
              <span class="kr">end</span>
          |};
        diag_equiv_isequiv :=
          <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
          equiv_isequiv
            (equiv_path (A (i + n.+<span class="mi">1</span>)) (A (i + n).+<span class="mi">1</span>)
               (ap A (nat_add_succ_r i n)))
      |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
      (iscolimit_colimit (succ_seq (shift_seq A n))))
   (<span class="nb">transitivity</span>
      (equiv_colim_succ_seq_to_colim_seq
         (shift_seq A n))
      {|
        equiv_fun := colim_shift_seq_to_colim_seq A n;
        equiv_isequiv := e
      |}) o inj (shift_seq A n.+<span class="mi">1</span>) k) n0 a =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k =&gt;
  J (nat_add_succ_r k n))
 :
 colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
 o inj (shift_seq A n.+<span class="mi">1</span>) k ==
 (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
  equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
   (Colimit (succ_seq (shift_seq A n))) (Colimit A)
   (equiv_functor_colimit
      {|
        diag_equiv_map :=
          {|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k0</span> : Graph.graph0 sequence_graph =&gt;
              coe (ap A (nat_add_succ_r k0 n));
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k0</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                (<span class="nv">p</span> : Graph.graph1 sequence_graph k0 l)
                (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k0) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
                <span class="kr">return</span>
                  ((...) (...) =
                   equiv_path (...) (...) (...) (...))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt; a1 ^+)
                    (nat_add_succ_r k0 n)
              <span class="kr">end</span>
          |};
        diag_equiv_isequiv :=
          <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
          equiv_isequiv
            (equiv_path (A (i + n.+<span class="mi">1</span>)) (A (i + n).+<span class="mi">1</span>)
               (ap A (nat_add_succ_r i n)))
      |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
      (iscolimit_colimit (succ_seq (shift_seq A n))))
   (<span class="nb">transitivity</span>
      (equiv_colim_succ_seq_to_colim_seq
         (shift_seq A n))
      {|
        equiv_fun := colim_shift_seq_to_colim_seq A n;
        equiv_isequiv := e
      |}) o inj (shift_seq A n.+<span class="mi">1</span>) k) n0.+<span class="mi">1</span> a ^+ @
ap
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
    equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
     (Colimit (succ_seq (shift_seq A n))) (Colimit A)
     (equiv_functor_colimit
        {|
          diag_equiv_map :=
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
                coe (ap A (nat_add_succ_r k n));
              DiagramMap_comm :=
                <span class="kr">fun</span>
                  (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                  (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
                  (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n1)
                  <span class="kr">return</span>
                    (((succ_seq (...)) _f p0)
                       (equiv_path (A (...))
                          (A (...).+<span class="mi">1</span>) (ap A (...)) a0) =
                     equiv_path (A (n1 + n.+<span class="mi">1</span>))
                       (A (n1 + n).+<span class="mi">1</span>)
                       (ap A (nat_add_succ_r n1 n))
                       (((...) _f p0) a0))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt;
                       a1 ^+) (nat_add_succ_r k n)
                <span class="kr">end</span>
            |};
          diag_equiv_isequiv :=
            <span class="kr">fun</span> <span class="nv">i</span> : Graph.graph0 sequence_graph =&gt;
            equiv_isequiv
              (equiv_path (A (i + n.+<span class="mi">1</span>))
                 (A (i + n).+<span class="mi">1</span>)
                 (ap A (nat_add_succ_r i n)))
        |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
        (iscolimit_colimit (succ_seq (shift_seq A n))))
     (<span class="nb">transitivity</span>
        (equiv_colim_succ_seq_to_colim_seq
           (shift_seq A n))
        {|
          equiv_fun :=
            colim_shift_seq_to_colim_seq A n;
          equiv_isequiv := e
        |})) (glue (shift_seq A n.+<span class="mi">1</span>) n0 a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkad"><span class="nb">intros</span> k a; <span class="nb">rewrite</span> Colimit_rec_beta_colimp; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n.+<span class="mi">1</span> k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_succ_r k n) =
J (ap S (nat_add_succ_r k n)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (shift_seq A n.+<span class="mi">1</span>) =&gt;
   colim_shift_seq_to_colim_seq A n
     (colim_succ_seq_to_colim_seq (shift_seq A n)
        (functor_colimit
           {|
             DiagramMap_obj :=
               <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
               transport idmap
                 (ap A (nat_add_succ_r k n));
             DiagramMap_comm :=
               <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                 (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
               <span class="kr">match</span>
                 p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
                 <span class="kr">return</span>
                   (<span class="kr">match</span>
                      p0 <span class="kr">in</span> (_ = n1)
                      <span class="kr">return</span> (... -&gt; ...)
                    <span class="kr">with</span>
                    | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A ....+<span class="mi">1</span> =&gt; a0 ^+
                    <span class="kr">end</span>
                      (transport idmap
                         (ap A (nat_add_succ_r k n)) a) =
                    transport idmap
                      (ap A (nat_add_succ_r n0 n))
                      (<span class="kr">match</span> p0 <span class="kr">in</span> ... <span class="kr">return</span> ... <span class="kr">with</span>
                       | <span class="mi">1</span> =&gt; <span class="kr">fun</span> ... =&gt; a0 ^+
                       <span class="kr">end</span> a))
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt;
                   K S
                     (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                      a0 ^+) (nat_add_succ_r k n)
               <span class="kr">end</span>
           |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
           (iscolimit_colimit
              (succ_seq (shift_seq A n))) x)))
  (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkae"><span class="nb">rewrite</span> <span class="mi">2</span>(ap_compose&#39; _ _ (glue _ k a)), Colimit_rec_beta_colimp, <span class="mi">2</span>ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n.+<span class="mi">1</span> k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_succ_r k n) =
J (ap S (nat_add_succ_r k n)) @
(ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (ap
         (iscolimit_colimit (succ_seq (shift_seq A n))
            k.+<span class="mi">1</span>)
         (DiagramMap_comm
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
                transport idmap
                  (ap A (nat_add_succ_r k n));
              DiagramMap_comm :=
                <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                  (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
                  <span class="kr">return</span>
                    (<span class="kr">match</span>
                       p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...)
                     <span class="kr">with</span>
                     | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; a0 ^+
                     <span class="kr">end</span>
                       (transport idmap (ap A (...)) a) =
                     transport idmap
                       (ap A (nat_add_succ_r n0 n))
                       (<span class="kr">match</span> ... ... <span class="kr">with</span>
                        | ... =&gt; ... =&gt; ...
                        <span class="kr">end</span> a))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                       a0 ^+) (nat_add_succ_r k n)
                <span class="kr">end</span>
            |} <span class="mi">1</span> a)^)) @
 ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (legs_comm
         (iscolimit_colimit (succ_seq (shift_seq A n)))
         k k.+<span class="mi">1</span> <span class="mi">1</span>
         ({|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
              transport idmap
                (ap A (nat_add_succ_r k n));
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
                <span class="kr">return</span>
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; a0 ^+
                   <span class="kr">end</span>
                     (transport idmap (ap A (...)) a) =
                   transport idmap
                     (ap A (nat_add_succ_r n0 n))
                     (<span class="kr">match</span> ... ... <span class="kr">with</span>
                      | ... =&gt; ... =&gt; ...
                      <span class="kr">end</span> a))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                    (nat_add_succ_r k n)
              <span class="kr">end</span>
          |} k a))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkaf"><span class="nb">rewrite</span> colim_succ_seq_to_colim_seq_ap_inj, colim_shift_seq_to_colim_seq_ap_inj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n.+<span class="mi">1</span> k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_succ_r k n) =
J (ap S (nat_add_succ_r k n)) @
(ap (inj A (k.+<span class="mi">2</span> + n))
   (DiagramMap_comm
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
          transport idmap (ap A (nat_add_succ_r k n));
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
            (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
            <span class="kr">return</span>
              (<span class="kr">match</span>
                 p0 <span class="kr">in</span> (_ = n1)
                 <span class="kr">return</span>
                   (A (k + n).+<span class="mi">1</span> -&gt; A (n1 + n).+<span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (k + n).+<span class="mi">1</span> =&gt; a0 ^+
               <span class="kr">end</span>
                 (transport idmap
                    (ap A (nat_add_succ_r k n)) a) =
               transport idmap
                 (ap A (nat_add_succ_r n0 n))
                 (<span class="kr">match</span>
                    p0 <span class="kr">in</span> (_ = n1)
                    <span class="kr">return</span> (A ... -&gt; A ...)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...) =&gt; a0 ^+
                  <span class="kr">end</span> a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                (nat_add_succ_r k n)
          <span class="kr">end</span>
      |} <span class="mi">1</span> a)^ @
 ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (legs_comm
         (iscolimit_colimit (succ_seq (shift_seq A n)))
         k k.+<span class="mi">1</span> <span class="mi">1</span>
         ({|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
              transport idmap
                (ap A (nat_add_succ_r k n));
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
                <span class="kr">return</span>
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; a0 ^+
                   <span class="kr">end</span>
                     (transport idmap (ap A (...)) a) =
                   transport idmap
                     (ap A (nat_add_succ_r n0 n))
                     (<span class="kr">match</span> ... ... <span class="kr">with</span>
                      | ... =&gt; ... =&gt; ...
                      <span class="kr">end</span> a))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                    (nat_add_succ_r k n)
              <span class="kr">end</span>
          |} k a))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb0"><span class="nb">rewrite</span> (colim_succ_seq_to_colim_seq_beta_glue (shift_seq A n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>shift_seq A n.+<span class="mi">1</span> k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_succ_r k n) =
J (ap S (nat_add_succ_r k n)) @
(ap (inj A (k.+<span class="mi">2</span> + n))
   (DiagramMap_comm
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
          transport idmap (ap A (nat_add_succ_r k n));
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
            (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
            <span class="kr">return</span>
              (<span class="kr">match</span>
                 p0 <span class="kr">in</span> (_ = n1)
                 <span class="kr">return</span>
                   (A (k + n).+<span class="mi">1</span> -&gt; A (n1 + n).+<span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (k + n).+<span class="mi">1</span> =&gt; a0 ^+
               <span class="kr">end</span>
                 (transport idmap
                    (ap A (nat_add_succ_r k n)) a) =
               transport idmap
                 (ap A (nat_add_succ_r n0 n))
                 (<span class="kr">match</span>
                    p0 <span class="kr">in</span> (_ = n1)
                    <span class="kr">return</span> (A ... -&gt; A ...)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...) =&gt; a0 ^+
                  <span class="kr">end</span> a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                (nat_add_succ_r k n)
          <span class="kr">end</span>
      |} <span class="mi">1</span> a)^ @
 ap (colim_shift_seq_to_colim_seq A n)
   (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span>
      ({|
         DiagramMap_obj :=
           <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
           transport idmap (ap A (nat_add_succ_r k n));
         DiagramMap_comm :=
           <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
             (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
             <span class="kr">return</span>
               (<span class="kr">match</span>
                  p0 <span class="kr">in</span> (_ = n1)
                  <span class="kr">return</span> (A ....+<span class="mi">1</span> -&gt; A ....+<span class="mi">1</span>)
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...).+<span class="mi">1</span> =&gt; a0 ^+
                <span class="kr">end</span>
                  (transport idmap
                     (ap A (nat_add_succ_r k n)) a) =
                transport idmap
                  (ap A (nat_add_succ_r n0 n))
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; a0 ^+
                   <span class="kr">end</span> a))
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; a0 ^+)
                 (nat_add_succ_r k n)
           <span class="kr">end</span>
       |} k a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> colim_shift_seq_to_colim_seq_beta_glue; <span class="bp">exact</span> (L (glue A)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_colim_shift_seq_to_colim_seq</span> `{Funext} A n
  : Colimit (shift_seq A n) &lt;~&gt; Colimit A
  := Build_Equiv _ _ (colim_shift_seq_to_colim_seq A n) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Corollary 7.7.1 for k := -2; implies Lemma 7.2. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb1"><span class="kn">Definition</span> <span class="nf">contr_colim_contr_seq</span> `{Funext} (A : Sequence)
  : (<span class="kr">forall</span> <span class="nv">k</span>, Contr (A k)) -&gt; Contr (Colimit A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph, Contr (A k)) -&gt;
Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph, Contr (A k)) -&gt;
Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb3"><span class="nb">intro</span> h_seqcontr; <span class="nb">pose</span> (unit_seq := Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Unit) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb4">srapply (contr_equiv&#39; (Colimit unit_seq)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit unit_seq &lt;~&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chkb5"><hr></label><div class="goal-conclusion">Contr (Colimit unit_seq)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit unit_seq &lt;~&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb7"><span class="nb">symmetry</span>; srapply equiv_functor_colimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ~d~ unit_seq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb8">srapply Build_diagram_equiv; srapply Build_DiagramMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; unit_seq i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chkb9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) 
(<span class="nv">x</span> : A i),
(unit_seq _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j ((A _f g) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkba">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; unit_seq i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbb">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
(unit_seq _f g)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">_</span> : A i0)
    =&gt; tt) i x) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">_</span> : A i0) =&gt;
 tt) j ((A _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit unit_seq)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbd">srapply (Build_Contr _ (inj unit_seq <span class="mi">0</span> tt)); <span class="nb">intro</span> y; <span class="nb">symmetry</span>; <span class="nb">revert</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Colimit unit_seq, y = inj unit_seq <span class="mi">0</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbe">srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
idmap o inj unit_seq n ==
(<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
o inj unit_seq n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chkbf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : unit_seq n),
ap idmap (glue unit_seq n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> a ^+ @
ap (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
  (glue unit_seq n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc0">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
idmap o inj unit_seq n ==
(<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
o inj unit_seq n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc1"><span class="nb">intros</span> n a; <span class="nb">destruct</span> a; <span class="nb">induction</span> n <span class="kr">as</span> [ | n r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj unit_seq <span class="mi">0</span> tt = inj unit_seq <span class="mi">0</span> tt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkc2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>inj unit_seq n tt = inj unit_seq <span class="mi">0</span> tt</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkc2"><hr></label><div class="goal-conclusion">inj unit_seq n.+<span class="mi">1</span> tt = inj unit_seq <span class="mi">0</span> tt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj unit_seq <span class="mi">0</span> tt = inj unit_seq <span class="mi">0</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>inj unit_seq n tt = inj unit_seq <span class="mi">0</span> tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj unit_seq n.+<span class="mi">1</span> tt = inj unit_seq <span class="mi">0</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (glue unit_seq n tt @ r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc5">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>h_seqcontr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span><br><span><var>unit_seq</var><span><span class="hyp-body"><b>:= </b><span>Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span><span class="hyp-type"><b>: </b><span>Sequence</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : unit_seq n),
ap idmap (glue unit_seq n a) @
(<span class="kr">fun</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : unit_seq n0 =&gt;
  <span class="kr">match</span>
    a0 <span class="kr">as</span> u
    <span class="kr">return</span> (inj unit_seq n0 u = inj unit_seq <span class="mi">0</span> tt)
  <span class="kr">with</span>
  | tt =&gt;
      nat_rect
        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
         inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt) <span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
           (<span class="nv">r</span> : inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt)
         =&gt; glue unit_seq n1 tt @ r) n0
  <span class="kr">end</span>)
 :
 idmap o inj unit_seq n0 ==
 (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
 o inj unit_seq n0) n a =
(<span class="kr">fun</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph =&gt;
 (<span class="kr">fun</span> <span class="nv">a0</span> : unit_seq n0 =&gt;
  <span class="kr">match</span>
    a0 <span class="kr">as</span> u
    <span class="kr">return</span> (inj unit_seq n0 u = inj unit_seq <span class="mi">0</span> tt)
  <span class="kr">with</span>
  | tt =&gt;
      nat_rect
        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
         inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt) <span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
           (<span class="nv">r</span> : inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt)
         =&gt; glue unit_seq n1 tt @ r) n0
  <span class="kr">end</span>)
 :
 idmap o inj unit_seq n0 ==
 (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
 o inj unit_seq n0) n.+<span class="mi">1</span> a ^+ @
ap (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
  (glue unit_seq n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> n; <span class="nb">destruct</span> a; <span class="nb">rewrite</span> ap_idmap, ap_const, concat_p1; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Fibered sequences; Section 4. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">FibSequence</span> (<span class="nv">A</span> : Sequence) := {
  fibSequence : sig A -&gt; <span class="kt">Type</span>;
  fibSequenceArr x : fibSequence x -&gt; fibSequence x^++
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">fibSequence</span> : FibSequence  &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> fibSequence {A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> fibSequenceArr {A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;b ^+f&quot;</span> := (fibSequenceArr _ _ b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The Sigma of a fibered type sequence; Definition 4.3. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc6"><span class="kn">Definition</span> <span class="nf">sig_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) : Sequence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc8">srapply Build_Sequence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkc9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="nl">?X</span> n -&gt; <span class="nl">?X</span> n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; {a : A n &amp; B (n;a)}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; {a : A n0 &amp; B (n0; a)}) n -&gt;
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; {a : A n0 &amp; B (n0; a)}) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n [a b]; <span class="bp">exact</span> (a^+; b^+f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcc"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_seq_colim_fst</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A)
  : Colimit (sig_seq B) -&gt; Colimit A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (sig_seq B) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (sig_seq B) -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkce">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; Colimit A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkcf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkcf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (sig_seq B) _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; Colimit A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n [a _]; <span class="bp">exact</span> (inj _ n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">_</span> : B (n; a)) =&gt; inj A n a) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  j o (sig_seq B) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">_</span> : B (n; a)) =&gt; inj A n a) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p [a b]; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue _ n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a sequence fibered over [A], each point [x : sig A] induces a new type sequence; Section 4. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd2"><span class="kn">Definition</span> <span class="nf">fib_seq_to_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A) : Sequence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sequence</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd4">srapply Build_Sequence; <span class="nb">intro</span> k; <span class="nb">revert</span> x; <span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkd5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chkd5"><hr></label><div class="goal-conclusion">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkd6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  <span class="mi">0</span> x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  <span class="mi">1</span> x</div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt;
   <span class="nl">?Goal0</span>) k x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt;
   <span class="nl">?Goal0</span>) k.+<span class="mi">1</span> x</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkd7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  k.+<span class="mi">1</span> x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  k.+<span class="mi">2</span> x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h x^++).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkda">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) <span class="mi">0</span> x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) <span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">b</span> =&gt; b^+f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdb">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) k x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) k.+<span class="mi">1</span> x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) k.+<span class="mi">1</span> x -&gt;
nat_rect (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h x0 ^++) k.+<span class="mi">2</span> x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h x^++).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The induced sequence can be equivalently described by using shifting; Lemma 7.1. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fib_seq_to_seq&#39;</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A) : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; B x^++k) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">b</span> =&gt; b^+f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdc"><span class="kn">Definition</span> <span class="nf">equiv_fib_seq_to_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A)
  : fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkde">srapply Build_diagram_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq&#39; B x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkdf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq&#39; B x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke1">srapply Build_DiagramMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq B x i -&gt; fib_seq_to_seq&#39; B x i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><label class="goal-separator" for="sequential-v-chke2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x0</span> : fib_seq_to_seq B x i),
((fib_seq_to_seq&#39; B x) _f g) (<span class="nl">?DiagramMap_obj</span> i x0) =
<span class="nl">?DiagramMap_obj</span> j (((fib_seq_to_seq B x) _f g) x0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke3">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq B x i -&gt; fib_seq_to_seq&#39; B x i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke4"><span class="nb">intro</span> n; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x <span class="mi">0</span> -&gt; fib_seq_to_seq&#39; B x <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n -&gt; fib_seq_to_seq&#39; B x n</span></span></span><br></div><label class="goal-separator" for="sequential-v-chke5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n.+<span class="mi">1</span> -&gt; fib_seq_to_seq&#39; B x n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x <span class="mi">0</span> -&gt; fib_seq_to_seq&#39; B x <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n -&gt; fib_seq_to_seq&#39; B x n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n.+<span class="mi">1</span> -&gt; fib_seq_to_seq&#39; B x n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; coe (ap B (seq_pair_shift_assoc x n)) o e x^++).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x0</span> : fib_seq_to_seq B x i),
((fib_seq_to_seq&#39; B x) _f g)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    nat_rect
      (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
       fib_seq_to_seq B x n0 -&gt; fib_seq_to_seq&#39; B x n0)
      (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
      (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
         (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
              fib_seq_to_seq B x n0 -&gt;
              fib_seq_to_seq&#39; B x n0)
         (<span class="nv">x</span> : {x : _ &amp; A x}) =&gt;
       coe (ap B (seq_pair_shift_assoc x n0))
       o e x ^++) n x) i x0) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 nat_rect
   (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x n0 -&gt; fib_seq_to_seq&#39; B x n0)
   (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x n0 -&gt;
           fib_seq_to_seq&#39; B x n0) (<span class="nv">x</span> : {x : _ &amp; A x})
    =&gt;
    coe (ap B (seq_pair_shift_assoc x n0)) o e x ^++)
   n x) j (((fib_seq_to_seq B x) _f g) x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke9"><span class="nb">intros</span> n m p; <span class="nb">destruct</span> p; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
   <span class="mi">0</span> x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
  <span class="mi">1</span> x x0 ^+</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt;
    fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n)
      (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n))
      (e x1 ^++ x2)) n x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n)
     (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n))
     (e x1 ^++ x2)) n.+<span class="mi">1</span> x x0 ^+</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkea"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n.+<span class="mi">1</span>),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
   n.+<span class="mi">1</span> x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
  n.+<span class="mi">2</span> x x0 ^+</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
   <span class="mi">0</span> x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
  <span class="mi">1</span> x x0 ^+</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt;
    fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n)
      (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n))
      (e x1 ^++ x2)) n x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n)
     (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n))
     (e x1 ^++ x2)) n.+<span class="mi">1</span> x x0 ^+</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n.+<span class="mi">1</span>),
(nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
    equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
      (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
   n.+<span class="mi">1</span> x x0) ^+ =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n) =&gt;
   equiv_path (B (x1 ^++) ^++ n) (B x1 ^++ (n.+<span class="mi">1</span>))
     (ap B (seq_pair_shift_assoc x1 n)) (e x1 ^++ x2))
  n.+<span class="mi">2</span> x x0 ^+</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">b</span> =&gt; K _ _ _ @ (ap _ (p (x^++) b))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chked">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; A x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x n0 -&gt;
          fib_seq_to_seq&#39; B x n0)
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x n0 -&gt;
                 fib_seq_to_seq&#39; B x n0)
            (<span class="nv">x</span> : {x : _ &amp; A x}) =&gt;
          coe (ap B (seq_pair_shift_assoc x n0))
          o e x ^++) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x n1 -&gt;
                  fib_seq_to_seq&#39; B x n1)
                 (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x n1 -&gt;
                         fib_seq_to_seq&#39; B x n1)
                    (<span class="nv">x</span> : {x : _ &amp; A x})
                    (<span class="nv">x1</span> : fib_seq_to_seq B x ^++ n1)
                  =&gt;
                  equiv_path (B (x ^++) ^++ n1)
                    (B x ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x n1))
                    (e x ^++ x1)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x n1 -&gt;
               fib_seq_to_seq&#39; B x n1)
              (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x n1 -&gt;
                      fib_seq_to_seq&#39; B x n1)
                 (<span class="nv">x</span> : {x : _ &amp; A x})
                 (<span class="nv">x1</span> : fib_seq_to_seq B x ^++ n1) =&gt;
               equiv_path (B (x ^++) ^++ n1)
                 (B x ^++ (n1.+<span class="mi">1</span>))
                 (ap B (seq_pair_shift_assoc x n1))
                 (e x ^++ x1)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
              (<span class="nv">x0</span> : fib_seq_to_seq B x n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                  =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n0 x x0) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x1 n1 -&gt;
                 fib_seq_to_seq&#39; B x1 n1)
                (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x1 n1 -&gt;
                        fib_seq_to_seq&#39; B x1 n1)
                   (<span class="nv">x1</span> : {x : _ &amp; A x})
                   (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                 =&gt;
                 equiv_path (B (x1 ^++) ^++ n1)
                   (B x1 ^++ (n1.+<span class="mi">1</span>))
                   (ap B (seq_pair_shift_assoc x1 n1))
                   (e x1 ^++ x2)) n0.+<span class="mi">1</span> x x0 ^+)
             (<span class="kr">fun</span> (<span class="nv">x</span> : {x : _ &amp; A x})
                (<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
                      (<span class="nv">x0</span> : fib_seq_to_seq B x n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x1 n1 -&gt;
                          fib_seq_to_seq&#39; B x1 n1)
                         (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x1</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x1
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x1
                                   n1)
                            (<span class="nv">x1</span> : {x : _ &amp; A x})
                            (<span class="nv">x2</span> : fib_seq_to_seq B
                                    x1 ^++ n1) =&gt;
                          equiv_path (B (...) ^++ n1)
                            (B x1 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x1 n1))
                            (e x1 ^++ x2)) n0 x x0) ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x1</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x1 n1 -&gt;
                                fib_seq_to_seq&#39; B x1
                                  n1)
                           (<span class="nv">x1</span> : {x : _ &amp; A x})
                           (<span class="nv">x2</span> : fib_seq_to_seq B
                                   x1 ^++ n1) =&gt;
                         equiv_path
                           (B (x1 ^++) ^++ n1)
                           (B x1 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc x1
                                 n1)) (e x1 ^++ x2))
                        n0.+<span class="mi">1</span> x x0 ^+)
                (<span class="nv">x</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x n0) @
              ap
                (equiv_path (B ((x ^++) ^++ n0) ^++)
                   (B
                      (((<span class="kr">fix</span> F ... : ... :=
                           ...
                           ...
                           ...
                           <span class="kr">end</span>) n0) ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x n0))))
                (p0 x ^++ b)) n x
       <span class="kr">end</span>
   |} i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkee"><span class="nb">intro</span> n; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                  =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1) =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                  =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                 =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0 x1)
                      ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e x2 ^++ x3))
                        n0.+<span class="mi">1</span> x0 x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift x0)
                       ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 x0 ^++ b)) n x
       <span class="kr">end</span>
   |} <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++
                            n1) =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B
                       (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
               =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B
                    (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++
                            n1) =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B
                       (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++
                           n1) =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B
                      (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span>
                          <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x}
                          =&gt; idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp;
                                      ...},
                                 fib_seq_to_seq B
                                   x2 n1 -&gt;
                                 fib_seq_to_seq&#39; B
                                   x2 n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path
                            (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0
                         x1) ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B
                                  x2 n1 -&gt;
                                fib_seq_to_seq&#39; B
                                  x2 n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc
                                 x2 n1))
                           (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0
                        x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path
                   (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift
                          x0) ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0
                            n0)))) (p0 x0 ^++ b))
             n x
       <span class="kr">end</span>
   |} n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkef"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                  =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1) =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                  =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                 =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0 x1)
                      ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e x2 ^++ x3))
                        n0.+<span class="mi">1</span> x0 x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift x0)
                       ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 x0 ^++ b)) n x
       <span class="kr">end</span>
   |} n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf0">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                  =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1) =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                  =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                 =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0 x1)
                      ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e x2 ^++ x3))
                        n0.+<span class="mi">1</span> x0 x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift x0)
                       ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 x0 ^++ b)) n x
       <span class="kr">end</span>
   |} <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; isequiv_idmap _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++
                            n1) =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B
                       (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
               =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B
                    (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++
                            n1) =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B
                       (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++
                           n1) =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B
                      (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span>
                          <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x}
                          =&gt; idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp;
                                      ...},
                                 fib_seq_to_seq B
                                   x2 n1 -&gt;
                                 fib_seq_to_seq&#39; B
                                   x2 n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path
                            (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0
                         x1) ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B
                                  x2 n1 -&gt;
                                fib_seq_to_seq&#39; B
                                  x2 n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc
                                 x2 n1))
                           (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0
                        x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path
                   (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift
                          x0) ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0
                            n0)))) (p0 x0 ^++ b))
             n x
       <span class="kr">end</span>
   |} n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B x0 ^++ n0) =&gt;
          equiv_path (B (x0 ^++) ^++ n0)
            (B x0 ^++ (n0.+<span class="mi">1</span>))
            (ap B (seq_pair_shift_assoc x0 n0))
            (e x0 ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1)
                  =&gt;
                  equiv_path (B (x1 ^++) ^++ n1)
                    (B x1 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e x1 ^++ x2)) n x x0) =
            nat_rect
              (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n1 -&gt;
               fib_seq_to_seq&#39; B x1 n1)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n1 -&gt;
                      fib_seq_to_seq&#39; B x1 n1)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B x1 ^++ n1) =&gt;
               equiv_path (B (x1 ^++) ^++ n1)
                 (B x1 ^++ (n1.+<span class="mi">1</span>))
                 (ap B (seq_pair_shift_assoc x1 n1))
                 (e x1 ^++ x2)) n0 x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                  =&gt;
                  equiv_path (B (x2 ^++) ^++ n1)
                    (B x2 ^++ (n1.+<span class="mi">1</span>))
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e x2 ^++ x3)) n0 x0 x1) ^+ =
              nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B x2 ^++ n1)
                 =&gt;
                 equiv_path (B (x2 ^++) ^++ n1)
                   (B x2 ^++ (n1.+<span class="mi">1</span>))
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e x2 ^++ x3)) n0.+<span class="mi">1</span> x0 x1 ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    x2 ^++ n1) =&gt;
                          equiv_path (B (...) ^++ n1)
                            (B x2 ^++ (n1.+<span class="mi">1</span>))
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e x2 ^++ x3)) n0 x0 x1)
                      ^+ =
                      nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   x2 ^++ n1) =&gt;
                         equiv_path
                           (B (x2 ^++) ^++ n1)
                           (B x2 ^++ (n1.+<span class="mi">1</span>))
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e x2 ^++ x3))
                        n0.+<span class="mi">1</span> x0 x1 ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (equiv_path (B ((x0 ^++) ^++ n0) ^++)
                   (B
                      ((nat_iter n0 seq_pair_shift x0)
                       ^++) ^++)
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 x0 ^++ b)) n x
       <span class="kr">end</span>
   |} n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; rapply isequiv_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A fibered type sequence defines a type family; Section 4. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf2"><span class="kn">Definition</span> <span class="nf">fib_seq_to_type_fam</span> `{Univalence} {A} (B : FibSequence A) : Colimit A -&gt; <span class="kt">Type</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit A -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit A -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf4">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chkf5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o A _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; Colimit (fib_seq_to_seq B (n;a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 Colimit (fib_seq_to_seq B (n; a))) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf8"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="nb">apply</span> path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; a ^+)) &lt;~&gt;
Colimit (fib_seq_to_seq B (n; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n;a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf9"><span class="kn">Definition</span> <span class="nf">fib_seq_to_type_fam_beta_glue</span> `{Univalence} {A} B n a :
  coe (ap (fib_seq_to_type_fam B) (glue A n a))=
  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n;a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Diagram sequence_graph</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coe (ap (fib_seq_to_type_fam B) (glue A n a)) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Diagram sequence_graph</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coe (ap (fib_seq_to_type_fam B) (glue A n a)) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfb">srapply (ap _ (Colimit_rec_beta_colimp _ _ _ _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Diagram sequence_graph</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coe
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt;
         Colimit (fib_seq_to_seq B (n; a));
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
         (<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
            <span class="kr">return</span>
              (Colimit
                 (fib_seq_to_seq B (n0; (A _f p0) a)) =
               Colimit (fib_seq_to_seq B (n; a)))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              path_universe_uncurried
                (equiv_colim_succ_seq_to_colim_seq
                   (fib_seq_to_seq B (n; a)))
          <span class="kr">end</span>)
         :
         (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt;
          Colimit (fib_seq_to_seq B (n0; a))) m
         o A _f p ==
         (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt;
          Colimit (fib_seq_to_seq B (n0; a))) n
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport_idmap_path_universe_uncurried _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfc"><span class="kn">Local Definition</span> <span class="nf">Delta</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) (<span class="nv">psi</span> : coe (ap Y p) = F) <span class="nv">y</span>
  : (x1;y) = (x2;F y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x1; y) = (x2; F y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x1; y) = (x2; F y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfe"><span class="kn">Local Definition</span> <span class="nf">Delta_proj</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) (<span class="nv">psi</span> : coe (ap Y p) = F) <span class="nv">y</span>
  : ap pr1 (Delta p psi y) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pr1 (Delta p psi y) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pr1 (Delta p psi y) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk100"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : Colimit (sig_seq B) -&gt; sig (fib_seq_to_type_fam B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (sig_seq B) -&gt;
{x : _ &amp; fib_seq_to_type_fam B x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (sig_seq B) -&gt;
{x : _ &amp; fib_seq_to_type_fam B x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk102">srapply Colimit_rec; srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; {x : _ &amp; fib_seq_to_type_fam B x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk103" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk103"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (sig_seq B) _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk104">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; {x : _ &amp; fib_seq_to_type_fam B x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n [a b]; <span class="bp">exact</span> (inj A n a; inj (fib_seq_to_seq _ _) <span class="mi">0</span> b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk105">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">b</span> : B (n; a)) =&gt;
  (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)) X.<span class="mi">1</span>
   X.<span class="mi">2</span>) j o (sig_seq B) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">b</span> : B (n; a)) =&gt;
  (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)) X.<span class="mi">1</span>
   X.<span class="mi">2</span>) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk106"><span class="nb">intros</span> n m p [a b]; <span class="nb">destruct</span> p; srefine (_ @ ap _ (glue (fib_seq_to_seq _ _) <span class="mi">0</span> b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inj A n.+<span class="mi">1</span> ((a; b) ^+).<span class="mi">1</span>;
inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; ((a; b) ^+).<span class="mi">1</span>)) <span class="mi">0</span>
  ((a; b) ^+).<span class="mi">2</span>) =
(inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">1</span> b ^+)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Delta _ (fib_seq_to_type_fam_beta_glue B n a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk107"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim_beta_glue</span> `{Univalence} {A} B n a b :
  ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b)) =
  Delta _ (fib_seq_to_type_fam_beta_glue B n a) (inj _ _ _) @
  ap (exist _ (inj A n a)) (glue (fib_seq_to_seq _ _) <span class="mi">0</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Diagram sequence_graph</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (seq_colim_sum_to_sum_seq_colim B)
  (glue (sig_seq B) n (a; b)) =
Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
  (fib_seq_to_type_fam_beta_glue B n a)
  (inj
     (fib_seq_to_seq B
        ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) <span class="mi">0</span> b ^+) @
ap (exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk108"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Diagram sequence_graph</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (seq_colim_sum_to_sum_seq_colim B)
  (glue (sig_seq B) n (a; b)) =
Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
  (fib_seq_to_type_fam_beta_glue B n a)
  (inj
     (fib_seq_to_seq B
        ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) <span class="mi">0</span> b ^+) @
ap (exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SeqColimitSumInd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {A} (B : FibSequence A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">E</span> : sig (fib_seq_to_type_fam B) -&gt; <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a;b)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b))
    # e n.+<span class="mi">1</span> (a^+) (b^+f) = e n a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The point-point case of the nested induction; corresponds to &quot;h&quot; in the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk109"><span class="kn">Local Definition</span> <span class="nf">Q</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, E (inj _ n a; inj _ k b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) k),
E
  (inj A n a;
  inj (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) k),
E
  (inj A n a;
  inj (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10b"><span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk10c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk10c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+<span class="mi">1</span> b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n a b; <span class="bp">exact</span> (Delta _ (fib_seq_to_type_fam_beta_glue B n a) _ # h n.+<span class="mi">1</span> (a^+) b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The path-point case of the nested induction is just reflexivity; corresponds to &quot;mu&quot; in the paper. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10f"><span class="kn">Local Definition</span> <span class="nf">Eta</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span> : Y x} {<span class="nv">z</span> : sig Y} {<span class="nv">p</span> : y1 = y2}
    {<span class="nv">q1</span> : z = (x;y1)} {<span class="nv">q2</span> : z = (x;y2)} (<span class="nv">theta</span> : q2 = q1 @ ap _ p)
    : transport (Z o exist Y x) p o transport Z q1 == transport Z q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>z = (x; y2)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>q2 = q1 @ ap (exist Y x) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Z o exist Y x) p o transport Z q1 ==
transport Z q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk110"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>z = (x; y2)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>q2 = q1 @ ap (exist Y x) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Z o exist Y x) p o transport Z q1 ==
transport Z q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk111"><span class="nb">symmetry in</span> theta; <span class="nb">destruct</span> theta; <span class="nb">destruct</span> p; <span class="nb">simpl</span>; <span class="nb">destruct</span> q1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Z z =&gt; transport Z <span class="mi">1</span> x0) ==
transport Z (<span class="mi">1</span> @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk112"><span class="kn">Local Definition</span> <span class="nf">Epsilon</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span>} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) {<span class="nv">q</span> : y1 = y2}
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">r</span> : F y1 = F y2} (<span class="nv">theta</span> : ap F q = r)
    : transport (Z o exist Y x2) r o transport Z (Delta p psi y1) ==
      transport Z (Delta p psi y2) o transport (Z o exist Y x1) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>F y1 = F y2</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>ap F q = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Z o exist Y x2) r
o transport Z (Delta p psi y1) ==
transport Z (Delta p psi y2)
o transport (Z o exist Y x1) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>F y1 = F y2</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>ap F q = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Z o exist Y x2) r
o transport Z (Delta p psi y1) ==
transport Z (Delta p psi y2)
o transport (Z o exist Y x1) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> theta; <span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The point-path case of the nested induction; corresponds to &quot;H&quot; in the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk114"><span class="kn">Local Definition</span> <span class="nf">R</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    transport (E o exist _ (inj A n a)) (glue _ k b) (Q k.+<span class="mi">1</span> n a (b^+)) = Q k n a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) k),
transport
  (E o exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) k b)
  (Q k.+<span class="mi">1</span> n a b ^+) = Q k n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk115"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) k),
transport
  (E o exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) k b)
  (Q k.+<span class="mi">1</span> n a b ^+) = Q k n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk116"><span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a b ^+) =
Q <span class="mi">0</span> n a b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a b ^+) = Q k n a b</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk117"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a b ^+) = Q k.+<span class="mi">1</span> n a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk118">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a b ^+) =
Q <span class="mi">0</span> n a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk119"><span class="nb">intros</span> n a b; srapply (_ @ t n a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B (n; a) <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a b ^+) =
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) (e n.+<span class="mi">1</span> a ^+ b ^+f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a b ^+) = Q k n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a b ^+) = Q k.+<span class="mi">1</span> n a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11b"><span class="nb">intros</span> n a b; srefine (_ @ ap _ (h n.+<span class="mi">1</span> (a^+) b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a b ^+) = Q k n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B (n; a) k.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a b ^+) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a)
     (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; a ^+)) k b))
  (transport
     (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> a ^+)
      =&gt; E (inj A n.+<span class="mi">1</span> a ^+; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
     (Q k.+<span class="mi">1</span> n.+<span class="mi">1</span> a ^+ b ^+))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Epsilon (glue A n a) (colim_succ_seq_to_colim_seq_beta_glue _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The point case of the nested induction; corresponds to &quot;g&quot; in the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11c"><span class="kn">Local Definition</span> <span class="nf">F</span> <span class="nv">n</span> <span class="nv">a</span> : <span class="kr">forall</span> <span class="nv">x</span>, E (inj _ n a; x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a),
E (inj A n a; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a),
E (inj A n a; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11e">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) i),
(<span class="kr">fun</span>
   <span class="nv">w</span> : Colimit (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>))
 =&gt; E (inj A n a; w))
  (inj (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk11f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) i),
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Colimit
           (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) =&gt;
   E (inj A n a; w)) (colimp i j g x)
  (<span class="nl">?q</span> j
     (((fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) _f g) x)) =
<span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk120">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) i),
(<span class="kr">fun</span>
   <span class="nv">w</span> : Colimit (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>))
 =&gt; E (inj A n a; w))
  (inj (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk121">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) i),
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Colimit
           (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) =&gt;
   E (inj A n a; w)) (colimp i j g x)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt; Q k n a) j
     (((fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) _f g) x)) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt; Q k n a) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> k l p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (R k n a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk122"><span class="kn">Local Definition</span> <span class="nf">F_beta_glue</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> : apD (F n a) (glue _ <span class="mi">0</span> b) = R <span class="mi">0</span> n a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (F n a)
  (glue (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) <span class="mi">0</span> b) =
R <span class="mi">0</span> n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk123"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>) <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (F n a)
  (glue (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) <span class="mi">0</span> b) =
R <span class="mi">0</span> n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Colimit_ind_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk124"><span class="kn">Local Definition</span> <span class="nf">Phi</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span>} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) {<span class="nv">q</span> : y1 = y2}
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">G1</span> : <span class="kr">forall</span> <span class="nv">y</span>, Z (x1;y)} {<span class="nv">G2</span> : <span class="kr">forall</span> <span class="nv">y</span>, Z (x2;y)}
    {<span class="nv">r</span> : F y1 = F y2} (<span class="nv">theta</span> : ap F q = r)
    : <span class="kr">forall</span> <span class="nv">u1</span> <span class="nv">u2</span>,
      apD G2 r @ u2 = ap (transport _ r) u1 @ Epsilon p theta (G1 y1) @
                      ap (transport Z (Delta p psi y2)) (apD G1 q)
      -&gt; transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; G2 (F y) = Delta p psi y # G1 y) q u1 = u2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>F y1 = F y2</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>ap F q = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">u1</span> : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))
(<span class="nv">u2</span> : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),
apD G2 r @ u2 =
(ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : Y x2 =&gt; Z (x2; x)) r) u1 @
 Epsilon p theta (G1 y1)) @
ap (transport Z (Delta p psi y2)) (apD G1 q) -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) q u1 =
u2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk125"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>F y1 = F y2</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>ap F q = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">u1</span> : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))
(<span class="nv">u2</span> : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),
apD G2 r @ u2 =
(ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : Y x2 =&gt; Z (x2; x)) r) u1 @
 Epsilon p theta (G1 y1)) @
ap (transport Z (Delta p psi y2)) (apD G1 q) -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) q u1 =
u2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk126"><span class="nb">destruct</span> theta; <span class="nb">destruct</span> q; <span class="nb">intros</span> u1 u2; <span class="nb">rewrite</span> ap_idmap, !concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br><span><var>u1, u2</var><span class="hyp-type"><b>: </b><span>G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD G2 (ap F <span class="mi">1</span>) @ u2 = u1 -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) <span class="mi">1</span> u1 =
u2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk127"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br><span><var>u1, u2</var><span class="hyp-type"><b>: </b><span>G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ u2 = u1 -&gt; u1 = u2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> s; <span class="nb">destruct</span> s; <span class="bp">exact</span> (concat_1p _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The path case of the nested induction; corresponds to &quot;omega&quot; in the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk128"><span class="kn">Local Definition</span> <span class="nf">G</span> <span class="nv">n</span> <span class="nv">a</span> : <span class="kr">forall</span> <span class="nv">y</span>,
    F n a _ = Delta _ (fib_seq_to_type_fam_beta_glue B n a) y # F n.+<span class="mi">1</span> (a^+) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> a ^+),
F n a
  (colim_succ_seq_to_colim_seq
     (fib_seq_to_seq B (n; a)) y) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a) y)
  (F n.+<span class="mi">1</span> a ^+ y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> a ^+),
F n a
  (colim_succ_seq_to_colim_seq
     (fib_seq_to_seq B (n; a)) y) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a) y)
  (F n.+<span class="mi">1</span> a ^+ y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12a">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
       i),
(<span class="kr">fun</span>
   <span class="nv">w</span> : Colimit
         (fib_seq_to_seq B
            ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) =&gt;
 F n a
   (colim_succ_seq_to_colim_seq
      (fib_seq_to_seq B (n; a)) w) =
 transport E
   (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
      (fib_seq_to_type_fam_beta_glue B n a) w)
   (F n.+<span class="mi">1</span> a ^+ w))
  (inj
     (fib_seq_to_seq B
        ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk12b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk12b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
       i),
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Colimit
           (fib_seq_to_seq B
              ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> a ^+ w)) (colimp i j g x)
  (<span class="nl">?q</span> j
     (((fib_seq_to_seq B
          ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) _f g) x)) =
<span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
       i),
(<span class="kr">fun</span>
   <span class="nv">w</span> : Colimit
         (fib_seq_to_seq B
            ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) =&gt;
 F n a
   (colim_succ_seq_to_colim_seq
      (fib_seq_to_seq B (n; a)) w) =
 transport E
   (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
      (fib_seq_to_type_fam_beta_glue B n a) w)
   (F n.+<span class="mi">1</span> a ^+ w))
  (inj
     (fib_seq_to_seq B
        ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">b</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
       i),
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Colimit
           (fib_seq_to_seq B
              ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> a ^+ w)) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
      (<span class="nv">b</span> : fib_seq_to_seq B
             ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>) k) =&gt; <span class="mi">1</span>)
     j
     (((fib_seq_to_seq B
          ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)) _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">b</span> : fib_seq_to_seq B
          ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>) k) =&gt; <span class="mi">1</span>) i
  x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12e"><span class="nb">intros</span> k l p b; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; a ^+)) =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> a ^+ w)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12f">snapply (Phi (glue A n a) (colim_succ_seq_to_colim_seq_beta_glue _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (F n a) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b) @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (glue A n a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> a ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         b ^+))) @
ap
  (transport E
     (Delta (glue A n a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (apD (F n.+<span class="mi">1</span> a ^+) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk130"><span class="nb">rewrite</span> (Colimit_ind_beta_colimp _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n a) _ _ _ idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R k.+<span class="mi">1</span> n a b @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> a ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         b ^+))) @
ap
  (transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (apD (F n.+<span class="mi">1</span> a ^+) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk131"><span class="nb">rewrite</span> (Colimit_ind_beta_colimp _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n.+<span class="mi">1</span> a^+) _ _ _ idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>fib_seq_to_seq B ((n.+<span class="mi">1</span>; a ^+).<span class="mi">1</span>; (n.+<span class="mi">1</span>; a ^+).<span class="mi">2</span>)
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R k.+<span class="mi">1</span> n a b @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> a ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         b ^+))) @
ap
  (transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (R k n.+<span class="mi">1</span> a ^+ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> concat_p1, concat_1p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk132"><span class="kn">Local Definition</span> <span class="nf">I</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">p</span> : x1 = x2} {<span class="nv">F</span>} (<span class="nv">psi</span> : coe (ap Y p) = F) {<span class="nv">G1</span> <span class="nv">G2</span>}
    : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>, Z (x;y)) p G1 = G2 &lt;~&gt;
      <span class="kr">forall</span> <span class="nv">y</span>, G2 (F y) = Delta p psi y # G1 y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Y x, Z (x; y)) p G1 =
G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (F y) = transport Z (Delta p psi y) (G1 y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk133"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Y x, Z (x; y)) p G1 =
G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (F y) = transport Z (Delta p psi y) (G1 y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk134"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Y x, Z (x; y)) <span class="mi">1</span> G1 =
G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (equiv_path (Y x1) (Y x1) (ap Y <span class="mi">1</span>) y) =
 transport Z (Delta <span class="mi">1</span> <span class="mi">1</span> y) (G1 y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="nb">transitivity</span> (equiv_path_inverse _ _) (equiv_apD10 _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The alternative induction rule in curried form; corresponds to curried &quot;G&quot; in</span>
<span class="sd">      the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk135"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_cur</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, E (x;y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : Colimit A) (<span class="nv">y</span> : fib_seq_to_type_fam B x),
E (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk136"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : Colimit A) (<span class="nv">y</span> : fib_seq_to_type_fam B x),
E (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk137">srapply (Colimit_ind _ F); <span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B w, E (w; y))
  (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a) (F n.+<span class="mi">1</span> a ^+) = F n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((I (fib_seq_to_type_fam_beta_glue B n a))^-<span class="mi">1</span> (G n a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The computation rule for the alternative induction rule in curried form. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk138"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_cur_beta_glue</span> <span class="nv">n</span> <span class="nv">a</span> :
    I (fib_seq_to_type_fam_beta_glue B n a) (apD seq_colim_sum_ind_cur (glue _ n a)) = G n a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">I (fib_seq_to_type_fam_beta_glue B n a)
  (apD seq_colim_sum_ind_cur (glue A n a)) = G n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk139"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">I (fib_seq_to_type_fam_beta_glue B n a)
  (apD seq_colim_sum_ind_cur (glue A n a)) = G n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveR_equiv_M; srapply Colimit_ind_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The alternative induction rule; corresponds to &quot;G&quot; in the paper. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13a"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind</span> : <span class="kr">forall</span> <span class="nv">x</span>, E x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x}, E x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x}, E x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [x y]; <span class="nb">apply</span> seq_colim_sum_ind_cur.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13c"><span class="kn">Local Definition</span> <span class="nf">Xi</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} <span class="nv">G</span> {<span class="nv">x</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span> : Y x} {<span class="nv">z</span> : sig Y} {<span class="nv">p</span> : y1 = y2}
    {<span class="nv">q1</span> : z = (x;y1)} {<span class="nv">q2</span> : z = (x;y2)} (<span class="nv">theta</span> : q2 = q1 @ ap _ p)
    : apD (G o exist Y x) p =
      ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta theta (G z) @ apD G q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>z = (x; y2)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>q2 = q1 @ ap (exist Y x) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (G o exist Y x) p =
(ap (transport (Z o exist Y x) p) (apD G q1)^ @
 Eta theta (G z)) @ apD G q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>z = (x; y2)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>q2 = q1 @ ap (exist Y x) p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (G o exist Y x) p =
(ap (transport (Z o exist Y x) p) (apD G q1)^ @
 Eta theta (G z)) @ apD G q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13e"><span class="nb">revert</span> theta; srapply (equiv_ind (equiv_path_inverse _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br><span><var>q2</var><span class="hyp-type"><b>: </b><span>z = (x; y2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : q1 @ ap (exist Y x) p = q2,
(<span class="kr">fun</span> <span class="nv">y</span> : q2 = q1 @ ap (exist Y x) p =&gt;
 apD (G o exist Y x) p =
 (ap (transport (Z o exist Y x) p) (apD G q1)^ @
  Eta y (G z)) @ apD G q2)
  (equiv_path_inverse (q1 @ ap (exist Y x) p) q2 x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13f"><span class="nb">intro</span> s; <span class="nb">destruct</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>z = (x; y1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; G (x; x0)) p =
(ap (transport (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; Z (x; x0)) p)
   (apD G q1)^ @
 Eta
   (equiv_path_inverse (q1 @ ap (exist Y x) p)
      (q1 @ ap (exist Y x) p) <span class="mi">1</span>) (G z)) @
apD G (q1 @ ap (exist Y x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk140"><span class="nb">revert</span> q1; srapply (equiv_ind (equiv_path_inverse _ _)); <span class="nb">intro</span> s; <span class="nb">destruct</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>Y x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; G (x; x0)) p =
(ap (transport (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; Z (x; x0)) p)
   (apD G (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span>))^ @
 Eta
   (equiv_path_inverse
      (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
       ap (exist Y x) p)
      (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
       ap (exist Y x) p) <span class="mi">1</span>) (G (x; y1))) @
apD G
  (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
   ap (exist Y x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk141"><span class="kn">Local Definition</span> <span class="nf">Mu</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} (<span class="nv">p</span> : x1 = x2) {<span class="nv">F</span>} (<span class="nv">G</span> : <span class="kr">forall</span> <span class="nv">z</span>, Z z)
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">q</span>} (<span class="nv">theta</span> : I psi (apD (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; G (x;y)) p) = q) <span class="nv">y</span>
    : apD G (Delta p psi y) = (q y)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : {x : _ &amp; Y x}, Z z</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1,
(<span class="kr">fun</span> <span class="nv">y0</span> : Y x2 =&gt; G (x2; y0)) (F y) =
transport Z (Delta p psi y)
  ((<span class="kr">fun</span> <span class="nv">y0</span> : Y x1 =&gt; G (x1; y0)) y)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>I psi
  (apD (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x) =&gt; G (x; y)) p) =
q</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD G (Delta p psi y) = (q y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk142"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Y x1 -&gt; Y x2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : {x : _ &amp; Y x}, Z z</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>coe (ap Y p) = F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y x1,
(<span class="kr">fun</span> <span class="nv">y0</span> : Y x2 =&gt; G (x2; y0)) (F y) =
transport Z (Delta p psi y)
  ((<span class="kr">fun</span> <span class="nv">y0</span> : Y x1 =&gt; G (x1; y0)) y)</span></span></span><br><span><var>theta</var><span class="hyp-type"><b>: </b><span>I psi
  (apD (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x) =&gt; G (x; y)) p) =
q</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD G (Delta p psi y) = (q y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="nb">destruct</span> theta; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The computation rule for the alternative induction rule. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk143"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_beta_glue</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    apD seq_colim_sum_ind (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n _)) =
    t n a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk144"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk145"><span class="nb">intros</span> n a b; <span class="nb">pose</span> (h := F_beta_glue n a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>F_beta_glue n a b</span></span><span class="hyp-type"><b>: </b><span>apD (F n a)
  (glue (fib_seq_to_seq B ((n; a).<span class="mi">1</span>; (n; a).<span class="mi">2</span>)) <span class="mi">0</span>
     b) = R <span class="mi">0</span> n a b</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk146"><span class="nb">rewrite</span> (Xi seq_colim_sum_ind (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x0</span> : fib_seq_to_type_fam B (inj A n a)
       =&gt; E (inj A n a; x0)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b))
   (apD seq_colim_sum_ind
      (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
         (fib_seq_to_type_fam_beta_glue B n a)
         (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; a ^+)) <span class="mi">0</span>
            b ^+)))^ @
 Eta
   (seq_colim_sum_to_sum_seq_colim_beta_glue B n a
      b)
   (seq_colim_sum_ind
      (seq_colim_sum_to_sum_seq_colim B
         (inj (sig_seq B) n.+<span class="mi">1</span> (a; b) ^+)))) @
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b))) = R <span class="mi">0</span> n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk147"><span class="nb">rewrite</span> (Mu (glue _ n a) seq_colim_sum_ind (seq_colim_sum_ind_cur_beta_glue n a)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> a ^+ b ^+f) = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x0</span> : fib_seq_to_type_fam B (inj A n a)
       =&gt; E (inj A n a; x0)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b))
   ((G n a
       (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; a ^+)) <span class="mi">0</span> b ^+))^)^ @
 Eta
   (seq_colim_sum_to_sum_seq_colim_beta_glue B n a
      b)
   (seq_colim_sum_ind
      (seq_colim_sum_to_sum_seq_colim B
         (inj (sig_seq B) n.+<span class="mi">1</span> (a; b) ^+)))) @
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b))) = R <span class="mi">0</span> n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> concat_1p <span class="kr">in</span> h; <span class="bp">exact</span> (cancelL _ _ _ h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SeqColimitSumInd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An alternative recursion principle for the sum of colimits; Lemma 5.3. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SeqColimitSumRec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {A} (B : FibSequence A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> <span class="nv">E</span> (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span>, B (n;a) -&gt; E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> (<span class="nv">b</span> : B (n;a)), e n.+<span class="mi">1</span> (a^+) (b^+f) = e n a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk148"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_rec</span> : sig (fib_seq_to_type_fam B)-&gt; E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> a ^+ b ^+f = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk149"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> a ^+ b ^+f = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (seq_colim_sum_ind B _ e (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; transport_const _ _ @ t n a b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14a"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_rec_beta_glue</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    ap seq_colim_sum_rec (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b))) =
    t n a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> a ^+ b ^+f = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
ap seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> a ^+ b ^+f = e n a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
ap seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14c"><span class="nb">intros</span> n a b; srapply (cancelL _ _ _ ((apD_const _ _)^ @ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> a ^+ b ^+f = e n a b</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) =
transport_const
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (seq_colim_sum_rec
     (seq_colim_sum_to_sum_seq_colim B
        (inj (sig_seq B) n.+<span class="mi">1</span> (a; b) ^+))) @ t n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srapply seq_colim_sum_ind_beta_glue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SeqColimitSumRec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Lemma 5.4. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14d"><span class="kn">Definition</span> <span class="nf">seq_colimit_sum_uniq</span> `{Univalence} {A} (B : FibSequence A) E
  (F G : sig (fib_seq_to_type_fam B) -&gt; E)
  : F o (seq_colim_sum_to_sum_seq_colim B) == G o (seq_colim_sum_to_sum_seq_colim B) -&gt;
    F == G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B -&gt; F == G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B -&gt; F == G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14f"><span class="nb">intro</span> h; srapply (seq_colim_sum_ind B _ (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; h _)); <span class="nb">intros</span> n a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F, G</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x} =&gt;
   F x = G x)
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  ((<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
      (<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a) =&gt;
    h (inj (sig_seq B) n (a; b))) n.+<span class="mi">1</span> a ^+ b ^+f) =
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
   (<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a) =&gt;
 h (inj (sig_seq B) n (a; b))) n a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply ((transport_compose _ _ _ _)^ @ _); <span class="bp">exact</span> (apD h (glue (sig_seq B) n (a;b))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk150"><span class="kn">Instance</span> <span class="nf">isequiv_seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : IsEquiv (seq_colim_sum_to_sum_seq_colim B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk151"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk152"><span class="nb">assert</span> (L : {G : _ &amp; G o seq_colim_sum_to_sum_seq_colim B == idmap}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  GraphQuotient.GraphQuotient.GraphQuotient
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
     {x
     : {x : {x : _ &amp; sig_seq B x} &amp;
       {j : Graph.graph0 sequence_graph &amp;
       Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
     ((x.<span class="mi">1</span> = a) *
      (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})
&amp;
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 G (seq_colim_sum_to_sum_seq_colim B x)) == idmap}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  GraphQuotient.GraphQuotient.GraphQuotient
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
     {x
     : {x : {x : _ &amp; sig_seq B x} &amp;
       {j : Graph.graph0 sequence_graph &amp;
       Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
     (((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt; t.<span class="mi">1</span>) x = a) *
      ((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt;
        ((t.<span class="mi">2</span>).<span class="mi">1</span>;
        ((sig_seq B) _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) x = b))%type})
&amp; G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk153"><hr></label><div class="goal-conclusion">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk154">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  GraphQuotient.GraphQuotient.GraphQuotient
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
     {x
     : {x : {x : _ &amp; sig_seq B x} &amp;
       {j : Graph.graph0 sequence_graph &amp;
       Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
     ((x.<span class="mi">1</span> = a) *
      (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})
&amp;
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 G (seq_colim_sum_to_sum_seq_colim B x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk155">srapply (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; fib_seq_to_type_fam B x} -&gt;
GraphQuotient.GraphQuotient.GraphQuotient
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
   {x
   : {x : {x : _ &amp; sig_seq B x} &amp;
     {j : Graph.graph0 sequence_graph &amp;
     Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
   ((x.<span class="mi">1</span> = a) *
    (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk156"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">G</span> : {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
       GraphQuotient.GraphQuotient.GraphQuotient
         (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
          {x
          : {x : {x : _ &amp; sig_seq B x} &amp;
            {j : Graph.graph0 sequence_graph &amp;
            Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
          ((x.<span class="mi">1</span> = a) *
           (((x.<span class="mi">2</span>).<span class="mi">1</span>;
            ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})
 =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
  G (seq_colim_sum_to_sum_seq_colim B x)) == idmap)
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk157">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; fib_seq_to_type_fam B x} -&gt;
GraphQuotient.GraphQuotient.GraphQuotient
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
   {x
   : {x : {x : _ &amp; sig_seq B x} &amp;
     {j : Graph.graph0 sequence_graph &amp;
     Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
   ((x.<span class="mi">1</span> = a) *
    (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk158">srapply seq_colim_sum_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
B (n; a) -&gt;
GraphQuotient.GraphQuotient.GraphQuotient
  (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
   {x
   : {x : {x : _ &amp; sig_seq B x} &amp;
     {j : Graph.graph0 sequence_graph &amp;
     Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
   ((x.<span class="mi">1</span> = a0) *
    (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk159" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk159"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), <span class="nl">?e</span> n.+<span class="mi">1</span> a ^+ b ^+f = <span class="nl">?e</span> n a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
B (n; a) -&gt;
GraphQuotient.GraphQuotient.GraphQuotient
  (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
   {x
   : {x : {x : _ &amp; sig_seq B x} &amp;
     {j : Graph.graph0 sequence_graph &amp;
     Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
   ((x.<span class="mi">1</span> = a0) *
    (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; inj (sig_seq B) n (a;b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0)
   (<span class="nv">b0</span> : B (n0; a0)) =&gt; inj (sig_seq B) n0 (a0; b0))
  n.+<span class="mi">1</span> a ^+ b ^+f =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0)
   (<span class="nv">b0</span> : B (n0; a0)) =&gt; inj (sig_seq B) n0 (a0; b0)) n
  a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; glue (sig_seq B) n (a;b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">G</span> : {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
       GraphQuotient.GraphQuotient.GraphQuotient
         (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
          {x
          : {x : {x : _ &amp; sig_seq B x} &amp;
            {j : Graph.graph0 sequence_graph &amp;
            Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
          ((x.<span class="mi">1</span> = a) *
           (((x.<span class="mi">2</span>).<span class="mi">1</span>;
            ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type})
 =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
  G (seq_colim_sum_to_sum_seq_colim B x)) == idmap)
  (seq_colim_sum_rec B
     (GraphQuotient.GraphQuotient.GraphQuotient
        (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
         {x
         : {x : {x : _ &amp; sig_seq B x} &amp;
           {j : Graph.graph0 sequence_graph &amp;
           Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
         ((x.<span class="mi">1</span> = a) *
          (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) =
           b))%type}))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; inj (sig_seq B) n (a; b))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; glue (sig_seq B) n (a; b)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15d">srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 seq_colim_sum_rec B
   (GraphQuotient.GraphQuotient.GraphQuotient
      (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
       {x0
       : {x0 : {x : _ &amp; sig_seq B x} &amp;
         {j : Graph.graph0 sequence_graph &amp;
         Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}} &amp;
       ((x0.<span class="mi">1</span> = a) *
        (((x0.<span class="mi">2</span>).<span class="mi">1</span>;
         ((sig_seq B) _f (x0.<span class="mi">2</span>).<span class="mi">2</span>) (x0.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type}))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; inj (sig_seq B) n0 (a; b))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; glue (sig_seq B) n0 (a; b))
   (seq_colim_sum_to_sum_seq_colim B x))
o inj (sig_seq B) n == idmap o inj (sig_seq B) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk15e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk15e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   seq_colim_sum_rec B
     (GraphQuotient.GraphQuotient.GraphQuotient
        (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
         {x0
         : {x0 : {x : _ &amp; sig_seq B x} &amp;
           {j : Graph.graph0 sequence_graph &amp;
           Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}} &amp;
         ((x0.<span class="mi">1</span> = a0) *
          (((x0.<span class="mi">2</span>).<span class="mi">1</span>;
           ((sig_seq B) _f (x0.<span class="mi">2</span>).<span class="mi">2</span>) (x0.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type}))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      inj (sig_seq B) n0 (a0; b))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      glue (sig_seq B) n0 (a0; b))
     (seq_colim_sum_to_sum_seq_colim B x))
  (glue (sig_seq B) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> a ^+ @ ap idmap (glue (sig_seq B) n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 seq_colim_sum_rec B
   (GraphQuotient.GraphQuotient.GraphQuotient
      (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
       {x0
       : {x0 : {x : _ &amp; sig_seq B x} &amp;
         {j : Graph.graph0 sequence_graph &amp;
         Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}} &amp;
       ((x0.<span class="mi">1</span> = a) *
        (((x0.<span class="mi">2</span>).<span class="mi">1</span>;
         ((sig_seq B) _f (x0.<span class="mi">2</span>).<span class="mi">2</span>) (x0.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type}))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; inj (sig_seq B) n0 (a; b))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; glue (sig_seq B) n0 (a; b))
   (seq_colim_sum_to_sum_seq_colim B x))
o inj (sig_seq B) n == idmap o inj (sig_seq B) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk160">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   seq_colim_sum_rec B
     (GraphQuotient.GraphQuotient.GraphQuotient
        (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
         {x0
         : {x0 : {x : _ &amp; sig_seq B x} &amp;
           {j : Graph.graph0 sequence_graph &amp;
           Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}} &amp;
         ((x0.<span class="mi">1</span> = a0) *
          (((x0.<span class="mi">2</span>).<span class="mi">1</span>;
           ((sig_seq B) _f (x0.<span class="mi">2</span>).<span class="mi">2</span>) (x0.<span class="mi">1</span>).<span class="mi">2</span>) = b))%type}))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      inj (sig_seq B) n0 (a0; b))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      glue (sig_seq B) n0 (a0; b))
     (seq_colim_sum_to_sum_seq_colim B x))
  (glue (sig_seq B) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n.+<span class="mi">1</span> a ^+ @
ap idmap (glue (sig_seq B) n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk161"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> concat_1p, concat_p1, ap_compose, ap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>sig_seq B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (seq_colim_sum_rec B
     (GraphQuotient.GraphQuotient.GraphQuotient
        (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
         {x
         : {x : {x : _ &amp; sig_seq B x} &amp;
           {j : Graph.graph0 sequence_graph &amp;
           Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
         ((x.<span class="mi">1</span> = a) *
          (((x.<span class="mi">2</span>).<span class="mi">1</span>; ((sig_seq B) _f (x.<span class="mi">2</span>).<span class="mi">2</span>) (x.<span class="mi">1</span>).<span class="mi">2</span>) =
           b))%type}))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; inj (sig_seq B) n (a; b))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)))
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)) = colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> seq_colim_sum_rec_beta_glue; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk162">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  GraphQuotient.GraphQuotient.GraphQuotient
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
     {x
     : {x : {x : _ &amp; sig_seq B x} &amp;
       {j : Graph.graph0 sequence_graph &amp;
       Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
     (((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt; t.<span class="mi">1</span>) x = a) *
      ((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt;
        ((t.<span class="mi">2</span>).<span class="mi">1</span>;
        ((sig_seq B) _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) x = b))%type})
&amp; G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk163">srapply (isequiv_adjointify _ L.<span class="mi">1</span> _ L.<span class="mi">2</span>); srapply seq_colimit_sum_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  GraphQuotient.GraphQuotient.GraphQuotient
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : {x : _ &amp; sig_seq B x} =&gt;
     {x
     : {x : {x : _ &amp; sig_seq B x} &amp;
       {j : Graph.graph0 sequence_graph &amp;
       Graph.graph1 sequence_graph x.<span class="mi">1</span> j}} &amp;
     (((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt; t.<span class="mi">1</span>) x = a) *
      ((<span class="kr">fun</span>
          <span class="nv">t</span> : {x0 : {x : _ &amp; sig_seq B x} &amp;
              {j : Graph.graph0 sequence_graph &amp;
              Graph.graph1 sequence_graph x0.<span class="mi">1</span> j}}
        =&gt;
        ((t.<span class="mi">2</span>).<span class="mi">1</span>;
        ((sig_seq B) _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) x = b))%type})
&amp; G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x} =&gt;
 seq_colim_sum_to_sum_seq_colim B (L.<span class="mi">1</span> x))
o seq_colim_sum_to_sum_seq_colim B ==
idmap o seq_colim_sum_to_sum_seq_colim B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="nb">rewrite</span> L.<span class="mi">2</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : Colimit (sig_seq B) &lt;~&gt; sig (fib_seq_to_type_fam B)
  := Build_Equiv _ _ _ (isequiv_seq_colim_sum_to_sum_seq_colim B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk164"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim_fst</span> `{Univalence} {A} (B : FibSequence A)
  : pr1 o (seq_colim_sum_to_sum_seq_colim B) == seq_colim_sum_to_seq_colim_fst B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pr1 o seq_colim_sum_to_sum_seq_colim B ==
seq_colim_sum_to_seq_colim_fst B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk165"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pr1 o seq_colim_sum_to_sum_seq_colim B ==
seq_colim_sum_to_seq_colim_fst B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk166">srapply seq_colimit_uniq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
o inj (sig_seq B) n ==
seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk167" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk167"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
  (glue (sig_seq B) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> a ^+ @
ap (seq_colim_sum_to_seq_colim_fst B)
  (glue (sig_seq B) n a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk168">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
o inj (sig_seq B) n ==
seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk169">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
  (glue (sig_seq B) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n.+<span class="mi">1</span> a ^+ @
ap (seq_colim_sum_to_seq_colim_fst B)
  (glue (sig_seq B) n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16a"><span class="nb">intros</span> n [a b]; <span class="nb">rewrite</span> concat_1p, concat_p1, ap_compose, !Colimit_rec_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap pr1
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">X</span> : sig_seq B n) =&gt;
         (inj A n X.<span class="mi">1</span>;
         inj (fib_seq_to_seq B (n; X.<span class="mi">1</span>)) <span class="mi">0</span> X.<span class="mi">2</span>);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">x</span> : sig_seq B n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
           <span class="kr">return</span>
             ((inj A n0
                 (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span>;
              inj
                (fib_seq_to_seq B
                   (n0;
                   (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span>))
                <span class="mi">0</span> (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">2</span>) =
              (inj A n x.<span class="mi">1</span>;
              inj (fib_seq_to_seq B (n; x.<span class="mi">1</span>)) <span class="mi">0</span> x.<span class="mi">2</span>))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt;
             Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>)
               (fib_seq_to_type_fam_beta_glue B n x.<span class="mi">1</span>)
               (inj
                  (fib_seq_to_seq B
                     (n.+<span class="mi">1</span>; ((x.<span class="mi">1</span>; x.<span class="mi">2</span>) ^+).<span class="mi">1</span>)) <span class="mi">0</span>
                  ((x.<span class="mi">1</span>; x.<span class="mi">2</span>) ^+).<span class="mi">2</span>) @
             ap
               (exist (fib_seq_to_type_fam B)
                  (inj A n x.<span class="mi">1</span>)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">2</span>)
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)) =
legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
        (<span class="nv">X</span> : sig_seq B n) =&gt; inj A n X.<span class="mi">1</span>;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
        (<span class="nv">x</span> : sig_seq B n) =&gt;
      <span class="kr">match</span>
        p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
        <span class="kr">return</span>
          (inj A n0 (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span> =
           inj A n x.<span class="mi">1</span>)
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>
      <span class="kr">end</span>
  |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16b"><span class="nb">rewrite</span> ap_pp, (Delta_proj _ (fib_seq_to_type_fam_beta_glue B n a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a @
ap pr1
  (ap (exist (fib_seq_to_type_fam B) (inj A n a))
     (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b)) =
legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
        (<span class="nv">X</span> : sig_seq B n) =&gt; inj A n X.<span class="mi">1</span>;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
        (<span class="nv">x</span> : sig_seq B n) =&gt;
      <span class="kr">match</span>
        p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
        <span class="kr">return</span>
          (inj A n0 (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span> =
           inj A n x.<span class="mi">1</span>)
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>
      <span class="kr">end</span>
  |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16c">srapply (whiskerL _ _ @ concat_p1 _); <span class="nb">rewrite</span> (ap_compose _ _ _)^; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B (n; a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">_</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
   inj A n a) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> ap_const; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The characterization of path spaces in sequential colimits; Theorem 7.4, first part. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_seq</span> (<span class="nv">A</span> : Sequence) (<span class="nv">a1</span> <span class="nv">a2</span> : A <span class="mi">0</span>)
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; a1^+k = a2^+k) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">p</span> =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a^+) p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16d"><span class="kn">Definition</span> <span class="nf">equiv_path_colim_zero</span> `{Univalence} {A : Sequence} (a1 a2 : A <span class="mi">0</span>) :
  (inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2) &lt;~&gt; Colimit (path_seq A a1 a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16f"><span class="nb">pose</span> (B := Build_FibSequence A (<span class="kr">fun</span> <span class="nv">x</span> =&gt; a1^+(x.<span class="mi">1</span>) = x.<span class="mi">2</span>) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a^+))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk170"><span class="nb">transitivity</span> (fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt;
fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk171" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk171"><hr></label><div class="goal-conclusion">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2) &lt;~&gt;
Colimit (path_seq A a1 a2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk172">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt;
fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk173"><span class="nb">symmetry</span>; srapply equiv_path_from_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk174" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk174"><hr></label><div class="goal-conclusion">Contr {y : Colimit A &amp; fib_seq_to_type_fam B y}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk175">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inj (fib_seq_to_seq B (<span class="mi">0</span>;a1)) <span class="mi">0</span> idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk176">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {y : Colimit A &amp; fib_seq_to_type_fam B y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk177">srefine (contr_equiv _ (seq_colim_sum_to_sum_seq_colim B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Colimit (sig_seq B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">srapply contr_colim_contr_seq; <span class="nb">intro</span> k; srapply contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk178">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2) &lt;~&gt;
Colimit (path_seq A a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk179">srapply equiv_functor_colimit; srefine (<span class="nb">transitivity</span> (equiv_fib_seq_to_seq B (<span class="mi">0</span>;a2)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) ~d~ path_seq A a1 a2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk17a">srapply Build_diagram_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2))
  (path_seq A a1 a2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk17b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk17b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk17c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap (fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2))
  (path_seq A a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk17d">srapply Build_DiagramMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i -&gt; path_seq A a1 a2 i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk17e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><label class="goal-separator" for="sequential-v-chk17e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i),
((path_seq A a1 a2) _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j
  (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f g) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk17f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i -&gt; path_seq A a1 a2 i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; coe (ap B (seq_shift_pair_from_zero a2 n))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk180">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i),
((path_seq A a1 a2) _f g)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap B (seq_shift_pair_from_zero a2 n))) j
  (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p b; <span class="nb">destruct</span> p; srapply (K _ _ (seq_shift_pair_from_zero a2 n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk181">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span></span></span></span><br><span><var>B</var><span><span class="hyp-body"><b>:= </b><span>{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; a1 ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; a ^+)
|}</span></span><span class="hyp-type"><b>: </b><span>FibSequence A</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap B (seq_shift_pair_from_zero a2 n));
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
         (<span class="nv">b</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) n) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = n0)
         <span class="kr">return</span>
           (((path_seq A a1 a2) _f p0)
              (equiv_path (B (<span class="mi">0</span>; a2) ^++ n)
                 (B (n; a2 ^+ n))
                 (ap B (seq_shift_pair_from_zero a2 n))
                 b) =
            equiv_path (B (<span class="mi">0</span>; a2) ^++ n0)
              (B (n0; a2 ^+ n0))
              (ap B (seq_shift_pair_from_zero a2 n0))
              (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f p0) b))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K seq_pair_shift (fibSequenceArr B)
             (seq_shift_pair_from_zero a2 n)
       <span class="kr">end</span>
   |} i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The characterization of path spaces in sequential colimits; Theorem 7.4, second part. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk182"><span class="kn">Definition</span> <span class="nf">equiv_path_colim</span> `{Univalence} {A : Sequence} n (a1 a2 : A n) :
  (inj A n a1 = inj A n a2) &lt;~&gt; Colimit (path_seq (shift_seq A n) a1 a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A n a1 = inj A n a2 &lt;~&gt;
Colimit (path_seq (shift_seq A n) a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk183"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj A n a1 = inj A n a2 &lt;~&gt;
Colimit (path_seq (shift_seq A n) a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk184">srefine (<span class="nb">transitivity</span> _ (equiv_path_colim_zero _ _)); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj (shift_seq A n) <span class="mi">0</span> a1 = inj (shift_seq A n) <span class="mi">0</span> a2 &lt;~&gt;
inj A n a1 = inj A n a2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (@equiv_ap _ _ (colim_shift_seq_to_colim_seq A n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Corollary 7.7.1, second part. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk185"><span class="kn">Instance</span> <span class="nf">trunc_seq_colim</span> `{Univalence} {A : Sequence} k :
  (<span class="kr">forall</span> <span class="nv">n</span>, IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A) | <span class="mi">100</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk186"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk187"><span class="nb">revert</span> A; <span class="nb">induction</span> k <span class="kr">as</span> [ | k IHk].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, Contr (A n)) -&gt;
Contr (Colimit A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk188" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk188"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt; IsTrunc k.+<span class="mi">1</span> (Colimit A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk189">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, Contr (A n)) -&gt;
Contr (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> contr_colim_contr_seq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt; IsTrunc k.+<span class="mi">1</span> (Colimit A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18b"><span class="nb">intros</span> A trH; <span class="nb">apply</span> istrunc_S; srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : Colimit A, IsTrunc k (w = y)) (inj A i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk18c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk18c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : Colimit A, IsTrunc k (w = y))
  (colimp i j g x) (<span class="nl">?q</span> j ((A _f g) x)) = <span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : Colimit A, IsTrunc k (w = y)) (inj A i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18e"><span class="nb">intro</span> n; <span class="nb">revert</span> trH; <span class="nb">revert</span> A; <span class="nb">induction</span> n <span class="kr">as</span> [ | n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A <span class="mi">0</span>%nat) (<span class="nv">y</span> : Colimit A),
IsTrunc k (inj A <span class="mi">0</span>%nat x = y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk18f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A), IsTrunc k (inj A n x = y)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk18f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n.+<span class="mi">1</span>%nat) (<span class="nv">y</span> : Colimit A),
IsTrunc k (inj A n.+<span class="mi">1</span>%nat x = y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk190">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A <span class="mi">0</span>%nat) (<span class="nv">y</span> : Colimit A),
IsTrunc k (inj A <span class="mi">0</span>%nat x = y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk191"><span class="nb">intros</span> A trH a; srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
  (inj A i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk192"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
  (colimp i j g x) (<span class="nl">?q</span> j ((A _f g) x)) = <span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk193">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
  (inj A i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk194"><span class="nb">intros</span> m b; <span class="nb">revert</span> b; <span class="nb">revert</span> a; <span class="nb">revert</span> trH; <span class="nb">revert</span> A; <span class="nb">induction</span> m <span class="kr">as</span> [ | m IHm].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A <span class="mi">0</span>%nat,
IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk195" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br></div><label class="goal-separator" for="sequential-v-chk195"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m.+<span class="mi">1</span>%nat),
IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m.+<span class="mi">1</span>%nat b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk196">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A <span class="mi">0</span>%nat,
IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk197"><span class="nb">intros</span> A trH a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (equiv_inverse (equiv_path_colim _ a b))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk198">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m.+<span class="mi">1</span>%nat),
IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m.+<span class="mi">1</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk199">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m.+<span class="mi">1</span>%nat),
IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m.+<span class="mi">1</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19a"><span class="nb">intros</span> A trH a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A m.+<span class="mi">1</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m.+<span class="mi">1</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19b">srefine (istrunc_equiv_istrunc _ (equiv_inverse (equiv_concat_l (glue A _ a) _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A m.+<span class="mi">1</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc k (inj A <span class="mi">1</span>%nat a ^+ = inj A m.+<span class="mi">1</span>%nat b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19c">srapply (@istrunc_equiv_istrunc _ _ _ k (IHm (succ_seq A) _ (@arr _ A <span class="mi">0</span>%nat _ <span class="mi">1</span>%path a) b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m), IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A m.+<span class="mi">1</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inj (succ_seq A) <span class="mi">0</span>%nat a ^+ = inj (succ_seq A) m b &lt;~&gt;
inj A <span class="mi">1</span>%nat a ^+ = inj A m.+<span class="mi">1</span>%nat b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (equiv_ap (colim_succ_seq_to_colim_seq A)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
  (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
    nat_rect
      (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
       <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
       IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat)
       =&gt;
       istrunc_equiv_istrunc
         (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
         (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
         (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
                IsTrunc k
                  (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
         (<span class="nv">b0</span> : A m0.+<span class="mi">1</span>%nat) =&gt;
       istrunc_equiv_istrunc
         (inj A <span class="mi">1</span>%nat a ^+ = inj A m0.+<span class="mi">1</span>%nat b0)
         (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
            (inj A m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a b) j
     ((A _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
 nat_rect
   (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
    <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
    IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
      (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
             IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
      (<span class="nv">b0</span> : A m0.+<span class="mi">1</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (inj A <span class="mi">1</span>%nat a ^+ = inj A m0.+<span class="mi">1</span>%nat b0)
      (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
         (inj A m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a b) i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A <span class="mi">0</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
  (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
    nat_rect
      (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
       <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
       IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat)
       =&gt;
       istrunc_equiv_istrunc
         (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
         (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
         (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
                IsTrunc k
                  (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
         (<span class="nv">b0</span> : A m0.+<span class="mi">1</span>%nat) =&gt;
       istrunc_equiv_istrunc
         (inj A <span class="mi">1</span>%nat a ^+ = inj A m0.+<span class="mi">1</span>%nat b0)
         (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
            (inj A m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a b) j
     ((A _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
 nat_rect
   (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
    <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
    IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
      (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
             IsTrunc k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
      (<span class="nv">b0</span> : A m0.+<span class="mi">1</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (inj A <span class="mi">1</span>%nat a ^+ = inj A m0.+<span class="mi">1</span>%nat b0)
      (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
         (inj A m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a b) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m p b; snapply path_ishprop; snapply ishprop_istrunc; <span class="bp">exact</span> _.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A), IsTrunc k (inj A n x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n.+<span class="mi">1</span>%nat) (<span class="nv">y</span> : Colimit A),
IsTrunc k (inj A n.+<span class="mi">1</span>%nat x = y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1a0"><span class="nb">intros</span> A trH a; srapply (functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A), IsTrunc k (inj A n x = y)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n.+<span class="mi">1</span>%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> : Colimit (succ_seq A),
(<span class="kr">fun</span> <span class="nv">b</span> : Colimit A =&gt; IsTrunc k (inj A n.+<span class="mi">1</span>%nat a = b))
  (colim_succ_seq_to_colim_seq A a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; srapply (@istrunc_equiv_istrunc _ _ _ k (IHn (succ_seq A) _ a x)); srapply equiv_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1a1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : Colimit A, IsTrunc k (w = y))
  (colimp i j g x)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    nat_rect
      (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
       <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
       IsTrunc k (inj A n0 x0 = y))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n0)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat) =&gt;
       Colimit_ind
         (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
          IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
         (<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">b</span> : A m) =&gt;
          nat_rect
            (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
             <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
             IsTrunc k
               (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0))
               (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (Colimit
                  (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
               (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
            (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
               (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                      (<span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
                      <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b0</span> : A0 m0),
                      IsTrunc k
                        (inj A0 <span class="mi">0</span>%nat a0 =
                         inj A0 m0 b0))
               (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0))
               (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0.+<span class="mi">1</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (inj A0 <span class="mi">1</span>%nat a0 ^+ =
                inj A0 m0.+<span class="mi">1</span>%nat b0)
               (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                  (inj A0 m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a
            b)
         (<span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            (<span class="nv">b</span> : A n0) =&gt;
          path_ishprop
            (transport
               (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
                IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
               (colimp n0 m p b)
               ((<span class="kr">fun</span>
                   (<span class="nv">m0</span> : Graph.graph0 sequence_graph)
                   (<span class="nv">b0</span> : A m0) =&gt;
                 nat_rect
                   (<span class="kr">fun</span> <span class="nv">m1</span> : nat =&gt;
                    <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                    (<span class="kr">forall</span> ..., ...) -&gt;
                    <span class="kr">forall</span> (<span class="nv">a0</span> : ...) (<span class="nv">b1</span> : ...),
                    IsTrunc k ...)
                   (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                      (<span class="nv">trH0</span> : <span class="kr">forall</span> <span class="nv">n1</span> : ...,
                              IsTrunc k.+<span class="mi">1</span> ...)
                      (<span class="nv">a0</span> <span class="nv">b1</span> : A0 <span class="mi">0</span>%nat) =&gt;
                    istrunc_equiv_istrunc
                      (Colimit (...))
                      (equiv_path_colim <span class="mi">0</span>%nat a0 b1)^-<span class="mi">1</span>)
                   (<span class="kr">fun</span> (<span class="nv">m1</span> : nat)
                      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                             ... -&gt; ...)
                      (<span class="nv">A0</span> : Sequence)
                      (<span class="nv">trH0</span> : <span class="kr">forall</span> <span class="nv">n1</span> : ...,
                              IsTrunc k.+<span class="mi">1</span> ...)
                      (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b1</span> : A0 m1.+<span class="mi">1</span>%nat) =&gt;
                    istrunc_equiv_istrunc
                      (inj A0 <span class="mi">1</span>%nat ... =
                       inj A0 m1.+<span class="mi">1</span>%nat b1)
                      (equiv_concat_l (...) (...))^-<span class="mi">1</span>)
                   m0 A trH a b0) m ((A _f p) b)))
            (nat_rect
               (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
                <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
                IsTrunc k
                  (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
               (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                  (<span class="nv">trH0</span> : <span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1))
                  (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
                istrunc_equiv_istrunc
                  (Colimit
                     (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
                  (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
               (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
                  (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                         (<span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                         <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                         (<span class="nv">b0</span> : A0 m0),
                         IsTrunc k
                           (inj A0 <span class="mi">0</span>%nat a0 =
                            inj A0 m0 b0))
                  (<span class="nv">A0</span> : Sequence)
                  (<span class="nv">trH0</span> : <span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1))
                  (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0.+<span class="mi">1</span>%nat)
                =&gt;
                istrunc_equiv_istrunc
                  (inj A0 <span class="mi">1</span>%nat a0 ^+ =
                   inj A0 m0.+<span class="mi">1</span>%nat b0)
                  (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                     (inj A0 m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) n0 A
               trH a b)))
      (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
         (<span class="nv">IHn</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
                <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
                IsTrunc k (inj A n0 x0 = y))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n1)) (<span class="nv">a</span> : A n0.+<span class="mi">1</span>%nat)
       =&gt;
       functor_forall_equiv_pb
         (colim_succ_seq_to_colim_seq A)
         (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit (succ_seq A) =&gt;
          istrunc_equiv_istrunc
            (inj (succ_seq A) n0 a = x0)
            (equiv_ap (colim_succ_seq_to_colim_seq A)
               (inj (succ_seq A) n0 a) x0))) n A trH)
     j ((A _f g) x)) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 nat_rect
   (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
    <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
    IsTrunc k (inj A n0 x0 = y))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n0)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat) =&gt;
    Colimit_ind
      (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
       IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
      (<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m)
       =&gt;
       nat_rect
         (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
          (<span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
           IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
          <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
          IsTrunc k (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
         (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
            (<span class="nv">trH0</span> : <span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0))
            (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
          istrunc_equiv_istrunc
            (Colimit (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
            (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
         (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
            (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                   (<span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
                   <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                   (<span class="nv">b0</span> : A0 m0),
                   IsTrunc k
                     (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="nv">A0</span> : Sequence)
            (<span class="nv">trH0</span> : <span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0))
            (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0.+<span class="mi">1</span>%nat) =&gt;
          istrunc_equiv_istrunc
            (inj A0 <span class="mi">1</span>%nat a0 ^+ = inj A0 m0.+<span class="mi">1</span>%nat b0)
            (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
               (inj A0 m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) m A trH a b)
      (<span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
         (<span class="nv">b</span> : A n0) =&gt;
       path_ishprop
         (transport
            (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
             IsTrunc k (inj A <span class="mi">0</span>%nat a = w))
            (colimp n0 m p b)
            ((<span class="kr">fun</span> (<span class="nv">m0</span> : Graph.graph0 sequence_graph)
                (<span class="nv">b0</span> : A m0) =&gt;
              nat_rect
                (<span class="kr">fun</span> <span class="nv">m1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                 (<span class="kr">forall</span>
                  <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                  IsTrunc k.+<span class="mi">1</span> (...)) -&gt;
                 <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b1</span> : A0 m1),
                 IsTrunc k (... = ...))
                (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                   (<span class="nv">trH0</span> : <span class="kr">forall</span>
                           <span class="nv">n1</span> : Graph.graph0
                                  sequence_graph,
                           IsTrunc k.+<span class="mi">1</span> (A0 n1))
                   (<span class="nv">a0</span> <span class="nv">b1</span> : A0 <span class="mi">0</span>%nat) =&gt;
                 istrunc_equiv_istrunc
                   (Colimit (path_seq (...) a0 b1))
                   (equiv_path_colim <span class="mi">0</span>%nat a0 b1)^-<span class="mi">1</span>)
                (<span class="kr">fun</span> (<span class="nv">m1</span> : nat)
                   (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                          (<span class="kr">forall</span> ..., ...) -&gt;
                          <span class="kr">forall</span> (<span class="nv">a0</span> : ...)
                          (<span class="nv">b1</span> : ...), IsTrunc k ...)
                   (<span class="nv">A0</span> : Sequence)
                   (<span class="nv">trH0</span> : <span class="kr">forall</span>
                           <span class="nv">n1</span> : Graph.graph0
                                  sequence_graph,
                           IsTrunc k.+<span class="mi">1</span> (A0 n1))
                   (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b1</span> : A0 m1.+<span class="mi">1</span>%nat)
                 =&gt;
                 istrunc_equiv_istrunc
                   (inj A0 <span class="mi">1</span>%nat a0 ^+ =
                    inj A0 m1.+<span class="mi">1</span>%nat b1)
                   (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                      (inj A0 m1.+<span class="mi">1</span>%nat b1))^-<span class="mi">1</span>) m0 A
                trH a b0) m ((A _f p) b)))
         (nat_rect
            (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
             <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
             IsTrunc k
               (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1))
               (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (Colimit
                  (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
               (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
            (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
               (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                      (<span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                      <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b0</span> : A0 m0),
                      IsTrunc k
                        (inj A0 <span class="mi">0</span>%nat a0 =
                         inj A0 m0 b0))
               (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1))
               (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0.+<span class="mi">1</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (inj A0 <span class="mi">1</span>%nat a0 ^+ =
                inj A0 m0.+<span class="mi">1</span>%nat b0)
               (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                  (inj A0 m0.+<span class="mi">1</span>%nat b0))^-<span class="mi">1</span>) n0 A trH
            a b)))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
      (<span class="nv">IHn</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
             <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
             IsTrunc k (inj A n0 x0 = y))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n1)) (<span class="nv">a</span> : A n0.+<span class="mi">1</span>%nat) =&gt;
    functor_forall_equiv_pb
      (colim_succ_seq_to_colim_seq A)
      (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit (succ_seq A) =&gt;
       istrunc_equiv_istrunc
         (inj (succ_seq A) n0 a = x0)
         (equiv_ap (colim_succ_seq_to_colim_seq A)
            (inj (succ_seq A) n0 a) x0))) n A trH) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1a2"><span class="nb">intros</span> n m p a; snapply path_ishprop; snapply istrunc_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Sequence</span></span></span><br><span><var>trH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>Graph.graph0 sequence_graph</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Graph.graph1 sequence_graph n m</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> : Colimit A,
IsHProp
  ((<span class="kr">fun</span> <span class="nv">a1</span> : Colimit A =&gt; IsTrunc k (inj A n a = a1))
     a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; srapply ishprop_istrunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
