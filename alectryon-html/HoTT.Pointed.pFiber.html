<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>pFiber.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types WildCat.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.pEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Loops.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointed fibers *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_fiber</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B) : IsPointed (hfiber f (point B))
  := (point A; point_eq f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B) : pType := [hfiber f (point B), _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pfib</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B) : pfiber f -&gt;* A
  := Build_pMap pr1 <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The double fiber object is equivalent to loops on the base. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1"><span class="kn">Definition</span> <span class="nf">pfiber2_loops</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
  : pfiber (pfib f) &lt;~&gt;* loops B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (pfib f) &lt;~&gt;* loops B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (pfib f) &lt;~&gt;* loops B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3">pointed_reduce_pmap f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) &lt;~&gt;*
loops [B, f pt]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk4">snapply Build_pEquiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) &lt;~&gt;
loops [B, f pt]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk5"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk6"><span class="mi">1</span>: make_equiv_contr_basedpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_adjointify
  (<span class="kr">fun</span>
     <span class="nv">H</span> : pfiber
           (pfib
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
   =&gt;
   (<span class="kr">fun</span> <span class="nv">H0</span> : hfiber f (f pt) =&gt;
    (<span class="kr">fun</span> (<span class="nv">H1</span> : A) (<span class="nv">H2</span> : f H1 = f pt) (<span class="nv">H3</span> : H1 = pt) =&gt;
     paths_ind_r pt
       (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = pt) =&gt;
        f y = f pt -&gt; loops [B, f pt])
       (<span class="kr">fun</span> <span class="nv">H4</span> : f pt = f pt =&gt; H4 : loops [B, f pt])
       H1 H3 H2) H0.<span class="mi">1</span> H0.<span class="mi">2</span>) H.<span class="mi">1</span> H.<span class="mi">2</span>)
  (<span class="kr">fun</span> <span class="nv">H</span> : loops [B, f pt] =&gt;
   ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
    H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
    :
    hfiber f (f pt);
   <span class="mi">1</span>
   :
   ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
    H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
    :
    hfiber f (f pt)).<span class="mi">1</span> = pt)
   :
   pfiber
     (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))
  ((<span class="kr">fun</span> <span class="nv">H</span> : loops [B, f pt] =&gt; <span class="mi">1</span>)
   :
   (<span class="kr">fun</span>
      <span class="nv">H</span> : pfiber
            (pfib
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
    =&gt;
    (<span class="kr">fun</span> <span class="nv">H0</span> : hfiber f (f pt) =&gt;
     (<span class="kr">fun</span> (<span class="nv">H1</span> : A) (<span class="nv">H2</span> : f H1 = f pt) (<span class="nv">H3</span> : H1 = pt)
      =&gt;
      paths_ind_r pt
        (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = pt) =&gt;
         f y = f pt -&gt; loops [B, f pt])
        (<span class="kr">fun</span> <span class="nv">H4</span> : f pt = f pt =&gt; H4 : loops [B, f pt])
        H1 H3 H2) H0.<span class="mi">1</span> H0.<span class="mi">2</span>) H.<span class="mi">1</span> H.<span class="mi">2</span>)
   o (<span class="kr">fun</span> <span class="nv">H</span> : loops [B, f pt] =&gt;
      ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
       H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
       :
       hfiber f (f pt);
      <span class="mi">1</span>
      :
      ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
       H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
       :
       hfiber f (f pt)).<span class="mi">1</span> = pt)
      :
      pfiber
        (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) ==
   idmap)
  ((<span class="kr">fun</span>
      <span class="nv">H</span> : pfiber
            (pfib
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
    =&gt;
    (<span class="kr">fun</span> <span class="nv">H0</span> : hfiber f (f pt) =&gt;
     (<span class="kr">fun</span> (<span class="nv">H1</span> : A) (<span class="nv">H2</span> : f H1 = f pt) (<span class="nv">H3</span> : H1 = pt)
      =&gt;
      paths_ind_r pt
        (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">p</span> : y = pt) =&gt;
         <span class="kr">forall</span> <span class="nv">H4</span> : f y = f pt,
         ((<span class="kr">let</span> <span class="nv">H5</span> := pt <span class="kr">in</span> H5;
          paths_ind_r pt
            (<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">_</span> : y0 = pt) =&gt;
             f y0 = f pt -&gt; loops [B, f pt]) idmap y p
            H4); <span class="mi">1</span>) = ((y; H4); p))
        (<span class="kr">fun</span> <span class="nv">H4</span> : f pt = f pt =&gt; <span class="mi">1</span>) H1 H3 H2) H0.<span class="mi">1</span>
       H0.<span class="mi">2</span>) H.<span class="mi">1</span> H.<span class="mi">2</span>)
   :
   (<span class="kr">fun</span> <span class="nv">H</span> : loops [B, f pt] =&gt;
    ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
     H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
     :
     hfiber f (f pt);
    <span class="mi">1</span>
    :
    ((<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0;
     H : f (<span class="kr">let</span> <span class="nv">H0</span> := pt <span class="kr">in</span> H0) = f pt)
     :
     hfiber f (f pt)).<span class="mi">1</span> = pt)
    :
    pfiber
      (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))
   o (<span class="kr">fun</span>
        <span class="nv">H</span> : pfiber
              (pfib
                 {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) =&gt;
      (<span class="kr">fun</span> <span class="nv">H0</span> : hfiber f (f pt) =&gt;
       (<span class="kr">fun</span> (<span class="nv">H1</span> : A) (<span class="nv">H2</span> : f H1 = f pt) (<span class="nv">H3</span> : H1 = pt)
        =&gt;
        paths_ind_r pt
          (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = pt) =&gt;
           f y = f pt -&gt; loops [B, f pt])
          (<span class="kr">fun</span> <span class="nv">H4</span> : f pt = f pt =&gt;
           H4 : loops [B, f pt]) H1 H3 H2) H0.<span class="mi">1</span> H0.<span class="mi">2</span>)
        H.<span class="mi">1</span> H.<span class="mi">2</span>) == idmap) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk7"><span class="kn">Definition</span> <span class="nf">pfiber_fmap_loops</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
  : pfiber (fmap loops f) &lt;~&gt;* loops (pfiber f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt;* loops (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt;* loops (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk9">srapply Build_pEquiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt; loops (pfiber f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chka"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chkb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt; loops (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chkc"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chkd"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; loops (pfiber f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chke"><span class="mi">2</span>: srapply equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap loops f) &lt;~&gt;
{p : pt.<span class="mi">1</span> = pt.<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p pt.<span class="mi">2</span> = pt.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chkf"><span class="nb">simpl</span>; <span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : pt = pt &amp;
(point_eq f)^ @ (ap f x @ point_eq f) = pt} &lt;~&gt;
{p : pt = pt &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk10">srapply equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pt = pt,
(<span class="kr">fun</span> <span class="nv">x</span> : pt = pt =&gt;
 (point_eq f)^ @ (ap f x @ point_eq f) = pt) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
 point_eq f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk11"><span class="nb">intro</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(point_eq f)^ @ (ap f p @ point_eq f) = pt &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk12"><span class="nb">refine</span> (_ oE equiv_moveL_Mp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p @ point_eq f = point_eq f @ pt &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk13"><span class="nb">refine</span> (_ oE equiv_concat_r (concat_p1 _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p @ point_eq f = point_eq f &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk14"><span class="nb">refine</span> (_ oE equiv_moveL_Vp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">point_eq f = (ap f p)^ @ point_eq f &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk15"><span class="nb">refine</span> (_ oE equiv_path_inverse _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f p)^ @ point_eq f = point_eq f &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk16"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
(ap f p)^ @ point_eq f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_paths_Fl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk17">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (pfiber (fmap loops f))
  {p : pt.<span class="mi">1</span> = pt.<span class="mi">1</span> &amp;
  transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p pt.<span class="mi">2</span> = pt.<span class="mi">2</span>}
  (loops (pfiber f))
  ((equiv_functor_sigma_id
      (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
       equiv_concat_l
         (transport_paths_Fl p (point_eq f))
         (point_eq f)
       oE equiv_path_inverse (point_eq f)
            ((ap f p)^ @ point_eq f)
       oE equiv_moveL_Vp (point_eq f) (point_eq f)
            (ap f p)
       oE equiv_concat_r (concat_p1 (point_eq f))
            (ap f p @ point_eq f)
       oE equiv_moveL_Mp pt (ap f p @ point_eq f)
            (point_eq f)
       :
       (<span class="kr">fun</span> <span class="nv">x</span> : pt = pt =&gt;
        (point_eq f)^ @ (ap f x @ point_eq f) = pt) p &lt;~&gt;
       (<span class="kr">fun</span> <span class="nv">p0</span> : pt = pt =&gt;
        transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p0
          (point_eq f) = point_eq f) p)
    :
    hfiber
      (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
       (point_eq f)^ @ (ap f p @ point_eq f)) pt &lt;~&gt;
    {p : pt = pt &amp;
    transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p (point_eq f) =
    point_eq f})
   :
   pfiber (fmap loops f) &lt;~&gt;
   {p : pt.<span class="mi">1</span> = pt.<span class="mi">1</span> &amp;
   transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) p pt.<span class="mi">2</span> = pt.<span class="mi">2</span>})
  (equiv_path_sigma (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) pt pt) pt =
pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> pointed_reduce.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk18"><span class="kn">Definition</span> <span class="nf">pr1_pfiber_fmap_loops</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt;* B)
  : fmap loops (pfib f) o* pfiber_fmap_loops f
    ==* pfib (fmap loops f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pfib f) o* pfiber_fmap_loops f ==*
pfib (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pfib f) o* pfiber_fmap_loops f ==*
pfib (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1a">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pfib f) o* pfiber_fmap_loops f ==
pfib (fmap loops f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk1b"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap loops (pfib f) o* pfiber_fmap_loops f) @
(dpoint_eq (pfib (fmap loops f)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pfib f) o* pfiber_fmap_loops f ==
pfib (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1d"><span class="nb">intros</span> [u v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>loops A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>fmap loops f u = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap loops (pfib f) o* pfiber_fmap_loops f) (u; v) =
pfib (fmap loops f) (u; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1e"><span class="nb">refine</span> (concat_1p _ @ concat_p1 _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>loops A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>fmap loops f u = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pfib f) (pfiber_fmap_loops f (u; v)) =
pfib (fmap loops f) (u; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@ap_pr1_path_sigma _ _ (point A; point_eq f) (point A;point_eq f) _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : pfiber (fmap loops f) =&gt;
  (<span class="kr">fun</span> (<span class="nv">u</span> : loops A) (<span class="nv">v</span> : fmap loops f u = pt) =&gt;
   (concat_1p
      (ap (pfib f) (pfiber_fmap_loops f (u; v)) @ <span class="mi">1</span>) @
    concat_p1
      (ap (pfib f) (pfiber_fmap_loops f (u; v)))) @
   ap_pr1_path_sigma (<span class="mi">1</span>%equiv (u; v).<span class="mi">1</span>)
     ((<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
       equiv_concat_l
         (transport_paths_Fl p (point_eq f))
         (point_eq f)
       oE equiv_path_inverse (point_eq f)
            ((ap f p)^ @ point_eq f)
       oE equiv_moveL_Vp (point_eq f) (point_eq f)
            (ap f p)
       oE equiv_concat_r (concat_p1 (point_eq f))
            (ap f p @ point_eq f)
       oE equiv_moveL_Mp pt (ap f p @ point_eq f)
            (point_eq f)
       :
       (<span class="kr">fun</span> <span class="nv">x0</span> : pt = pt =&gt;
        (point_eq f)^ @ (ap f x0 @ point_eq f) = pt) p &lt;~&gt;
       (<span class="kr">fun</span> <span class="nv">p0</span> : pt = pt =&gt;
        transport (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; f x0 = pt) p0
          (point_eq f) = point_eq f) p) (u; v).<span class="mi">1</span>
        (u; v).<span class="mi">2</span>)) x.<span class="mi">1</span> x.<span class="mi">2</span>)
 :
 fmap loops (pfib f) o* pfiber_fmap_loops f ==
 pfib (fmap loops f)) pt =
dpoint_eq (fmap loops (pfib f) o* pfiber_fmap_loops f) @
(dpoint_eq (pfib (fmap loops f)))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (pointed_reduce_rewrite; <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk20"><span class="kn">Definition</span> <span class="nf">pfiber_fmap_iterated_loops</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">n</span> : nat) (<span class="nv">f</span> : A -&gt;* B)
  : pfiber (fmap (iterated_loops n) f) &lt;~&gt;* iterated_loops n (pfiber f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap (iterated_loops n) f) &lt;~&gt;*
iterated_loops n (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap (iterated_loops n) f) &lt;~&gt;*
iterated_loops n (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk22"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap (iterated_loops <span class="mi">0</span>) f) &lt;~&gt;*
iterated_loops <span class="mi">0</span> (pfiber f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>pfiber (fmap (iterated_loops n) f) &lt;~&gt;* iterated_loops n (pfiber f)</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk23"><hr></label><div class="goal-conclusion">pfiber (fmap (iterated_loops n.+<span class="mi">1</span>) f) &lt;~&gt;*
iterated_loops n.+<span class="mi">1</span> (pfiber f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk24"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>pfiber (fmap (iterated_loops n) f) &lt;~&gt;* iterated_loops n (pfiber f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap (iterated_loops n.+<span class="mi">1</span>) f) &lt;~&gt;*
iterated_loops n.+<span class="mi">1</span> (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk25"><span class="nb">refine</span> (_ o*E pfiber_fmap_loops _ ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>pfiber (fmap (iterated_loops n) f) &lt;~&gt;* iterated_loops n (pfiber f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loops (pfiber (fmap (iterated_loops n) f)) &lt;~&gt;*
iterated_loops n.+<span class="mi">1</span> (pfiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk26">tapply (emap loops).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>pfiber (fmap (iterated_loops n) f) &lt;~&gt;* iterated_loops n (pfiber f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber (fmap (iterated_loops n) f) $&lt;~&gt;
(<span class="kr">fix</span> F (m : nat) : pType :=
   <span class="kr">match</span> m <span class="kr">with</span>
   | <span class="mi">0</span>%nat =&gt; pfiber f
   | m&#39;.+<span class="mi">1</span>%nat =&gt; loops (F m&#39;)
   <span class="kr">end</span>) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk27"><span class="kn">Definition</span> <span class="nf">functor_pfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt;* B} {<span class="nv">g</span> : C -&gt;* D} {<span class="nv">h</span> : A -&gt;* C} {<span class="nv">k</span> : B -&gt;* D}
           (<span class="nv">p</span> : k o* f ==* g o* h)
  : pfiber f -&gt;* pfiber g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber f -&gt;* pfiber g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber f -&gt;* pfiber g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk29">srapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber f -&gt; pfiber g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk2a"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk2b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber f -&gt; pfiber g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk2c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f pt -&gt; hfiber g pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_hfiber2 p (point_eq k)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_hfiber2 p (point_eq k) : pfiber f -&gt; pfiber g)
  pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk2e">srapply path_hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_hfiber2 p (point_eq k) pt).<span class="mi">1</span> = pt.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk2f"><hr></label><div class="goal-conclusion">(functor_hfiber2 p (point_eq k) pt).<span class="mi">2</span> = ap g <span class="nl">?q</span> @ pt.<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_hfiber2 p (point_eq k) pt).<span class="mi">1</span> = pt.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> point_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_hfiber2 p (point_eq k) pt).<span class="mi">2</span> =
ap g (point_eq h) @ pt.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk32"><span class="nb">refine</span> (concat_pp_p _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p pt.<span class="mi">1</span>)^ @ (ap k pt.<span class="mi">2</span> @ point_eq k) =
ap g (point_eq h) @ pt.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk33"><span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap k pt.<span class="mi">2</span> @ point_eq k =
p pt.<span class="mi">1</span> @ (ap g (point_eq h) @ pt.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (point_htpy p)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_pfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt;* B} {<span class="nv">g</span> : C -&gt;* D} (<span class="nv">h</span> : A &lt;~&gt;* C) (<span class="nv">k</span> : B &lt;~&gt;* D)
           (<span class="nv">p</span> : k o* f ==* g o* h)
  : pfiber f $&lt;~&gt; pfiber g
  := Build_pEquiv (functor_pfiber p) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk34"><span class="kn">Definition</span> <span class="nf">square_functor_pfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt;* B} {<span class="nv">g</span> : C -&gt;* D} {<span class="nv">h</span> : A -&gt;* C} {<span class="nv">k</span> : B -&gt;* D}
           (<span class="nv">p</span> : k o* f ==* g o* h)
  : h o* pfib f ==* pfib g o* functor_pfiber p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* pfib f ==* pfib g o* functor_pfiber p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* pfib f ==* pfib g o* functor_pfiber p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk36">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* pfib f == pfib g o* functor_pfiber p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk37"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (h o* pfib f) @
(dpoint_eq (pfib g o* functor_pfiber p))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h o* pfib f == pfib g o* functor_pfiber p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : pfiber f =&gt; <span class="mi">1</span>)
 :
 h o* pfib f == pfib g o* functor_pfiber p) pt =
dpoint_eq (h o* pfib f) @
(dpoint_eq (pfib g o* functor_pfiber p))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3a"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ dpoint_eq (pfib g o* functor_pfiber p) =
dpoint_eq (h o* pfib f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3b"><span class="nb">cbn</span>; <span class="nb">unfold</span> functor_sigma; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt;* D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt;* C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt;* D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o* f ==* g o* h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @
(ap pr1
   (path_sigma_uncurried (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = pt)
      (functor_hfiber2 p (point_eq k)
         (ispointed_fiber f)) (ispointed_fiber g)
      (point_eq h;
      transport_paths_Fl (point_eq h)
        (((p pt)^ @ ap k (point_eq f)) @ point_eq k) @
      moveR_Vp
        (((p pt)^ @ ap k (point_eq f)) @ point_eq k)
        (point_eq g) (ap g (point_eq h))
        (concat_pp_p (p pt)^ (ap k (point_eq f))
           (point_eq k) @
         moveR_Vp (ap k (point_eq f) @ point_eq k)
           (ap g (point_eq h) @ point_eq g) (p pt)
           (point_htpy p)^))) @ <span class="mi">1</span>) = <span class="mi">1</span> @ point_eq h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">rewrite</span> ap_pr1_path_sigma, concat_p1; <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">square_pequiv_pfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt;* B} {<span class="nv">g</span> : C -&gt;* D} (<span class="nv">h</span> : A &lt;~&gt;* C) (<span class="nv">k</span> : B &lt;~&gt;* D)
           (<span class="nv">p</span> : k o* f ==* g o* h)
  : h o* pfib f ==* pfib g o* pequiv_pfiber h k p
  := square_functor_pfiber p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The triple-fiber functor is equal to the negative of the loop space functor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3c"><span class="kn">Definition</span> <span class="nf">pfiber2_fmap_loops</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} (<span class="nv">f</span> : A -&gt;* B)
: pfiber2_loops f o* pfib (pfib (pfib f))
  ==* fmap loops f o* (loops_inv _ o* pfiber2_loops (pfib f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber2_loops f o* pfib (pfib (pfib f)) ==*
fmap loops f
o* (loops_inv A o* pfiber2_loops (pfib f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pfiber2_loops f o* pfib (pfib (pfib f)) ==*
fmap loops f
o* (loops_inv A o* pfiber2_loops (pfib f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3e">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
   paths_ind_r point0
     (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
      f y = f point0 -&gt; f point0 = f point0) idmap
     (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
o* pfib
     (pfib
        (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) ==*
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
o* (Build_pMap inverse <span class="mi">1</span>
    o* Build_pMap
         (<span class="kr">fun</span>
            <span class="nv">H</span> : hfiber pr1
                  (ispointed_fiber
                     {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                     |}) =&gt;
          paths_ind_r
            (ispointed_fiber
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
            (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
               (<span class="nv">_</span> : y =
                    ispointed_fiber
                      {|
                        pointed_fun := f;
                        dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
             y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
            (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk3f"><span class="nb">simple refine</span> (Build_pHomotopy _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
   paths_ind_r point0
     (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
      f y = f point0 -&gt; f point0 = f point0) idmap
     (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
o* pfib
     (pfib
        (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) ==
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
o* (Build_pMap inverse <span class="mi">1</span>
    o* Build_pMap
         (<span class="kr">fun</span>
            <span class="nv">H</span> : hfiber pr1
                  (ispointed_fiber
                     {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                     |}) =&gt;
          paths_ind_r
            (ispointed_fiber
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
            (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
               (<span class="nv">_</span> : y =
                    ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
             y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
            (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
            (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pfiber-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><label class="goal-separator" for="pfiber-v-chk40"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (Build_pMap
     (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
      paths_ind_r point0
        (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
         f y = f point0 -&gt; f point0 = f point0) idmap
        (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
   o* pfib
        (pfib
           (pfib
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))) @
(dpoint_eq
   (Build_pMap
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
    o* (Build_pMap inverse <span class="mi">1</span>
        o* Build_pMap
             (<span class="kr">fun</span>
                <span class="nv">H</span> : hfiber pr1
                      (ispointed_fiber
                       {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                       |}) =&gt;
              paths_ind_r
                (ispointed_fiber
                   {|
                     pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                   |})
                (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
                   (<span class="nv">_</span> : 
                    y =
                    ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
                 y.<span class="mi">1</span> = point0 -&gt; point0 = point0)
                idmap (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
                (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
   paths_ind_r point0
     (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
      f y = f point0 -&gt; f point0 = f point0) idmap
     (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
o* pfib
     (pfib
        (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) ==
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
o* (Build_pMap inverse <span class="mi">1</span>
    o* Build_pMap
         (<span class="kr">fun</span>
            <span class="nv">H</span> : hfiber pr1
                  (ispointed_fiber
                     {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                     |}) =&gt;
          paths_ind_r
            (ispointed_fiber
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
            (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
               (<span class="nv">_</span> : y =
                    ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
             y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
            (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
            (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk42"><span class="nb">intros</span> [[[x p] q] r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[A, point0]</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>{| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} x = pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} (x; p) =
pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>pfib (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ((x; p); q) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Build_pMap
   (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
    paths_ind_r point0
      (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
       f y = f point0 -&gt; f point0 = f point0) idmap
      (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
 o* pfib
      (pfib
         (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})))
  (((x; p); q); r) =
(Build_pMap
   (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
 o* (Build_pMap inverse <span class="mi">1</span>
     o* Build_pMap
          (<span class="kr">fun</span>
             <span class="nv">H</span> : hfiber pr1
                   (ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
           paths_ind_r
             (ispointed_fiber
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
             (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
                (<span class="nv">_</span> : y =
                     ispointed_fiber
                       {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                       |}) =&gt;
              y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
             (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
             (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)) 
  (((x; p); q); r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk43"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(x; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths_ind_r point0
  (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
   f y = f point0 -&gt; f point0 = f point0) idmap x q p =
<span class="mi">1</span> @
(ap f
   (paths_ind_r
      (ispointed_fiber
         {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
      (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
         (<span class="nv">_</span> : y =
              ispointed_fiber
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
       =&gt; y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
      (x; p) r q)^ @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Apparently [destruct q] isn&#39;t smart enough to generalize over [p]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk44"><span class="nb">move</span> q <span class="nb">before</span> x; <span class="nb">revert dependent</span> x;
      <span class="nb">refine</span> (paths_ind_r _ _ _); <span class="nb">intros</span> p r; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p =
<span class="mi">1</span> @
(ap f
   (paths_ind_r
      (ispointed_fiber
         {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
      (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
         (<span class="nv">_</span> : y =
              ispointed_fiber
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
       =&gt; y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
      (pt; p) r <span class="mi">1</span>)^ @ <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk45"><span class="nb">rewrite</span> !concat_1p, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p =
ap f
  (paths_ind_r
     (ispointed_fiber
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
        (<span class="nv">_</span> : y =
             ispointed_fiber
               {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
      =&gt; y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
     (pt; p) r <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk46"><span class="nb">rewrite</span> paths_ind_r_transport.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p =
ap f
  (transport
     (<span class="kr">fun</span> <span class="nv">b</span> : hfiber f (f point0) =&gt;
      b.<span class="mi">1</span> = point0 -&gt; point0 = point0) r^ idmap <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk47"><span class="nb">rewrite</span> transport_arrow_toconst, transport_paths_Fl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p =
ap f
  ((ap (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f point0) =&gt; x.<span class="mi">1</span>) (r^)^)^ @
   <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk48"><span class="nb">rewrite</span> concat_p1, inv_V, ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = ap f (ap (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f point0) =&gt; x.<span class="mi">1</span>) r^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk49"><span class="nb">refine</span> (((r^)..<span class="mi">2</span>)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = pt) (r^) ..<span class="mi">1</span> pt.<span class="mi">2</span> =
ap f (ap (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f point0) =&gt; x.<span class="mi">1</span>) r^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk4a"><span class="nb">rewrite</span> transport_paths_Fl; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (r^) ..<span class="mi">1</span>)^ @ <span class="mi">1</span> =
ap f (ap (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f point0) =&gt; x.<span class="mi">1</span>) r^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk4b"><span class="nb">rewrite</span> pr1_path_V, !ap_V, !inv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(pt; p) = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f r ..<span class="mi">1</span> @ <span class="mi">1</span> =
ap f (ap (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f point0) =&gt; x.<span class="mi">1</span>) r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pfiber-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="pfiber-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span>
    <span class="nv">x0</span> : pfiber
           (pfib
              (pfib
                 {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |})) =&gt;
  (<span class="kr">fun</span>
     <span class="nv">proj2</span> : pfiber
               (pfib
                  {|
                    pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                  |}) =&gt;
   (<span class="kr">fun</span>
      <span class="nv">proj3</span> : pfiber
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
    =&gt;
    (<span class="kr">fun</span> (<span class="nv">x</span> : [A, point0])
       (<span class="nv">p</span> : {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} x =
            pt)
       (<span class="nv">q</span> : pfib
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
              (x; p) = pt)
       (<span class="nv">r</span> : pfib
              (pfib
                 {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) ((x; p); q) = pt) =&gt;
     paths_ind_r pt
       (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">p0</span> : y = pt) =&gt;
        <span class="kr">forall</span> (<span class="nv">p1</span> : f y = pt) 
        (<span class="nv">r0</span> : (y; p1) = pt),
        paths_ind_r point0
          (<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">_</span> : y0 = point0) =&gt;
           f y0 = f point0 -&gt; f point0 = f point0)
          idmap y p0 p1 =
        <span class="mi">1</span> @
        (ap f (paths_ind_r ... ... idmap ... r0 p0)^ @
         <span class="mi">1</span>))
       (<span class="kr">fun</span> (<span class="nv">p0</span> : f pt = pt) (<span class="nv">r0</span> : (pt; p0) = pt) =&gt;
        internal_paths_rew_r
          (<span class="kr">fun</span> <span class="nv">p1</span> : f point0 = f point0 =&gt; p0 = p1)
          (internal_paths_rew_r
             (<span class="kr">fun</span> <span class="nv">p1</span> : ... =&gt; p0 = p1)
             (internal_paths_rew_r 
                (... =&gt; ...)
                (internal_paths_rew_r ... ... ...)
                (paths_ind_r_transport ... r0 idmap))
             (concat_p1 (ap f ...^)))
          (concat_1p (ap f (...)^ @ <span class="mi">1</span>))
        :
        paths_ind_r point0
          (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
           f y = f point0 -&gt; f point0 = f point0)
          idmap pt <span class="mi">1</span> p0 =
        <span class="mi">1</span> @
        (ap f (paths_ind_r ... ... idmap ... r0 <span class="mi">1</span>)^ @
         <span class="mi">1</span>)) x q p r
     :
     (Build_pMap
        (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
         paths_ind_r point0
           (<span class="kr">fun</span> ... ... =&gt; ... -&gt; ...) idmap 
           (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
      o* pfib (pfib (pfib {| ...; ... |})))
       (((x; p); q); r) =
     (Build_pMap
        (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>))
        <span class="mi">1</span>
      o* (Build_pMap inverse <span class="mi">1</span>
          o* Build_pMap
               (<span class="kr">fun</span> <span class="nv">H</span> : ... =&gt;
                paths_ind_r 
                  (...) 
                  (...) idmap 
                  (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
                  (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)) 
       (((x; p); q); r)) proj3.<span class="mi">1</span> proj3.<span class="mi">2</span>) proj2.<span class="mi">1</span>
     proj2.<span class="mi">2</span>) x0.<span class="mi">1</span> x0.<span class="mi">2</span>)
 :
 Build_pMap
   (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
    paths_ind_r point0
      (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
       f y = f point0 -&gt; f point0 = f point0) idmap
      (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
 o* pfib
      (pfib
         (pfib {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) ==
 Build_pMap
   (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
 o* (Build_pMap inverse <span class="mi">1</span>
     o* Build_pMap
          (<span class="kr">fun</span>
             <span class="nv">H</span> : hfiber pr1
                   (ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
           paths_ind_r
             (ispointed_fiber
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
             (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
                (<span class="nv">_</span> : y =
                     ispointed_fiber
                       {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                       |}) =&gt;
              y.<span class="mi">1</span> = point0 -&gt; point0 = point0) idmap
             (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
             (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)) pt =
dpoint_eq
  (Build_pMap
     (<span class="kr">fun</span> <span class="nv">H</span> : hfiber pr1 point0 =&gt;
      paths_ind_r point0
        (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = point0) =&gt;
         f y = f point0 -&gt; f point0 = f point0) idmap
        (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>
   o* pfib
        (pfib
           (pfib
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))) @
(dpoint_eq
   (Build_pMap
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) <span class="mi">1</span>
    o* (Build_pMap inverse <span class="mi">1</span>
        o* Build_pMap
             (<span class="kr">fun</span>
                <span class="nv">H</span> : hfiber pr1
                      (ispointed_fiber
                       {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                       |}) =&gt;
              paths_ind_r
                (ispointed_fiber
                   {|
                     pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                   |})
                (<span class="kr">fun</span> (<span class="nv">y</span> : hfiber f (f point0))
                   (<span class="nv">_</span> : 
                    y =
                    ispointed_fiber
                      {|
                       pointed_fun := f;
                       dpoint_eq := <span class="mi">1</span>
                      |}) =&gt;
                 y.<span class="mi">1</span> = point0 -&gt; point0 = point0)
                idmap (H.<span class="mi">1</span>).<span class="mi">1</span> H.<span class="mi">2</span> 
                (H.<span class="mi">1</span>).<span class="mi">2</span>) <span class="mi">1</span>)))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre>
</div>
</div></body>
</html>
