<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Colimit_Flattening.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Diagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Graph.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.DDiagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Colimit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Flattening lemma *)</span>

<span class="sd">(** This file provides a proof of the flattening lemma for colimits. This lemma describes the type [sig E&#39;] when [E&#39; : colimit D -&gt; Type] is a type family defined by recursion on a colimit. The flattening lemma in the case of coequalizers is presented in section 6.12 of the HoTT book and is in Colimits/Coeq.v. *)</span>
<span class="sd">(** TODO: See whether there&#39;s a straightforward way to deduce the flattening lemma for general colimits from the version for coequalizers. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Flattening</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** ** Equifibered diagrams *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {G : Graph} (D : Diagram G)
    (E : DDiagram D) `(Equifibered _ _ E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">E_f</span> {<span class="nv">i</span> <span class="nv">j</span> : G} (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) : E (i; x) -&gt; E (j; (D _f g) x)
      := @arr _ E (i; x) (j; D _f g x) (g; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now, given an equifibered diagram and using univalence, one can define a type family [E&#39; : colimit D -&gt; Type] by recursion on the colimit. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1"><span class="kn">Definition</span> <span class="nf">E&#39;</span> : Colimit D -&gt; <span class="kt">Type</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3"><span class="nb">apply</span> Colimit_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone D <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4"><span class="nb">simple refine</span> (Build_Cocone _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
<span class="nl">?legs</span> j o D _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> =&gt; E (i; x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x</span> : D i0) =&gt; E (i0; x)) j o D _f g ==
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x</span> : D i0) =&gt; E (i0; x)) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8"><span class="nb">intros</span> i j g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E (j; (D _f g) x) = E (i; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E (i; x) = E (j; (D _f g) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_universe (E_f _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Helper lemmas *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka"><span class="kn">Definition</span> <span class="nf">transport_E&#39;</span> {<span class="nv">i</span> <span class="nv">j</span> : G} (<span class="nv">g</span> : G i j)  (<span class="nv">x</span> : D i) (<span class="nv">y</span> : E (i; x))
    : transport E&#39; (colimp i j g x) (E_f g x y) = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x) (E_f g x y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x) (E_f g x y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkc"><span class="nb">refine</span> (transport_idmap_ap _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (ap E&#39; (colimp i j g x)) (E_f g x y) =
y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkd">srefine (transport2 idmap _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E&#39; (colim j ((D _f g) x)) = E&#39; (colim i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chke"><hr></label><div class="goal-conclusion">ap E&#39; (colimp i j g x) = <span class="nl">?q</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chkf"><hr></label><div class="goal-conclusion">transport idmap <span class="nl">?q</span> (E_f g x y) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk10"><span class="mi">2</span>: <span class="nb">apply</span> Colimit_rec_beta_colimp; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (legs_comm
     {|
       legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) =&gt; E (i; x);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
         (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt;
          (path_universe (E_f g x))^
          :
          E (j; (D _f g) x) = E (i; x))
         :
         (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x</span> : D i0) =&gt; E (i0; x)) j
         o D _f g ==
         (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x</span> : D i0) =&gt; E (i0; x)) i
     |} i j g x) (E_f g x y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk11"><span class="nb">apply</span> (moveR_transport_V idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E_f g x y =
transport idmap (path_universe (E_f g x)) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> transport_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk12"><span class="kn">Definition</span> <span class="nf">transport_E&#39;_V</span> {<span class="nv">i</span> <span class="nv">j</span> : G} (<span class="nv">g</span> : G i j)  (<span class="nv">x</span> : D i) (<span class="nv">y</span> : E (i; x))
    : transport E&#39; (colimp i j g x)^ y = E_f g x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)^ y = E_f g x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)^ y = E_f g x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk14"><span class="nb">apply</span> moveR_transport_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = transport E&#39; (colimp i j g x) (E_f g x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk15"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x) (E_f g x y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_E&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk16"><span class="kn">Definition</span> <span class="nf">transport_E&#39;_V_E&#39;</span> {<span class="nv">i</span> <span class="nv">j</span> : G} (<span class="nv">g</span> : G i j)  (<span class="nv">x</span> : D i) (<span class="nv">y</span> : E (i; x))
    : transport_E&#39; g x y
      = ap (transport E&#39; (colimp i j g x)) (transport_E&#39;_V g x y)^
        @ transport_pV E&#39; (colimp i j g x) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39; g x y =
ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x y)^ @
transport_pV E&#39; (colimp i j g x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39; g x y =
ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x y)^ @
transport_pV E&#39; (colimp i j g x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk18"><span class="nb">rewrite</span> moveR_transport_V_V, inv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39; g x y =
ap (transport E&#39; (colimp i j g x))
  (moveL_transport_V E&#39; (colimp i j g x) (E_f g x y) y
     (transport_E&#39; g x y)) @
transport_pV E&#39; (colimp i j g x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> ap_transport_transport_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Main result *)</span>

  <span class="sd">(** We define the cocone over the sigma diagram to [sig E&#39;]. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk19"><span class="kn">Definition</span> <span class="nf">cocone_E&#39;</span> : Cocone (diagram_sigma E) (sig E&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1b">srapply Build_Cocone; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; {x : _ &amp; E&#39; x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk1c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 <span class="nl">?Goal</span> j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == <span class="nl">?Goal</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1e"><span class="nb">intros</span> i w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk1f"><span class="kr">exists</span> (<span class="nv">colim</span> <span class="nv">i</span> <span class="nv">w</span>.<span class="mi">1</span>); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E&#39; (colim i w.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> w.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">w</span> : {x0 : D i0 &amp; E (i0; x0)}) =&gt;
  (colim i0 w.<span class="mi">1</span>; w.<span class="mi">2</span> : E&#39; (colim i0 w.<span class="mi">1</span>))) j
   ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) ==
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">w</span> : {x : D i0 &amp; E (i0; x)}) =&gt;
 (colim i0 w.<span class="mi">1</span>; w.<span class="mi">2</span> : E&#39; (colim i0 w.<span class="mi">1</span>))) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk21"><span class="nb">intros</span> i j g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(colim j ((D _f g) x.<span class="mi">1</span>); (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>) =
(colim i x.<span class="mi">1</span>; x.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk22">srapply path_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim j ((D _f g) x.<span class="mi">1</span>) = colim i x.<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk23"><hr></label><div class="goal-conclusion">transport E&#39; <span class="nl">?p</span> ((E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>) = x.<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk24">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">colim j ((D _f g) x.<span class="mi">1</span>) = colim i x.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk25">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{x : D i &amp; E (i; x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x.<span class="mi">1</span>) ((E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>) =
x.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_E&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And we directly prove that it is universal.  We break the proof into parts to slightly speed it up. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Opaque</span> path_sigma ap11.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk26"><span class="kn">Local Definition</span> <span class="nf">cocone_extends</span> <span class="nv">Z</span>: Cocone (diagram_sigma E) Z -&gt; ((sig E&#39;) -&gt; Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) Z -&gt; {x : _ &amp; E&#39; x} -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) Z -&gt; {x : _ &amp; E&#39; x} -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk28"><span class="nb">intros</span> [q qq]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : _ &amp; E&#39; x} -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk29"><span class="nb">intros</span> [x y]; <span class="nb">revert</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Colimit D, E&#39; x -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2a">srapply Colimit_ind; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), E&#39; (colim i x) -&gt; Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk2b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
  (colimp i j g x) (<span class="nl">?Goal</span> j ((D _f g) x)) = <span class="nl">?Goal</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), E&#39; (colim i x) -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> i x y; <span class="bp">exact</span> (q i (x; y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
  (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) (<span class="nv">y</span> : E&#39; (colim i0 x0)) =&gt;
    q i0 (x0; y)) j ((D _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) (<span class="nv">y</span> : E&#39; (colim i0 x0)) =&gt;
 q i0 (x0; y)) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2e"><span class="nb">intros</span> i j g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
  (colimp i j g x)
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
   q j ((D _f g) x; y)) =
(<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim i x) =&gt; q i (x; y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk2f">funext y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
  (colimp i j g x)
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
   q j ((D _f g) x; y)) y = q i (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk30"><span class="nb">refine</span> (transport_arrow_toconst _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q j ((D _f g) x; transport E&#39; (colimp i j g x)^ y) =
q i (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk31"><span class="nb">refine</span> (_ @ qq i j g (x; y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q j ((D _f g) x; transport E&#39; (colimp i j g x)^ y) =
q j ((D _f g) (x; y).<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) (x; y).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk32"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((D _f g) x; transport E&#39; (colimp i j g x)^ y) =
((D _f g) x; (E _f (g; <span class="mi">1</span>)) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk33"><span class="nb">refine</span> (path_sigma&#39; _ <span class="mi">1</span> _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, {x : D i &amp; E (i; x)} -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : {x : D i &amp; E (i; x)} =&gt;
 q j ((D _f g) x.<span class="mi">1</span>; (E _f (g; <span class="mi">1</span>)) x.<span class="mi">2</span>)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)^ y = (E _f (g; <span class="mi">1</span>)) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_E&#39;_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk34"><span class="kn">Local Definition</span> <span class="nf">cocone_isretr</span> <span class="nv">Z</span>
    : cocone_postcompose cocone_E&#39; o cocone_extends Z == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose cocone_E&#39; o cocone_extends Z ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose cocone_E&#39; o cocone_extends Z ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk36"><span class="nb">intros</span> [q qq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose cocone_E&#39;
  (cocone_extends Z {| legs := q; legs_comm := qq |}) =
{| legs := q; legs_comm := qq |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk37">srapply path_cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_postcompose cocone_E&#39;
  (cocone_extends Z {| legs := q; legs_comm := qq |})
  i == {| legs := q; legs_comm := qq |} i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk38"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : diagram_sigma E i),
legs_comm
  (cocone_postcompose cocone_E&#39;
     (cocone_extends Z
        {| legs := q; legs_comm := qq |})) i j g x @
<span class="nl">?path_legs</span> i x =
<span class="nl">?path_legs</span> j (((diagram_sigma E) _f g) x) @
legs_comm {| legs := q; legs_comm := qq |} i j g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk39">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_postcompose cocone_E&#39;
  (cocone_extends Z {| legs := q; legs_comm := qq |})
  i == {| legs := q; legs_comm := qq |} i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> i x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : diagram_sigma E i),
legs_comm
  (cocone_postcompose cocone_E&#39;
     (cocone_extends Z
        {| legs := q; legs_comm := qq |})) i j g x @
(<span class="kr">fun</span> <span class="nv">i0</span> : G =&gt;
 (<span class="kr">fun</span> <span class="nv">x0</span> : diagram_sigma E i0 =&gt; <span class="mi">1</span>)
 :
 cocone_postcompose cocone_E&#39;
   (cocone_extends Z {| legs := q; legs_comm := qq |})
   i0 == {| legs := q; legs_comm := qq |} i0) i x =
(<span class="kr">fun</span> <span class="nv">i0</span> : G =&gt;
 (<span class="kr">fun</span> <span class="nv">x0</span> : diagram_sigma E i0 =&gt; <span class="mi">1</span>)
 :
 cocone_postcompose cocone_E&#39;
   (cocone_extends Z {| legs := q; legs_comm := qq |})
   i0 == {| legs := q; legs_comm := qq |} i0) j
  (((diagram_sigma E) _f g) x) @
legs_comm {| legs := q; legs_comm := qq |} i j g x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3b"><span class="nb">intros</span> i j g [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm
  (cocone_postcompose cocone_E&#39;
     (cocone_extends Z
        {| legs := q; legs_comm := qq |})) i j g
  (x; y) @ <span class="mi">1</span> =
<span class="mi">1</span> @
legs_comm {| legs := q; legs_comm := qq |} i j g
  (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3c"><span class="nb">rewrite</span> concat_1p, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legs_comm
  (cocone_postcompose cocone_E&#39;
     (cocone_extends Z
        {| legs := q; legs_comm := qq |})) i j g
  (x; y) =
legs_comm {| legs := q; legs_comm := qq |} i j g
  (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3d"><span class="nb">cbn</span>; <span class="nb">rewrite</span> ap_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
      (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
       q i (x; y0))
      (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
       path_forall
         (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
            (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             q j ((D _f g) x; y0)))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt; q i (x; y0))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          transport_arrow_toconst (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             q j ((D _f g) x; y1)) y0 @
          (ap11 <span class="mi">1</span>
             (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
           qq i j g (x; y0)))) (colim j ((D _f g) x))
      y)
   (moveL_transport_V E&#39; (colimp i j g x)
      ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
     Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
       (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
        q i (x; y0))
       (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
        path_forall
          (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
             (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              q j ((D _f g) x; y0)))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt; q i (x; y0))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           transport_arrow_toconst (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              q j ((D _f g) x; y1)) y0 @
           (ap11 <span class="mi">1</span>
              (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                 <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
            qq i j g (x; y0)))) (colim j ((D _f g) x))
       y) y)^) @
ap10
  (apD
     (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
      Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
        (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x0</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x0))
         =&gt; q i (x0; y0))
        (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         path_forall
           (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
              (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x0)) =&gt;
               q j ((D _f g) x0; y0)))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x0) =&gt; q i (x0; y0))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x0) =&gt;
            transport_arrow_toconst (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x0)) =&gt;
               q j ((D _f g) x0; y1)) y0 @
            (ap11 <span class="mi">1</span>
               (path_sigma&#39;
                  (<span class="kr">fun</span> <span class="nv">x1</span> : D j =&gt; E (j; x1)) <span class="mi">1</span>
                  (transport_E&#39;_V g x0 y0)) @
             qq i j g (x0; y0)))) x y)
     (colimp i j g x)) y = qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
   (moveL_transport_V E&#39; (colimp i j g x)
      ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
    y)^) @
ap10
  (apD
     (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
      Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
        (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x0</span> : D i) (<span class="nv">y0</span> : E (i; x0)) =&gt;
         q i (x0; y0))
        (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         path_forall
           (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
              (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y0</span> : E (j; (D _f g) x0) =&gt;
               q j ((D _f g) x0; y0)))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E (i; x0) =&gt; q i (x0; y0))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E (i; x0) =&gt;
            transport_arrow_toconst (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y1</span> : E (j; (D _f g) x0) =&gt;
               q j ((D _f g) x0; y1)) y0 @
            (ap11 <span class="mi">1</span>
               (path_sigma&#39;
                  (<span class="kr">fun</span> <span class="nv">x1</span> : D j =&gt; E (j; x1)) <span class="mi">1</span>
                  (transport_E&#39;_V g x0 y0)) @
             qq i j g (x0; y0)))) x y)
     (colimp i j g x)) y = qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk3f"><span class="nb">rewrite</span> Colimit_ind_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
   (moveL_transport_V E&#39; (colimp i j g x)
      ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
    y)^) @
ap10
  (path_forall
     (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
        (colimp i j g x)
        (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
         q j ((D _f g) x; y)))
     (<span class="kr">fun</span> <span class="nv">y</span> : E (i; x) =&gt; q i (x; y))
     (<span class="kr">fun</span> <span class="nv">y</span> : E (i; x) =&gt;
      transport_arrow_toconst (colimp i j g x)
        (<span class="kr">fun</span> <span class="nv">y0</span> : E (j; (D _f g) x) =&gt;
         q j ((D _f g) x; y0)) y @
      (ap11 <span class="mi">1</span>
         (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
            (transport_E&#39;_V g x y)) @ qq i j g (x; y))))
  y = qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk40"><span class="nb">rewrite</span> ap10_path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
   (moveL_transport_V E&#39; (colimp i j g x)
      ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
    y)^) @
(transport_arrow_toconst (colimp i j g x)
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
   y @
 (ap11 <span class="mi">1</span>
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x y)) @ qq i j g (x; y))) =
qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk41"><span class="nb">rewrite</span> concat_pp_p, concat_V_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  (moveL_transport_V E&#39; (colimp i j g x)
     ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
(ap11 <span class="mi">1</span>
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x y)) @ qq i j g (x; y)) =
qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk42"><span class="nb">refine</span> (_ @ concat_1p _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  (moveL_transport_V E&#39; (colimp i j g x)
     ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
(ap11 <span class="mi">1</span>
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x y)) @ qq i j g (x; y)) =
<span class="mi">1</span> @ qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk43"><span class="nb">refine</span> (concat_p_pp _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
   (moveL_transport_V E&#39; (colimp i j g x)
      ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
 ap11 <span class="mi">1</span>
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x y))) @ qq i j g (x; y) =
<span class="mi">1</span> @ qq i j g (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk44"><span class="nb">refine</span> (_ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  (moveL_transport_V E&#39; (colimp i j g x)
     ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)) @
ap11 <span class="mi">1</span>
  (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
     (transport_E&#39;_V g x y)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk45"><span class="kr">match goal with</span> |- ap _ <span class="nl">?X</span> @ _ = _ =&gt; <span class="nb">set</span> (p := X) <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  p @
ap11 <span class="mi">1</span>
  (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
     (transport_E&#39;_V g x y)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk46"><span class="nb">assert</span> (r : transport_E&#39;_V g x y = p^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39;_V g x y = p^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>transport_E&#39;_V g x y = p^</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk47"><hr></label><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  p @
ap11 <span class="mi">1</span>
  (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
     (transport_E&#39;_V g x y)) = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk48">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39;_V g x y = p^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk49"><span class="nb">subst</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_E&#39;_V g x y =
(moveL_transport_V E&#39; (colimp i j g x)
   ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (moveL_transport_V_V E&#39; _ _ _ _)^.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>transport_E&#39;_V g x y = p^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  p @
ap11 <span class="mi">1</span>
  (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
     (transport_E&#39;_V g x y)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4b"><span class="nb">rewrite</span> r; <span class="nb">clear</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>)) y) y (transport_E&#39; g x y)</span></span><span class="hyp-type"><b>: </b><span>(E _f (g; <span class="mi">1</span>)) y = transport E&#39; (colimp i j g x)^ y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  p @
ap11 <span class="mi">1</span> (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span> p^) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4c"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, diagram_sigma E i -&gt; Z</span></span></span><br><span><var>qq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : diagram_sigma E i =&gt;
 q j (((diagram_sigma E) _f g) x)) == q i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E (i; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt; q j ((D _f g) x; y))
  <span class="mi">1</span> @
ap11 <span class="mi">1</span> (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span> <span class="mi">1</span>^) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>. <span class="c">(* 0.1s *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4d"><span class="kn">Local Definition</span> <span class="nf">cocone_issect</span> <span class="nv">Z</span>
    : cocone_extends Z o cocone_postcompose cocone_E&#39; == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_extends Z o cocone_postcompose cocone_E&#39; ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_extends Z o cocone_postcompose cocone_E&#39; ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk4f"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_extends Z (cocone_postcompose cocone_E&#39; f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk50">funext [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_extends Z (cocone_postcompose cocone_E&#39; f)
  (x; y) = f (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk51"><span class="nb">revert</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x),
cocone_extends Z (cocone_postcompose cocone_E&#39; f)
  (x; y) = f (x; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk52">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
 cocone_extends Z (cocone_postcompose cocone_E&#39; f)
   (w; y) = f (w; y)) (colim i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk53"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
   cocone_extends Z (cocone_postcompose cocone_E&#39; f)
     (w; y) = f (w; y)) (colimp i j g x)
  (<span class="nl">?q</span> j ((D _f g) x)) = <span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk54">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
 cocone_extends Z (cocone_postcompose cocone_E&#39; f)
   (w; y) = f (w; y)) (colim i x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk55">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
   cocone_extends Z (cocone_postcompose cocone_E&#39; f)
     (w; y) = f (w; y)) (colimp i j g x)
  (((<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) (<span class="nv">y</span> : E&#39; (colim i0 x0))
     =&gt; <span class="mi">1</span>)
    :
    <span class="kr">forall</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0),
    (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
     <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
     cocone_extends Z (cocone_postcompose cocone_E&#39; f)
       (w; y) = f (w; y)) (colim i0 x0)) j
     ((D _f g) x)) =
((<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) (<span class="nv">y</span> : E&#39; (colim i0 x0)) =&gt; <span class="mi">1</span>)
 :
 <span class="kr">forall</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0),
 (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
  <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
  cocone_extends Z (cocone_postcompose cocone_E&#39; f)
    (w; y) = f (w; y)) (colim i0 x0)) i x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk56"><span class="nb">intros</span> i j g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
   cocone_extends Z (cocone_postcompose cocone_E&#39; f)
     (w; y) = f (w; y)) (colimp i j g x)
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt; <span class="mi">1</span>) =
(<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim i x) =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk57">funext y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w,
   cocone_extends Z (cocone_postcompose cocone_E&#39; f)
     (w; y) = f (w; y)) (colimp i j g x)
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt; <span class="mi">1</span>) y = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk58"><span class="nb">set</span> (L := cocone_extends Z (cocone_postcompose cocone_E&#39; f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : E&#39; w, L (w; y) = f (w; y))
  (colimp i j g x)
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt; <span class="mi">1</span>) y = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk59"><span class="nb">refine</span> (transport_forall _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim i x) =&gt;
   L (colim i x; y) = f (colim i x; y))
  (transport_pV E&#39; (colimp i j g x) y)
  (transportD E&#39;
     (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
      L (x; y) = f (x; y)) (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y) <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5a">transport_paths (transport_paths_FlFr (f:=<span class="kr">fun</span> <span class="nv">y0</span> =&gt; L (_; y0))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt; L (colim i x; y0))
  (transport_pV E&#39; (colimp i j g x) y) @ <span class="mi">1</span> =
transportD E&#39;
  (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
   L (x; y) = f (x; y)) (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) <span class="mi">1</span> @
ap (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt; f (colim i x; x0))
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5b">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt; L (colim i x; y0))
  (transport_pV E&#39; (colimp i j g x) y) =
transportD E&#39;
  (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
   L (x; y) = f (x; y)) (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) <span class="mi">1</span> @
ap (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt; f (colim i x; x0))
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5c">lhs_V napply concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @
ap (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt; L (colim i x; y0))
  (transport_pV E&#39; (colimp i j g x) y) =
transportD E&#39;
  (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
   L (x; y) = f (x; y)) (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) <span class="mi">1</span> @
ap (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt; f (colim i x; x0))
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5d"><span class="nb">refine</span> (_^ @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transportD E&#39;
  (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
   L (x; y) = f (x; y)) (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5e">lhs rapply (transportD_is_transport E&#39; (<span class="kr">fun</span> <span class="nv">w</span> =&gt; L w = f w)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">w</span> : {x : _ &amp; E&#39; x} =&gt; L w = f w)
  (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk5f">transport_paths FlFr; <span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap L (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk60"><span class="nb">rewrite</span> ap_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
      (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
       cocone_postcompose cocone_E&#39; f i (x; y0))
      (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
       path_forall
         (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
            (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y0)))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          cocone_postcompose cocone_E&#39; f i (x; y0))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          transport_arrow_toconst (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y1)) y0 @
          (ap11 <span class="mi">1</span>
             (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
           legs_comm (cocone_postcompose cocone_E&#39; f)
             i j g (x; y0)))) (colim j ((D _f g) x)) y)
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
     Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
       (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
        cocone_postcompose cocone_E&#39; f i (x; y0))
       (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
        path_forall
          (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
             (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y0)))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           cocone_postcompose cocone_E&#39; f i (x; y0))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           transport_arrow_toconst (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y1)) y0 @
           (ap11 <span class="mi">1</span>
              (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                 <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
            legs_comm (cocone_postcompose cocone_E&#39; f)
              i j g (x; y0)))) (colim j ((D _f g) x))
       y)
    (transport E&#39; (colimp i j g x)
       (transport E&#39; (colimp i j g x)^ y)))^) @
ap10
  (apD
     (<span class="kr">fun</span> (<span class="nv">x</span> : Colimit D) (<span class="nv">y</span> : E&#39; x) =&gt;
      Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
        (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x0</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x0))
         =&gt; cocone_postcompose cocone_E&#39; f i (x0; y0))
        (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         path_forall
           (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
              (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x0)) =&gt;
               cocone_postcompose cocone_E&#39; f j
                 ((D _f g) x0; y0)))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x0) =&gt;
            cocone_postcompose cocone_E&#39; f i (x0; y0))
           (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x0) =&gt;
            transport_arrow_toconst (colimp i j g x0)
              (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x0)) =&gt;
               cocone_postcompose cocone_E&#39; f j
                 ((D _f g) x0; y1)) y0 @
            (ap11 <span class="mi">1</span>
               (path_sigma&#39;
                  (<span class="kr">fun</span> <span class="nv">x1</span> : D j =&gt; E (j; x1)) <span class="mi">1</span>
                  (transport_E&#39;_V g x0 y0)) @
             legs_comm
               (cocone_postcompose cocone_E&#39; f) i j g
               (x0; y0)))) x y) (colimp i j g x))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk61"><span class="nb">rewrite</span> Colimit_ind_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
      (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
       cocone_postcompose cocone_E&#39; f i (x; y0))
      (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
       path_forall
         (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
            (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y0)))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          cocone_postcompose cocone_E&#39; f i (x; y0))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          transport_arrow_toconst (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y1)) y0 @
          (ap11 <span class="mi">1</span>
             (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
           legs_comm (cocone_postcompose cocone_E&#39; f)
             i j g (x; y0)))) (colim j ((D _f g) x)) y)
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
     Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
       (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
        cocone_postcompose cocone_E&#39; f i (x; y0))
       (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
        path_forall
          (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
             (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y0)))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           cocone_postcompose cocone_E&#39; f i (x; y0))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           transport_arrow_toconst (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y1)) y0 @
           (ap11 <span class="mi">1</span>
              (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                 <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
            legs_comm (cocone_postcompose cocone_E&#39; f)
              i j g (x; y0)))) (colim j ((D _f g) x))
       y)
    (transport E&#39; (colimp i j g x)
       (transport E&#39; (colimp i j g x)^ y)))^) @
ap10
  (path_forall
     (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
        (colimp i j g x)
        (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
         cocone_postcompose cocone_E&#39; f j
           ((D _f g) x; y)))
     (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim i x) =&gt;
      cocone_postcompose cocone_E&#39; f i (x; y))
     (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim i x) =&gt;
      transport_arrow_toconst (colimp i j g x)
        (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
         cocone_postcompose cocone_E&#39; f j
           ((D _f g) x; y0)) y @
      (ap11 <span class="mi">1</span>
         (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
            (transport_E&#39;_V g x y)) @
       legs_comm (cocone_postcompose cocone_E&#39; f) i j
         g (x; y))))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk62"><span class="nb">rewrite</span> ap10_path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
      (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
       cocone_postcompose cocone_E&#39; f i (x; y0))
      (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
       path_forall
         (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
            (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y0)))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          cocone_postcompose cocone_E&#39; f i (x; y0))
         (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
          transport_arrow_toconst (colimp i j g x)
            (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
             cocone_postcompose cocone_E&#39; f j
               ((D _f g) x; y1)) y0 @
          (ap11 <span class="mi">1</span>
             (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
           legs_comm (cocone_postcompose cocone_E&#39; f)
             i j g (x; y0)))) (colim j ((D _f g) x)) y)
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
     Colimit_ind (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
       (<span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) (<span class="nv">y0</span> : E&#39; (colim i x)) =&gt;
        cocone_postcompose cocone_E&#39; f i (x; y0))
       (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
        path_forall
          (transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt; E&#39; w -&gt; Z)
             (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y0)))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           cocone_postcompose cocone_E&#39; f i (x; y0))
          (<span class="kr">fun</span> <span class="nv">y0</span> : E&#39; (colim i x) =&gt;
           transport_arrow_toconst (colimp i j g x)
             (<span class="kr">fun</span> <span class="nv">y1</span> : E&#39; (colim j ((D _f g) x)) =&gt;
              cocone_postcompose cocone_E&#39; f j
                ((D _f g) x; y1)) y0 @
           (ap11 <span class="mi">1</span>
              (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x0</span> : D j =&gt; E (j; x0))
                 <span class="mi">1</span> (transport_E&#39;_V g x y0)) @
            legs_comm (cocone_postcompose cocone_E&#39; f)
              i j g (x; y0)))) (colim j ((D _f g) x))
       y)
    (transport E&#39; (colimp i j g x)
       (transport E&#39; (colimp i j g x)^ y)))^) @
(transport_arrow_toconst (colimp i j g x)
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    cocone_postcompose cocone_E&#39; f j ((D _f g) x; y))
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)) @
 (ap11 <span class="mi">1</span>
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y)))) @
  legs_comm (cocone_postcompose cocone_E&#39; f) i j g
    (x;
    transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk63"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>L</var><span><span class="hyp-body"><b>:= </b><span>cocone_extends Z (cocone_postcompose cocone_E&#39; f)</span></span><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
    f (colim j ((D _f g) x); y))
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
     f (colim j ((D _f g) x); y))
    (transport E&#39; (colimp i j g x)
       (transport E&#39; (colimp i j g x)^ y)))^) @
(transport_arrow_toconst (colimp i j g x)
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
    f (colim j ((D _f g) x); y))
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)) @
 (ap11 <span class="mi">1</span>
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y)))) @
  ap f
    (path_sigma&#39; E&#39; (colimp i j g x)
       (transport_E&#39; g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y)))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk64"><span class="nb">clear</span> L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
    f (colim j ((D _f g) x); y))
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 (transport_arrow_toconst (colimp i j g x)
    (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
     f (colim j ((D _f g) x); y))
    (transport E&#39; (colimp i j g x)
       (transport E&#39; (colimp i j g x)^ y)))^) @
(transport_arrow_toconst (colimp i j g x)
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
    f (colim j ((D _f g) x); y))
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)) @
 (ap11 <span class="mi">1</span>
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y)))) @
  ap f
    (path_sigma&#39; E&#39; (colimp i j g x)
       (transport_E&#39; g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y)))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk65"><span class="nb">rewrite</span> concat_pp_p, concat_V_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
   f (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
(ap11 <span class="mi">1</span>
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y)))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk66"><span class="nb">rewrite</span> ap11_is_ap10_ap01.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
   f (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
((ap10 <span class="mi">1</span>
    ((D _f g) x;
    transport E&#39; (colimp i j g x)^
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))) @
  ap
    (<span class="kr">fun</span> <span class="nv">x</span> : {x : D j &amp; E (j; x)} =&gt;
     f (colim j x.<span class="mi">1</span>; x.<span class="mi">2</span>))
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y))))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk67"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
   f (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
((<span class="mi">1</span> @
  ap
    (<span class="kr">fun</span> <span class="nv">x</span> : {x : D j &amp; E (j; x)} =&gt;
     f (colim j x.<span class="mi">1</span>; x.<span class="mi">2</span>))
    (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
       (transport_E&#39;_V g x
          (transport E&#39; (colimp i j g x)
             (transport E&#39; (colimp i j g x)^ y))))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk68"><span class="nb">rewrite</span> concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
   f (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
(ap
   (<span class="kr">fun</span> <span class="nv">x</span> : {x : D j &amp; E (j; x)} =&gt;
    f (colim j x.<span class="mi">1</span>; x.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y)))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk69"><span class="nb">rewrite</span> (ap_compose (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (colim j ((D _f g) x); y)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (ap
     (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
      (colim j ((D _f g) x); y))
     (moveL_transport_V E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)
        (transport E&#39; (colimp i j g x)
           (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>)) @
(ap
   (<span class="kr">fun</span> <span class="nv">x</span> : {x : D j &amp; E (j; x)} =&gt;
    f (colim j x.<span class="mi">1</span>; x.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y)))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6a"><span class="nb">rewrite</span> (ap_compose (<span class="kr">fun</span> <span class="nv">x0</span> : <span class="kr">exists</span> <span class="nv">x0</span> : D j, E (j; x0)
        =&gt; (colim j (pr1 x0); pr2 x0)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (ap
     (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
      (colim j ((D _f g) x); y))
     (moveL_transport_V E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)
        (transport E&#39; (colimp i j g x)
           (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>)) @
(ap f
   (ap
      (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
       (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
      (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
         (transport_E&#39;_V g x
            (transport E&#39; (colimp i j g x)
               (transport E&#39; (colimp i j g x)^ y))))) @
 ap f
   (path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6b"><span class="nb">rewrite</span> &lt;- ! (ap_pp f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (ap
     (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
      (colim j ((D _f g) x); y))
     (moveL_transport_V E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)
        (transport E&#39; (colimp i j g x)
           (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
   (ap
      (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
       (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
      (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
         (transport_E&#39;_V g x
            (transport E&#39; (colimp i j g x)
               (transport E&#39; (colimp i j g x)^ y)))) @
    path_sigma&#39; E&#39; (colimp i j g x)
      (transport_E&#39; g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) =
ap f (path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6c"><span class="nb">apply</span> (ap (ap f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
   (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
(ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y)))) @
 path_sigma&#39; E&#39; (colimp i j g x)
   (transport_E&#39; g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))) =
path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6d"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
   (colim j ((D _f g) x); y))
  (moveL_transport_V E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
(ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y)))) @
 path_sigma&#39; E&#39; (colimp i j g x)
   (transport_E&#39; g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6e"><span class="nb">refine</span> (_ @ concat_pp_p _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    (colim j ((D _f g) x); y))
   (moveL_transport_V E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span>) @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk6f"><span class="kr">match goal with</span> |- _ = (ap <span class="nl">?ff</span> <span class="nl">?pp1</span> @ <span class="nl">?pp2</span>) @ <span class="nl">?pp3</span>
        =&gt; <span class="nb">set</span> (p1 := pp1) <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>transport E&#39; (colimp i j g x)^ y =
transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    (colim j ((D _f g) x); y)) p1 @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk70"><span class="nb">assert</span> (p1eq : p1 = ap (transport E&#39; (colimp i j g x)^)
        (transport_pV E&#39; (colimp i j g x) y)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>transport E&#39; (colimp i j g x)^ y =
transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>transport E&#39; (colimp i j g x)^ y =
transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span></span><br><span><var>p1eq</var><span class="hyp-type"><b>: </b><span>p1 =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk71"><hr></label><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    (colim j ((D _f g) x); y)) p1 @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk72">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>transport E&#39; (colimp i j g x)^ y =
transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk73"><span class="nb">subst</span> p1; <span class="nb">clear</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span> =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk74"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span> = <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk75"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk76"><span class="mi">1</span>: srapply moveL_transport_V_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_Vp E&#39; (colimp i j g x)
   (transport E&#39; (colimp i j g x)^ y))^ =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk77"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_Vp E&#39; (colimp i j g x)
   (transport E&#39; (colimp i j g x)^ y))^ = <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk78"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk79"><span class="mi">1</span>: napply inverse2; snapply transport_VpV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport E&#39; (colimp i j g x)^)
   (transport_pV E&#39; (colimp i j g x) y))^ =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> ap_V.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>moveL_transport_V E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>transport E&#39; (colimp i j g x)^ y =
transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span></span><br><span><var>p1eq</var><span class="hyp-type"><b>: </b><span>p1 =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)^</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    (colim j ((D _f g) x); y)) p1 @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7b"><span class="nb">rewrite</span> p1eq; <span class="nb">clear</span> p1eq p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E&#39; (colim j ((D _f g) x)) =&gt;
    (colim j ((D _f g) x); y))
   (ap (transport E&#39; (colimp i j g x)^)
      (transport_pV E&#39; (colimp i j g x) y)^) @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7c"><span class="nb">rewrite</span> &lt;- ap_compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
    (colim j ((D _f g) x);
    transport E&#39; (colimp i j g x)^ x0))
   (transport_pV E&#39; (colimp i j g x) y)^ @
 ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : {x0 : D j &amp; E (j; x0)} =&gt;
    (colim j x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))
   (path_sigma&#39; (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
      (transport_E&#39;_V g x
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7d"><span class="nb">rewrite</span> (ap_path_sigma (<span class="kr">fun</span> <span class="nv">x</span> =&gt; E (j; x))
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; (colim j x; y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
    (colim j ((D _f g) x);
    transport E&#39; (colimp i j g x)^ x0))
   (transport_pV E&#39; (colimp i j g x) y)^ @
 ((ap
     (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
      (colim j ((D _f g) x); y))
     (moveL_transport_V (<span class="kr">fun</span> <span class="nv">x</span> : D j =&gt; E (j; x)) <span class="mi">1</span>
        (transport E&#39; (colimp i j g x)^
           (transport E&#39; (colimp i j g x)
              (transport E&#39; (colimp i j g x)^ y)))
        ((E _f (g; <span class="mi">1</span>))
           (transport E&#39; (colimp i j g x)
              (transport E&#39; (colimp i j g x)^ y)))
        (transport_E&#39;_V g x
           (transport E&#39; (colimp i j g x)
              (transport E&#39; (colimp i j g x)^ y)))) @
   (transport_arrow_toconst <span class="mi">1</span>
      (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
       (colim j ((D _f g) x); y))
      ((E _f (g; <span class="mi">1</span>))
         (transport E&#39; (colimp i j g x)
            (transport E&#39; (colimp i j g x)^ y))))^) @
  ap10
    (apD
       (<span class="kr">fun</span> (<span class="nv">x</span> : D j) (<span class="nv">y</span> : E (j; x)) =&gt; (colim j x; y))
       <span class="mi">1</span>)
    ((E _f (g; <span class="mi">1</span>))
       (transport E&#39; (colimp i j g x)
          (transport E&#39; (colimp i j g x)^ y))))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7e"><span class="nb">cbn</span>; <span class="nb">rewrite</span> !concat_p1, concat_pp_p, ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
(ap
   (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
    (colim j ((D _f g) x);
    transport E&#39; (colimp i j g x)^ x0))
   (transport_pV E&#39; (colimp i j g x) y))^ @
(ap
   (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
    (colim j ((D _f g) x); y))
   (transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))) @
 path_sigma&#39; E&#39; (colimp i j g x)
   (transport_E&#39; g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk7f"><span class="nb">apply</span> moveL_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) @
path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
ap
  (<span class="kr">fun</span> <span class="nv">y</span> : E (j; (D _f g) x) =&gt;
   (colim j ((D _f g) x); y))
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk80"><span class="kr">match goal with</span> |- <span class="nl">?pp1</span> @ _ = <span class="nl">?pp2</span> @ _
        =&gt; <span class="nb">set</span> (p1 := pp1);
          <span class="nb">change</span> pp2 <span class="kr">with</span> (path_sigma&#39; E&#39; <span class="mi">1</span>
                            (transport_E&#39;_V g x
                               (transport E&#39; (colimp i j g x) (transport E&#39; (colimp i j g x)^ y)))) <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0)) y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 @ path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk81"><span class="nb">assert</span> (p1eq : p1 = path_sigma&#39; E&#39; <span class="mi">1</span> (transport_Vp _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0)) y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0)) y</span></span></span></span><br><span><var>p1eq</var><span class="hyp-type"><b>: </b><span>p1 =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk82"><hr></label><div class="goal-conclusion">p1 @ path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk83">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0)) y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk84"><span class="nb">subst</span> p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk85"><span class="nb">rewrite</span> &lt;- ap_exist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
ap (exist E&#39; (colim j ((D _f g) x)))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk86"><span class="nb">rewrite</span> (ap_compose (transport E&#39; (colimp i j g x)^)
          (<span class="kr">fun</span> <span class="nv">v</span> =&gt; (colim j ((D _f g) x); v))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">v</span> : E&#39; (colim j ((D _f g) x)) =&gt;
   (colim j ((D _f g) x); v))
  (ap (transport E&#39; (colimp i j g x)^)
     (transport_pV E&#39; (colimp i j g x) y)) =
ap (exist E&#39; (colim j ((D _f g) x)))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk87">f_ap; <span class="nb">set</span> (p := colimp i j g x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>colimp i j g x</span></span><span class="hyp-type"><b>: </b><span>colim j ((D _f g) x) = colim i x</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; p^) (transport_pV E&#39; p y) =
transport_Vp E&#39; p (transport E&#39; p^ y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk88"><span class="nb">clear</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>colimp i j g x</span></span><span class="hyp-type"><b>: </b><span>colim j ((D _f g) x) = colim i x</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_Vp E&#39; p (transport E&#39; p^ y) =
ap (transport E&#39; p^) (transport_pV E&#39; p y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_VpV.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk89">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   (colim j ((D _f g) x);
   transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
(<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
 (colim j ((D _f g) x);
 transport E&#39; (colimp i j g x)^ x0)) y</span></span></span></span><br><span><var>p1eq</var><span class="hyp-type"><b>: </b><span>p1 =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p1 @ path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8a"><span class="nb">rewrite</span> p1eq; <span class="nb">clear</span> p1eq p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) @
path_sigma&#39; E&#39; (colimp i j g x) <span class="mi">1</span> =
path_sigma&#39; E&#39; <span class="mi">1</span>
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
path_sigma&#39; E&#39; (colimp i j g x)
  (transport_E&#39; g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8b"><span class="nb">rewrite</span> &lt;- !path_sigma_pp_pp&#39;; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_pp E&#39; <span class="mi">1</span> (colimp i j g x)
   (transport E&#39; (colimp i j g x)^
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))) @
 ap (transport E&#39; (colimp i j g x))
   (transport_Vp E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y))) @ <span class="mi">1</span> =
(transport_pp E&#39; <span class="mi">1</span> (colimp i j g x)
   (transport E&#39; (colimp i j g x)^
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))) @
 ap (transport E&#39; (colimp i j g x))
   (transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))) @
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8c"><span class="nb">rewrite</span> concat_p1, concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_pp E&#39; <span class="mi">1</span> (colimp i j g x)
  (transport E&#39; (colimp i j g x)^
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
ap (transport E&#39; (colimp i j g x))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
transport_pp E&#39; <span class="mi">1</span> (colimp i j g x)
  (transport E&#39; (colimp i j g x)^
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
(ap (transport E&#39; (colimp i j g x))
   (transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))) @
 transport_E&#39; g x
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8d"><span class="nb">refine</span> (<span class="mi">1</span> @@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) @
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8e"><span class="nb">apply</span> moveL_Mp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport E&#39; (colimp i j g x))
   (transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y))))^ @
ap (transport E&#39; (colimp i j g x))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk8f"><span class="nb">rewrite</span> &lt;- ap_V, &lt;- ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))^ @
   transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk90">srefine (_ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>))
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) =
transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk91"><hr></label><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))^ @
   transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) = <span class="nl">?y</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chk92"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> =
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk93">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)
  ((E _f (g; <span class="mi">1</span>))
     (transport E&#39; (colimp i j g x)
        (transport E&#39; (colimp i j g x)^ y))) =
transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk94"><span class="nb">refine</span> (ap (transport E&#39; (colimp i j g x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(E _f (g; <span class="mi">1</span>))
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
transport E&#39; (colimp i j g x)^ y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk95"><span class="nb">refine</span> ((transport_E&#39;_V _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport E&#39; (colimp i j g x)^
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
transport E&#39; (colimp i j g x)^ y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (transport_pV _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))^ @
   transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y)) =
ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))^ @
   ap (transport E&#39; (colimp i j g x)^)
     (transport_pV E&#39; (colimp i j g x) y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk97">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_E&#39;_V g x
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)))^ @
transport_Vp E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) =
(transport_E&#39;_V g x
   (transport E&#39; (colimp i j g x)
      (transport E&#39; (colimp i j g x)^ y)))^ @
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk98"><span class="nb">refine</span> (<span class="mi">1</span> @@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_Vp E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_VpV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x
      (transport E&#39; (colimp i j g x)
         (transport E&#39; (colimp i j g x)^ y)))^ @
   ap (transport E&#39; (colimp i j g x)^)
     (transport_pV E&#39; (colimp i j g x) y)) =
transport_E&#39; g x
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9a"><span class="nb">set</span> (e := transport E&#39; (colimp i j g x)
          (transport E&#39; (colimp i j g x)^ y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</span></span><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  ((transport_E&#39;_V g x e)^ @
   ap (transport E&#39; (colimp i j g x)^)
     (transport_pV E&#39; (colimp i j g x) y)) =
transport_E&#39; g x e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9b"><span class="nb">rewrite</span> ap_pp, &lt;- ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</span></span><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x e)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
transport_E&#39; g x e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9c"><span class="nb">refine</span> (_ @ (transport_E&#39;_V_E&#39; _ _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</span></span><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x e)^ @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
ap (transport E&#39; (colimp i j g x))
  (transport_E&#39;_V g x e)^ @
transport_pV E&#39; (colimp i j g x) e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9d"><span class="nb">refine</span> (<span class="mi">1</span> @@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>transport E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y)</span></span><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
transport_pV E&#39; (colimp i j g x) e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9e"><span class="nb">subst</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
transport_pV E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chk9f"><span class="nb">refine</span> (_ @ (transport_pVp _ _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : E&#39; (colim i x) =&gt;
   transport E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ x0))
  (transport_pV E&#39; (colimp i j g x) y) =
ap (transport E&#39; (colimp i j g x))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka0"><span class="nb">rewrite</span> ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (transport E&#39; (colimp i j g x))
  (ap (transport E&#39; (colimp i j g x)^)
     (transport_pV E&#39; (colimp i j g x) y)) =
ap (transport E&#39; (colimp i j g x))
  (transport_Vp E&#39; (colimp i j g x)
     (transport E&#39; (colimp i j g x)^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka1">f_ap; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{x : _ &amp; E&#39; x} -&gt; Z</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>E&#39; (colim i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_Vp E&#39; (colimp i j g x)
  (transport E&#39; (colimp i j g x)^ y) =
ap (transport E&#39; (colimp i j g x)^)
  (transport_pV E&#39; (colimp i j g x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_VpV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>. <span class="c">(* TODO: a little slow, 0.40s *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka2">#[export] <span class="kn">Instance</span> <span class="nf">unicocone_cocone_E&#39;</span> : UniversalCocone cocone_E&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone cocone_E&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone cocone_E&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka4">srapply Build_UniversalCocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Y</span> : <span class="kt">Type</span>,
IsEquiv (cocone_postcompose cocone_E&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka5"><span class="nb">intro</span> Z; srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) Z -&gt; {x : _ &amp; E&#39; x} -&gt; Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chka6"><hr></label><div class="goal-conclusion">cocone_postcompose cocone_E&#39; o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chka7"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o cocone_postcompose cocone_E&#39; == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone (diagram_sigma E) Z -&gt; {x : _ &amp; E&#39; x} -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cocone_extends Z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose cocone_E&#39; o cocone_extends Z ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cocone_isretr Z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkaa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_extends Z o cocone_postcompose cocone_E&#39; ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cocone_issect Z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The flattening lemma follows by colimit uniqueness. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkab"><span class="kn">Definition</span> <span class="nf">flattening_lemma</span> : Colimit (diagram_sigma E) &lt;~&gt; sig E&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (diagram_sigma E) &lt;~&gt; {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit (diagram_sigma E) &lt;~&gt; {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkad">srapply colimit_unicity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Graph</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chkae"><hr></label><div class="goal-conclusion">Diagram <span class="nl">?G</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chkaf"><hr></label><div class="goal-conclusion">IsColimit <span class="nl">?D</span> (Colimit (diagram_sigma E))</div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-flattening-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><label class="goal-separator" for="colimit-flattening-v-chkb0"><hr></label><div class="goal-conclusion">IsColimit <span class="nl">?D</span> {x : _ &amp; E&#39; x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkb1"><span class="mi">3</span>: <span class="nb">apply</span> iscolimit_colimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit (diagram_sigma E) {x : _ &amp; E&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-flattening-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-flattening-v-chkb2">rapply Build_IsColimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>DDiagram D</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Equifibered E</span></span></span><br><span><var>E_f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
E _f (g; <span class="mi">1</span>)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i), E (i; x) -&gt; E (j; (D _f g) x)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> unicocone_cocone_E&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Flattening</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* TODO: ending the section is a bit slow (0.2s).  But simply removing the Section (and changing &quot;Let&quot; to &quot;Local Definition&quot;) causes the whole file to be much slower.  It should be possible to remove the section without making the whole file slower. *)</span></span></pre>
</div>
</div></body>
</html>
